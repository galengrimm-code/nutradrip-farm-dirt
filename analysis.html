<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/svg+xml" href="favicon.svg">
  <title>Soil Sample Analysis - Analysis</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f8fafc; color: #1e293b; min-height: 100vh; }
    .top-bar { background: linear-gradient(135deg, #1e293b 0%, #334155 100%); color: white; padding: 1rem 1.5rem; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem; }
    .top-bar h1 { font-size: 1.5rem; font-weight: 700; }
    .top-bar p { font-size: 0.875rem; opacity: 0.8; margin-top: 0.25rem; }
    .nav-links { display: flex; gap: 0.5rem; flex-wrap: wrap; }
    .nav-link { padding: 0.5rem 1rem; background: rgba(255,255,255,0.1); color: white; text-decoration: none; border-radius: 0.375rem; font-size: 0.875rem; font-weight: 500; }
    .nav-link:hover { background: rgba(255,255,255,0.2); }
    .nav-link.active { background: #3b82f6; }
    .auth-section { display: flex; align-items: center; gap: 1rem; }
    .user-info { font-size: 0.875rem; color: rgba(255,255,255,0.9); }
    .sign-in-btn { padding: 0.5rem 1rem; background: #4285f4; color: white; border: none; border-radius: 0.375rem; font-size: 0.875rem; cursor: pointer; }
    .sign-in-btn.signed-in { background: #22c55e; }
    
    .analysis-container { max-width: 1400px; margin: 0 auto; padding: 1.5rem; }
    
    /* Tabs */
    .tabs { display: flex; gap: 0.5rem; margin-bottom: 1.5rem; flex-wrap: wrap; }
    .tab { padding: 0.75rem 1.25rem; background: white; border: 1px solid #cbd5e1; border-radius: 0.5rem; cursor: pointer; font-weight: 500; font-size: 0.875rem; }
    .tab:hover { background: #f1f5f9; }
    .tab.active { background: #3b82f6; color: white; border-color: #3b82f6; }
    
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    
    /* Controls */
    .controls-bar { background: white; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1.5rem; box-shadow: 0 1px 3px rgba(0,0,0,0.1); display: flex; gap: 1.5rem; flex-wrap: wrap; align-items: flex-end; }
    .control-group { display: flex; flex-direction: column; gap: 0.25rem; }
    .control-group label { font-size: 0.75rem; font-weight: 600; color: #64748b; text-transform: uppercase; }
    .control-group select { padding: 0.5rem 0.75rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 0.375rem; min-width: 160px; }
    .export-btn { padding: 0.5rem 1rem; background: #8b5cf6; color: white; border: none; border-radius: 0.375rem; font-size: 0.875rem; font-weight: 500; cursor: pointer; margin-left: auto; }
    .export-btn:hover { background: #7c3aed; }

    /* Nutrient Grid for Year Comparison */
    .nutrient-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1rem; }
    
    .nutrient-card { background: white; border-radius: 0.5rem; padding: 1rem; box-shadow: 0 1px 3px rgba(0,0,0,0.1); border-left: 4px solid #94a3b8; }
    .nutrient-card.positive { border-left-color: #22c55e; background: linear-gradient(to right, #f0fdf4, white); }
    .nutrient-card.negative { border-left-color: #ef4444; background: linear-gradient(to right, #fef2f2, white); }
    .nutrient-card.no-comparison { border-left-color: #f59e0b; background: linear-gradient(to right, #fffbeb, white); }
    
    .nutrient-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem; }
    .nutrient-name { font-size: 1rem; font-weight: 700; color: #1e293b; }
    .nutrient-pct { font-size: 1.125rem; font-weight: 700; }
    .nutrient-pct.positive { color: #22c55e; }
    .nutrient-pct.negative { color: #ef4444; }
    .nutrient-pct.neutral { color: #64748b; }
    
    .nutrient-stats { display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem; margin-bottom: 0.75rem; }
    .stat-box { background: #f8fafc; border-radius: 0.375rem; padding: 0.5rem; text-align: center; }
    .stat-box .label { font-size: 0.625rem; font-weight: 600; color: #64748b; text-transform: uppercase; }
    .stat-box .value { font-size: 0.9375rem; font-weight: 700; color: #1e293b; }
    
    .year-comparison { display: flex; justify-content: space-between; align-items: center; background: #f1f5f9; border-radius: 0.375rem; padding: 0.5rem 0.75rem; margin-bottom: 0.5rem; }
    .year-val { text-align: center; }
    .year-val .yr { font-size: 0.625rem; font-weight: 600; color: #64748b; }
    .year-val .num { font-size: 1.125rem; font-weight: 700; color: #1e293b; }
    .year-arrow { font-size: 1.25rem; color: #94a3b8; }
    
    .change-row { display: flex; justify-content: center; gap: 1.5rem; font-size: 0.75rem; color: #64748b; }
    .change-row .val { font-weight: 600; }
    .change-row .val.positive { color: #22c55e; }
    .change-row .val.negative { color: #ef4444; }
    
    /* Historical Trends */
    .trend-card { background: white; border: 2px solid; border-radius: 0.75rem; padding: 1.25rem; margin-bottom: 1.25rem; box-shadow: 0 2px 8px rgba(0,0,0,0.06); }
    .trend-card.positive { background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%); border-color: #22c55e; }
    .trend-card.negative { background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%); border-color: #ef4444; }
    .trend-card.neutral { background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%); border-color: #94a3b8; }
    .trend-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 1rem; padding-bottom: 0.75rem; border-bottom: 1px solid rgba(0,0,0,0.08); }
    .trend-title { font-size: 1.25rem; font-weight: 700; color: #1e293b; }
    .trend-pct { font-size: 1.5rem; font-weight: 700; text-align: right; }
    .trend-sub { font-size: 0.75rem; color: #64748b; font-weight: 500; }
    .trend-content { display: flex; flex-wrap: nowrap; gap: 1rem; align-items: stretch; }
    .trend-values { background: rgba(255,255,255,0.7); border-radius: 0.5rem; padding: 0.5rem; min-width: 200px; flex: 0 0 auto; max-height: 400px; overflow-y: auto; }
    .trend-row { display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0.75rem; font-size: 0.875rem; border-radius: 0.25rem; }
    .trend-row.alt { background: rgba(0,0,0,0.03); }
    .trend-year { font-weight: 600; color: #475569; min-width: 50px; }
    .trend-value { font-weight: 700; color: #1e293b; }
    .trend-graph { flex: 1 1 auto; background: rgba(255,255,255,0.5); border-radius: 0.5rem; padding: 0.75rem; min-width: 400px; }
    .trend-graph svg { display: block; width: 100%; height: auto; min-height: 180px; }
    .trend-graph.large svg { min-height: 220px; }
    .trend-graph.xlarge svg { min-height: 280px; }
    @media (max-width: 900px) {
      .trend-content { flex-direction: column; }
      .trend-graph { min-width: 100%; width: 100%; }
      .trend-graph svg { min-height: 200px; }
    }
    
    /* Field Rankings */
    .rankings-table { width: 100%; border-collapse: collapse; background: white; border-radius: 0.5rem; overflow: hidden; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
    .rankings-table th, .rankings-table td { padding: 0.75rem 1rem; text-align: left; border-bottom: 1px solid #e2e8f0; }
    .rankings-table th { background: #f8fafc; font-weight: 600; color: #475569; font-size: 0.75rem; text-transform: uppercase; }
    .rankings-table th.sortable-header:hover { background: #e2e8f0; }
    .rankings-table tr:hover { background: #f8fafc; }
    .rankings-table .rank { font-weight: 700; color: #64748b; width: 60px; }
    .rankings-table .field { font-weight: 500; }
    .rankings-table .value { font-weight: 700; }
    .rankings-table .high { color: #22c55e; }
    .rankings-table .low { color: #ef4444; }
    
    .no-data { background: #fef3c7; border: 2px solid #f59e0b; border-radius: 0.5rem; padding: 2rem; text-align: center; color: #92400e; }
    #statusMessage { display: none; position: fixed; top: 1rem; left: 50%; transform: translateX(-50%); z-index: 9999; padding: 0.75rem 1rem; border-radius: 0.375rem; box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
    
    @media (max-width: 639px) {
      .nutrient-grid { grid-template-columns: 1fr; }
      .controls-bar { flex-direction: column; align-items: stretch; }
      .tabs { flex-direction: column; }
      .tab { text-align: center; }
    }
    .backup-footer { position: fixed; bottom: 0; left: 0; right: 0; background: #f8fafc; border-top: 1px solid #e2e8f0; padding: 0.25rem 1rem; font-size: 0.7rem; color: #64748b; text-align: center; z-index: 900; }
  </style>
</head>
<body>
  <div class="top-bar">
    <div>
      <h1>üìä Soil Analysis</h1>
      <p>Trends, Comparisons & Rankings</p>
    </div>
    <nav class="nav-links">
      <a href="index.html" class="nav-link">üìç Map</a>
      <a href="analysis.html" class="nav-link active">üìä Analysis</a>
      <a href="import.html" class="nav-link">üìÅ Import</a>
      <a href="settings.html" class="nav-link">‚öôÔ∏è Settings</a>
    </nav>
    <div class="auth-section">
      <span class="user-info" id="userInfo"></span>
      <button class="sign-in-btn" id="authBtn" onclick="handleAuth()">Sign In to Edit</button>
    </div>
  </div>

  <!-- Active Operation Indicator (shown when filtering by client/farm) -->
  <div id="activeOperationIndicator" style="display: none; padding: 0.35rem 1rem; background: #f5f3ff; border-bottom: 1px solid #ddd6fe; font-size: 0.75rem; color: #6b21a8;"></div>

  <div class="analysis-container">
    <div class="tabs">
      <div class="tab active" data-tab="history">üìà Field Trends</div>
      <div class="tab" data-tab="comparison">üìä Year-Over-Year</div>
      <div class="tab" data-tab="rankings">üèÜ Field Rankings</div>
      <div class="tab" data-tab="yield">üåæ Yield Correlation</div>
      <div class="tab" data-tab="spatial">üó∫Ô∏è Spatial Change</div>
    </div>
    
    <!-- Tab: Year Comparison (Operation-wide) -->
    <div id="comparison" class="tab-content">
      <div class="controls-bar">
        <div class="control-group">
          <label>From Year</label>
          <select id="year1Select"></select>
        </div>
        <div class="control-group">
          <label>To Year</label>
          <select id="year2Select"></select>
        </div>
        <button onclick="exportYearComparison()" class="export-btn">üìÑ Export Report</button>
      </div>
      
      <!-- Year Stats Section -->
      <div id="yearStats" style="display: flex; gap: 1rem; margin-bottom: 1rem; flex-wrap: wrap;">
        <div id="fromYearStats" style="flex: 1; min-width: 250px; background: #f8fafc; border: 2px solid #cbd5e1; border-radius: 0.5rem; padding: 1rem;">
          <h4 style="margin: 0 0 0.5rem 0; color: #64748b; font-size: 0.875rem;">From Year Stats</h4>
          <div id="fromYearInfo"></div>
        </div>
        <div id="toYearStats" style="flex: 1; min-width: 250px; background: #f0fdf4; border: 2px solid #22c55e; border-radius: 0.5rem; padding: 1rem;">
          <h4 style="margin: 0 0 0.5rem 0; color: #166534; font-size: 0.875rem;">To Year Stats</h4>
          <div id="toYearInfo"></div>
        </div>
      </div>
      
      <!-- Field Selection & Mismatch Warning -->
      <div id="fieldSelectionSection" style="background: white; border: 2px solid #e2e8f0; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1.5rem;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
          <h4 style="margin: 0; color: #475569; font-size: 0.875rem;">üìã Fields Included in Comparison</h4>
          <div>
            <button onclick="selectMatchingComparisonFields()" style="padding: 0.25rem 0.5rem; font-size: 0.75rem; border: 1px solid #cbd5e1; border-radius: 0.25rem; background: white; cursor: pointer; margin-right: 0.25rem;">Select Matching</button>
            <button onclick="selectAllComparisonFields()" style="padding: 0.25rem 0.5rem; font-size: 0.75rem; border: 1px solid #cbd5e1; border-radius: 0.25rem; background: white; cursor: pointer;">Select All</button>
          </div>
        </div>
        <div id="fieldCheckboxes" style="display: flex; flex-wrap: wrap; gap: 0.5rem;"></div>
        <div id="fieldMismatchWarning" style="margin-top: 0.75rem;"></div>
      </div>
      
      <div id="comparisonGrid" class="nutrient-grid"></div>
    </div>
    
    <!-- Tab: Historical Field Trends -->
    <div id="history" class="tab-content active">
      <div class="controls-bar">
        <div class="control-group">
          <label>Select Field</label>
          <select id="historyFieldSelect"><option value="">Select a field...</option></select>
        </div>
        <button onclick="exportFieldTrends()" class="export-btn">üìÑ Export Report</button>
      </div>
      <div id="historyContent"></div>
    </div>

    <!-- Tab 3: Field Rankings -->
    <div id="rankings" class="tab-content">
      <div class="controls-bar">
        <div class="control-group">
          <label>Nutrient</label>
          <select id="rankingAttrSelect"></select>
        </div>
        <div class="control-group">
          <label>Year</label>
          <select id="rankingYearSelect"></select>
        </div>
        <button onclick="exportFieldRankings()" class="export-btn">üìÑ Export Report</button>
      </div>
      <div id="rankingsContent"></div>
    </div>

    <!-- Tab 4: Yield Correlation -->
    <div id="yield" class="tab-content">
      <div class="controls-bar">
        <div class="control-group">
          <label>Crop</label>
          <select id="yieldCropSelect">
            <option value="corn">üåΩ Corn</option>
            <option value="soybeans">ü´ò Soybeans</option>
            <option value="amylose">üçö Amylose</option>
          </select>
        </div>
        <div class="control-group">
          <label>Yield Year <span onclick="toggleYieldYearInfo()" style="cursor: pointer; font-size: 0.9rem; color: #3b82f6;" title="Learn about yield year options">‚ÑπÔ∏è</span></label>
          <select id="yieldYearSelect" onchange="updateYieldYearDescription()"></select>
        </div>
        <div class="control-group">
          <label>Soil Sample Year</label>
          <select id="soilYearSelect">
            <option value="recent">Most Recent</option>
          </select>
        </div>
        <div class="control-group">
          <label>Field</label>
          <select id="yieldFieldSelect">
            <option value="all">All Fields</option>
          </select>
        </div>
        <div class="control-group" style="display: flex; align-items: center; gap: 0.5rem;">
          <input type="checkbox" id="yieldNormalizeToggle" style="width: 18px; height: 18px; cursor: pointer;" title="Convert yield to % of field average to isolate nutrient effect from field productivity">
          <label style="margin: 0; white-space: nowrap;">Normalize by Field</label>
          <span onclick="toggleNormalizeInfo()" style="cursor: pointer; font-size: 1rem; color: #3b82f6; margin-left: -0.25rem;" title="Learn about normalization">‚ÑπÔ∏è</span>
        </div>
        <button onclick="exportYieldCorrelation()" class="export-btn">üìÑ Export Report</button>
      </div>

      <!-- Yield Year Description (shows based on selection) -->
      <div id="yieldYearDescription" style="display: none; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 0.5rem; padding: 0.75rem 1rem; margin-bottom: 0.75rem; font-size: 0.8rem;">
        <div id="yieldYearDescText" style="color: #475569;"></div>
        <div id="yieldYearWarning" style="display: none; margin-top: 0.5rem; padding: 0.5rem; background: #fef3c7; border: 1px solid #f59e0b; border-radius: 0.375rem; color: #92400e;">
          <strong>‚ö†Ô∏è Warning:</strong> <span id="yieldYearWarningText"></span>
        </div>
        <div id="yieldYearAverages" style="display: none; margin-top: 0.5rem; padding: 0.5rem; background: #eff6ff; border-radius: 0.375rem; color: #1e40af; font-size: 0.75rem;"></div>
      </div>

      <!-- Yield Year explanation (hidden by default) -->
      <div id="yieldYearInfoBox" style="display: none; background: linear-gradient(to right, #f0fdf4, #ecfdf5); border: 1px solid #22c55e; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem; font-size: 0.85rem; color: #166534;">
        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 0.75rem;">
          <strong style="font-size: 1rem;">üìÖ Understanding Yield Year Options</strong>
          <span onclick="toggleYieldYearInfo()" style="cursor: pointer; color: #64748b; font-size: 1.2rem;">&times;</span>
        </div>

        <div style="display: grid; gap: 0.75rem;">
          <div style="background: white; border-radius: 0.375rem; padding: 0.75rem; border-left: 4px solid #3b82f6;">
            <div style="font-weight: 600; color: #1e40af; margin-bottom: 0.25rem;">All Years (Averaged)</div>
            <p style="font-size: 0.8rem; color: #475569; margin: 0;">
              Averages yield across all years at each location. A sample with 180 bu in 2024 and 220 bu in 2025 becomes 200 bu.<br>
              <strong>Best for:</strong> Finding patterns that persist across years. Smooths out weather variation.
            </p>
          </div>

          <div style="background: white; border-radius: 0.375rem; padding: 0.75rem; border-left: 4px solid #8b5cf6;">
            <div style="font-weight: 600; color: #6d28d9; margin-bottom: 0.25rem;">All Years (Combined)</div>
            <p style="font-size: 0.8rem; color: #475569; margin: 0;">
              Each year treated as separate data point. Same location counted multiple times (once per year).<br>
              <strong>Best for:</strong> Maximum sample size when years had similar growing conditions.<br>
              <span style="color: #b45309;">‚ö†Ô∏è Combines good and bad years together - results may be misleading if yields varied significantly.</span>
            </p>
          </div>

          <div style="background: white; border-radius: 0.375rem; padding: 0.75rem; border-left: 4px solid #22c55e;">
            <div style="font-weight: 600; color: #166534; margin-bottom: 0.25rem;">All Years (Year-Normalized)</div>
            <p style="font-size: 0.8rem; color: #475569; margin: 0;">
              Each year treated separately, but yields converted to % of that year's average.<br>
              <em>Example: 200 bu yield in a 180 bu avg year = 111%. 250 bu yield in a 250 bu avg year = 100%.</em><br>
              <strong>Best for:</strong> Comparing across years with different weather. Isolates nutrient effect from seasonal variation.
            </p>
          </div>

          <div style="background: white; border-radius: 0.375rem; padding: 0.75rem; border-left: 4px solid #f59e0b;">
            <div style="font-weight: 600; color: #b45309; margin-bottom: 0.25rem;">Individual Year (e.g., "2024")</div>
            <p style="font-size: 0.8rem; color: #475569; margin: 0;">
              Only uses yield from that specific harvest year.<br>
              <strong>Best for:</strong> Analyzing a specific season's results.
            </p>
          </div>
        </div>

        <div style="margin-top: 1rem; padding: 0.75rem; background: white; border-radius: 0.375rem; border: 1px dashed #22c55e;">
          <div style="font-weight: 600; color: #166534; margin-bottom: 0.5rem;">ü§î How should I choose?</div>
          <ul style="font-size: 0.8rem; color: #475569; margin: 0; padding-left: 1.25rem;">
            <li><strong>Similar yields across years?</strong> ‚Üí "Combined" gives you more data points</li>
            <li><strong>Very different yields (drought vs good year)?</strong> ‚Üí "Year-Normalized" controls for weather</li>
            <li><strong>Want simplicity?</strong> ‚Üí "Averaged" is most straightforward</li>
            <li><strong>Analyzing specific season?</strong> ‚Üí Select individual year</li>
          </ul>
        </div>
      </div>

      <!-- Normalization explanation (hidden by default) -->
      <div id="normalizeInfoBox" style="display: none; background: linear-gradient(to right, #eff6ff, #f0f9ff); border: 1px solid #3b82f6; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem; font-size: 0.85rem; color: #1e40af;">
        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 0.75rem;">
          <strong style="font-size: 1rem;">üìä Understanding Field Normalization</strong>
          <span onclick="toggleNormalizeInfo()" style="cursor: pointer; color: #64748b; font-size: 1.2rem;">&times;</span>
        </div>

        <p style="margin-bottom: 0.75rem;"><strong>Why do correlations change when normalized?</strong></p>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
          <div style="background: white; border-radius: 0.375rem; padding: 0.75rem;">
            <div style="font-weight: 600; color: #dc2626; margin-bottom: 0.5rem;">WITHOUT normalization:</div>
            <p style="font-size: 0.8rem; color: #475569;">Correlations include differences between fields. A high-yielding field with high P will inflate the P-yield correlation, even if P isn't the reason that field yields well (could be better soil type, drainage, etc.)</p>
          </div>
          <div style="background: white; border-radius: 0.375rem; padding: 0.75rem;">
            <div style="font-weight: 600; color: #16a34a; margin-bottom: 0.5rem;">WITH normalization:</div>
            <p style="font-size: 0.8rem; color: #475569;">Yields are converted to "% of field average", removing field-to-field differences. This isolates the nutrient effect by asking: "Within each field, do higher nutrient levels produce above-average yields?"</p>
          </div>
        </div>

        <div style="background: #fef3c7; border-radius: 0.375rem; padding: 0.75rem; margin-bottom: 0.75rem;">
          <div style="font-weight: 600; color: #92400e; margin-bottom: 0.5rem;">Why correlations often decrease:</div>
          <p style="font-size: 0.8rem; color: #78350f;">Some of the original correlation was driven by field productivity differences, not the nutrient itself. The normalized correlation is stricter but more trustworthy for fertilizer decisions.</p>
        </div>

        <div style="background: white; border-radius: 0.375rem; padding: 0.75rem; margin-bottom: 0.75rem;">
          <div style="font-weight: 600; color: #1e40af; margin-bottom: 0.5rem;">Example:</div>
          <ul style="font-size: 0.8rem; color: #475569; margin: 0; padding-left: 1.25rem;">
            <li>Raw correlation: P = <strong>+0.35</strong> (includes field effects)</li>
            <li>Normalized: P = <strong>+0.18</strong> (nutrient effect only)</li>
            <li>The 0.18 is more reliable for predicting if adding P will help within a field.</li>
          </ul>
        </div>

        <div style="background: #dcfce7; border-radius: 0.375rem; padding: 0.75rem;">
          <div style="font-weight: 600; color: #166534;">üí° Recommendation:</div>
          <p style="font-size: 0.8rem; color: #166534; margin: 0;">Use <strong>normalized correlations</strong> when deciding on variable-rate fertilizer applications within fields. Use <strong>raw correlations</strong> when comparing overall field performance.</p>
        </div>
      </div>

      <!-- Sub-tabs for Yield Correlation -->
      <div class="yield-subtabs" style="display: flex; gap: 0.5rem; margin-bottom: 1rem; border-bottom: 2px solid #e2e8f0; padding-bottom: 0.5rem;">
        <button class="yield-subtab active" data-subtab="single" onclick="switchYieldSubtab('single')" style="padding: 0.5rem 1rem; border: none; background: #3b82f6; color: white; border-radius: 0.375rem 0.375rem 0 0; font-weight: 500; cursor: pointer;">
          üìä Individual Correlations
        </button>
        <button class="yield-subtab" data-subtab="multi" onclick="switchYieldSubtab('multi')" style="padding: 0.5rem 1rem; border: none; background: #f1f5f9; color: #64748b; border-radius: 0.375rem 0.375rem 0 0; font-weight: 500; cursor: pointer;">
          üî¨ Multivariate Regression
        </button>
        <button class="yield-subtab" data-subtab="buckets" onclick="switchYieldSubtab('buckets')" style="padding: 0.5rem 1rem; border: none; background: #f1f5f9; color: #64748b; border-radius: 0.375rem 0.375rem 0 0; font-weight: 500; cursor: pointer;">
          üìà Yield by Nutrient Level
        </button>
      </div>

      <!-- Single Nutrient Tab Content -->
      <div id="yieldSingleTab" class="yield-subtab-content">
        <div style="background: #f0fdf4; border: 1px solid #86efac; border-radius: 0.375rem; padding: 0.75rem; margin-bottom: 1rem; font-size: 0.8rem; color: #166534;">
          <strong>Individual Correlations:</strong> Analyzes each nutrient separately. Shows how each nutrient relates to yield independently - useful for exploring individual relationships.
        </div>
        <div id="yieldContent">
        <div class="no-data">No yield data available. Import yield maps on the Import page to see correlations.</div>
      </div>

      <!-- Scatter Plot Section -->
      <div id="scatterSection" style="margin-top: 1.5rem; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 0.5rem; padding: 1rem;">
        <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem; margin-bottom: 1rem;">
          <div style="display: flex; align-items: center; gap: 1rem;">
            <h3 id="scatterTitle" style="margin: 0; color: #1e293b;">Scatter Plot: Nutrient vs Yield</h3>
            <button onclick="toggleScatterAxes()" id="swapAxesBtn" style="padding: 0.375rem 0.75rem; border-radius: 0.375rem; border: 1px solid #3b82f6; background: #eff6ff; color: #1d4ed8; font-size: 0.8rem; cursor: pointer; display: flex; align-items: center; gap: 0.25rem;">
              <span style="font-size: 1rem;">‚áÑ</span> Swap Axes
            </button>
          </div>
          <div style="display: flex; gap: 1rem; align-items: center; flex-wrap: wrap;">
            <div>
              <label style="margin-right: 0.5rem;">Nutrient:</label>
              <select id="scatterNutrientSelect" onchange="drawScatterPlot()" style="padding: 0.375rem 0.75rem; border-radius: 0.375rem; border: 1px solid #cbd5e1;"></select>
            </div>
            <div style="display: flex; align-items: center; gap: 0.5rem;">
              <label>Yield Threshold:</label>
              <input type="range" id="yieldThresholdSlider" min="100" max="400" value="200" step="10" onchange="updateThresholdDisplay(); drawScatterPlot();" style="width: 120px;">
              <input type="number" id="yieldThresholdInput" value="200" min="50" max="500" step="5" onchange="syncThresholdSlider(); drawScatterPlot();" style="width: 70px; padding: 0.25rem; border-radius: 0.25rem; border: 1px solid #cbd5e1;">
              <span style="color: #64748b;">bu/ac</span>
            </div>
          </div>
        </div>
        <!-- Outlier Filter -->
        <div style="margin-bottom: 0.75rem; display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;">
          <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; padding: 0.375rem 0.75rem; background: #fef2f2; border: 1px solid #fca5a5; border-radius: 0.375rem;">
            <input type="checkbox" id="hideOutliersCheckbox" checked onchange="drawScatterPlot();" style="width: 16px; height: 16px;">
            <span style="font-size: 0.85rem; color: #991b1b; font-weight: 500;">Hide outliers</span>
          </label>
          <span id="outlierFilterInfo" style="font-size: 0.8rem; color: #dc2626;"></span>
        </div>
        <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
          <div style="flex: 1; min-width: 600px;">
            <canvas id="scatterCanvas" width="900" height="500" style="background: white; border: 1px solid #e2e8f0; border-radius: 0.375rem; width: 100%; height: auto;"></canvas>
          </div>
          <div id="thresholdAnalysis" style="min-width: 280px; background: white; border: 1px solid #e2e8f0; border-radius: 0.375rem; padding: 1rem;">
            <h4 style="margin: 0 0 0.75rem 0; color: #1e293b; font-size: 0.95rem;">Threshold Analysis</h4>
            <div id="thresholdContent" style="font-size: 0.85rem; color: #475569;"></div>
          </div>
        </div>
        <div id="scatterStats" style="margin-top: 0.75rem; font-size: 0.875rem; color: #64748b;"></div>

        <!-- Data Verification Button -->
        <div style="margin-top: 1rem; text-align: center;">
          <button onclick="toggleYieldDebug()" class="export-btn" style="background: #f1f5f9; color: #475569; border: 1px solid #cbd5e1;">üîç Data Verification Check</button>
        </div>
      </div>

      <!-- Debug Panel (hidden by default) -->
      <div id="yieldDebugPanel" style="display: none; margin-top: 1rem; background: #fffbeb; border: 2px solid #f59e0b; border-radius: 0.5rem; padding: 1rem;">
        <h4 style="margin: 0 0 1rem 0; color: #92400e;">Data Verification Report</h4>
        <div id="yieldDebugContent" style="font-family: monospace; font-size: 0.75rem; white-space: pre-wrap; color: #78350f; max-height: 500px; overflow-y: auto;"></div>
      </div>
      </div><!-- End yieldSingleTab -->

      <!-- Multivariate Model Tab Content -->
      <div id="yieldMultiTab" class="yield-subtab-content" style="display: none;">
        <div style="background: #eff6ff; border: 1px solid #93c5fd; border-radius: 0.375rem; padding: 0.75rem; margin-bottom: 1rem; font-size: 0.8rem; color: #1e40af;">
          <strong>Multivariate Regression:</strong> Analyzes all nutrients together. Shows which nutrients significantly affect yield <em>after controlling for the others</em> - answers "What matters when everything is considered?"
        </div>

        <!-- Variable Selection -->
        <div style="background: white; border: 1px solid #e2e8f0; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
            <h4 style="margin: 0; color: #1e293b; font-size: 0.95rem;">üìã Select Variables for Model</h4>
            <div>
              <button onclick="selectAllMultiVars()" style="padding: 0.25rem 0.5rem; font-size: 0.75rem; border: 1px solid #cbd5e1; border-radius: 0.25rem; background: white; cursor: pointer; margin-right: 0.25rem;">Select All</button>
              <button onclick="selectCoreMultiVars()" style="padding: 0.25rem 0.5rem; font-size: 0.75rem; border: 1px solid #cbd5e1; border-radius: 0.25rem; background: white; cursor: pointer;">Core Only</button>
            </div>
          </div>
          <div id="multiVarCheckboxes" style="display: flex; flex-wrap: wrap; gap: 0.5rem;"></div>
          <div id="multiVarWarning" style="margin-top: 0.75rem; font-size: 0.8rem; color: #92400e;"></div>
        </div>

        <!-- Run Model Button -->
        <div style="margin-bottom: 1rem;">
          <button onclick="runMultivariateRegression()" style="padding: 0.75rem 1.5rem; background: #3b82f6; color: white; border: none; border-radius: 0.375rem; font-weight: 600; cursor: pointer; font-size: 0.95rem;">
            üî¨ Run Multivariate Regression
          </button>
        </div>

        <!-- Model Results -->
        <div id="multiModelResults" style="display: none;">
          <!-- Model Summary -->
          <div id="multiModelSummary" style="background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%); border: 2px solid #22c55e; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem;">
            <h4 style="margin: 0 0 0.75rem 0; color: #166534;">üìä Model Summary</h4>
            <div id="multiSummaryContent" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem;"></div>
          </div>

          <!-- Interpretation / Key Findings - BEFORE the table -->
          <div id="multiInterpretation" style="margin-bottom: 1rem;"></div>

          <!-- Collinearity Warning -->
          <div id="multiCollinearityWarning" style="display: none; background: #fef3c7; border: 1px solid #f59e0b; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem;">
            <h4 style="margin: 0 0 0.5rem 0; color: #92400e; font-size: 0.9rem;">‚ö†Ô∏è Collinearity Warning</h4>
            <p style="margin: 0 0 0.5rem 0; font-size: 0.8rem; color: #78350f;">Some variables are highly correlated with each other, which can make coefficient estimates unreliable.</p>
            <div id="collinearityDetails" style="font-size: 0.8rem; color: #78350f;"></div>
          </div>

          <!-- Coefficients Table - AFTER interpretation -->
          <div id="multiCoeffTableContainer" style="background: white; border: 1px solid #e2e8f0; border-radius: 0.5rem; overflow: hidden; margin-bottom: 1rem;">
            <div style="background: #f8fafc; padding: 0.75rem 1rem; border-bottom: 1px solid #e2e8f0;">
              <h4 style="margin: 0; color: #1e293b; font-size: 0.95rem;">üìà Regression Coefficients</h4>
              <p style="margin: 0.25rem 0 0 0; font-size: 0.75rem; color: #64748b;">Each coefficient shows the nutrient's effect on yield while holding other nutrients constant</p>
            </div>
            <div style="overflow-x: auto;">
              <table id="multiCoeffTable" style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
                <thead>
                  <tr style="background: #f1f5f9;">
                    <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0;">Variable</th>
                    <th style="padding: 0.75rem; text-align: right; border-bottom: 2px solid #e2e8f0;">Coefficient</th>
                    <th style="padding: 0.75rem; text-align: right; border-bottom: 2px solid #e2e8f0;">Std Error</th>
                    <th style="padding: 0.75rem; text-align: right; border-bottom: 2px solid #e2e8f0;">t-value</th>
                    <th style="padding: 0.75rem; text-align: right; border-bottom: 2px solid #e2e8f0;">p-value</th>
                    <th style="padding: 0.75rem; text-align: center; border-bottom: 2px solid #e2e8f0;">Sig.</th>
                  </tr>
                </thead>
                <tbody id="multiCoeffBody"></tbody>
              </table>
            </div>
            <div style="padding: 0.5rem 1rem; background: #f8fafc; font-size: 0.75rem; color: #64748b;">
              Significance: *** p < 0.001, ** p < 0.01, * p < 0.05, . p < 0.1
            </div>
          </div>

          <!-- Yield Predictor -->
          <div style="background: linear-gradient(135deg, #faf5ff 0%, #f3e8ff 100%); border: 2px solid #a855f7; border-radius: 0.5rem; padding: 1rem;">
            <h4 style="margin: 0 0 0.75rem 0; color: #7c3aed; font-size: 0.95rem;">üéØ Yield Predictor</h4>
            <p style="margin: 0 0 0.75rem 0; font-size: 0.8rem; color: #6b21a8;">Enter nutrient values to predict yield based on the model.</p>
            <div id="predictorInputs" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 0.75rem; margin-bottom: 0.75rem;"></div>
            <button onclick="predictYield()" style="padding: 0.5rem 1rem; background: #a855f7; color: white; border: none; border-radius: 0.375rem; cursor: pointer; font-weight: 500;">
              Predict Yield
            </button>
            <div id="predictionResult" style="margin-top: 0.75rem; padding: 0.75rem; background: white; border-radius: 0.375rem; display: none;"></div>
          </div>
        </div>
      </div><!-- End yieldMultiTab -->

      <!-- Yield by Nutrient Level Tab Content -->
      <div id="yieldBucketsTab" class="yield-subtab-content" style="display: none;">
        <div style="background: #fef3c7; border: 1px solid #fcd34d; border-radius: 0.375rem; padding: 0.75rem; margin-bottom: 1rem; font-size: 0.8rem; color: #92400e;">
          <strong>Yield by Nutrient Level:</strong> Groups soil samples into Low, Medium, and High categories for each nutrient, then shows the average yield for each group. Helps identify which nutrient levels are associated with the best yields.
        </div>

        <!-- Filters -->
        <div class="controls-bar" style="margin-bottom: 1rem;">
          <div class="control-group">
            <label>Field</label>
            <select id="bucketFieldSelect" onchange="updateYieldBucketAnalysis()"></select>
          </div>
          <div class="control-group">
            <label>Yield Year</label>
            <select id="bucketYieldYearSelect" onchange="updateYieldBucketAnalysis()"></select>
          </div>
          <div class="control-group">
            <label>Crop</label>
            <select id="bucketCropSelect" onchange="updateYieldBucketAnalysis()">
              <option value="all">All Crops</option>
              <option value="corn">Corn</option>
              <option value="soybeans">Soybeans</option>
            </select>
          </div>
        </div>

        <div id="yieldBucketsContent">
          <div class="no-data">Loading yield bucket analysis...</div>
        </div>
      </div><!-- End yieldBucketsTab -->
    </div>

    <!-- Tab: Spatial Change Analysis -->
    <div id="spatial" class="tab-content">
      <div class="controls-bar">
        <div class="control-group">
          <label>Field</label>
          <select id="spatialFieldSelect"></select>
        </div>
        <div class="control-group">
          <label>Nutrient</label>
          <select id="spatialNutrientSelect"></select>
        </div>
        <div class="control-group">
          <label>Base Year</label>
          <select id="spatialBaseYearSelect"></select>
        </div>
        <div class="control-group">
          <label>Compare To</label>
          <select id="spatialCompareYearSelect"></select>
        </div>
        <div class="control-group">
          <label>Match Radius</label>
          <select id="spatialRadiusSelect">
            <option value="50">50 ft</option>
            <option value="100" selected>100 ft (default)</option>
            <option value="150">150 ft</option>
            <option value="200">200 ft</option>
          </select>
        </div>
        <button onclick="exportSpatialAnalysis()" class="export-btn">üìÑ Export Report</button>
      </div>
      <div id="spatialContent">
        <div class="no-data">Select a field and nutrient to analyze spatial changes over time.</div>
      </div>
    </div>
  </div>

  <div id="statusMessage"></div>

  <script src="https://apis.google.com/js/api.js"></script>
  <script src="https://accounts.google.com/gsi/client"></script>
  <script src="js/core/data.js"></script>
  <script src="js/core/utils.js"></script>
  <script>
    // ========== APP VERSION ==========
    const APP_VERSION = "v1.0.103";
    const BUILD_DATE = "2026-01-21T16:46:33";

    // Reference shared data config with analysis-specific additions
    const CONFIG = {
      get CLIENT_ID() { return DataCore.config.CLIENT_ID; },
      get API_KEY() { return DataCore.config.API_KEY; },
      get SHEET_ID() { return DataCore.config.SHEET_ID; },

      NUTRIENTS: ['pH', 'P', 'P2', 'K', 'OM', 'CEC', 'Ca_sat', 'Mg_sat', 'K_Sat', 'H_Sat', 'Na_Sat', 'Zn', 'Cu', 'Mn', 'Fe', 'Boron', 'S', 'Buffer_pH', 'Na', 'Ca', 'Mg', 'NO3', 'NH4', 'Soluble_Salts', 'EC'],
      
      NUTRIENT_NAMES: {
        pH: 'pH', P: 'Phosphorus (P)', P2: 'Phosphorus P2', K: 'Potassium (K)', OM: 'Organic Matter',
        CEC: 'CEC', Ca_sat: 'Calcium Sat %', Mg_sat: 'Magnesium Sat %',
        K_Sat: 'K Base Sat %', H_Sat: 'H Base Sat %', Na_Sat: 'Na Base Sat %', Zn: 'Zinc', Cu: 'Copper',
        Mn: 'Manganese', Fe: 'Iron', Boron: 'Boron', S: 'Sulfur', Buffer_pH: 'Buffer pH',
        Na: 'Sodium', Ca: 'Calcium', Mg: 'Magnesium', NO3: 'Nitrate', NH4: 'Ammonium', Soluble_Salts: 'Soluble Salts', EC: 'EC'
      },
      
      NUTRIENT_UNITS: {
        pH: '', P: 'ppm', P2: 'ppm', K: 'ppm', OM: '%', CEC: 'meq/100g',
        Ca_sat: '%', Mg_sat: '%', K_Sat: '%', H_Sat: '%', Na_Sat: '%',
        Zn: 'ppm', Cu: 'ppm', Mn: 'ppm', Fe: 'ppm', Boron: 'ppm', S: 'ppm', Buffer_pH: '',
        Na: 'ppm', Ca: 'ppm', Mg: 'ppm', NO3: 'ppm', NH4: 'ppm', Soluble_Salts: 'mmhos/cm', EC: 'dS/m'
      },
      
      LOWER_IS_BETTER: ['Mg_sat', 'H_Sat', 'Na_Sat', 'Soluble_Salts'],

      // Default visibility for nutrients (used if no settings saved)
      DEFAULT_VISIBLE: ['pH', 'P', 'K', 'OM', 'CEC', 'Ca_sat', 'Mg_sat', 'K_Sat', 'H_Sat', 'Zn', 'Cu', 'Mn', 'Fe', 'Boron', 'S', 'Buffer_pH'],

      // Default decimal places for each attribute
      DECIMAL_PLACES: {
        pH: 2, Buffer_pH: 2, OM: 2, P: 0, P2: 0, K: 0, CEC: 1,
        Ca_sat: 1, Mg_sat: 1, K_Sat: 1, H_Sat: 1, Na_Sat: 1,
        Zn: 2, Cu: 2, Mn: 1, Fe: 1, Boron: 2, S: 1,
        Ca: 0, Mg: 0, Na: 0, NO3: 1, NH4: 1, Soluble_Salts: 2, EC: 2
      }
    };

    // Use shared getDecimals and formatValue from Utils
    function getDecimals(attr) {
      return window.Utils.getDecimals(attr, CONFIG.DECIMAL_PLACES);
    }
    function formatValue(value, attr) {
      return window.Utils.formatValue(value, attr, CONFIG.DECIMAL_PLACES);
    }

    // Get visible nutrients based on settings
    function getVisibleNutrients() {
      const saved = JSON.parse(localStorage.getItem('nutrientVisibility') || '{}');
      return CONFIG.NUTRIENTS.filter(n => {
        if (saved[n] !== undefined) return saved[n];
        return CONFIG.DEFAULT_VISIBLE.includes(n);
      });
    }

    let tokenClient, accessToken = null, tokenExpiry = null;
    let sampleData = [];
    let yieldData = []; // Raw yield points (for getting available yield years)
    let year1 = null, year2 = null;
    let selectedComparisonFields = new Set(); // Track which fields are included in comparison

    // Yield correlation table state
    let yieldCorrelationsData = [];
    let yieldSortColumn = 'r'; // Default sort by correlation
    let yieldSortDirection = 'desc'; // desc = highest first

    // ========== CLIENT/FARM DATA ==========
    let clientsData = [];
    let farmsData = [];
    let fieldBoundaries = {};
    let activeClientId = 'all';
    let activeFarmId = 'all';

    // Use shared functions from DataCore
    const generateId = DataCore.generateId;
    const migrateDataIfNeeded = DataCore.migrateDataIfNeeded;

    function loadClientsData() {
      clientsData = DataCore.loadClientsData();
      return clientsData;
    }

    function loadFarmsData() {
      farmsData = DataCore.loadFarmsData();
      return farmsData;
    }

    function loadFieldBoundaries() {
      fieldBoundaries = DataCore.loadFieldBoundaries();
      return fieldBoundaries;
    }

    function loadActiveSelection() {
      const selection = DataCore.loadActiveSelection();
      activeClientId = selection.clientId;
      activeFarmId = selection.farmId;
    }

    function getActiveFields() {
      return DataCore.getActiveFields(fieldBoundaries, farmsData, activeClientId, activeFarmId);
    }

    // Update active operation indicator
    function updateActiveOperationIndicator() {
      const indicator = document.getElementById('activeOperationIndicator');
      if (!indicator) return;

      if (activeClientId === 'all') {
        indicator.style.display = 'none';
        return;
      }

      const client = clientsData.find(c => c.id === activeClientId);
      let text = client?.name || 'Unknown Client';

      if (activeFarmId !== 'all') {
        const farm = farmsData.find(f => f.id === activeFarmId);
        text += ` > ${farm?.name || 'Unknown Farm'}`;
      }

      indicator.innerHTML = `<span style="margin-right: 0.5rem;">üë§</span>${text} <a href="settings.html" style="color: #3b82f6; margin-left: 0.5rem;">[change]</a>`;
      indicator.style.display = 'block';
    }

    // Use shared SheetsAPI from DataCore
    const SheetsAPI = DataCore.SheetsAPI;

    document.addEventListener('DOMContentLoaded', async () => {
      // Run migration first to ensure data structures are up to date
      migrateDataIfNeeded();
      loadClientsData();
      loadFarmsData();
      loadFieldBoundaries();
      loadActiveSelection();

      try { await SheetsAPI.init(); SheetsAPI.onSignInChange = handleSignInChange; handleSignInChange(SheetsAPI.isSignedIn); } catch (e) {}
      await loadLocalData();
      setupTabs();
      setupEventListeners();
      updateBackupFooter();
      updateActiveOperationIndicator();
    });

    async function handleAuth() { if (SheetsAPI.isSignedIn) await SheetsAPI.signOut(); else await SheetsAPI.signIn(); }
    
    function handleSignInChange(isSignedIn) {
      const authBtn = document.getElementById('authBtn'), userInfo = document.getElementById('userInfo');
      if (isSignedIn) { userInfo.textContent = 'Connected'; authBtn.textContent = '‚úì Signed In'; authBtn.classList.add('signed-in'); }
      else { userInfo.textContent = ''; authBtn.textContent = 'Sign In to Edit'; authBtn.classList.remove('signed-in'); }
    }

    // IndexedDB - use shared openDB from DataCore
    const openDB = DataCore.openDB;

    async function loadFromIndexedDB() {
      try {
        const db = await openDB();
        // Check which stores exist
        const storeNames = Array.from(db.objectStoreNames);
        const hasYield = storeNames.includes('yield');
        const hasBoundaries = storeNames.includes('boundaries');
        const stores = ['samples'];
        if (hasBoundaries) stores.push('boundaries');
        if (hasYield) stores.push('yield');
        const tx = db.transaction(stores, 'readonly');

        const samplesData = await new Promise((resolve, reject) => {
          const req = tx.objectStore('samples').get('all');
          req.onsuccess = () => resolve(req.result?.data || []);
          req.onerror = reject;
        });

        let boundariesData = {};
        if (hasBoundaries) {
          boundariesData = await new Promise((resolve, reject) => {
            const req = tx.objectStore('boundaries').get('all');
            req.onsuccess = () => resolve(req.result?.data || {});
            req.onerror = reject;
          });
        }

        let yieldDataResult = [];
        if (hasYield) {
          yieldDataResult = await new Promise((resolve, reject) => {
            const req = tx.objectStore('yield').get('all');
            req.onsuccess = () => resolve(req.result?.data || []);
            req.onerror = reject;
          });
        }

        db.close();
        return { samples: samplesData, boundaries: boundariesData, yield: yieldDataResult };
      } catch (e) { return null; }
    }

    async function loadLocalData() {
      try {
        // Check IndexedDB first if flagged
        if (localStorage.getItem('usingIndexedDB') === 'true') {
          const idbData = await loadFromIndexedDB();
          if (idbData) {
            // Load samples, boundaries, and yield independently
            if (idbData.samples && idbData.samples.length > 0) {
              sampleData = idbData.samples;
            }
            if (idbData.boundaries && Object.keys(idbData.boundaries).length > 0) {
              fieldBoundaries = idbData.boundaries;
            }
            if (idbData.yield && idbData.yield.length > 0) {
              yieldData = idbData.yield;
            }
            console.log('Loaded from IndexedDB:', sampleData.length, 'samples,', Object.keys(fieldBoundaries).length, 'fields,', yieldData.length, 'yield points');
          }
        } else {
          const saved = localStorage.getItem('soilSamples');
          const yieldSaved = localStorage.getItem('yieldData');
          const boundariesSaved = localStorage.getItem('fieldBoundaries');
          if (saved) sampleData = JSON.parse(saved);
          if (yieldSaved) yieldData = JSON.parse(yieldSaved);
          if (boundariesSaved) fieldBoundaries = JSON.parse(boundariesSaved);
          console.log('Loaded from localStorage:', sampleData.length, 'samples,', Object.keys(fieldBoundaries).length, 'fields,', yieldData.length, 'yield points');
        }
      } catch (e) { console.error(e); }
      populateSelectors();
      updateComparison();
      updateHistory('__all__');  // Default to All Fields view
      updateRankings();
      updateYieldAnalysis();
    }

    function populateSelectors() {
      // Filter by active client/farm
      const activeFields = getActiveFields();
      const filteredSamples = sampleData.filter(s => activeFields.includes(s.field));

      const years = [...new Set(filteredSamples.map(s => s.year).filter(y => y))].sort((a, b) => b - a);
      const fields = [...new Set(filteredSamples.map(s => s.field).filter(f => f && f !== 'Unknown'))].sort();
      
      // Year comparison selectors - year1 is earlier (FROM), year2 is later (TO)
      const year1Sel = document.getElementById('year1Select');
      const year2Sel = document.getElementById('year2Select');
      year1Sel.innerHTML = ''; year2Sel.innerHTML = '';
      years.forEach((y, i) => {
        year1Sel.innerHTML += `<option value="${y}" ${i === 1 ? 'selected' : ''}>${y}</option>`;
        year2Sel.innerHTML += `<option value="${y}" ${i === 0 ? 'selected' : ''}>${y}</option>`;
      });
      year1 = years[1] || years[0] || null;  // Earlier year (second most recent)
      year2 = years[0] || null;               // Later year (most recent)
      
      // History field selector - default to All Fields (Operation Average)
      const historyFieldSel = document.getElementById('historyFieldSelect');
      historyFieldSel.innerHTML = '<option value="__all__" style="font-weight: bold;">üìä All Fields (Operation Average)</option>';
      fields.forEach(f => { historyFieldSel.innerHTML += `<option value="${f}">${f}</option>`; });
      historyFieldSel.value = '__all__';
      
      // Rankings selectors
      const rankAttrSel = document.getElementById('rankingAttrSelect');
      rankAttrSel.innerHTML = '';
      const visibleNutrients = getVisibleNutrients();
      visibleNutrients.forEach(n => { rankAttrSel.innerHTML += `<option value="${n}">${CONFIG.NUTRIENT_NAMES[n] || n}</option>`; });
      
      const rankYearSel = document.getElementById('rankingYearSelect');
      rankYearSel.innerHTML = '<option value="most_recent" selected>Most Recent</option>';
      years.forEach(y => { rankYearSel.innerHTML += `<option value="${y}">${y}</option>`; });
      
      // Yield year selector - filtered by selected crop
      updateYieldYearSelector();

      // Soil sample year selector
      const soilYearSel = document.getElementById('soilYearSelect');
      const soilYears = getSoilYearsWithYield();
      soilYearSel.innerHTML = '<option value="recent">Most Recent (default)</option><option value="all">All Years</option>';
      soilYears.forEach(y => { soilYearSel.innerHTML += `<option value="${y}">${y}</option>`; });

      // Yield field selector - will be populated by updateYieldFieldSelector based on selected crop
      updateYieldFieldSelector();

      // Spatial Change Analysis selectors
      const spatialFieldSel = document.getElementById('spatialFieldSelect');
      spatialFieldSel.innerHTML = '<option value="__all__">All Fields (Operation-Wide)</option>';
      fields.forEach(f => { spatialFieldSel.innerHTML += `<option value="${f}">${f}</option>`; });

      // Default to All Fields (Operation-Wide)
      spatialFieldSel.value = '__all__';

      const spatialNutrientSel = document.getElementById('spatialNutrientSelect');
      spatialNutrientSel.innerHTML = '';
      visibleNutrients.forEach(n => { spatialNutrientSel.innerHTML += `<option value="${n}">${CONFIG.NUTRIENT_NAMES[n] || n}</option>`; });

      // Initialize year selectors with All Fields selection
      updateSpatialYearSelectors('__all__');
    }

    function updateSpatialYearSelectors(field) {
      // Filter by active client/farm first
      const activeFieldsList = getActiveFields();
      const filteredSamples = sampleData.filter(s => activeFieldsList.includes(s.field));

      // Get years that have data for the selected field (or all fields if __all__)
      const fieldYears = [...new Set(
        filteredSamples
          .filter(s => (field === '__all__' || s.field === field) && s.year)
          .map(s => s.year)
      )].sort((a, b) => a - b); // Sort ascending (oldest first for base year)

      const spatialBaseYearSel = document.getElementById('spatialBaseYearSelect');
      const spatialCompareYearSel = document.getElementById('spatialCompareYearSelect');

      if (fieldYears.length === 0) {
        spatialBaseYearSel.innerHTML = '<option value="">No data for field</option>';
        spatialCompareYearSel.innerHTML = '<option value="">No data for field</option>';
        return;
      }

      // Base year dropdown - "Earliest Available" as default, then specific years
      spatialBaseYearSel.innerHTML = '<option value="earliest">Earliest Available (per field)</option>';
      fieldYears.forEach(y => { spatialBaseYearSel.innerHTML += `<option value="${y}">${y}</option>`; });

      // Compare year dropdown - includes "All Years" option (default), newest first (descending)
      const descendingYears = [...fieldYears].sort((a, b) => b - a);
      spatialCompareYearSel.innerHTML = '<option value="all">All Years</option>';
      descendingYears.forEach(y => { spatialCompareYearSel.innerHTML += `<option value="${y}">${y}</option>`; });
    }

    function updateYieldFieldSelector() {
      // Get selected crop and filter fields to only those with yield data for that crop
      const cropFilter = document.getElementById('yieldCropSelect').value;
      const yieldFieldSel = document.getElementById('yieldFieldSelect');
      const currentValue = yieldFieldSel.value;

      // Find fields that have yield data for the selected crop
      const fieldsWithYield = [...new Set(
        sampleData
          .filter(s => s.yieldCorrelations && Object.keys(s.yieldCorrelations).length > 0)
          .filter(s => {
            // Check if any yield correlation matches the crop filter
            return Object.values(s.yieldCorrelations).some(yieldInfo => yieldInfo.crop === cropFilter);
          })
          .map(s => s.field)
          .filter(f => f && f !== 'Unknown')
      )].sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));

      yieldFieldSel.innerHTML = '<option value="all">All Fields</option>';
      fieldsWithYield.forEach(f => { yieldFieldSel.innerHTML += `<option value="${f}">${f}</option>`; });

      // Try to restore previous selection if still valid
      if (currentValue && (currentValue === 'all' || fieldsWithYield.includes(currentValue))) {
        yieldFieldSel.value = currentValue;
      }
    }

    function getSoilYearsWithYield() {
      // Get soil sample years that have yield correlations
      const years = new Set();
      sampleData.forEach(s => {
        if (s.yieldCorrelations && Object.keys(s.yieldCorrelations).length > 0 && s.year) {
          years.add(s.year);
        }
      });
      return [...years].sort((a, b) => b - a);
    }
    
    function getYieldYears(cropFilter = null) {
      const yearCounts = {};  // Matched samples with yield correlations
      const rawYearCounts = {}; // Raw yield points by year (may not be matched)

      // Count matched yield correlations on soil samples - filter by crop if specified
      sampleData.forEach(s => {
        if (s.yieldCorrelations) {
          Object.entries(s.yieldCorrelations).forEach(([y, yieldInfo]) => {
            // Only count if crop matches (or no filter)
            if (!cropFilter || yieldInfo.crop === cropFilter) {
              const year = parseInt(y);
              yearCounts[year] = (yearCounts[year] || 0) + 1;
            }
          });
        }
      });

      // Also check raw yieldData for unmatched years - filter by crop if specified
      if (yieldData && yieldData.length > 0) {
        yieldData.forEach(y => {
          if (y.year && (!cropFilter || y.crop === cropFilter)) {
            rawYearCounts[y.year] = (rawYearCounts[y.year] || 0) + 1;
          }
        });
      }

      // Debug logging
      console.log('=== YIELD YEARS DEBUG ===');
      console.log('Crop filter:', cropFilter);
      console.log('Years in yieldCorrelations (matched):', yearCounts);
      console.log('Years in raw yieldData:', rawYearCounts);

      // Merge: include years from both matched and raw data
      const allYears = new Set([...Object.keys(yearCounts), ...Object.keys(rawYearCounts)]);
      return Array.from(allYears)
        .map(y => parseInt(y))
        .sort((a, b) => b - a) // Sort newest first
        .map(year => ({
          year,
          count: yearCounts[year] || 0,
          rawCount: rawYearCounts[year] || 0
        }));
    }

    function updateYieldYearSelector() {
      const cropFilter = document.getElementById('yieldCropSelect').value;
      const yieldYearSel = document.getElementById('yieldYearSelect');
      const yieldYears = getYieldYears(cropFilter);

      yieldYearSel.innerHTML = `<option value="avg">All Years (Averaged)</option>`;
      yieldYearSel.innerHTML += `<option value="combined">All Years (Combined)</option>`;
      yieldYearSel.innerHTML += `<option value="normalized">All Years (Year-Normalized)</option>`;

      yieldYears.forEach(y => {
        if (y.count > 0) {
          yieldYearSel.innerHTML += `<option value="${y.year}">${y.year} (${y.count.toLocaleString()} samples)</option>`;
        } else if (y.rawCount > 0) {
          yieldYearSel.innerHTML += `<option value="${y.year}" disabled>${y.year} - ${y.rawCount.toLocaleString()} yield pts (not matched)</option>`;
        }
      });

      updateYieldYearDescription();
    }

    function setupTabs() {
      document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', () => {
          document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
          tab.classList.add('active');
          document.getElementById(tab.dataset.tab).classList.add('active');

          // Auto-run analysis when switching to spatial tab
          if (tab.dataset.tab === 'spatial') {
            updateSpatialAnalysis();
          }
        });
      });
    }

    function setupEventListeners() {
      document.getElementById('year1Select').addEventListener('change', (e) => { year1 = e.target.value; selectedComparisonFields.clear(); updateComparison(); });
      document.getElementById('year2Select').addEventListener('change', (e) => { year2 = e.target.value; selectedComparisonFields.clear(); updateComparison(); });
      document.getElementById('historyFieldSelect').addEventListener('change', (e) => { updateHistory(e.target.value); });
      document.getElementById('rankingAttrSelect').addEventListener('change', updateRankings);
      document.getElementById('rankingYearSelect').addEventListener('change', updateRankings);
      document.getElementById('yieldCropSelect').addEventListener('change', () => {
        updateYieldYearSelector();  // Update year dropdown to show only years with data for selected crop
        updateYieldFieldSelector();
        updateYieldAnalysis();
        resetMultiModel();
      });
      document.getElementById('yieldYearSelect').addEventListener('change', () => {
        updateYieldAnalysis();
        resetMultiModel();
      });
      document.getElementById('soilYearSelect').addEventListener('change', () => {
        updateYieldAnalysis();
        resetMultiModel();
      });
      document.getElementById('yieldFieldSelect').addEventListener('change', () => {
        updateYieldAnalysis();
        resetMultiModel();
      });
      document.getElementById('yieldNormalizeToggle').addEventListener('change', () => {
        updateYieldAnalysis();
        resetMultiModel();
      });
      // Spatial Change Analysis listeners
      document.getElementById('spatialFieldSelect').addEventListener('change', (e) => {
        updateSpatialYearSelectors(e.target.value);
        updateSpatialAnalysis();
      });
      document.getElementById('spatialNutrientSelect').addEventListener('change', updateSpatialAnalysis);
      document.getElementById('spatialBaseYearSelect').addEventListener('change', updateSpatialAnalysis);
      document.getElementById('spatialCompareYearSelect').addEventListener('change', updateSpatialAnalysis);
      document.getElementById('spatialRadiusSelect').addEventListener('change', updateSpatialAnalysis);
    }

    function getStats(samples, attr) {
      // Filter to only valid numeric values - exclude undefined, null, empty strings, and NaN
      const values = samples.map(s => s[attr])
        .filter(v => v !== undefined && v !== null && v !== '' && !isNaN(parseFloat(v)))
        .map(v => parseFloat(v));
      if (values.length === 0) return null;
      const sorted = [...values].sort((a, b) => a - b);
      const mid = Math.floor(sorted.length / 2);
      const median = sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
      return {
        avg: values.reduce((a, b) => a + b, 0) / values.length,
        median: median,
        high: Math.max(...values),
        low: Math.min(...values),
        count: values.length
      };
    }
    
    function updateYearStatsBox(container, year, samples) {
      if (!year || samples.length === 0) {
        container.innerHTML = '<p style="color: #94a3b8; font-style: italic;">No data</p>';
        return;
      }

      // Get unique fields
      const fields = [...new Set(samples.map(s => s.field).filter(f => f && f !== 'Unknown'))].sort();

      let html = `
        <div style="display: flex; gap: 1.5rem; flex-wrap: wrap; align-items: center;">
          <div>
            <div style="font-size: 1.5rem; font-weight: 700; color: #1e293b;">${year}</div>
            <div style="font-size: 0.875rem; color: #64748b;">${samples.length} samples across ${fields.length} fields</div>
          </div>
        </div>
      `;

      container.innerHTML = html;
    }
    
    window.toggleComparisonField = function(field) {
      if (selectedComparisonFields.has(field)) {
        selectedComparisonFields.delete(field);
      } else {
        selectedComparisonFields.add(field);
      }
      updateComparison();
    };
    
    window.selectMatchingComparisonFields = function() {
      const allSamplesFrom = year1 ? sampleData.filter(s => String(s.year) === String(year1)) : [];
      const allSamplesTo = sampleData.filter(s => String(s.year) === String(year2));
      const excludeFields = ['Unknown', 'Unassigned', 'unknown', 'unassigned', null, undefined, ''];
      const fieldsFrom = new Set(allSamplesFrom.map(s => s.field).filter(f => f && !excludeFields.includes(f)));
      const fieldsTo = new Set(allSamplesTo.map(s => s.field).filter(f => f && !excludeFields.includes(f)));
      const allFields = [...new Set([...fieldsFrom, ...fieldsTo])];
      // Clear first, then only select fields that have data in both years (matching fields)
      selectedComparisonFields.clear();
      allFields.forEach(f => {
        if (fieldsFrom.has(f) && fieldsTo.has(f)) {
          selectedComparisonFields.add(f);
        }
      });
      updateComparison();
    };

    window.selectAllComparisonFields = function() {
      const allSamplesFrom = year1 ? sampleData.filter(s => String(s.year) === String(year1)) : [];
      const allSamplesTo = sampleData.filter(s => String(s.year) === String(year2));
      const excludeFields = ['Unknown', 'Unassigned', 'unknown', 'unassigned', null, undefined, ''];
      const fieldsFrom = new Set(allSamplesFrom.map(s => s.field).filter(f => f && !excludeFields.includes(f)));
      const fieldsTo = new Set(allSamplesTo.map(s => s.field).filter(f => f && !excludeFields.includes(f)));
      const allFields = [...new Set([...fieldsFrom, ...fieldsTo])];
      // Select all fields from both years
      selectedComparisonFields.clear();
      allFields.forEach(f => selectedComparisonFields.add(f));
      updateComparison();
    };

    // ========== TAB 1: Year Comparison ==========
    // year1 = FROM (earlier year), year2 = TO (later year)
    // Stats shown are for year2, change = year2 - year1
    function updateComparison() {
      const grid = document.getElementById('comparisonGrid');
      const fromYearInfo = document.getElementById('fromYearInfo');
      const toYearInfo = document.getElementById('toYearInfo');
      const fieldCheckboxes = document.getElementById('fieldCheckboxes');
      const mismatchWarning = document.getElementById('fieldMismatchWarning');

      // Filter samples by active client/farm
      const activeFields = getActiveFields();
      const filteredSampleData = sampleData.filter(s => activeFields.includes(s.field));

      if (!year2 || filteredSampleData.length === 0) {
        grid.innerHTML = '<div class="no-data">No data available. Import soil samples to see analysis.</div>';
        fromYearInfo.innerHTML = '';
        toYearInfo.innerHTML = '';
        fieldCheckboxes.innerHTML = '';
        mismatchWarning.innerHTML = '';
        return;
      }

      const allSamplesFrom = year1 ? filteredSampleData.filter(s => String(s.year) === String(year1)) : [];
      const allSamplesTo = filteredSampleData.filter(s => String(s.year) === String(year2));
      
      // Get all fields from both years (exclude Unknown and Unassigned)
      const excludeFields = ['Unknown', 'Unassigned', 'unknown', 'unassigned', null, undefined, ''];
      const fieldsFrom = new Set(allSamplesFrom.map(s => s.field).filter(f => f && !excludeFields.includes(f)));
      const fieldsTo = new Set(allSamplesTo.map(s => s.field).filter(f => f && !excludeFields.includes(f)));
      const allFields = [...new Set([...fieldsFrom, ...fieldsTo])].sort();
      
      // Initialize selectedComparisonFields if empty - only select fields in BOTH years by default
      if (selectedComparisonFields.size === 0) {
        allFields.forEach(f => {
          // Only check fields that have data in both years
          if (fieldsFrom.has(f) && fieldsTo.has(f)) {
            selectedComparisonFields.add(f);
          }
        });
      }
      
      // Update field checkboxes
      fieldCheckboxes.innerHTML = allFields.map(field => {
        const inFrom = fieldsFrom.has(field);
        const inTo = fieldsTo.has(field);
        const checked = selectedComparisonFields.has(field);
        const mismatch = (inFrom && !inTo) || (!inFrom && inTo);
        const bgColor = mismatch ? '#fef3c7' : (checked ? '#dcfce7' : '#f8fafc');
        const borderColor = mismatch ? '#f59e0b' : (checked ? '#22c55e' : '#cbd5e1');
        
        return `
          <label style="display: flex; align-items: center; gap: 0.375rem; padding: 0.375rem 0.625rem; background: ${bgColor}; border: 1px solid ${borderColor}; border-radius: 0.375rem; cursor: pointer; font-size: 0.8125rem;">
            <input type="checkbox" ${checked ? 'checked' : ''} onchange="toggleComparisonField('${field}')" style="cursor: pointer;">
            <span>${field}</span>
            ${mismatch ? '<span style="color: #f59e0b;" title="Not in both years">‚ö†Ô∏è</span>' : ''}
          </label>
        `;
      }).join('');
      
      // Check for mismatches
      const onlyInFrom = [...fieldsFrom].filter(f => !fieldsTo.has(f));
      const onlyInTo = [...fieldsTo].filter(f => !fieldsFrom.has(f));
      
      if (onlyInFrom.length > 0 || onlyInTo.length > 0) {
        let warningHtml = '<div style="background: #fef3c7; border: 1px solid #f59e0b; border-radius: 0.375rem; padding: 0.75rem; font-size: 0.8125rem;">';
        warningHtml += '<strong style="color: #92400e;">‚ö†Ô∏è Field Mismatch Detected</strong><br>';
        if (onlyInFrom.length > 0) {
          warningHtml += `<span style="color: #92400e;">Only in ${year1}: ${onlyInFrom.join(', ')}</span><br>`;
        }
        if (onlyInTo.length > 0) {
          warningHtml += `<span style="color: #92400e;">Only in ${year2}: ${onlyInTo.join(', ')}</span>`;
        }
        warningHtml += '</div>';
        mismatchWarning.innerHTML = warningHtml;
      } else {
        mismatchWarning.innerHTML = '';
      }
      
      // Filter samples by selected fields
      const samplesFrom = allSamplesFrom.filter(s => selectedComparisonFields.has(s.field));
      const samplesTo = allSamplesTo.filter(s => selectedComparisonFields.has(s.field));
      
      // Update year stats boxes
      updateYearStatsBox(fromYearInfo, year1, samplesFrom);
      updateYearStatsBox(toYearInfo, year2, samplesTo);
      
      if (samplesTo.length === 0) {
        // Check if the issue is no matching fields
        const matchingFields = allFields.filter(f => fieldsFrom.has(f) && fieldsTo.has(f));
        if (matchingFields.length === 0 && allFields.length > 0) {
          grid.innerHTML = `<div class="no-data">No matching fields between ${year1} and ${year2}.<br><small style="color: #64748b;">Fields may have different names. Try "Reassign samples to boundaries" on the Import page, or select fields manually above.</small></div>`;
        } else {
          grid.innerHTML = `<div class="no-data">No samples found for ${year2} with selected fields.<br><small style="color: #64748b;">Select fields above to include in comparison.</small></div>`;
        }
        return;
      }
      
      let html = '';
      
      const visibleNutrients = getVisibleNutrients();
      visibleNutrients.forEach(attr => {
        const statsTo = getStats(samplesTo, attr);
        const statsFrom = year1 ? getStats(samplesFrom, attr) : null;
        
        if (!statsTo) return;
        
        const name = CONFIG.NUTRIENT_NAMES[attr] || attr;
        const unit = CONFIG.NUTRIENT_UNITS[attr] || '';
        const decimals = getDecimals(attr);
        const isLowerBetter = CONFIG.LOWER_IS_BETTER.includes(attr);
        
        let pointChange = 0, pctChange = 0, cardClass = '', pctClass = 'neutral';
        
        if (statsFrom && statsFrom.avg !== undefined) {
          pointChange = statsTo.avg - statsFrom.avg;
          pctChange = statsFrom.avg !== 0 ? (pointChange / statsFrom.avg) * 100 : 0;
          const isPositive = isLowerBetter ? pointChange < 0 : pointChange > 0;
          const isSignificant = Math.abs(pctChange) > 2;
          if (isSignificant) {
            cardClass = isPositive ? 'positive' : 'negative';
            pctClass = isPositive ? 'positive' : 'negative';
          }
        } else if (year1 && samplesFrom.length === 0) {
          // No data from year1 for selected fields - show warning style
          cardClass = 'no-comparison';
        }
        
        html += `
          <div class="nutrient-card ${cardClass}">
            <div class="nutrient-header">
              <span class="nutrient-name">${name}</span>
              ${statsFrom ? `<span class="nutrient-pct ${pctClass}">${pctChange >= 0 ? '+' : ''}${pctChange.toFixed(1)}%</span>` : ''}
            </div>
            <div class="nutrient-stats">
              <div class="stat-box"><div class="label">Average</div><div class="value">${statsTo.avg.toFixed(decimals)}</div></div>
              <div class="stat-box"><div class="label">High</div><div class="value">${statsTo.high.toFixed(decimals)}</div></div>
              <div class="stat-box"><div class="label">Low</div><div class="value">${statsTo.low.toFixed(decimals)}</div></div>
            </div>
            ${statsFrom ? `
              <div class="year-comparison">
                <div class="year-val"><div class="yr">${year1}</div><div class="num">${statsFrom.avg.toFixed(decimals)}</div></div>
                <div class="year-arrow">‚Üí</div>
                <div class="year-val"><div class="yr">${year2}</div><div class="num">${statsTo.avg.toFixed(decimals)}</div></div>
              </div>
              <div class="change-row">
                <span>Point: <span class="val ${pctClass}">${pointChange >= 0 ? '+' : ''}${pointChange.toFixed(decimals)}</span></span>
                <span>%: <span class="val ${pctClass}">${pctChange >= 0 ? '+' : ''}${pctChange.toFixed(1)}%</span></span>
              </div>
            ` : `<div class="year-comparison" style="justify-content:center; flex-direction:column; align-items:center;">
              <div class="year-val"><div class="yr">${year2}</div><div class="num">${statsTo.avg.toFixed(decimals)} ${unit}</div></div>
              ${year1 && samplesFrom.length === 0 ? `<div style="font-size:0.75rem;color:#92400e;margin-top:0.5rem;">‚ö†Ô∏è No ${year1} data for selected fields</div>` : ''}
            </div>`}
          </div>
        `;
      });
      
      grid.innerHTML = html || '<div class="no-data">No nutrient data available</div>';
    }

    // ========== TAB 2: Historical Field Trends ==========
    function updateHistory(fieldName) {
      const container = document.getElementById('historyContent');

      if (!fieldName) {
        container.innerHTML = '<div class="no-data">Select a field to view nutrient trends over time</div>';
        return;
      }

      // Handle "All Fields" operation-wide trends
      if (fieldName === '__all__') {
        renderOperationTrends(container);
        return;
      }

      console.log('=== Field Trends Debug ===');
      console.log('Selected field:', JSON.stringify(fieldName), 'length:', fieldName.length);

      const fieldSamples = sampleData.filter(s => s.field === fieldName);
      console.log('Samples found:', fieldSamples.length);

      const years = [...new Set(fieldSamples.map(s => s.year).filter(y => y))].sort();
      console.log('Years found:', years);

      if (fieldSamples.length > 0) {
        console.log('First sample:', JSON.stringify(fieldSamples[0]));
        console.log('Sample years breakdown:', years.map(y => ({ year: y, count: fieldSamples.filter(s => String(s.year) === String(y)).length })));
      }

      if (years.length < 1) {
        container.innerHTML = '<div class="no-data">No data available for this field</div>';
        return;
      }

      let html = `<div style="background:#f8fafc;border:2px solid #cbd5e1;border-radius:0.5rem;padding:1rem;margin-bottom:1rem;"><h3 style="margin:0 0 0.25rem 0;">${fieldName}</h3><p style="margin:0;color:#64748b;">Years: ${years.join(', ')} (${fieldSamples.length} samples)</p></div>`;

      try {
        const visibleNutrients = getVisibleNutrients();
        console.log('Visible nutrients:', visibleNutrients.length);

        visibleNutrients.forEach(attr => {
          try {
            const yearData = [];
            let hasData = false;

            years.forEach(year => {
              const yearSamples = fieldSamples.filter(s => String(s.year) === String(year));
              const stats = getStats(yearSamples, attr);
              if (stats) { yearData.push({ year, avg: stats.avg, median: stats.median, count: stats.count }); hasData = true; }
            });

            if (!hasData || yearData.length < 1) return;

            const first = yearData[0], last = yearData[yearData.length - 1];
            const avgChange = last.avg - first.avg;
            const medianChange = last.median - first.median;
            const pctChange = first.avg !== 0 ? (avgChange / first.avg) * 100 : 0;
            const isLowerBetter = CONFIG.LOWER_IS_BETTER.includes(attr);
            const isPositive = isLowerBetter ? avgChange < 0 : avgChange > 0;
            const decimals = getDecimals(attr);
            const unit = CONFIG.NUTRIENT_UNITS[attr] || '';
            const name = CONFIG.NUTRIENT_NAMES[attr] || attr;

            let cardClass = 'neutral', color = '#64748b';
            if (yearData.length > 1) {
              cardClass = isPositive ? 'positive' : 'negative';
              color = isPositive ? '#22c55e' : '#ef4444';
            }

            const graph = createDualLineGraph(yearData, color, attr);

            html += `
              <div class="trend-card ${cardClass}">
                <div class="trend-header">
                  <h4 class="trend-title">${name}</h4>
                  ${yearData.length > 1 ? `<div class="trend-pct" style="color:${color};">${pctChange >= 0 ? '+' : ''}${pctChange.toFixed(1)}%<div class="trend-sub">${first.year} ‚Üí ${last.year}</div></div>` : ''}
                </div>
                <div class="trend-content">
                  <div class="trend-values">
                    <div style="font-size:0.7rem;color:#64748b;margin-bottom:0.25rem;display:flex;justify-content:space-between;padding:0 0.75rem;"><span></span><span style="width:70px;text-align:center;">Avg</span><span style="width:70px;text-align:center;">Median</span></div>
                    ${yearData.map((d, i) => `<div class="trend-row ${i % 2 === 0 ? 'alt' : ''}"><span class="trend-year">${d.year}:</span><span class="trend-value" style="width:70px;text-align:center;">${d.avg.toFixed(decimals)}</span><span class="trend-value" style="width:70px;text-align:center;color:#8b5cf6;">${d.median.toFixed(decimals)}</span></div>`).join('')}
                    ${yearData.length > 1 ? `<div class="trend-row" style="margin-top:0.5rem;border-top:2px solid ${color};padding-top:0.5rem;"><span>Change:</span><span style="width:70px;text-align:center;color:${color};font-weight:700;">${avgChange >= 0 ? '+' : ''}${avgChange.toFixed(decimals)}</span><span style="width:70px;text-align:center;color:#8b5cf6;font-weight:700;">${medianChange >= 0 ? '+' : ''}${medianChange.toFixed(decimals)}</span></div>` : ''}
                  </div>
                  <div class="trend-graph ${yearData.length > 10 ? 'xlarge' : (yearData.length > 5 ? 'large' : '')}">
                    <div style="display:flex;gap:1rem;font-size:0.7rem;margin-bottom:0.25rem;justify-content:center;">
                      <span><span style="color:${color};">‚óè</span> Average</span>
                      <span><span style="color:#8b5cf6;">‚óè</span> Median</span>
                    </div>
                    ${graph}
                  </div>
                </div>
              </div>
            `;
          } catch (attrError) {
            console.error('Error processing attribute', attr, ':', attrError);
          }
        });

        console.log('Generated HTML length:', html.length);
        container.innerHTML = html || '<div class="no-data">No nutrient data available</div>';
      } catch (error) {
        console.error('Error in updateHistory:', error);
        container.innerHTML = `<div class="no-data" style="color: red;">Error loading data: ${error.message}</div>`;
      }
    }

    // Operation-wide trends (All Fields)
    function renderOperationTrends(container) {
      // Filter samples by active client/farm
      const activeFieldsList = getActiveFields();
      const filteredSamples = sampleData.filter(s => activeFieldsList.includes(s.field));

      const years = [...new Set(filteredSamples.map(s => s.year).filter(y => y))].sort();
      const allFields = [...new Set(filteredSamples.map(s => s.field).filter(f => f && f !== 'Unknown' && f !== 'Unassigned'))];

      if (years.length < 1) {
        container.innerHTML = '<div class="no-data">No data available for selected client/farm</div>';
        return;
      }

      // Calculate per-year statistics
      const yearStats = years.map(year => {
        const yearSamples = filteredSamples.filter(s => String(s.year) === String(year));
        const fieldsInYear = [...new Set(yearSamples.map(s => s.field).filter(f => f && f !== 'Unknown' && f !== 'Unassigned'))];
        return {
          year,
          sampleCount: yearSamples.length,
          fieldCount: fieldsInYear.length,
          fields: fieldsInYear
        };
      });

      const totalSamples = filteredSamples.length;
      const operationName = localStorage.getItem('operationName') || 'Operation';

      let html = `
        <div style="background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%); border: 2px solid #3b82f6; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem;">
          <h3 style="margin: 0 0 0.5rem 0; color: #1e40af;">üìä ${operationName} - All Fields Average</h3>
          <p style="margin: 0 0 0.5rem 0; color: #64748b; font-size: 0.875rem;">
            Operation-wide nutrient trends across <strong>${allFields.length} fields</strong> and <strong>${totalSamples.toLocaleString()} total samples</strong>
          </p>
          <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; font-size: 0.75rem;">
            ${yearStats.map(ys => `
              <span style="background: white; padding: 0.25rem 0.5rem; border-radius: 0.25rem; border: 1px solid #93c5fd;">
                <strong>${ys.year}:</strong> ${ys.sampleCount} samples, ${ys.fieldCount} fields
              </span>
            `).join('')}
          </div>
        </div>
      `;

      try {
        const visibleNutrients = getVisibleNutrients();

        visibleNutrients.forEach(attr => {
          try {
            const yearData = [];
            let hasData = false;

            years.forEach(year => {
              const yearSamples = filteredSamples.filter(s => String(s.year) === String(year));
              const stats = getStats(yearSamples, attr);

              // Calculate per-field averages for range band
              const fieldsInYear = [...new Set(yearSamples.map(s => s.field).filter(f => f && f !== 'Unknown' && f !== 'Unassigned'))];
              const fieldAvgs = fieldsInYear.map(field => {
                const fieldSamples = yearSamples.filter(s => s.field === field);
                const fieldStats = getStats(fieldSamples, attr);
                return fieldStats ? fieldStats.avg : null;
              }).filter(v => v !== null);

              if (stats) {
                yearData.push({
                  year,
                  avg: stats.avg,
                  median: stats.median,
                  count: stats.count,
                  fieldCount: fieldsInYear.length,
                  minFieldAvg: fieldAvgs.length > 0 ? Math.min(...fieldAvgs) : stats.avg,
                  maxFieldAvg: fieldAvgs.length > 0 ? Math.max(...fieldAvgs) : stats.avg
                });
                hasData = true;
              }
            });

            if (!hasData || yearData.length < 1) return;

            const first = yearData[0], last = yearData[yearData.length - 1];
            const avgChange = last.avg - first.avg;
            const medianChange = last.median - first.median;
            const pctChange = first.avg !== 0 ? (avgChange / first.avg) * 100 : 0;
            const isLowerBetter = CONFIG.LOWER_IS_BETTER.includes(attr);
            const isPositive = isLowerBetter ? avgChange < 0 : avgChange > 0;
            const decimals = getDecimals(attr);
            const name = CONFIG.NUTRIENT_NAMES[attr] || attr;

            let cardClass = 'neutral', color = '#64748b';
            if (yearData.length > 1) {
              cardClass = isPositive ? 'positive' : 'negative';
              color = isPositive ? '#22c55e' : '#ef4444';
            }

            const graph = createOperationTrendGraph(yearData, color);

            html += `
              <div class="trend-card ${cardClass}">
                <div class="trend-header">
                  <h4 class="trend-title">${name}</h4>
                  ${yearData.length > 1 ? `<div class="trend-pct" style="color:${color};">${pctChange >= 0 ? '+' : ''}${pctChange.toFixed(1)}%<div class="trend-sub">${first.year} ‚Üí ${last.year}</div></div>` : ''}
                </div>
                <div class="trend-content">
                  <div class="trend-values">
                    <div style="font-size:0.65rem;color:#64748b;margin-bottom:0.25rem;display:flex;justify-content:space-between;padding:0 0.5rem;">
                      <span></span>
                      <span style="width:50px;text-align:center;">Avg</span>
                      <span style="width:50px;text-align:center;">Med</span>
                      <span style="width:70px;text-align:center;font-size:0.6rem;">Range</span>
                    </div>
                    ${yearData.map((d, i) => `
                      <div class="trend-row ${i % 2 === 0 ? 'alt' : ''}" style="font-size:0.8rem;">
                        <span class="trend-year">${d.year}:</span>
                        <span style="width:50px;text-align:center;">${d.avg.toFixed(decimals)}</span>
                        <span style="width:50px;text-align:center;color:#8b5cf6;">${d.median.toFixed(decimals)}</span>
                        <span style="width:70px;text-align:center;font-size:0.65rem;color:#94a3b8;">${d.minFieldAvg.toFixed(decimals)}-${d.maxFieldAvg.toFixed(decimals)}</span>
                      </div>
                    `).join('')}
                    ${yearData.length > 1 ? `
                      <div class="trend-row" style="margin-top:0.5rem;border-top:2px solid ${color};padding-top:0.5rem;">
                        <span>Change:</span>
                        <span style="width:50px;text-align:center;color:${color};font-weight:700;">${avgChange >= 0 ? '+' : ''}${avgChange.toFixed(decimals)}</span>
                        <span style="width:50px;text-align:center;color:#8b5cf6;font-weight:700;">${medianChange >= 0 ? '+' : ''}${medianChange.toFixed(decimals)}</span>
                        <span style="width:70px;"></span>
                      </div>
                    ` : ''}
                  </div>
                  <div class="trend-graph ${yearData.length > 10 ? 'xlarge' : (yearData.length > 5 ? 'large' : '')}">
                    <div style="display:flex;gap:0.75rem;font-size:0.65rem;margin-bottom:0.25rem;justify-content:center;">
                      <span><span style="color:${color};">‚óè</span> Avg</span>
                      <span><span style="color:#8b5cf6;">‚óè</span> Median</span>
                      <span style="color:#cbd5e1;">‚ñà Field Range</span>
                    </div>
                    ${graph}
                  </div>
                </div>
              </div>
            `;
          } catch (attrError) {
            console.error('Error processing attribute', attr, ':', attrError);
          }
        });

        container.innerHTML = html || '<div class="no-data">No nutrient data available</div>';
      } catch (error) {
        console.error('Error in renderOperationTrends:', error);
        container.innerHTML = `<div class="no-data" style="color: red;">Error loading data: ${error.message}</div>`;
      }
    }

    // Graph with range band for operation trends
    function createOperationTrendGraph(yearData, avgColor) {
      if (yearData.length < 1) return '';
      const medianColor = '#8b5cf6';
      const numYears = yearData.length;

      // Get all values including range to determine scale
      const allValues = [
        ...yearData.map(d => d.avg),
        ...yearData.map(d => d.median),
        ...yearData.map(d => d.minFieldAvg),
        ...yearData.map(d => d.maxFieldAvg)
      ];
      const minVal = Math.min(...allValues) * 0.9, maxVal = Math.max(...allValues) * 1.1;
      const range = maxVal - minVal || 1;

      // Dynamic dimensions based on year count - larger for PDF readability
      const baseWidth = 450;
      const width = numYears <= 5 ? baseWidth : Math.max(baseWidth, numYears * 60);
      const height = numYears <= 5 ? 190 : (numYears <= 10 ? 230 : 290);
      const padLeft = 35, padRight = 35, padTop = 30, padBottom = 40;
      const gw = width - padLeft - padRight;
      const gh = height - padTop - padBottom;

      // Determine label skip interval - only skip for very many years
      const labelSkip = numYears > 15 ? 2 : (numYears > 10 ? 1 : 0);

      // Calculate points
      const avgPts = yearData.map((d, i) => {
        const x = padLeft + (yearData.length > 1 ? (i / (yearData.length - 1)) * gw : gw / 2);
        const y = padTop + gh - ((d.avg - minVal) / range) * gh;
        return { x, y, year: d.year, val: d.avg };
      });

      const medianPts = yearData.map((d, i) => {
        const x = padLeft + (yearData.length > 1 ? (i / (yearData.length - 1)) * gw : gw / 2);
        const y = padTop + gh - ((d.median - minVal) / range) * gh;
        return { x, y, year: d.year, val: d.median };
      });

      // Range band (min/max field averages)
      const rangePts = yearData.map((d, i) => {
        const x = padLeft + (yearData.length > 1 ? (i / (yearData.length - 1)) * gw : gw / 2);
        const yMin = padTop + gh - ((d.minFieldAvg - minVal) / range) * gh;
        const yMax = padTop + gh - ((d.maxFieldAvg - minVal) / range) * gh;
        return { x, yMin, yMax };
      });

      // Create range band path (polygon)
      let rangePath = '';
      if (yearData.length > 1) {
        const topPoints = rangePts.map(p => `${p.x},${p.yMax}`).join(' L');
        const bottomPoints = [...rangePts].reverse().map(p => `${p.x},${p.yMin}`).join(' L');
        rangePath = `<path d="M${topPoints} L${bottomPoints} Z" fill="#e2e8f0" opacity="0.5"/>`;
      } else {
        // Single point - draw a vertical line
        const p = rangePts[0];
        rangePath = `<line x1="${p.x}" y1="${p.yMin}" x2="${p.x}" y2="${p.yMax}" stroke="#cbd5e1" stroke-width="8" opacity="0.5"/>`;
      }

      // Create lines
      const avgLine = avgPts.map((p, i) => `${i === 0 ? 'M' : 'L'}${p.x},${p.y}`).join(' ');
      const medianLine = medianPts.map((p, i) => `${i === 0 ? 'M' : 'L'}${p.x},${p.y}`).join(' ');

      // Create dots
      const dotRadius = numYears > 10 ? 4 : 5;
      const avgDots = avgPts.map(p => `<circle cx="${p.x}" cy="${p.y}" r="${dotRadius}" fill="${avgColor}" stroke="white" stroke-width="2"/>`).join('');
      const medianDots = medianPts.map(p => `<circle cx="${p.x}" cy="${p.y}" r="${dotRadius}" fill="${medianColor}" stroke="white" stroke-width="2"/>`).join('');

      // Year labels - always show all for small datasets
      const yearLabels = avgPts.map((p, i) => {
        const showLabel = i === 0 || i === avgPts.length - 1 || (labelSkip === 0) || (labelSkip === 1 && i % 2 === 0) || (labelSkip === 2 && i % 3 === 0);
        if (!showLabel) return '';
        const fontSize = numYears > 12 ? 10 : 11;
        return `<text x="${p.x}" y="${height - 12}" text-anchor="middle" font-size="${fontSize}" font-weight="600" fill="#475569">${p.year}</text>`;
      }).join('');

      const sizeClass = numYears > 10 ? 'xlarge' : (numYears > 5 ? 'large' : '');

      return `<svg width="100%" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet" style="width:100%;height:auto;min-height:${height}px;" data-size="${sizeClass}">
        ${rangePath}
        <path d="${avgLine}" fill="none" stroke="${avgColor}" stroke-width="3" stroke-linecap="round"/>
        <path d="${medianLine}" fill="none" stroke="${medianColor}" stroke-width="2.5" stroke-linecap="round" stroke-dasharray="4,2"/>
        ${avgDots}
        ${medianDots}
        ${yearLabels}
      </svg>`;
    }

    function createLineGraph(yearData, color, attr = 'P') {
      if (yearData.length < 1) return '';
      const decimals = getDecimals(attr);
      const values = yearData.map(d => d.avg);
      const minVal = Math.min(...values) * 0.9, maxVal = Math.max(...values) * 1.1;
      const range = maxVal - minVal || 1;
      const width = 400, height = 140, pad = 20;
      const gw = width - pad * 2, gh = height - pad * 2 - 20;

      const pts = yearData.map((d, i) => {
        const x = pad + (yearData.length > 1 ? (i / (yearData.length - 1)) * gw : gw / 2);
        const y = pad + gh - ((d.avg - minVal) / range) * gh;
        return { x, y, year: d.year, val: d.avg };
      });

      const line = pts.map((p, i) => `${i === 0 ? 'M' : 'L'}${p.x},${p.y}`).join(' ');
      const dots = pts.map(p => `<circle cx="${p.x}" cy="${p.y}" r="6" fill="${color}" stroke="white" stroke-width="2"/><text x="${p.x}" y="${height - 5}" text-anchor="middle" font-size="11" fill="#64748b">${p.year}</text><text x="${p.x}" y="${p.y - 12}" text-anchor="middle" font-size="12" font-weight="700" fill="#1e293b">${p.val.toFixed(decimals)}</text>`).join('');

      return `<svg width="100%" height="${height}" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet"><path d="${line}" fill="none" stroke="${color}" stroke-width="3" stroke-linecap="round"/>${dots}</svg>`;
    }

    function createDualLineGraph(yearData, avgColor, attr = 'P') {
      if (yearData.length < 1) return '';
      const medianColor = '#8b5cf6'; // Purple for median
      const numYears = yearData.length;
      const decimals = getDecimals(attr);

      // Get all values to determine scale
      const allValues = [...yearData.map(d => d.avg), ...yearData.map(d => d.median)];
      const minVal = Math.min(...allValues) * 0.85, maxVal = Math.max(...allValues) * 1.15;
      const range = maxVal - minVal || 1;

      // Dynamic dimensions based on year count - larger for PDF readability
      const baseWidth = 450;  // Wider base for better label spacing
      const width = numYears <= 5 ? baseWidth : Math.max(baseWidth, numYears * 60);
      const height = numYears <= 5 ? 180 : (numYears <= 10 ? 220 : 280);
      const padLeft = 35, padRight = 35, padTop = 30, padBottom = 40; // More padding for labels
      const gw = width - padLeft - padRight;
      const gh = height - padTop - padBottom;

      // Determine label skip interval - only skip for very many years
      const labelSkip = numYears > 15 ? 2 : (numYears > 10 ? 1 : 0);

      // Calculate points for both lines
      const avgPts = yearData.map((d, i) => {
        const x = padLeft + (yearData.length > 1 ? (i / (yearData.length - 1)) * gw : gw / 2);
        const y = padTop + gh - ((d.avg - minVal) / range) * gh;
        return { x, y, year: d.year, val: d.avg, idx: i };
      });

      const medianPts = yearData.map((d, i) => {
        const x = padLeft + (yearData.length > 1 ? (i / (yearData.length - 1)) * gw : gw / 2);
        const y = padTop + gh - ((d.median - minVal) / range) * gh;
        return { x, y, year: d.year, val: d.median, idx: i };
      });

      // Create path lines
      const avgLine = avgPts.map((p, i) => `${i === 0 ? 'M' : 'L'}${p.x},${p.y}`).join(' ');
      const medianLine = medianPts.map((p, i) => `${i === 0 ? 'M' : 'L'}${p.x},${p.y}`).join(' ');

      // Create dots - smaller for many years
      const dotRadius = numYears > 10 ? 4 : 5;
      const avgDots = avgPts.map(p => `<circle cx="${p.x}" cy="${p.y}" r="${dotRadius}" fill="${avgColor}" stroke="white" stroke-width="2"/>`).join('');
      const medianDots = medianPts.map(p => `<circle cx="${p.x}" cy="${p.y}" r="${dotRadius}" fill="${medianColor}" stroke="white" stroke-width="2"/>`).join('');

      // Year labels at bottom - always show all for small datasets
      const yearLabels = avgPts.map((p, i) => {
        // Always show first and last, skip middle ones only for very many years
        const showLabel = i === 0 || i === avgPts.length - 1 || (labelSkip === 0) || (labelSkip === 1 && i % 2 === 0) || (labelSkip === 2 && i % 3 === 0);
        if (!showLabel) return '';
        const fontSize = numYears > 12 ? 10 : 11;
        return `<text x="${p.x}" y="${height - 12}" text-anchor="middle" font-size="${fontSize}" font-weight="600" fill="#475569">${p.year}</text>`;
      }).join('');

      // Value labels - show for up to 10 years
      let avgLabels = '', medianLabels = '';
      if (numYears <= 10) {
        avgLabels = avgPts.map((p, i) => {
          const medianY = medianPts[i].y;
          const gap = Math.abs(p.y - medianY);
          let offset = gap < 20 ? (p.y < medianY ? -12 : 16) : -12;
          const fontSize = numYears > 6 ? 9 : 10;
          return `<text x="${p.x}" y="${p.y + offset}" text-anchor="middle" font-size="${fontSize}" font-weight="700" fill="${avgColor}">${p.val.toFixed(decimals)}</text>`;
        }).join('');

        medianLabels = medianPts.map((p, i) => {
          const avgY = avgPts[i].y;
          const gap = Math.abs(p.y - avgY);
          let offset = gap < 20 ? (p.y <= avgY ? -12 : 16) : 16;
          const fontSize = numYears > 6 ? 9 : 10;
          return `<text x="${p.x}" y="${p.y + offset}" text-anchor="middle" font-size="${fontSize}" font-weight="700" fill="${medianColor}">${p.val.toFixed(decimals)}</text>`;
        }).join('');
      }

      // Add size class hint via data attribute
      const sizeClass = numYears > 10 ? 'xlarge' : (numYears > 5 ? 'large' : '');

      return `<svg viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet" style="width:100%;height:auto;min-height:${height}px;" data-size="${sizeClass}">
        <path d="${avgLine}" fill="none" stroke="${avgColor}" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
        <path d="${medianLine}" fill="none" stroke="${medianColor}" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" stroke-dasharray="6,3"/>
        ${avgDots}${medianDots}
        ${yearLabels}
        ${avgLabels}${medianLabels}
      </svg>`;
    }

    // ========== TAB 3: Field Rankings ==========
    function updateRankings() {
      const container = document.getElementById('rankingsContent');
      const attr = document.getElementById('rankingAttrSelect').value;
      const yearOption = document.getElementById('rankingYearSelect').value;

      if (!attr) {
        container.innerHTML = '<div class="no-data">Select nutrient</div>';
        return;
      }

      // Filter samples by active client/farm
      const activeFieldsList = getActiveFields();
      const filteredSamples = sampleData.filter(s => activeFieldsList.includes(s.field));

      // Get all unique fields from filtered samples
      const allFields = [...new Set(filteredSamples.map(s => s.field).filter(f => f && f !== 'Unknown'))];

      const fieldStats = allFields.map(field => {
        // Get samples for this field
        let fieldSamples = filteredSamples.filter(s => s.field === field);
        
        if (yearOption === 'most_recent') {
          // Find most recent year for this field
          const fieldYears = [...new Set(fieldSamples.map(s => s.year).filter(y => y))].sort((a, b) => b - a);
          if (fieldYears.length === 0) return null;
          const mostRecentYear = fieldYears[0];
          fieldSamples = fieldSamples.filter(s => String(s.year) === String(mostRecentYear));
          const stats = getStats(fieldSamples, attr);
          return stats ? { field, avg: stats.avg, high: stats.high, low: stats.low, count: stats.count, year: mostRecentYear } : null;
        } else {
          // Filter by selected year
          fieldSamples = fieldSamples.filter(s => String(s.year) === String(yearOption));
          const stats = getStats(fieldSamples, attr);
          return stats ? { field, avg: stats.avg, high: stats.high, low: stats.low, count: stats.count, year: yearOption } : null;
        }
      }).filter(f => f);
      
      const isLowerBetter = CONFIG.LOWER_IS_BETTER.includes(attr);
      fieldStats.sort((a, b) => isLowerBetter ? a.avg - b.avg : b.avg - a.avg);
      
      const name = CONFIG.NUTRIENT_NAMES[attr] || attr;
      const unit = CONFIG.NUTRIENT_UNITS[attr] || '';
      const decimals = getDecimals(attr);
      const maxAvg = Math.max(...fieldStats.map(f => f.avg));
      const minAvg = Math.min(...fieldStats.map(f => f.avg));
      
      // Add Year column if using Most Recent
      const showYearCol = yearOption === 'most_recent';
      
      let html = `<table class="rankings-table"><thead><tr><th>Rank</th><th>Field</th>${showYearCol ? '<th>Year</th>' : ''}<th>Average</th><th>High</th><th>Low</th><th>Samples</th></tr></thead><tbody>`;
      
      fieldStats.forEach((f, i) => {
        const isTop = f.avg === (isLowerBetter ? minAvg : maxAvg);
        const isBottom = f.avg === (isLowerBetter ? maxAvg : minAvg);
        html += `<tr><td class="rank">#${i + 1}</td><td class="field">${f.field}</td>${showYearCol ? `<td>${f.year}</td>` : ''}<td class="value ${isTop ? 'high' : isBottom ? 'low' : ''}">${f.avg.toFixed(decimals)} ${unit}</td><td>${f.high.toFixed(decimals)}</td><td>${f.low.toFixed(decimals)}</td><td>${f.count}</td></tr>`;
      });
      
      html += '</tbody></table>';
      container.innerHTML = fieldStats.length > 0 ? html : '<div class="no-data">No data available</div>';
    }
    
    // ========== TAB 4: Yield Correlation ==========
    function updateYieldAnalysis() {
      const container = document.getElementById('yieldContent');
      const cropFilter = document.getElementById('yieldCropSelect').value;
      const yearFilter = document.getElementById('yieldYearSelect').value;
      const soilYearFilter = document.getElementById('soilYearSelect').value;
      const fieldFilter = document.getElementById('yieldFieldSelect').value;

      // Filter by active client/farm first
      const activeFieldsList = getActiveFields();
      const filteredSamples = sampleData.filter(s => activeFieldsList.includes(s.field));

      // Get samples with yield correlations
      let samplesWithYield = filteredSamples.filter(s => s.yieldCorrelations && Object.keys(s.yieldCorrelations).length > 0);

      if (samplesWithYield.length === 0) {
        container.innerHTML = '<div class="no-data">No yield data available. Import yield maps on the Import page to see correlations.</div>';
        return;
      }

      // Filter by field
      if (fieldFilter !== 'all') {
        samplesWithYield = samplesWithYield.filter(s => s.field === fieldFilter);
      }

      // Filter by soil sample year
      let soilYearDescription = '';
      if (soilYearFilter === 'recent') {
        // Use only the most recent soil sample at each location
        // Group by approximate location (rounded to 5 decimal places ~1m precision)
        const locationMap = new Map();
        samplesWithYield.forEach(sample => {
          const locKey = `${sample.lat.toFixed(5)},${sample.lon.toFixed(5)}`;
          const existing = locationMap.get(locKey);
          if (!existing || (sample.year && sample.year > existing.year)) {
            locationMap.set(locKey, sample);
          }
        });
        samplesWithYield = Array.from(locationMap.values());
        soilYearDescription = 'Most recent at each location';
      } else if (soilYearFilter === 'all') {
        // Use all soil samples (may have multiple per location)
        soilYearDescription = 'All years (may include duplicates)';
      } else {
        // Filter to specific soil sample year
        const selectedYear = parseInt(soilYearFilter);
        samplesWithYield = samplesWithYield.filter(s => s.year === selectedYear);
        soilYearDescription = `${selectedYear} only`;
      }

      // Get soil sample year range (after filtering)
      const soilYears = [...new Set(samplesWithYield.map(s => s.year).filter(y => y))].sort();
      const soilYearRange = soilYears.length > 0
        ? (soilYears.length === 1 ? `${soilYears[0]}` : `${Math.min(...soilYears)}-${Math.max(...soilYears)}`)
        : 'N/A';

      // Get all available yield years (before filtering)
      const allYieldYears = new Set();
      samplesWithYield.forEach(sample => {
        Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
          if (cropFilter === 'all' || yieldInfo.crop === cropFilter) {
            allYieldYears.add(parseInt(year));
          }
        });
      });
      const sortedYieldYears = [...allYieldYears].sort();

      // Build correlation data points based on yearFilter mode
      const dataPoints = [];
      const uniqueLocations = samplesWithYield.length;

      if (yearFilter === 'avg') {
        // ALL YEARS (AVERAGE): Average yield across all years at each location
        samplesWithYield.forEach(sample => {
          const validYields = [];
          Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
            if (cropFilter === 'all' || yieldInfo.crop === cropFilter) {
              validYields.push({
                yield: yieldInfo.avgYield,
                crop: yieldInfo.crop,
                pointCount: yieldInfo.pointCount
              });
            }
          });

          if (validYields.length > 0) {
            const avgYield = validYields.reduce((sum, v) => sum + v.yield, 0) / validYields.length;
            dataPoints.push({
              ...sample,
              yieldYear: 'avg',
              avgYield: avgYield,
              crop: validYields[0].crop,
              yieldPointCount: validYields.reduce((sum, v) => sum + v.pointCount, 0),
              yearsAveraged: validYields.length
            });
          }
        });
      } else if (yearFilter === 'combined') {
        // ALL YEARS (COMBINED): Each year is a separate data point
        samplesWithYield.forEach(sample => {
          Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
            if (cropFilter === 'all' || yieldInfo.crop === cropFilter) {
              dataPoints.push({
                ...sample,
                yieldYear: parseInt(year),
                avgYield: yieldInfo.avgYield,
                crop: yieldInfo.crop,
                yieldPointCount: yieldInfo.pointCount
              });
            }
          });
        });
      } else if (yearFilter === 'normalized') {
        // ALL YEARS (YEAR-NORMALIZED): Each year separate, but yields as % of year average
        // First calculate year averages
        const yearTotals = {};
        const yearCounts = {};
        samplesWithYield.forEach(sample => {
          Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
            if (cropFilter === 'all' || yieldInfo.crop === cropFilter) {
              const yr = parseInt(year);
              if (!yearTotals[yr]) {
                yearTotals[yr] = 0;
                yearCounts[yr] = 0;
              }
              yearTotals[yr] += yieldInfo.avgYield;
              yearCounts[yr]++;
            }
          });
        });

        const yearAverages = {};
        Object.keys(yearTotals).forEach(yr => {
          yearAverages[yr] = yearTotals[yr] / yearCounts[yr];
        });

        // Now create data points with normalized yields
        samplesWithYield.forEach(sample => {
          Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
            if (cropFilter === 'all' || yieldInfo.crop === cropFilter) {
              const yr = parseInt(year);
              const yearAvg = yearAverages[yr];
              const normalizedYield = (yieldInfo.avgYield / yearAvg) * 100; // % of year average

              dataPoints.push({
                ...sample,
                yieldYear: yr,
                avgYield: normalizedYield, // This is now % of year average
                rawYield: yieldInfo.avgYield, // Store original
                yearAvg: yearAvg,
                crop: yieldInfo.crop,
                yieldPointCount: yieldInfo.pointCount,
                isYearNormalized: true
              });
            }
          });
        });
      } else {
        // SPECIFIC YEAR: Only use yield from that year
        samplesWithYield.forEach(sample => {
          const yieldInfo = sample.yieldCorrelations[yearFilter];
          if (yieldInfo && (cropFilter === 'all' || yieldInfo.crop === cropFilter)) {
            dataPoints.push({
              ...sample,
              yieldYear: parseInt(yearFilter),
              avgYield: yieldInfo.avgYield,
              crop: yieldInfo.crop,
              yieldPointCount: yieldInfo.pointCount
            });
          }
        });
      }

      if (dataPoints.length === 0) {
        container.innerHTML = '<div class="no-data">No matching yield data for selected filters.</div>';
        return;
      }

      // Check if year-normalized mode - adjust label
      const isYearNormalized = yearFilter === 'normalized';

      // Check if normalization is enabled
      const normalizeByField = document.getElementById('yieldNormalizeToggle').checked;
      let fieldAverages = {};
      let fieldAvgRange = { min: Infinity, max: -Infinity };
      let yieldLabel = isYearNormalized ? 'Yield (% of Year Avg)' : 'Yield (bu/ac)';
      let normalizeNote = '';

      if (normalizeByField) {
        // Calculate average yield for each field
        const fieldYields = {};
        dataPoints.forEach(dp => {
          const field = dp.field || 'Unknown';
          if (!fieldYields[field]) fieldYields[field] = [];
          fieldYields[field].push(dp.avgYield);
        });

        // Calculate field averages
        Object.entries(fieldYields).forEach(([field, yields]) => {
          const avg = yields.reduce((a, b) => a + b, 0) / yields.length;
          fieldAverages[field] = avg;
          if (avg < fieldAvgRange.min) fieldAvgRange.min = avg;
          if (avg > fieldAvgRange.max) fieldAvgRange.max = avg;
        });

        // Convert yields to % of field average
        dataPoints.forEach(dp => {
          const field = dp.field || 'Unknown';
          const fieldAvg = fieldAverages[field];
          dp.rawYield = dp.avgYield; // Store original
          dp.avgYield = (dp.avgYield / fieldAvg) * 100; // Convert to %
          dp.fieldAvg = fieldAvg;
        });

        yieldLabel = 'Yield (% of Field Avg)';
        const fieldCount = Object.keys(fieldAverages).length;
        normalizeNote = `<div style="background: #fef3c7; border: 1px solid #f59e0b; border-radius: 0.375rem; padding: 0.5rem; margin-bottom: 0.75rem; font-size: 0.8rem; color: #92400e;">
          <strong>üìä Normalized by Field Productivity</strong><br>
          Yields converted to % of each field's average to isolate nutrient effect.<br>
          Field averages range from <strong>${fieldAvgRange.min.toFixed(0)}</strong> to <strong>${fieldAvgRange.max.toFixed(0)}</strong> bu/ac across ${fieldCount} fields.
          <br><span style="font-size: 0.75rem; color: #b45309;">100% = field average ‚Ä¢ >100% = above average ‚Ä¢ <100% = below average</span>
        </div>`;
      }

      // Calculate correlations for each nutrient
      const visibleNutrients = getVisibleNutrients();
      const correlations = [];

      console.log('=== YIELD CORRELATION DEBUG ===');
      console.log('Crop filter:', cropFilter);
      console.log('Year filter:', yearFilter);
      console.log('Yield years found for this crop:', sortedYieldYears);
      console.log('Data points:', dataPoints.length);
      console.log('Unique locations:', uniqueLocations);
      // Debug: show sample yieldCorrelations structure
      if (samplesWithYield.length > 0) {
        const sampleYC = samplesWithYield[0].yieldCorrelations;
        console.log('Sample yieldCorrelations keys:', Object.keys(sampleYC));
        console.log('Sample yieldCorrelations crops:', Object.values(sampleYC).map(v => v.crop));
      }

      visibleNutrients.forEach(nutrient => {
        // Filter for valid numeric values - must handle strings, empty values, etc.
        const pairs = dataPoints.filter(d => {
          const val = d[nutrient];
          if (val === undefined || val === null || val === '') return false;
          const num = parseFloat(val);
          return isFinite(num);
        });
        console.log(`  ${nutrient}: ${pairs.length} valid pairs (need 5+)`);
        if (pairs.length < 5) return; // Need at least 5 points

        const correlation = calculateCorrelation(
          pairs.map(p => parseFloat(p[nutrient])),
          pairs.map(p => p.avgYield)
        );

        if (correlation !== null && !isNaN(correlation.r)) {
          correlations.push({
            nutrient,
            name: CONFIG.NUTRIENT_NAMES[nutrient] || nutrient,
            r: correlation.r,
            r2: correlation.r2,
            n: pairs.length,
            significance: getSignificance(correlation.r, pairs.length)
          });
        }
      });

      // Store correlations globally for re-sorting
      yieldCorrelationsData = correlations;

      // Apply current sort
      sortYieldCorrelations();

      // Get summary stats
      const avgYield = dataPoints.reduce((sum, d) => sum + d.avgYield, 0) / dataPoints.length;
      const crops = [...new Set(dataPoints.map(d => d.crop))];
      const usedYieldYears = yearFilter === 'avg' || yearFilter === 'combined'
        ? sortedYieldYears
        : [parseInt(yearFilter)];

      // Get yield search radius values for selected crop only
      const radiusValues = new Set();
      samplesWithYield.forEach(sample => {
        Object.values(sample.yieldCorrelations).forEach(yieldInfo => {
          if (yieldInfo.radiusFt && yieldInfo.crop === cropFilter) {
            radiusValues.add(yieldInfo.radiusFt);
          }
        });
      });
      const radiusNote = radiusValues.size > 0
        ? `<br><strong>Yield Search Radius (${cropFilter}):</strong> ${[...radiusValues].sort((a,b) => a-b).join(', ')} ft`
        : '';

      const getSortIcon = (col) => {
        if (yieldSortColumn !== col) return '<span style="opacity: 0.3; font-size: 0.75rem;">&#9650;&#9660;</span>';
        return yieldSortDirection === 'asc' ? '<span style="color: #3b82f6;">&#9650;</span>' : '<span style="color: #3b82f6;">&#9660;</span>';
      };

      // Build description based on mode
      let modeDescription = '';
      if (yearFilter === 'avg') {
        modeDescription = `<div style="font-size: 0.8rem; color: #64748b;">${uniqueLocations} locations √ó avg of ${sortedYieldYears.length} yield years</div>`;
      } else if (yearFilter === 'combined') {
        modeDescription = `<div style="font-size: 0.8rem; color: #64748b;">${uniqueLocations} locations √ó ${sortedYieldYears.length} yield years</div>`;
      } else {
        modeDescription = `<div style="font-size: 0.8rem; color: #64748b;">${dataPoints.length} locations with ${yearFilter} yield</div>`;
      }

      let html = `
        <div style="background: #f0f9ff; border: 1px solid #0ea5e9; border-radius: 0.5rem; padding: 0.75rem; margin-bottom: 1rem; font-size: 0.8rem; color: #0369a1;">
          <strong>Data Selection:</strong><br>
          <strong>Soil Samples:</strong> ${soilYearDescription} (${soilYearRange})<br>
          <strong>Yield Years:</strong> ${usedYieldYears.join(', ')}
          ${yearFilter === 'avg' ? ' <em>(averaged at each location)</em>' : yearFilter === 'combined' ? ' <em>(each year = separate data point)</em>' : ''}${radiusNote}
        </div>

        ${normalizeNote}

        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1.5rem;">
          <div style="background: #fef3c7; border: 2px solid #f59e0b; border-radius: 0.5rem; padding: 1rem; text-align: center;">
            <div style="font-size: 2rem; font-weight: 700; color: #92400e;">${dataPoints.length}</div>
            <div style="color: #92400e; font-size: 0.875rem;">Data Points</div>
            ${modeDescription}
          </div>
          <div style="background: #f0fdf4; border: 2px solid #22c55e; border-radius: 0.5rem; padding: 1rem; text-align: center;">
            <div style="font-size: 2rem; font-weight: 700; color: #166534;">${avgYield.toFixed(1)}${normalizeByField ? '%' : ''}</div>
            <div style="color: #166534; font-size: 0.875rem;">${normalizeByField ? 'Avg Yield (% of Field)' : 'Avg Yield (bu/ac)'}</div>
          </div>
          <div style="background: #eff6ff; border: 2px solid #3b82f6; border-radius: 0.5rem; padding: 1rem; text-align: center;">
            <div style="font-size: 1.25rem; font-weight: 600; color: #1e40af;">${crops.map(c => c === 'corn' ? 'üåΩ' : 'ü´ò').join(' ')}</div>
            <div style="color: #1e40af; font-size: 0.875rem;">Yield Years: ${usedYieldYears.join(', ')}</div>
          </div>
        </div>

        <h3 style="margin: 0 0 1rem 0; color: #1e293b;">Nutrient-Yield Correlations</h3>
        <p style="color: #64748b; font-size: 0.875rem; margin-bottom: 0.5rem;">Shows how each soil nutrient correlates with crop yield at matched sample locations. Click column headers to sort.</p>
        <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 0.375rem; padding: 0.75rem; margin-bottom: 1rem; font-size: 0.8rem; color: #475569;">
          <strong>How to read this table:</strong><br>
          <strong>r (Correlation)</strong> ranges from -1 to +1. Positive = higher nutrient, higher yield. Negative = higher nutrient, lower yield. Values closer to +/-1 indicate stronger relationships.<br>
          <strong>R¬≤ (R-squared)</strong> shows what % of yield variation is explained by this nutrient. Example: R¬≤=25% means 25% of yield differences can be attributed to this nutrient.<br>
          <strong>Significance:</strong> *** = strong (|r| > 0.7), ** = moderate (|r| > 0.4), * = weak (|r| > 0.2), - = no meaningful correlation
        </div>

        <table class="rankings-table" id="yieldCorrelationTable">
          <thead>
            <tr>
              <th class="sortable-header" onclick="sortYieldTable('name')" style="cursor: pointer;">Nutrient ${getSortIcon('name')}</th>
              <th class="sortable-header" onclick="sortYieldTable('r')" style="cursor: pointer;">Correlation (r) ${getSortIcon('r')}</th>
              <th class="sortable-header" onclick="sortYieldTable('r2')" style="cursor: pointer;">R¬≤ ${getSortIcon('r2')}</th>
              <th class="sortable-header" onclick="sortYieldTable('significance')" style="cursor: pointer;">Significance ${getSortIcon('significance')}</th>
              <th class="sortable-header" onclick="sortYieldTable('n')" style="cursor: pointer;">Samples ${getSortIcon('n')}</th>
            </tr>
          </thead>
          <tbody id="yieldCorrelationBody">
      `;

      html += renderYieldCorrelationRows();

      html += '</tbody></table>';

      if (yieldCorrelationsData.length === 0) {
        html = '<div class="no-data">Not enough data points to calculate correlations. Need at least 5 samples with yield data.</div>';
      }

      container.innerHTML = html;

      // Initialize scatter plot
      populateScatterSelect();
      drawScatterPlot();
    }

    function calculateCorrelation(x, y) {
      const n = x.length;
      if (n < 3) return null;
      
      const sumX = x.reduce((a, b) => a + b, 0);
      const sumY = y.reduce((a, b) => a + b, 0);
      const sumXY = x.reduce((total, xi, i) => total + xi * y[i], 0);
      const sumX2 = x.reduce((total, xi) => total + xi * xi, 0);
      const sumY2 = y.reduce((total, yi) => total + yi * yi, 0);
      
      const numerator = n * sumXY - sumX * sumY;
      const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
      
      if (denominator === 0) return null;
      
      const r = numerator / denominator;
      return { r, r2: r * r };
    }
    
    function getSignificance(r, n) {
      // Simplified significance based on r value and sample size
      const absR = Math.abs(r);
      if (n < 10) return 'insufficient';
      if (absR > 0.7) return 'high';
      if (absR > 0.4) return 'medium';
      if (absR > 0.2) return 'low';
      return 'none';
    }

    // Sort the yield correlations data array
    function sortYieldCorrelations() {
      const sigOrder = { 'high': 3, 'medium': 2, 'low': 1, 'none': 0, 'insufficient': -1 };

      yieldCorrelationsData.sort((a, b) => {
        let aVal, bVal;

        switch (yieldSortColumn) {
          case 'name':
            aVal = a.name.toLowerCase();
            bVal = b.name.toLowerCase();
            return yieldSortDirection === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
          case 'r':
            // Sort by absolute value for correlation
            aVal = Math.abs(a.r);
            bVal = Math.abs(b.r);
            break;
          case 'r2':
            aVal = a.r2;
            bVal = b.r2;
            break;
          case 'significance':
            aVal = sigOrder[a.significance] || 0;
            bVal = sigOrder[b.significance] || 0;
            break;
          case 'n':
            aVal = a.n;
            bVal = b.n;
            break;
          default:
            aVal = Math.abs(a.r);
            bVal = Math.abs(b.r);
        }

        if (yieldSortDirection === 'asc') {
          return aVal - bVal;
        } else {
          return bVal - aVal;
        }
      });
    }

    // Render just the table rows (for re-sorting without rebuilding header)
    function renderYieldCorrelationRows() {
      let rows = '';
      yieldCorrelationsData.forEach(c => {
        const color = c.r > 0 ? '#22c55e' : '#ef4444';
        const barWidth = Math.abs(c.r) * 100;
        const significance = c.significance === 'high' ? '***' : c.significance === 'medium' ? '**' : c.significance === 'low' ? '*' : '-';
        const sigColor = c.significance === 'high' ? '#22c55e' : c.significance === 'medium' ? '#f59e0b' : '#94a3b8';

        rows += `
          <tr>
            <td class="field">${c.name}</td>
            <td>
              <div style="display: flex; align-items: center; gap: 0.5rem;">
                <div style="width: 80px; height: 12px; background: #e2e8f0; border-radius: 6px; overflow: hidden;">
                  <div style="width: ${barWidth}%; height: 100%; background: ${color}; ${c.r < 0 ? 'margin-left: auto;' : ''}"></div>
                </div>
                <span style="font-weight: 600; color: ${color};">${c.r > 0 ? '+' : ''}${c.r.toFixed(3)}</span>
              </div>
            </td>
            <td>${(c.r2 * 100).toFixed(1)}%</td>
            <td style="color: ${sigColor};">${significance}</td>
            <td>${c.n}</td>
          </tr>
        `;
      });
      return rows;
    }

    // Handle column header click to sort (attached to window for inline onclick)
    window.sortYieldTable = function(column) {
      if (yieldSortColumn === column) {
        // Toggle direction if same column
        yieldSortDirection = yieldSortDirection === 'asc' ? 'desc' : 'asc';
      } else {
        // New column, default to desc (highest first)
        yieldSortColumn = column;
        yieldSortDirection = 'desc';
      }

      // Re-run the full update to rebuild with new sort
      updateYieldAnalysis();
    };

    // ========== SCATTER PLOT & DEBUG ==========
    let currentYieldDataPoints = []; // Store for scatter plot

    function populateScatterSelect() {
      const select = document.getElementById('scatterNutrientSelect');
      const visibleNutrients = getVisibleNutrients();
      select.innerHTML = visibleNutrients.map(n =>
        `<option value="${n}"${n === 'P' ? ' selected' : ''}>${CONFIG.NUTRIENT_NAMES[n] || n}</option>`
      ).join('');
    }

    // Get crop-specific yield outlier limits
    function getYieldOutlierLimits(cropFilter) {
      const cropLower = (cropFilter || '').toLowerCase();
      if (cropLower.includes('soy') || cropLower.includes('bean')) {
        return { min: 20, max: 100 };  // Soybeans: 20-100 bu/ac
      } else if (cropLower === 'amylose') {
        return { min: 40, max: 280 };  // Amylose corn: 40-280 bu/ac (typically 15-30% lower than regular corn)
      } else if (cropLower.includes('corn') || cropLower.includes('maize')) {
        return { min: 50, max: 350 };  // Corn: 50-350 bu/ac
      }
      // Default to corn limits for unknown crops
      return { min: 50, max: 350 };
    }

    function getYieldDataPoints() {
      const cropFilter = document.getElementById('yieldCropSelect').value;
      const yearFilter = document.getElementById('yieldYearSelect').value;
      const fieldFilter = document.getElementById('yieldFieldSelect').value;

      let samplesWithYield = sampleData.filter(s => s.yieldCorrelations && Object.keys(s.yieldCorrelations).length > 0);
      if (fieldFilter !== 'all') samplesWithYield = samplesWithYield.filter(s => s.field === fieldFilter);

      const locationMap = new Map();
      samplesWithYield.forEach(sample => {
        const locKey = `${sample.lat.toFixed(5)},${sample.lon.toFixed(5)}`;
        const existing = locationMap.get(locKey);
        if (!existing || (sample.year && sample.year > existing.year)) {
          locationMap.set(locKey, sample);
        }
      });
      samplesWithYield = Array.from(locationMap.values());

      const dataPoints = [];

      if (yearFilter === 'avg') {
        // ALL YEARS (AVERAGE): Average yield across all years at each location
        samplesWithYield.forEach(sample => {
          const validYields = [];
          Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
            if (cropFilter === 'all' || yieldInfo.crop === cropFilter) {
              validYields.push({
                yield: yieldInfo.avgYield,
                crop: yieldInfo.crop,
                pointCount: yieldInfo.pointCount
              });
            }
          });
          if (validYields.length > 0) {
            const avgYield = validYields.reduce((sum, v) => sum + v.yield, 0) / validYields.length;
            dataPoints.push({
              ...sample,
              yieldYear: 'avg',
              avgYield: avgYield,
              crop: validYields[0].crop,
              yieldPointCount: validYields.reduce((sum, v) => sum + v.pointCount, 0),
              yearsAveraged: validYields.length
            });
          }
        });
      } else if (yearFilter === 'combined') {
        // ALL YEARS (COMBINED): Each year is a separate data point
        samplesWithYield.forEach(sample => {
          Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
            if (cropFilter === 'all' || yieldInfo.crop === cropFilter) {
              dataPoints.push({
                ...sample,
                yieldYear: parseInt(year),
                avgYield: yieldInfo.avgYield,
                crop: yieldInfo.crop,
                yieldPointCount: yieldInfo.pointCount
              });
            }
          });
        });
      } else if (yearFilter === 'normalized') {
        // ALL YEARS (YEAR-NORMALIZED): Each year separate, but yields as % of year average
        const yearTotals = {};
        const yearCounts = {};
        samplesWithYield.forEach(sample => {
          Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
            if (cropFilter === 'all' || yieldInfo.crop === cropFilter) {
              const yr = parseInt(year);
              if (!yearTotals[yr]) { yearTotals[yr] = 0; yearCounts[yr] = 0; }
              yearTotals[yr] += yieldInfo.avgYield;
              yearCounts[yr]++;
            }
          });
        });
        const yearAverages = {};
        Object.keys(yearTotals).forEach(yr => { yearAverages[yr] = yearTotals[yr] / yearCounts[yr]; });

        samplesWithYield.forEach(sample => {
          Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
            if (cropFilter === 'all' || yieldInfo.crop === cropFilter) {
              const yr = parseInt(year);
              const normalizedYield = (yieldInfo.avgYield / yearAverages[yr]) * 100;
              dataPoints.push({
                ...sample,
                yieldYear: yr,
                avgYield: normalizedYield,
                rawYield: yieldInfo.avgYield,
                yearAvg: yearAverages[yr],
                crop: yieldInfo.crop,
                yieldPointCount: yieldInfo.pointCount,
                isYearNormalized: true
              });
            }
          });
        });
      } else {
        // SPECIFIC YEAR: Only use yield from that year
        samplesWithYield.forEach(sample => {
          const yieldInfo = sample.yieldCorrelations[yearFilter];
          if (yieldInfo && (cropFilter === 'all' || yieldInfo.crop === cropFilter)) {
            dataPoints.push({
              ...sample,
              yieldYear: parseInt(yearFilter),
              avgYield: yieldInfo.avgYield,
              crop: yieldInfo.crop,
              yieldPointCount: yieldInfo.pointCount
            });
          }
        });
      }

      // Apply normalization if enabled
      const normalizeByField = document.getElementById('yieldNormalizeToggle').checked;
      if (normalizeByField && dataPoints.length > 0) {
        // Calculate average yield for each field
        const fieldYields = {};
        dataPoints.forEach(dp => {
          const field = dp.field || 'Unknown';
          if (!fieldYields[field]) fieldYields[field] = [];
          fieldYields[field].push(dp.avgYield);
        });

        const fieldAverages = {};
        Object.entries(fieldYields).forEach(([field, yields]) => {
          fieldAverages[field] = yields.reduce((a, b) => a + b, 0) / yields.length;
        });

        // Convert yields to % of field average
        dataPoints.forEach(dp => {
          const field = dp.field || 'Unknown';
          const fieldAvg = fieldAverages[field];
          dp.rawYield = dp.avgYield;
          dp.avgYield = (dp.avgYield / fieldAvg) * 100;
          dp.fieldAvg = fieldAvg;
        });
      }

      return dataPoints;
    }

    // Scatter plot axis state
    let scatterAxesFlipped = false;

    function toggleScatterAxes() {
      scatterAxesFlipped = !scatterAxesFlipped;
      const btn = document.getElementById('swapAxesBtn');
      const title = document.getElementById('scatterTitle');
      const nutrient = document.getElementById('scatterNutrientSelect').value;
      const nutrientName = CONFIG.NUTRIENT_NAMES[nutrient] || nutrient;

      if (scatterAxesFlipped) {
        btn.style.background = '#3b82f6';
        btn.style.color = 'white';
        title.textContent = `Scatter Plot: Yield vs ${nutrientName}`;
      } else {
        btn.style.background = '#eff6ff';
        btn.style.color = '#1d4ed8';
        title.textContent = `Scatter Plot: ${nutrientName} vs Yield`;
      }
      drawScatterPlot();
    }

    // Threshold slider sync functions
    function updateThresholdDisplay() {
      const slider = document.getElementById('yieldThresholdSlider');
      const input = document.getElementById('yieldThresholdInput');
      input.value = slider.value;
    }

    function syncThresholdSlider() {
      const slider = document.getElementById('yieldThresholdSlider');
      const input = document.getElementById('yieldThresholdInput');
      slider.value = Math.max(100, Math.min(400, input.value));
    }

    function drawScatterPlot() {
      const canvas = document.getElementById('scatterCanvas');
      const ctx = canvas.getContext('2d');
      const nutrient = document.getElementById('scatterNutrientSelect').value;
      const yieldThreshold = parseFloat(document.getElementById('yieldThresholdInput').value) || 200;
      const hideOutliers = document.getElementById('hideOutliersCheckbox').checked;
      let dataPoints = getYieldDataPoints();

      // Get crop-specific yield thresholds for outlier filtering
      const cropFilter = document.getElementById('yieldCropSelect').value;
      const yieldLimits = getYieldOutlierLimits(cropFilter);

      // Filter out outliers if checkbox is checked
      let outliersRemoved = 0;
      if (hideOutliers) {
        const beforeCount = dataPoints.length;
        dataPoints = dataPoints.filter(d => {
          return d.avgYield >= yieldLimits.min && d.avgYield <= yieldLimits.max;
        });
        outliersRemoved = beforeCount - dataPoints.length;
      }

      // Update outlier info display
      const outlierInfoEl = document.getElementById('outlierFilterInfo');
      if (outliersRemoved > 0) {
        outlierInfoEl.textContent = `(${outliersRemoved} outliers hidden: yield <${yieldLimits.min} or >${yieldLimits.max} bu/ac)`;
        outlierInfoEl.style.color = '#dc2626';
      } else if (hideOutliers) {
        outlierInfoEl.textContent = `(no outliers found)`;
        outlierInfoEl.style.color = '#16a34a';
      } else {
        outlierInfoEl.textContent = '';
        outlierInfoEl.style.color = '#dc2626';
      }

      // Filter for valid data
      const validPoints = dataPoints.filter(d => {
        const val = d[nutrient];
        if (val === undefined || val === null || val === '') return false;
        return isFinite(parseFloat(val));
      });

      // Clear canvas
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      if (validPoints.length < 3) {
        ctx.fillStyle = '#64748b';
        ctx.font = '14px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('Not enough data points', canvas.width / 2, canvas.height / 2);
        document.getElementById('thresholdContent').innerHTML = '<p style="color: #94a3b8;">Not enough data</p>';
        return;
      }

      // Get data ranges - swap if axes are flipped
      const nutrientValues = validPoints.map(p => parseFloat(p[nutrient]));
      const yieldValues = validPoints.map(p => p.avgYield);

      // When flipped: X = Yield, Y = Nutrient
      const xValues = scatterAxesFlipped ? yieldValues : nutrientValues;
      const yValues = scatterAxesFlipped ? nutrientValues : yieldValues;
      const xMin = Math.min(...xValues);
      const xMax = Math.max(...xValues);
      const yMin = Math.min(...yValues);
      const yMax = Math.max(...yValues);

      // Labels for axes - check if normalized
      const normalizeByField = document.getElementById('yieldNormalizeToggle').checked;
      const yieldAxisLabel = normalizeByField ? 'Yield (% of Field Avg)' : 'Yield (bu/ac)';
      const nutrientName = CONFIG.NUTRIENT_NAMES[nutrient] || nutrient;
      const xLabel = scatterAxesFlipped ? yieldAxisLabel : nutrientName;
      const yLabel = scatterAxesFlipped ? nutrientName : yieldAxisLabel;

      // Padding for axes
      const padding = { left: 70, right: 40, top: 40, bottom: 60 };
      const plotWidth = canvas.width - padding.left - padding.right;
      const plotHeight = canvas.height - padding.top - padding.bottom;

      // Scale functions
      const xScale = (val) => padding.left + ((val - xMin) / (xMax - xMin || 1)) * plotWidth;
      const yScale = (val) => canvas.height - padding.bottom - ((val - yMin) / (yMax - yMin || 1)) * plotHeight;

      // Calculate regression
      const n = xValues.length;
      const meanX = xValues.reduce((a, b) => a + b, 0) / n;
      const meanY = yValues.reduce((a, b) => a + b, 0) / n;
      const ssX = xValues.reduce((sum, xi) => sum + (xi - meanX) ** 2, 0);
      const ssY = yValues.reduce((sum, yi) => sum + (yi - meanY) ** 2, 0);
      const ssXY = xValues.reduce((sum, xi, i) => sum + (xi - meanX) * (yValues[i] - meanY), 0);
      const slope = ssX > 0 ? ssXY / ssX : 0;
      const intercept = meanY - slope * meanX;
      const correlation = calculateCorrelation(xValues, yValues);
      const r = correlation ? correlation.r : 0;
      const r2 = r * r;

      // Calculate standard error for confidence bands
      const predictions = xValues.map(x => slope * x + intercept);
      const residuals = yValues.map((y, i) => y - predictions[i]);
      const sse = residuals.reduce((sum, r) => sum + r * r, 0);
      const mse = sse / (n - 2);
      const se = Math.sqrt(mse);

      // Draw axes
      ctx.strokeStyle = '#cbd5e1';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding.left, padding.top);
      ctx.lineTo(padding.left, canvas.height - padding.bottom);
      ctx.lineTo(canvas.width - padding.right, canvas.height - padding.bottom);
      ctx.stroke();

      // Draw grid lines
      ctx.strokeStyle = '#f1f5f9';
      ctx.lineWidth = 1;
      for (let i = 0; i <= 5; i++) {
        const y = padding.top + (i * plotHeight / 5);
        ctx.beginPath();
        ctx.moveTo(padding.left, y);
        ctx.lineTo(canvas.width - padding.right, y);
        ctx.stroke();
        const x = padding.left + (i * plotWidth / 5);
        ctx.beginPath();
        ctx.moveTo(x, padding.top);
        ctx.lineTo(x, canvas.height - padding.bottom);
        ctx.stroke();
      }

      // Draw confidence bands (95% CI)
      if (n > 5 && ssX > 0) {
        const tValue = 1.96; // ~95% CI
        ctx.fillStyle = 'rgba(59, 130, 246, 0.1)';
        ctx.beginPath();
        const bandPoints = 50;
        // Upper band
        for (let i = 0; i <= bandPoints; i++) {
          const x = xMin + (i / bandPoints) * (xMax - xMin);
          const yPred = slope * x + intercept;
          const seY = se * Math.sqrt(1 + 1/n + (x - meanX)**2 / ssX);
          const yUpper = yPred + tValue * seY;
          const px = xScale(x);
          const py = yScale(Math.min(yMax * 1.1, Math.max(yMin * 0.9, yUpper)));
          if (i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        // Lower band (reverse)
        for (let i = bandPoints; i >= 0; i--) {
          const x = xMin + (i / bandPoints) * (xMax - xMin);
          const yPred = slope * x + intercept;
          const seY = se * Math.sqrt(1 + 1/n + (x - meanX)**2 / ssX);
          const yLower = yPred - tValue * seY;
          const px = xScale(x);
          const py = yScale(Math.min(yMax * 1.1, Math.max(yMin * 0.9, yLower)));
          ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();
      }

      // Draw yield threshold line (vertical when flipped, horizontal when normal)
      if (scatterAxesFlipped) {
        // Flipped: X = Yield, so threshold is a vertical line
        if (yieldThreshold >= xMin && yieldThreshold <= xMax) {
          const thresholdX = xScale(yieldThreshold);
          ctx.strokeStyle = '#f59e0b';
          ctx.lineWidth = 2;
          ctx.setLineDash([8, 4]);
          ctx.beginPath();
          ctx.moveTo(thresholdX, padding.top);
          ctx.lineTo(thresholdX, canvas.height - padding.bottom);
          ctx.stroke();
          ctx.setLineDash([]);

          // Label the threshold line
          const thresholdUnit = normalizeByField ? '%' : 'bu/ac';
          ctx.fillStyle = '#92400e';
          ctx.font = 'bold 12px system-ui';
          ctx.save();
          ctx.translate(thresholdX + 5, padding.top + 60);
          ctx.rotate(Math.PI / 2);
          ctx.textAlign = 'left';
          ctx.fillText(`${yieldThreshold} ${thresholdUnit} threshold`, 0, 0);
          ctx.restore();
        }
      } else {
        // Normal: Y = Yield, so threshold is a horizontal line
        if (yieldThreshold >= yMin && yieldThreshold <= yMax) {
          const thresholdY = yScale(yieldThreshold);
          ctx.strokeStyle = '#f59e0b';
          ctx.lineWidth = 2;
          ctx.setLineDash([8, 4]);
          ctx.beginPath();
          ctx.moveTo(padding.left, thresholdY);
          ctx.lineTo(canvas.width - padding.right, thresholdY);
          ctx.stroke();
          ctx.setLineDash([]);

          // Label the threshold line
          const thresholdUnit = normalizeByField ? '%' : 'bu/ac';
          ctx.fillStyle = '#92400e';
          ctx.font = 'bold 12px system-ui';
          ctx.textAlign = 'left';
          ctx.fillText(`${yieldThreshold} ${thresholdUnit} threshold`, padding.left + 5, thresholdY - 5);
        }
      }

      // Separate points above/below threshold (always based on yield, not axis position)
      const aboveThreshold = validPoints.filter(p => p.avgYield >= yieldThreshold);
      const belowThreshold = validPoints.filter(p => p.avgYield < yieldThreshold);

      // Draw points below threshold (gray/muted)
      belowThreshold.forEach(p => {
        const px = scatterAxesFlipped ? xScale(p.avgYield) : xScale(parseFloat(p[nutrient]));
        const py = scatterAxesFlipped ? yScale(parseFloat(p[nutrient])) : yScale(p.avgYield);
        ctx.beginPath();
        ctx.arc(px, py, 4, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(148, 163, 184, 0.4)';
        ctx.fill();
        ctx.strokeStyle = '#94a3b8';
        ctx.lineWidth = 1;
        ctx.stroke();
      });

      // Draw points above threshold (highlighted)
      aboveThreshold.forEach(p => {
        const px = scatterAxesFlipped ? xScale(p.avgYield) : xScale(parseFloat(p[nutrient]));
        const py = scatterAxesFlipped ? yScale(parseFloat(p[nutrient])) : yScale(p.avgYield);
        ctx.beginPath();
        ctx.arc(px, py, 6, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(34, 197, 94, 0.7)';
        ctx.fill();
        ctx.strokeStyle = '#16a34a';
        ctx.lineWidth = 2;
        ctx.stroke();
      });

      // Draw trend line
      if (ssX > 0) {
        const y1 = slope * xMin + intercept;
        const y2 = slope * xMax + intercept;

        ctx.strokeStyle = '#3b82f6';
        ctx.lineWidth = 2.5;
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.moveTo(xScale(xMin), yScale(y1));
        ctx.lineTo(xScale(xMax), yScale(y2));
        ctx.stroke();
      }

      // Draw axis labels
      ctx.fillStyle = '#64748b';
      ctx.font = '12px system-ui';
      ctx.textAlign = 'center';

      // X-axis labels (format based on what's on X axis)
      for (let i = 0; i <= 5; i++) {
        const val = xMin + (i * (xMax - xMin) / 5);
        const x = xScale(val);
        ctx.fillText(scatterAxesFlipped ? val.toFixed(0) : val.toFixed(1), x, canvas.height - padding.bottom + 20);
      }
      ctx.font = 'bold 13px system-ui';
      ctx.fillText(xLabel, canvas.width / 2, canvas.height - 12);

      // Y-axis labels (format based on what's on Y axis)
      ctx.font = '12px system-ui';
      ctx.textAlign = 'right';
      for (let i = 0; i <= 5; i++) {
        const val = yMin + (i * (yMax - yMin) / 5);
        const y = yScale(val);
        ctx.fillText(scatterAxesFlipped ? val.toFixed(1) : val.toFixed(0), padding.left - 10, y + 4);
      }
      ctx.save();
      ctx.translate(18, canvas.height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.textAlign = 'center';
      ctx.font = 'bold 13px system-ui';
      ctx.fillText(yLabel, 0, 0);
      ctx.restore();

      // Draw equation and R¬≤ on chart
      ctx.fillStyle = '#1e293b';
      ctx.font = 'bold 13px system-ui';
      ctx.textAlign = 'left';
      const eqY = padding.top + 20;
      const slopeSign = slope >= 0 ? '+' : '';
      ctx.fillText(`y = ${slope.toFixed(2)}x ${slopeSign}${intercept.toFixed(1)}`, padding.left + 10, eqY);
      ctx.fillText(`R¬≤ = ${(r2 * 100).toFixed(1)}%`, padding.left + 10, eqY + 18);
      ctx.font = '12px system-ui';
      ctx.fillStyle = '#64748b';
      ctx.fillText(`n = ${n}`, padding.left + 10, eqY + 36);

      // Draw legend
      const legendX = canvas.width - padding.right - 180;
      const legendY = padding.top + 10;
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.fillRect(legendX - 10, legendY - 5, 190, 85);
      ctx.strokeStyle = '#e2e8f0';
      ctx.lineWidth = 1;
      ctx.strokeRect(legendX - 10, legendY - 5, 190, 85);

      ctx.font = '11px system-ui';
      ctx.textAlign = 'left';

      // Above threshold legend
      ctx.beginPath();
      ctx.arc(legendX + 6, legendY + 10, 5, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(34, 197, 94, 0.7)';
      ctx.fill();
      ctx.strokeStyle = '#16a34a';
      ctx.stroke();
      const yieldUnit = normalizeByField ? '%' : 'bu/ac';
      ctx.fillStyle = '#1e293b';
      ctx.fillText(`Above ${yieldThreshold} ${yieldUnit} (${aboveThreshold.length})`, legendX + 18, legendY + 14);

      // Below threshold legend
      ctx.beginPath();
      ctx.arc(legendX + 6, legendY + 30, 4, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(148, 163, 184, 0.4)';
      ctx.fill();
      ctx.strokeStyle = '#94a3b8';
      ctx.stroke();
      ctx.fillStyle = '#64748b';
      ctx.fillText(`Below ${yieldThreshold} ${yieldUnit} (${belowThreshold.length})`, legendX + 18, legendY + 34);

      // Trend line legend
      ctx.strokeStyle = '#3b82f6';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(legendX, legendY + 50);
      ctx.lineTo(legendX + 20, legendY + 50);
      ctx.stroke();
      ctx.fillStyle = '#1e293b';
      ctx.fillText('Trend line', legendX + 28, legendY + 54);

      // Confidence band legend
      ctx.fillStyle = 'rgba(59, 130, 246, 0.3)';
      ctx.fillRect(legendX, legendY + 63, 20, 10);
      ctx.fillStyle = '#64748b';
      ctx.fillText('95% prediction interval', legendX + 28, legendY + 72);

      // Update threshold analysis panel
      updateThresholdAnalysis(nutrient, validPoints, yieldThreshold, aboveThreshold, belowThreshold, scatterAxesFlipped);

      // Update stats bar
      const statsDiv = document.getElementById('scatterStats');
      const corrDirection = r >= 0 ? '‚Üó Positive' : '‚Üò Negative';
      const corrColor = r >= 0 ? '#16a34a' : '#dc2626';
      const nutrientMin = Math.min(...nutrientValues);
      const nutrientMax = Math.max(...nutrientValues);
      const yieldMin = Math.min(...yieldValues);
      const yieldMax = Math.max(...yieldValues);
      const axisNote = scatterAxesFlipped
        ? '<span style="color: #3b82f6; font-weight: 600;">[Axes Flipped: X=Yield, Y=Nutrient]</span>'
        : '';
      statsDiv.innerHTML = `
        <strong>${nutrientName}:</strong>
        n=${validPoints.length} |
        r=${r.toFixed(3)} |
        R¬≤=${(r2 * 100).toFixed(1)}% |
        ${nutrient} Range: ${nutrientMin.toFixed(1)} - ${nutrientMax.toFixed(1)} |
        Yield Range: ${yieldMin.toFixed(0)} - ${yieldMax.toFixed(0)} bu/ac |
        <span style="color: ${corrColor};">${corrDirection} correlation</span>
        ${axisNote}
      `;
    }

    function updateThresholdAnalysis(nutrient, validPoints, threshold, aboveThreshold, belowThreshold, isFlipped = false) {
      const content = document.getElementById('thresholdContent');
      const nutrientName = CONFIG.NUTRIENT_NAMES[nutrient] || nutrient;
      const normalizeByField = document.getElementById('yieldNormalizeToggle').checked;
      const yieldUnit = normalizeByField ? '%' : 'bu/ac';
      const yieldDesc = normalizeByField ? '% of field avg' : 'bu/ac';

      if (aboveThreshold.length === 0) {
        content.innerHTML = `
          <p style="color: #dc2626; font-weight: 600;">No samples above ${threshold} ${yieldUnit}</p>
          <p>Try lowering the yield threshold to analyze high-yielding samples.</p>
        `;
        return;
      }

      // Calculate stats for points above threshold
      const aboveNutrientValues = aboveThreshold.map(p => parseFloat(p[nutrient]));
      const minAbove = Math.min(...aboveNutrientValues);
      const maxAbove = Math.max(...aboveNutrientValues);
      const avgAbove = aboveNutrientValues.reduce((a, b) => a + b, 0) / aboveNutrientValues.length;
      const sortedAbove = [...aboveNutrientValues].sort((a, b) => a - b);
      const p10Above = sortedAbove[Math.floor(sortedAbove.length * 0.1)] || minAbove;

      // Calculate stats for points below threshold
      let belowStats = '';
      if (belowThreshold.length > 0) {
        const belowNutrientValues = belowThreshold.map(p => parseFloat(p[nutrient]));
        const avgBelow = belowNutrientValues.reduce((a, b) => a + b, 0) / belowNutrientValues.length;
        const diff = avgAbove - avgBelow;
        const diffPct = avgBelow > 0 ? ((diff / avgBelow) * 100).toFixed(0) : 'N/A';
        belowStats = `
          <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #e2e8f0;">
            <div style="font-weight: 600; color: #64748b; margin-bottom: 0.5rem;">Below ${threshold} ${yieldUnit}:</div>
            <div>Avg ${nutrient}: <strong>${avgBelow.toFixed(1)}</strong></div>
            <div style="margin-top: 0.5rem; color: ${diff >= 0 ? '#16a34a' : '#dc2626'};">
              Difference: ${diff >= 0 ? '+' : ''}${diff.toFixed(1)} (${diffPct}%)
            </div>
          </div>
        `;
      }

      // Different interpretation based on axis orientation and normalization
      const thresholdDesc = normalizeByField ? `${threshold}% of field average` : `${threshold} bu/ac`;
      const interpretationText = isFlipped
        ? `<strong>Key insight:</strong> At yields ‚â•${thresholdDesc}, ${nutrient} levels ranged from <strong>${minAbove.toFixed(1)}</strong> to <strong>${maxAbove.toFixed(1)}</strong>. The minimum ${nutrient} observed at this yield level was <strong>${minAbove.toFixed(1)}</strong> - you never see ${nutrient} below this at high yields.`
        : `<strong>Interpretation:</strong> For high yields (‚â•${thresholdDesc}), the minimum ${nutrientName} observed was <strong>${minAbove.toFixed(1)}</strong>. This suggests ${nutrient} levels below this may limit yield potential.`;

      content.innerHTML = `
        ${isFlipped ? '<div style="background: #eff6ff; border: 1px solid #3b82f6; border-radius: 0.375rem; padding: 0.5rem; margin-bottom: 0.75rem; font-size: 0.75rem; color: #1d4ed8;"><strong>Flipped View:</strong> X=Yield, Y=${nutrientName}. Look left of the threshold line to see nutrient levels at high yields.</div>' : ''}
        <div style="background: #f0fdf4; border: 1px solid #22c55e; border-radius: 0.375rem; padding: 0.75rem; margin-bottom: 0.75rem;">
          <div style="font-weight: 700; color: #166534; margin-bottom: 0.5rem;">
            üéØ For yields ‚â• ${threshold} ${yieldUnit}:
          </div>
          <div style="font-size: 0.8rem; color: #166534;">
            <strong>Minimum ${nutrient}:</strong> ${minAbove.toFixed(1)}<br>
            <strong>10th percentile:</strong> ${p10Above.toFixed(1)}<br>
            <strong>Average ${nutrient}:</strong> ${avgAbove.toFixed(1)}<br>
            <strong>Maximum ${nutrient}:</strong> ${maxAbove.toFixed(1)}
          </div>
        </div>

        <div style="font-size: 0.8rem; color: #475569;">
          <strong>${aboveThreshold.length}</strong> samples above threshold<br>
          <strong>${belowThreshold.length}</strong> samples below threshold
        </div>

        ${belowStats}

        <div style="margin-top: 0.75rem; padding: 0.5rem; background: #fef3c7; border-radius: 0.25rem; font-size: 0.75rem; color: #92400e;">
          ${interpretationText}
        </div>
      `;
    }

    // Toggle yield year explanation info box
    function toggleYieldYearInfo() {
      const box = document.getElementById('yieldYearInfoBox');
      box.style.display = box.style.display === 'none' ? 'block' : 'none';
    }

    // Calculate year averages for yield data
    function calculateYearAverages() {
      const yearTotals = {};
      const yearCounts = {};
      const cropFilter = document.getElementById('yieldCropSelect').value;

      sampleData.forEach(sample => {
        if (sample.yieldCorrelations) {
          Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
            if (cropFilter === 'all' || yieldInfo.crop === cropFilter) {
              const yr = parseInt(year);
              if (!yearTotals[yr]) {
                yearTotals[yr] = 0;
                yearCounts[yr] = 0;
              }
              yearTotals[yr] += yieldInfo.avgYield;
              yearCounts[yr]++;
            }
          });
        }
      });

      const yearAverages = {};
      Object.keys(yearTotals).forEach(yr => {
        yearAverages[yr] = yearTotals[yr] / yearCounts[yr];
      });
      return yearAverages;
    }

    // Update description below dropdown based on selection
    function updateYieldYearDescription() {
      const yearFilter = document.getElementById('yieldYearSelect').value;
      const descBox = document.getElementById('yieldYearDescription');
      const descText = document.getElementById('yieldYearDescText');
      const warningBox = document.getElementById('yieldYearWarning');
      const warningText = document.getElementById('yieldYearWarningText');
      const avgBox = document.getElementById('yieldYearAverages');

      descBox.style.display = 'block';
      warningBox.style.display = 'none';
      avgBox.style.display = 'none';

      const yearAverages = calculateYearAverages();
      const years = Object.keys(yearAverages).map(Number).sort();

      if (yearFilter === 'avg') {
        descText.innerHTML = `<strong>Averaged:</strong> Averages yield across all years at each location. A sample with 180 bu in 2024 and 220 bu in 2025 becomes 200 bu.<br><em>Best for finding patterns that persist across years. Smooths out weather variation.</em>`;
      } else if (yearFilter === 'combined') {
        descText.innerHTML = `<strong>Combined:</strong> Each year treated as separate data point. Same location counted multiple times (once per year).<br><em>Best for maximum sample size when years had similar growing conditions.</em>`;

        // Check if year averages differ by >15%
        if (years.length >= 2) {
          const avgValues = years.map(yr => yearAverages[yr]);
          const minAvg = Math.min(...avgValues);
          const maxAvg = Math.max(...avgValues);
          const diffPercent = ((maxAvg - minAvg) / minAvg) * 100;

          if (diffPercent > 15) {
            warningBox.style.display = 'block';
            warningText.textContent = `Yields varied by ${Math.round(diffPercent)}% between years. Consider using Year-Normalized to control for weather differences.`;
          }

          // Show year averages
          avgBox.style.display = 'block';
          avgBox.innerHTML = `<strong>Year averages:</strong> ${years.map(yr => `${yr}: ${Math.round(yearAverages[yr])} bu/ac`).join(' | ')}`;
        }
      } else if (yearFilter === 'normalized') {
        descText.innerHTML = `<strong>Year-Normalized:</strong> Each year treated separately, but yields converted to % of that year's average. A 200 bu yield in a 180 bu avg year = 111%.<br><em>Best for comparing across years with different weather. Isolates nutrient effect from seasonal variation.</em>`;

        // Show year averages
        if (years.length > 0) {
          avgBox.style.display = 'block';
          avgBox.innerHTML = `<strong>Year averages being normalized:</strong> ${years.map(yr => `${yr}: ${Math.round(yearAverages[yr])} bu/ac`).join(' | ')}`;
        }
      } else {
        // Individual year
        descText.innerHTML = `<strong>${yearFilter}:</strong> Only uses yield from this specific harvest year.<br><em>Best for analyzing that season's results specifically.</em>`;
        if (yearAverages[yearFilter]) {
          avgBox.style.display = 'block';
          avgBox.innerHTML = `<strong>${yearFilter} average:</strong> ${Math.round(yearAverages[yearFilter])} bu/ac`;
        }
      }
    }

    // Toggle normalization explanation info box
    function toggleNormalizeInfo() {
      const box = document.getElementById('normalizeInfoBox');
      box.style.display = box.style.display === 'none' ? 'block' : 'none';
    }

    // ========== YIELD BY NUTRIENT LEVEL (BUCKET ANALYSIS) ==========

    // Initialize selectors for bucket analysis
    function initYieldBucketSelectors() {
      // Filter by active client/farm
      const activeFieldsList = getActiveFields();
      const filteredSamples = sampleData.filter(s => activeFieldsList.includes(s.field));

      // Get samples with yield data
      const samplesWithYield = filteredSamples.filter(s => s.yieldCorrelations && Object.keys(s.yieldCorrelations).length > 0);

      // Populate field selector
      const fieldSelect = document.getElementById('bucketFieldSelect');
      const fields = [...new Set(samplesWithYield.map(s => s.field).filter(f => f))].sort();
      fieldSelect.innerHTML = '<option value="all">All Fields</option>' +
        fields.map(f => `<option value="${f}">${f}</option>`).join('');

      // Populate yield year selector
      const yearSelect = document.getElementById('bucketYieldYearSelect');
      const yieldYears = new Set();
      samplesWithYield.forEach(s => {
        Object.keys(s.yieldCorrelations).forEach(y => yieldYears.add(y));
      });
      const sortedYears = [...yieldYears].sort((a, b) => b - a);
      yearSelect.innerHTML = '<option value="all">All Years</option>' +
        sortedYears.map(y => `<option value="${y}">${y}</option>`).join('');
    }

    // Main bucket analysis function
    function updateYieldBucketAnalysis() {
      const container = document.getElementById('yieldBucketsContent');
      const fieldFilter = document.getElementById('bucketFieldSelect')?.value || 'all';
      const yearFilter = document.getElementById('bucketYieldYearSelect')?.value || 'all';
      const cropFilter = document.getElementById('bucketCropSelect')?.value || 'all';

      // Filter by active client/farm
      const activeFieldsList = getActiveFields();
      const filteredSamples = sampleData.filter(s => activeFieldsList.includes(s.field));

      // Get samples with yield data
      let samplesWithYield = filteredSamples.filter(s => s.yieldCorrelations && Object.keys(s.yieldCorrelations).length > 0);

      if (samplesWithYield.length === 0) {
        container.innerHTML = '<div class="no-data">No yield data available. Import yield maps on the Import page first.</div>';
        return;
      }

      // Apply field filter
      if (fieldFilter !== 'all') {
        samplesWithYield = samplesWithYield.filter(s => s.field === fieldFilter);
      }

      // Build data points with yield values
      const dataPoints = [];
      samplesWithYield.forEach(sample => {
        Object.entries(sample.yieldCorrelations).forEach(([yieldYear, yieldInfo]) => {
          // Year filter
          if (yearFilter !== 'all' && String(yieldYear) !== String(yearFilter)) return;
          // Crop filter
          if (cropFilter !== 'all' && yieldInfo.crop !== cropFilter) return;

          const yieldValue = yieldInfo.avgYield;
          if (typeof yieldValue !== 'number' || isNaN(yieldValue)) return;

          // Apply crop-specific outlier filtering
          const isCorn = yieldInfo.crop === 'corn';
          const minYield = isCorn ? 50 : 20;
          const maxYield = isCorn ? 350 : 100;
          if (yieldValue < minYield || yieldValue > maxYield) return;

          dataPoints.push({
            ...sample,
            yieldValue,
            yieldYear,
            crop: yieldInfo.crop
          });
        });
      });

      if (dataPoints.length === 0) {
        container.innerHTML = '<div class="no-data">No yield data matches the selected filters.</div>';
        return;
      }

      // Get settings for thresholds
      const settings = JSON.parse(localStorage.getItem('soilSettings') || '{}');

      // Define nutrients to analyze
      const nutrients = ['pH', 'P', 'K', 'OM', 'Ca_sat', 'Mg_sat', 'K_Sat', 'CEC', 'Zn', 'S'];
      const results = [];

      nutrients.forEach(nutrient => {
        // Get valid values for this nutrient
        const validPoints = dataPoints.filter(p => {
          const val = p[nutrient];
          return typeof val === 'number' && !isNaN(val) && val !== 0;
        });

        if (validPoints.length < 10) return; // Need enough data

        // Get threshold settings for this nutrient
        const thresholds = getNutrientThresholds(nutrient, settings);
        if (!thresholds) return;

        // Bucket the samples
        const buckets = { low: [], medium: [], high: [] };
        validPoints.forEach(p => {
          const val = p[nutrient];
          const bucket = getBucketForValue(val, nutrient, thresholds);
          buckets[bucket].push(p);
        });

        // Calculate average yield for each bucket
        const calcAvg = (arr) => arr.length > 0 ? arr.reduce((sum, p) => sum + p.yieldValue, 0) / arr.length : null;

        const lowAvg = calcAvg(buckets.low);
        const medAvg = calcAvg(buckets.medium);
        const highAvg = calcAvg(buckets.high);

        // Calculate yield difference (high - low)
        const yieldDiff = (lowAvg !== null && highAvg !== null) ? highAvg - lowAvg : null;

        results.push({
          nutrient,
          name: CONFIG.NUTRIENT_NAMES[nutrient] || nutrient,
          unit: CONFIG.NUTRIENT_UNITS[nutrient] || '',
          thresholds,
          low: { count: buckets.low.length, avgYield: lowAvg },
          medium: { count: buckets.medium.length, avgYield: medAvg },
          high: { count: buckets.high.length, avgYield: highAvg },
          yieldDiff,
          totalSamples: validPoints.length
        });
      });

      // Sort by yield difference (biggest impact first)
      results.sort((a, b) => {
        const diffA = a.yieldDiff !== null ? Math.abs(a.yieldDiff) : 0;
        const diffB = b.yieldDiff !== null ? Math.abs(b.yieldDiff) : 0;
        return diffB - diffA;
      });

      // Build HTML
      let html = `
        <div style="background: #f0fdf4; border: 1px solid #86efac; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem;">
          <strong>Summary:</strong> Analyzing <strong>${dataPoints.length}</strong> sample-yield pairs across <strong>${results.length}</strong> nutrients.
          Sorted by yield impact (biggest differences first).
        </div>

        <table class="rankings-table" style="width: 100%; font-size: 0.85rem;">
          <thead>
            <tr style="background: #f1f5f9;">
              <th style="text-align: left; padding: 0.75rem;">Nutrient</th>
              <th style="text-align: center; padding: 0.75rem; background: #fee2e2; color: #991b1b;">Low<br><span style="font-weight: normal; font-size: 0.7rem;">Avg Yield</span></th>
              <th style="text-align: center; padding: 0.75rem; background: #fef3c7; color: #92400e;">Medium<br><span style="font-weight: normal; font-size: 0.7rem;">Avg Yield</span></th>
              <th style="text-align: center; padding: 0.75rem; background: #dcfce7; color: #166534;">High<br><span style="font-weight: normal; font-size: 0.7rem;">Avg Yield</span></th>
              <th style="text-align: center; padding: 0.75rem;">Yield Impact<br><span style="font-weight: normal; font-size: 0.7rem;">(High - Low)</span></th>
            </tr>
          </thead>
          <tbody>
      `;

      results.forEach((r, idx) => {
        const formatYield = (bucket) => {
          if (bucket.avgYield === null) return '<span style="color: #9ca3af;">-</span>';
          return `<strong>${bucket.avgYield.toFixed(1)}</strong> <span style="color: #64748b; font-size: 0.75rem;">bu/ac</span><br><span style="color: #64748b; font-size: 0.7rem;">(n=${bucket.count})</span>`;
        };

        const impactColor = r.yieldDiff !== null ? (r.yieldDiff > 0 ? '#166534' : '#991b1b') : '#64748b';
        const impactText = r.yieldDiff !== null ? `${r.yieldDiff > 0 ? '+' : ''}${r.yieldDiff.toFixed(1)} bu/ac` : '-';

        // Show threshold ranges
        const rangeText = getThresholdRangeText(r.nutrient, r.thresholds);

        html += `
          <tr style="${idx % 2 === 0 ? '' : 'background: #f8fafc;'}">
            <td style="padding: 0.75rem;">
              <strong>${r.name}</strong>
              <div style="font-size: 0.7rem; color: #64748b; margin-top: 0.25rem;">${rangeText}</div>
            </td>
            <td style="text-align: center; padding: 0.75rem; background: rgba(254, 226, 226, 0.3);">${formatYield(r.low)}</td>
            <td style="text-align: center; padding: 0.75rem; background: rgba(254, 243, 199, 0.3);">${formatYield(r.medium)}</td>
            <td style="text-align: center; padding: 0.75rem; background: rgba(220, 252, 231, 0.3);">${formatYield(r.high)}</td>
            <td style="text-align: center; padding: 0.75rem; font-weight: 600; color: ${impactColor}; font-size: 1rem;">${impactText}</td>
          </tr>
        `;
      });

      html += '</tbody></table>';

      // Add interpretation guide
      html += `
        <div style="margin-top: 1.5rem; padding: 1rem; background: #eff6ff; border: 1px solid #93c5fd; border-radius: 0.5rem; font-size: 0.85rem;">
          <strong>üìñ How to Read This:</strong>
          <ul style="margin: 0.5rem 0 0 1.5rem; padding: 0; line-height: 1.8;">
            <li><strong>Low/Medium/High</strong> - Samples grouped by nutrient level using your threshold settings</li>
            <li><strong>Avg Yield</strong> - Average yield (bu/ac) for samples in each group</li>
            <li><strong>Yield Impact</strong> - Difference between High and Low groups (positive = higher nutrient = higher yield)</li>
            <li><strong>Large positive impact</strong> - Consider increasing fertilizer applications</li>
            <li><strong>Negative impact</strong> - May indicate over-application or toxicity at high levels</li>
          </ul>
        </div>
      `;

      container.innerHTML = html;
    }

    // Get threshold values for a nutrient
    function getNutrientThresholds(nutrient, settings) {
      const defaults = {
        pH: { low: 6.0, high: 7.0 },
        P: { low: 15, high: 30 },
        K: { low: 120, high: 180 },
        OM: { low: 2.5, high: 4.0 },
        Ca_sat: { low: 60, high: 70 },
        Mg_sat: { low: 10, high: 15 },
        K_Sat: { low: 2.5, high: 4.0 },
        CEC: { low: 10, high: 20 },
        Zn: { low: 1.0, high: 3.0 },
        S: { low: 8, high: 15 }
      };

      // Use settings if available, otherwise defaults
      if (settings[`${nutrient}_min`] !== undefined) {
        return {
          low: settings[`${nutrient}_min`],
          high: settings[`${nutrient}_max`] || defaults[nutrient]?.high || settings[`${nutrient}_min`] * 1.5
        };
      }

      return defaults[nutrient] || null;
    }

    // Determine which bucket a value falls into
    function getBucketForValue(value, nutrient, thresholds) {
      // Handle "lower is better" nutrients (inverted)
      const lowerIsBetter = CONFIG.LOWER_IS_BETTER.includes(nutrient);

      if (lowerIsBetter) {
        // For lower-is-better: low values are "high" quality, high values are "low" quality
        if (value <= thresholds.low) return 'high';
        if (value >= thresholds.high) return 'low';
        return 'medium';
      } else {
        // Normal: low values are "low", high values are "high"
        if (value < thresholds.low) return 'low';
        if (value > thresholds.high) return 'high';
        return 'medium';
      }
    }

    // Get human-readable threshold range text
    function getThresholdRangeText(nutrient, thresholds) {
      const unit = CONFIG.NUTRIENT_UNITS[nutrient] || '';
      const lowerIsBetter = CONFIG.LOWER_IS_BETTER.includes(nutrient);

      if (lowerIsBetter) {
        return `Low: >${thresholds.high}${unit}, Med: ${thresholds.low}-${thresholds.high}${unit}, High: <${thresholds.low}${unit}`;
      } else {
        return `Low: <${thresholds.low}${unit}, Med: ${thresholds.low}-${thresholds.high}${unit}, High: >${thresholds.high}${unit}`;
      }
    }

    // ========== MULTIVARIATE REGRESSION ==========
    let lastMultiModel = null;
    const CORE_NUTRIENTS = ['P', 'K', 'pH', 'OM'];

    // Switch between yield correlation sub-tabs
    function switchYieldSubtab(tab) {
      // Update tab buttons
      document.querySelectorAll('.yield-subtab').forEach(btn => {
        if (btn.dataset.subtab === tab) {
          btn.style.background = '#3b82f6';
          btn.style.color = 'white';
          btn.classList.add('active');
        } else {
          btn.style.background = '#f1f5f9';
          btn.style.color = '#64748b';
          btn.classList.remove('active');
        }
      });

      // Show/hide content
      document.getElementById('yieldSingleTab').style.display = tab === 'single' ? 'block' : 'none';
      document.getElementById('yieldMultiTab').style.display = tab === 'multi' ? 'block' : 'none';
      document.getElementById('yieldBucketsTab').style.display = tab === 'buckets' ? 'block' : 'none';

      // Initialize tabs when switching to them
      if (tab === 'multi') {
        initMultiVariableCheckboxes();
      } else if (tab === 'buckets') {
        initYieldBucketSelectors();
        updateYieldBucketAnalysis();
      }
    }

    // Reset multivariate model when data filters change
    function resetMultiModel() {
      const resultsDiv = document.getElementById('multiModelResults');
      if (resultsDiv && resultsDiv.style.display !== 'none') {
        resultsDiv.style.display = 'none';
        // Show message that filters changed
        const warningDiv = document.getElementById('multiVarWarning');
        if (warningDiv) {
          const dataPoints = getYieldDataPoints();
          warningDiv.innerHTML = `<span style="color: #0369a1;">‚ÑπÔ∏è Data filters changed. ${dataPoints.length} data points available. Click "Run Multivariate Regression" to update results.</span>`;
        }
      }
      // Also update warning to show current data point count
      updateMultiVarWarning();
    }

    // Initialize checkboxes for variable selection in multivariate model
    function initMultiVariableCheckboxes() {
      const container = document.getElementById('multiVarCheckboxes');
      const nutrients = CONFIG.NUTRIENTS.filter(n => {
        const vis = JSON.parse(localStorage.getItem('nutrientVisibility') || '{}');
        return vis[n] !== false;
      });

      container.innerHTML = nutrients.map(n => {
        const checked = CORE_NUTRIENTS.includes(n) ? 'checked' : '';
        return `
          <label style="display: flex; align-items: center; gap: 0.25rem; padding: 0.375rem 0.75rem; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 0.375rem; cursor: pointer; font-size: 0.8rem;">
            <input type="checkbox" class="multi-var-checkbox" value="${n}" ${checked} onchange="updateMultiVarWarning()">
            ${CONFIG.NUTRIENT_NAMES[n] || n}
          </label>
        `;
      }).join('');

      updateMultiVarWarning();
    }

    function selectAllMultiVars() {
      document.querySelectorAll('.multi-var-checkbox').forEach(cb => cb.checked = true);
      updateMultiVarWarning();
    }

    function selectCoreMultiVars() {
      document.querySelectorAll('.multi-var-checkbox').forEach(cb => {
        cb.checked = CORE_NUTRIENTS.includes(cb.value);
      });
      updateMultiVarWarning();
    }

    function updateMultiVarWarning() {
      const selected = document.querySelectorAll('.multi-var-checkbox:checked').length;
      const dataPoints = getYieldDataPoints();
      const n = dataPoints.length;
      const warningDiv = document.getElementById('multiVarWarning');
      const crop = document.getElementById('yieldCropSelect').value;
      const cropLabel = crop === 'all' ? 'all crops' : crop;

      if (n === 0) {
        warningDiv.innerHTML = `<span style="color: #dc2626;">‚ö†Ô∏è No data available for ${cropLabel}. Check your filter selections.</span>`;
      } else if (selected === 0) {
        warningDiv.innerHTML = `<span style="color: #dc2626;">‚ö†Ô∏è ${n} data points for ${cropLabel}. Select at least one variable.</span>`;
      } else if (n < selected * 10) {
        warningDiv.innerHTML = `<span style="color: #f59e0b;">‚ö†Ô∏è ${n} data points for ${cropLabel}, ${selected} variables. Sample size warning: need ~${selected * 10} for reliable results.</span>`;
      } else {
        warningDiv.innerHTML = `<span style="color: #166534;">‚úì ${n} data points for ${cropLabel}, ${selected} variables selected. Good sample size.</span>`;
      }
    }

    // Matrix operations for regression
    function matrixMultiply(A, B) {
      const rowsA = A.length, colsA = A[0].length, colsB = B[0].length;
      const result = Array(rowsA).fill().map(() => Array(colsB).fill(0));
      for (let i = 0; i < rowsA; i++) {
        for (let j = 0; j < colsB; j++) {
          for (let k = 0; k < colsA; k++) {
            result[i][j] += A[i][k] * B[k][j];
          }
        }
      }
      return result;
    }

    function matrixTranspose(A) {
      return A[0].map((_, i) => A.map(row => row[i]));
    }

    function matrixInverse(A) {
      const n = A.length;
      const augmented = A.map((row, i) => [...row, ...Array(n).fill(0).map((_, j) => i === j ? 1 : 0)]);

      // Gaussian elimination with partial pivoting
      for (let i = 0; i < n; i++) {
        // Find pivot
        let maxRow = i;
        for (let k = i + 1; k < n; k++) {
          if (Math.abs(augmented[k][i]) > Math.abs(augmented[maxRow][i])) maxRow = k;
        }
        [augmented[i], augmented[maxRow]] = [augmented[maxRow], augmented[i]];

        if (Math.abs(augmented[i][i]) < 1e-10) {
          throw new Error('Matrix is singular');
        }

        // Scale row
        const scale = augmented[i][i];
        for (let j = 0; j < 2 * n; j++) augmented[i][j] /= scale;

        // Eliminate column
        for (let k = 0; k < n; k++) {
          if (k !== i) {
            const factor = augmented[k][i];
            for (let j = 0; j < 2 * n; j++) augmented[k][j] -= factor * augmented[i][j];
          }
        }
      }

      return augmented.map(row => row.slice(n));
    }

    // t-distribution CDF approximation for p-values
    function tCDF(t, df) {
      // Approximation using the incomplete beta function
      const x = df / (df + t * t);
      const a = df / 2;
      const b = 0.5;

      // Simple approximation for large df
      if (df > 100) {
        // Use normal approximation
        return 0.5 * (1 + erf(t / Math.sqrt(2)));
      }

      // Incomplete beta function approximation
      let result = Math.pow(x, a) * Math.pow(1 - x, b) / (a * beta(a, b));
      return t > 0 ? 1 - result / 2 : result / 2;
    }

    function erf(x) {
      const a1 =  0.254829592, a2 = -0.284496736, a3 =  1.421413741;
      const a4 = -1.453152027, a5 =  1.061405429, p  =  0.3275911;
      const sign = x < 0 ? -1 : 1;
      x = Math.abs(x);
      const t = 1 / (1 + p * x);
      const y = 1 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
      return sign * y;
    }

    function beta(a, b) {
      return Math.exp(lnGamma(a) + lnGamma(b) - lnGamma(a + b));
    }

    function lnGamma(x) {
      const cof = [76.18009172947146, -86.50532032941677, 24.01409824083091,
                   -1.231739572450155, 0.1208650973866179e-2, -0.5395239384953e-5];
      let y = x, tmp = x + 5.5;
      tmp -= (x + 0.5) * Math.log(tmp);
      let ser = 1.000000000190015;
      for (let j = 0; j < 6; j++) ser += cof[j] / ++y;
      return -tmp + Math.log(2.5066282746310005 * ser / x);
    }

    // Calculate p-value from t-statistic
    function pValueFromT(t, df) {
      // Two-tailed test
      const absT = Math.abs(t);
      // Approximation for p-value
      if (df > 100) {
        // Normal approximation
        return 2 * (1 - 0.5 * (1 + erf(absT / Math.sqrt(2))));
      }
      // Use t-distribution approximation
      const x = df / (df + absT * absT);
      return x; // Simplified - would need proper beta function for accuracy
    }

    // Simple but more accurate p-value calculation
    function calculatePValue(t, df) {
      // Using normal approximation for simplicity (good for df > 30)
      const absT = Math.abs(t);
      const p = 2 * (1 - normalCDF(absT));
      return Math.max(0.0001, Math.min(0.9999, p));
    }

    function normalCDF(x) {
      return 0.5 * (1 + erf(x / Math.sqrt(2)));
    }

    // Run multiple linear regression
    function runMultivariateRegression() {
      const selectedVars = Array.from(document.querySelectorAll('.multi-var-checkbox:checked')).map(cb => cb.value);

      if (selectedVars.length === 0) {
        showStatus('Select at least one variable', false);
        return;
      }

      const dataPoints = getYieldDataPoints();
      if (dataPoints.length < selectedVars.length + 2) {
        showStatus('Not enough data points for regression', false);
        return;
      }

      // Build X matrix (with intercept) and Y vector
      const n = dataPoints.length;
      const p = selectedVars.length + 1; // +1 for intercept

      const X = [];
      const Y = [];
      const validRows = [];

      dataPoints.forEach((dp, idx) => {
        const row = [1]; // Intercept
        let valid = true;

        selectedVars.forEach(v => {
          const val = parseFloat(dp[v]);
          if (isNaN(val) || val === 0) valid = false;
          row.push(val);
        });

        if (valid && dp.avgYield && !isNaN(dp.avgYield)) {
          X.push(row);
          Y.push([dp.avgYield]);
          validRows.push(idx);
        }
      });

      if (X.length < p + 1) {
        showStatus('Not enough valid data points after filtering missing values', false);
        return;
      }

      try {
        // Calculate regression: Œ≤ = (X'X)^(-1) X'Y
        const Xt = matrixTranspose(X);
        const XtX = matrixMultiply(Xt, X);
        const XtXinv = matrixInverse(XtX);
        const XtY = matrixMultiply(Xt, Y);
        const beta = matrixMultiply(XtXinv, XtY);

        // Calculate predictions and residuals
        const Yhat = matrixMultiply(X, beta);
        const residuals = Y.map((y, i) => y[0] - Yhat[i][0]);

        // Calculate statistics
        const yMean = Y.reduce((sum, y) => sum + y[0], 0) / Y.length;
        const SST = Y.reduce((sum, y) => sum + Math.pow(y[0] - yMean, 2), 0);
        const SSE = residuals.reduce((sum, r) => sum + r * r, 0);
        const SSR = SST - SSE;

        const R2 = 1 - SSE / SST;
        const adjR2 = 1 - (1 - R2) * (n - 1) / (n - p);
        const MSE = SSE / (X.length - p);
        const RMSE = Math.sqrt(MSE);

        // F-statistic
        const MSR = SSR / (p - 1);
        const Fstat = MSR / MSE;

        // Standard errors of coefficients
        const varBeta = XtXinv.map(row => row.map(val => val * MSE));
        const seBeta = varBeta.map((row, i) => Math.sqrt(Math.max(0, row[i])));

        // t-statistics and p-values
        const tStats = beta.map((b, i) => seBeta[i] > 0 ? b[0] / seBeta[i] : 0);
        const pValues = tStats.map(t => calculatePValue(t, X.length - p));

        // Store model for predictions
        lastMultiModel = {
          beta: beta.map(b => b[0]),
          vars: ['Intercept', ...selectedVars],
          seBeta,
          tStats,
          pValues,
          R2,
          adjR2,
          Fstat,
          RMSE,
          n: X.length,
          p: p
        };

        // Calculate VIF for collinearity check
        const vifs = calculateVIF(X, selectedVars);

        // Display results
        displayMultiResults(lastMultiModel, vifs);

      } catch (e) {
        console.error('Regression error:', e);
        showStatus('Regression failed: ' + e.message, false);
      }
    }

    // Calculate Variance Inflation Factor for collinearity detection
    function calculateVIF(X, vars) {
      const vifs = {};

      // Skip intercept column
      for (let j = 1; j < X[0].length; j++) {
        // Regress Xj on all other X variables
        const y = X.map(row => row[j]);
        const otherX = X.map(row => [1, ...row.slice(1, j), ...row.slice(j + 1)]);

        try {
          const Xt = matrixTranspose(otherX);
          const XtX = matrixMultiply(Xt, otherX);
          const XtXinv = matrixInverse(XtX);
          const Xty = matrixMultiply(Xt, y.map(v => [v]));
          const b = matrixMultiply(XtXinv, Xty);

          // Calculate R¬≤ for this regression
          const yhat = otherX.map(row => row.reduce((sum, x, i) => sum + x * b[i][0], 0));
          const yMean = y.reduce((a, b) => a + b, 0) / y.length;
          const SST = y.reduce((sum, yi) => sum + Math.pow(yi - yMean, 2), 0);
          const SSE = y.reduce((sum, yi, i) => sum + Math.pow(yi - yhat[i], 2), 0);
          const R2 = 1 - SSE / SST;

          vifs[vars[j - 1]] = 1 / (1 - R2);
        } catch (e) {
          vifs[vars[j - 1]] = Infinity;
        }
      }

      return vifs;
    }

    // Display multivariate regression results
    function displayMultiResults(model, vifs) {
      document.getElementById('multiModelResults').style.display = 'block';

      // Model Summary
      const summaryHtml = `
        <div style="text-align: center; padding: 0.5rem; background: white; border-radius: 0.375rem;">
          <div style="font-size: 1.5rem; font-weight: 700; color: #166534;">${(model.R2 * 100).toFixed(1)}%</div>
          <div style="font-size: 0.75rem; color: #64748b;">R¬≤ (Variance Explained)</div>
        </div>
        <div style="text-align: center; padding: 0.5rem; background: white; border-radius: 0.375rem;">
          <div style="font-size: 1.5rem; font-weight: 700; color: #1e40af;">${(model.adjR2 * 100).toFixed(1)}%</div>
          <div style="font-size: 0.75rem; color: #64748b;">Adjusted R¬≤</div>
        </div>
        <div style="text-align: center; padding: 0.5rem; background: white; border-radius: 0.375rem;">
          <div style="font-size: 1.5rem; font-weight: 700; color: #7c3aed;">${model.Fstat.toFixed(2)}</div>
          <div style="font-size: 0.75rem; color: #64748b;">F-statistic</div>
        </div>
        <div style="text-align: center; padding: 0.5rem; background: white; border-radius: 0.375rem;">
          <div style="font-size: 1.5rem; font-weight: 700; color: #475569;">${model.n}</div>
          <div style="font-size: 0.75rem; color: #64748b;">Observations</div>
        </div>
      `;
      document.getElementById('multiSummaryContent').innerHTML = summaryHtml;

      // Build interpretation section FIRST (before table)
      const r2Pct = (model.R2 * 100).toFixed(0);
      const remainingPct = (100 - model.R2 * 100).toFixed(0);

      // Sort variables by significance (excluding intercept)
      const varResults = model.vars.slice(1).map((v, i) => ({
        name: v,
        displayName: CONFIG.NUTRIENT_NAMES[v] || v,
        coef: model.beta[i + 1],
        pValue: model.pValues[i + 1],
        sig: model.pValues[i + 1] < 0.001 ? '***' : model.pValues[i + 1] < 0.01 ? '**' : model.pValues[i + 1] < 0.05 ? '*' : ''
      })).sort((a, b) => a.pValue - b.pValue);

      const sigVars = varResults.filter(v => v.pValue < 0.05);
      const marginalVars = varResults.filter(v => v.pValue >= 0.05 && v.pValue < 0.1);

      // Build key findings list
      let keyFindings = '';
      varResults.forEach(v => {
        if (v.pValue < 0.05) {
          const effect = v.coef >= 0 ? 'positive' : 'negative';
          const effectDesc = v.coef >= 0 ? 'Higher values = higher yields' : 'Higher values = lower yields';
          const noteText = v.coef < 0 ? ` <span style="color: #92400e; font-size: 0.75rem;">(Note: This may indicate high-${v.displayName} soils have other limiting factors, not that ${v.displayName} hurts yield)</span>` : '';
          keyFindings += `<div style="padding: 0.5rem; background: #f0fdf4; border-left: 3px solid #22c55e; margin-bottom: 0.5rem; border-radius: 0 0.25rem 0.25rem 0;">
            <strong style="color: #166534;">${v.displayName}</strong> <span style="color: #166534;">(${v.sig})</span> - Strong ${effect} effect. ${effectDesc}.${v.coef < 0 ? noteText : ''}
          </div>`;
        } else if (v.pValue < 0.1) {
          keyFindings += `<div style="padding: 0.5rem; background: #fefce8; border-left: 3px solid #eab308; margin-bottom: 0.5rem; border-radius: 0 0.25rem 0.25rem 0;">
            <strong style="color: #a16207;">${v.displayName}</strong> <span style="color: #a16207;">(.)</span> - Marginal effect. May be meaningful but not conclusive.
          </div>`;
        }
      });

      const notSigVars = varResults.filter(v => v.pValue >= 0.1).map(v => v.displayName).join(', ');
      if (notSigVars) {
        keyFindings += `<div style="padding: 0.5rem; background: #f8fafc; border-left: 3px solid #94a3b8; margin-bottom: 0.5rem; border-radius: 0 0.25rem 0.25rem 0; color: #64748b;">
          <strong>${notSigVars}</strong> - Not significant in this model when other nutrients are considered.
        </div>`;
      }

      // Significance bar chart
      let barChart = '<div style="margin-top: 1rem;"><strong style="font-size: 0.85rem;">Variable Significance:</strong>';
      barChart += '<div style="margin-top: 0.5rem;">';
      varResults.forEach(v => {
        const maxWidth = 200;
        // Use -log10(pValue) for bar width, capped at 4 (-log10(0.0001))
        const logP = Math.min(-Math.log10(Math.max(v.pValue, 0.0001)), 4);
        const width = (logP / 4) * maxWidth;
        const barColor = v.pValue < 0.05 ? (v.coef >= 0 ? '#22c55e' : '#ef4444') : v.pValue < 0.1 ? '#eab308' : '#cbd5e1';
        const textColor = v.pValue < 0.05 ? '#166534' : v.pValue < 0.1 ? '#a16207' : '#64748b';
        barChart += `
          <div style="display: flex; align-items: center; margin-bottom: 0.375rem; gap: 0.5rem;">
            <div style="width: 80px; font-size: 0.75rem; color: ${textColor}; text-align: right;">${v.displayName}</div>
            <div style="flex: 1; background: #f1f5f9; border-radius: 0.25rem; height: 20px; position: relative; max-width: ${maxWidth}px;">
              <div style="width: ${width}px; height: 100%; background: ${barColor}; border-radius: 0.25rem;"></div>
            </div>
            <div style="font-size: 0.7rem; color: ${textColor}; width: 40px;">${v.sig || 'n.s.'}</div>
          </div>`;
      });
      barChart += '</div></div>';

      // Interpretation section
      const interp = document.getElementById('multiInterpretation');
      interp.innerHTML = `
        <div style="margin-bottom: 1rem; padding: 1rem; background: #f8fafc; border-radius: 0.5rem;">
          <h4 style="margin: 0 0 0.75rem 0; color: #1e293b; font-size: 1rem;">What This Means</h4>
          <p style="margin: 0 0 0.75rem 0; color: #475569; font-size: 0.875rem;">
            This model explains <strong>${r2Pct}%</strong> of yield variation using soil nutrients.
            The remaining <strong>${remainingPct}%</strong> is due to other factors (weather, genetics, management, soil properties not measured, etc.).
          </p>
          ${sigVars.length > 0 ? `
            <h5 style="margin: 0 0 0.5rem 0; color: #1e293b; font-size: 0.9rem;">Key Findings:</h5>
            ${keyFindings}
          ` : `
            <div style="padding: 0.75rem; background: #fef3c7; border-radius: 0.375rem; color: #92400e;">
              <strong>No significant relationships found.</strong> This doesn't mean nutrients don't matter - it may mean:
              <ul style="margin: 0.5rem 0 0 1rem; padding: 0;">
                <li>Sample size may be too small to detect effects</li>
                <li>Other factors are more important in this dataset</li>
                <li>Nutrient levels may not vary enough to show effect</li>
              </ul>
            </div>
          `}
          ${barChart}
          <div style="margin-top: 1rem; padding-top: 0.75rem; border-top: 1px solid #e2e8f0;">
            <strong style="font-size: 0.8rem; color: #64748b;">How to read the table below:</strong>
            <ul style="margin: 0.25rem 0 0 1rem; padding: 0; font-size: 0.75rem; color: #64748b;">
              <li><strong>Coefficient:</strong> Yield change (bu/ac) for each 1-unit increase in that nutrient</li>
              <li><strong>p-value:</strong> Lower = more confident the effect is real (&lt;0.05 = significant)</li>
              <li><strong>Sig:</strong> *** = very strong, ** = strong, * = moderate, . = marginal, - = not significant</li>
            </ul>
          </div>
        </div>
      `;

      // Coefficients Table
      const tbody = document.getElementById('multiCoeffBody');
      tbody.innerHTML = model.vars.map((v, i) => {
        const coef = model.beta[i];
        const se = model.seBeta[i];
        const t = model.tStats[i];
        const p = model.pValues[i];
        const sig = p < 0.001 ? '***' : p < 0.01 ? '**' : p < 0.05 ? '*' : p < 0.1 ? '.' : '';
        const sigColor = p < 0.05 ? '#166534' : p < 0.1 ? '#ca8a04' : '#64748b';
        const bgColor = p < 0.05 ? '#f0fdf4' : '';

        return `
          <tr style="background: ${bgColor};">
            <td style="padding: 0.75rem; border-bottom: 1px solid #e2e8f0; font-weight: 500;">${v === 'Intercept' ? '(Intercept)' : CONFIG.NUTRIENT_NAMES[v] || v}</td>
            <td style="padding: 0.75rem; border-bottom: 1px solid #e2e8f0; text-align: right; font-family: monospace;">${coef >= 0 ? '+' : ''}${coef.toFixed(4)}</td>
            <td style="padding: 0.75rem; border-bottom: 1px solid #e2e8f0; text-align: right; font-family: monospace;">${se.toFixed(4)}</td>
            <td style="padding: 0.75rem; border-bottom: 1px solid #e2e8f0; text-align: right; font-family: monospace;">${t.toFixed(3)}</td>
            <td style="padding: 0.75rem; border-bottom: 1px solid #e2e8f0; text-align: right; font-family: monospace;">${p < 0.0001 ? '<0.0001' : p.toFixed(4)}</td>
            <td style="padding: 0.75rem; border-bottom: 1px solid #e2e8f0; text-align: center; font-weight: 700; color: ${sigColor};">${sig || '-'}</td>
          </tr>
        `;
      }).join('');

      // Collinearity warning
      const highVIF = Object.entries(vifs).filter(([k, v]) => v > 5);
      const collinearDiv = document.getElementById('multiCollinearityWarning');
      if (highVIF.length > 0) {
        collinearDiv.style.display = 'block';
        document.getElementById('collinearityDetails').innerHTML =
          '<strong>High VIF values (>5):</strong><br>' +
          highVIF.map(([k, v]) => `‚Ä¢ ${CONFIG.NUTRIENT_NAMES[k] || k}: VIF = ${v.toFixed(2)}`).join('<br>') +
          '<br><br>Consider removing one of the correlated variables for more reliable estimates.';
      } else {
        collinearDiv.style.display = 'none';
      }

      // Setup predictor inputs
      const predictorDiv = document.getElementById('predictorInputs');
      predictorDiv.innerHTML = model.vars.filter(v => v !== 'Intercept').map(v => {
        const name = CONFIG.NUTRIENT_NAMES[v] || v;
        return `
          <div>
            <label style="font-size: 0.7rem; color: #64748b; display: block;">${name}</label>
            <input type="number" id="predict_${v}" placeholder="${v}" style="width: 100%; padding: 0.375rem; border: 1px solid #d8b4fe; border-radius: 0.25rem; font-size: 0.85rem;">
          </div>
        `;
      }).join('');

      showStatus('Regression complete', true);
    }

    // Predict yield from entered values
    function predictYield() {
      if (!lastMultiModel) {
        showStatus('Run regression first', false);
        return;
      }

      const values = [1]; // Intercept
      let missing = [];

      lastMultiModel.vars.forEach((v, i) => {
        if (v === 'Intercept') return;
        const input = document.getElementById(`predict_${v}`);
        const val = parseFloat(input?.value);
        if (isNaN(val)) {
          missing.push(CONFIG.NUTRIENT_NAMES[v] || v);
          values.push(0);
        } else {
          values.push(val);
        }
      });

      if (missing.length > 0) {
        showStatus(`Enter values for: ${missing.join(', ')}`, false);
        return;
      }

      // Calculate prediction
      let prediction = 0;
      for (let i = 0; i < lastMultiModel.beta.length; i++) {
        prediction += lastMultiModel.beta[i] * values[i];
      }

      // Simple confidence interval (rough approximation)
      const se = lastMultiModel.RMSE;
      const ci95 = 1.96 * se;

      const resultDiv = document.getElementById('predictionResult');
      resultDiv.style.display = 'block';
      resultDiv.innerHTML = `
        <div style="text-align: center;">
          <div style="font-size: 1.5rem; font-weight: 700; color: #7c3aed;">${prediction.toFixed(1)} bu/ac</div>
          <div style="font-size: 0.8rem; color: #64748b;">Predicted Yield</div>
          <div style="font-size: 0.75rem; color: #a855f7; margin-top: 0.5rem;">95% CI: ${(prediction - ci95).toFixed(1)} ‚Äì ${(prediction + ci95).toFixed(1)} bu/ac</div>
        </div>
      `;
    }

    // Toggle yield debug panel
    function toggleYieldDebug() {
      const panel = document.getElementById('yieldDebugPanel');
      const content = document.getElementById('yieldDebugContent');

      if (panel.style.display === 'none') {
        content.textContent = generateDebugReport();
        panel.style.display = 'block';
      } else {
        panel.style.display = 'none';
      }
    }

    // Generate comprehensive debug report for yield correlation verification
    function generateDebugReport() {
      const cropFilter = document.getElementById('yieldCropSelect').value;
      const yearFilter = document.getElementById('yieldYearSelect').value;
      const soilYearFilter = document.getElementById('soilYearSelect').value;
      const fieldFilter = document.getElementById('yieldFieldSelect').value;

      let report = [];
      report.push('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
      report.push('‚ïë               YIELD CORRELATION VERIFICATION REPORT                ‚ïë');
      report.push('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
      report.push('');

      // Get samples with yield correlations
      let samplesWithYield = sampleData.filter(s => s.yieldCorrelations && Object.keys(s.yieldCorrelations).length > 0);

      report.push(`FILTERS APPLIED:`);
      report.push(`  Crop: ${cropFilter}`);
      report.push(`  Yield Year: ${yearFilter}`);
      report.push(`  Soil Sample Year: ${soilYearFilter}`);
      report.push(`  Field: ${fieldFilter}`);
      report.push('');

      // Filter by field
      if (fieldFilter !== 'all') {
        samplesWithYield = samplesWithYield.filter(s => s.field === fieldFilter);
      }

      // Filter by soil sample year
      let soilYearDescription = '';
      if (soilYearFilter === 'recent') {
        // Use only most recent soil sample at each location
        const locationMap = new Map();
        samplesWithYield.forEach(sample => {
          const locKey = `${sample.lat.toFixed(5)},${sample.lon.toFixed(5)}`;
          const existing = locationMap.get(locKey);
          if (!existing || (sample.year && sample.year > existing.year)) {
            locationMap.set(locKey, sample);
          }
        });
        samplesWithYield = Array.from(locationMap.values());
        soilYearDescription = 'Most recent at each location';
      } else if (soilYearFilter === 'all') {
        soilYearDescription = 'All years (may include duplicates)';
      } else {
        const selectedYear = parseInt(soilYearFilter);
        samplesWithYield = samplesWithYield.filter(s => s.year === selectedYear);
        soilYearDescription = `${selectedYear} only`;
      }

      report.push(`STEP 1: DATA SELECTION`);
      report.push(`  Total samples in database: ${sampleData.length}`);
      report.push(`  Samples with yield data: ${samplesWithYield.length}`);
      report.push(`  Soil year filter: ${soilYearDescription}`);
      report.push('');

      // Build data points based on yearFilter mode
      const dataPoints = [];

      if (yearFilter === 'avg') {
        samplesWithYield.forEach(sample => {
          const validYields = [];
          Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
            if (cropFilter === 'all' || yieldInfo.crop === cropFilter) {
              validYields.push({ yield: yieldInfo.avgYield, year: year });
            }
          });
          if (validYields.length > 0) {
            const avgYield = validYields.reduce((sum, v) => sum + v.yield, 0) / validYields.length;
            dataPoints.push({ ...sample, avgYield: avgYield, yearsUsed: validYields.map(v => v.year).join(',') });
          }
        });
        report.push(`STEP 2: MULTI-YEAR AVERAGING`);
        report.push(`  Mode: All Years (Average) - averaging yield across years at each location`);
        report.push(`  Resulting data points: ${dataPoints.length}`);
      } else if (yearFilter === 'combined') {
        samplesWithYield.forEach(sample => {
          Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
            if (cropFilter === 'all' || yieldInfo.crop === cropFilter) {
              dataPoints.push({ ...sample, avgYield: yieldInfo.avgYield, yieldYear: year });
            }
          });
        });
        report.push(`STEP 2: MULTI-YEAR COMBINED`);
        report.push(`  Mode: All Years (Combined) - each year is a separate data point`);
        report.push(`  Resulting data points: ${dataPoints.length}`);
      } else {
        samplesWithYield.forEach(sample => {
          const yieldInfo = sample.yieldCorrelations[yearFilter];
          if (yieldInfo && (cropFilter === 'all' || yieldInfo.crop === cropFilter)) {
            dataPoints.push({ ...sample, avgYield: yieldInfo.avgYield });
          }
        });
        report.push(`STEP 2: SINGLE YEAR FILTER`);
        report.push(`  Selected year: ${yearFilter}`);
        report.push(`  Matching data points: ${dataPoints.length}`);
      }
      report.push('');

      // Show radius information for selected crop
      report.push(`STEP 3: YIELD SEARCH RADIUS (${cropFilter})`);
      const radiusValues = new Set();
      samplesWithYield.forEach(sample => {
        Object.values(sample.yieldCorrelations).forEach(yieldInfo => {
          if (yieldInfo.radiusFt && yieldInfo.crop === cropFilter) {
            radiusValues.add(yieldInfo.radiusFt);
          }
        });
      });
      if (radiusValues.size > 0) {
        report.push(`  Radius values for ${cropFilter}: ${[...radiusValues].sort((a,b) => a-b).join(', ')} ft`);
      } else {
        report.push(`  No radius information stored for ${cropFilter} (older import or no data)`);
      }
      report.push('');

      // Show crop breakdown
      report.push(`STEP 3.5: CROP DATA BREAKDOWN`);
      const cropCounts = {};
      const cropsByYear = {};
      samplesWithYield.forEach(sample => {
        Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
          const crop = yieldInfo.crop || 'unknown';
          cropCounts[crop] = (cropCounts[crop] || 0) + 1;
          if (!cropsByYear[year]) cropsByYear[year] = {};
          cropsByYear[year][crop] = (cropsByYear[year][crop] || 0) + 1;
        });
      });
      report.push(`  Crops stored in database:`);
      Object.entries(cropCounts).sort((a,b) => b[1] - a[1]).forEach(([crop, count]) => {
        const marker = (cropFilter === 'all' || crop === cropFilter) ? '‚úì' : '‚úó';
        report.push(`    ${marker} ${crop}: ${count} yield entries ${cropFilter !== 'all' && crop !== cropFilter ? '(filtered out)' : '(included)'}`);
      });
      report.push(`  Crops by year:`);
      Object.keys(cropsByYear).sort().forEach(year => {
        const crops = Object.entries(cropsByYear[year]).map(([c, n]) => `${c}:${n}`).join(', ');
        report.push(`    ${year}: ${crops}`);
      });
      report.push(`  Current crop filter: "${cropFilter}"`);
      if (cropFilter !== 'all') {
        const filteredCount = cropCounts[cropFilter] || 0;
        report.push(`  ‚Üí Only using ${filteredCount} entries matching "${cropFilter}"`);
      }
      report.push('');

      // Get yield statistics
      const yields = dataPoints.map(d => d.avgYield);
      const avgYield = yields.reduce((a, b) => a + b, 0) / yields.length;
      const minYield = Math.min(...yields);
      const maxYield = Math.max(...yields);

      report.push(`STEP 4: YIELD DATA QUALITY`);
      report.push(`  Data points: ${dataPoints.length}`);
      report.push(`  Yield range: ${minYield.toFixed(1)} - ${maxYield.toFixed(1)} bu/ac`);
      report.push(`  Average yield: ${avgYield.toFixed(1)} bu/ac`);
      report.push('');

      // Pick a sample nutrient for detailed verification
      const testNutrient = 'P';
      const pairsP = dataPoints.filter(d => d[testNutrient] !== undefined && d[testNutrient] !== null && d[testNutrient] !== '');
      const xValues = pairsP.map(d => parseFloat(d[testNutrient]));
      const yValues = pairsP.map(d => d.avgYield);

      if (pairsP.length >= 5) {
        const n = xValues.length;
        const sumX = xValues.reduce((a, b) => a + b, 0);
        const sumY = yValues.reduce((a, b) => a + b, 0);
        const meanX = sumX / n;
        const meanY = sumY / n;
        const sumXY = xValues.reduce((sum, x, i) => sum + x * yValues[i], 0);
        const sumX2 = xValues.reduce((sum, x) => sum + x * x, 0);
        const sumY2 = yValues.reduce((sum, y) => sum + y * y, 0);

        const numerator = n * sumXY - sumX * sumY;
        const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
        const r = denominator !== 0 ? numerator / denominator : 0;

        report.push(`STEP 5: CORRELATION CALCULATION (Example: ${testNutrient})`);
        report.push(`  Valid pairs (n): ${n}`);
        report.push(`  Mean ${testNutrient}: ${meanX.toFixed(2)}`);
        report.push(`  Mean Yield: ${meanY.toFixed(2)}`);
        report.push(`  Sum(X): ${sumX.toFixed(2)}`);
        report.push(`  Sum(Y): ${sumY.toFixed(2)}`);
        report.push(`  Sum(XY): ${sumXY.toFixed(2)}`);
        report.push(`  Sum(X¬≤): ${sumX2.toFixed(2)}`);
        report.push(`  Sum(Y¬≤): ${sumY2.toFixed(2)}`);
        report.push('');
        report.push(`  Formula: r = (n√óŒ£XY - Œ£X√óŒ£Y) / ‚àö[(n√óŒ£X¬≤ - (Œ£X)¬≤)(n√óŒ£Y¬≤ - (Œ£Y)¬≤)]`);
        report.push(`  Numerator: ${n} √ó ${sumXY.toFixed(2)} - ${sumX.toFixed(2)} √ó ${sumY.toFixed(2)} = ${numerator.toFixed(2)}`);
        report.push(`  Denominator: ${denominator.toFixed(2)}`);
        report.push(`  r = ${numerator.toFixed(2)} / ${denominator.toFixed(2)} = ${r.toFixed(4)}`);
        report.push(`  R¬≤ = ${(r * r * 100).toFixed(2)}%`);
        report.push('');

        // Show sample data points
        report.push(`SAMPLE DATA POINTS (first 10):`);
        report.push(`  ${'Sample ID'.padEnd(20)} ${'Field'.padEnd(15)} ${testNutrient.padStart(8)} ${'Yield'.padStart(10)}`);
        report.push(`  ${'-'.repeat(20)} ${'-'.repeat(15)} ${'-'.repeat(8)} ${'-'.repeat(10)}`);
        pairsP.slice(0, 10).forEach(d => {
          const id = (d.sampleId || 'N/A').toString().substring(0, 18).padEnd(20);
          const field = (d.field || 'N/A').substring(0, 13).padEnd(15);
          const pVal = parseFloat(d[testNutrient]).toFixed(1).padStart(8);
          const yVal = d.avgYield.toFixed(1).padStart(10);
          report.push(`  ${id} ${field} ${pVal} ${yVal}`);
        });
      } else {
        report.push(`STEP 5: INSUFFICIENT DATA`);
        report.push(`  Only ${pairsP.length} valid ${testNutrient} values (need 5+)`);
      }

      report.push('');
      report.push('');
      report.push('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
      report.push('‚ïë                    UNDERSTANDING CORRELATIONS                       ‚ïë');
      report.push('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
      report.push('');
      report.push('WHY MIGHT CORRELATIONS BE NEGATIVE?');
      report.push('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
      report.push('A negative correlation means higher nutrient levels are associated');
      report.push('with LOWER yields. This can happen for several legitimate reasons:');
      report.push('');
      report.push('1. NUTRIENT TOXICITY OR IMBALANCE');
      report.push('   ‚Ä¢ Too much of some nutrients can harm crops (e.g., high Na, Fe)');
      report.push('   ‚Ä¢ Nutrient imbalances affect uptake of other nutrients');
      report.push('   ‚Ä¢ Example: High Mg can block Ca uptake');
      report.push('');
      report.push('2. SOIL QUALITY INDICATORS');
      report.push('   ‚Ä¢ Some nutrients accumulate in poor-draining soils');
      report.push('   ‚Ä¢ High H_Sat indicates acidic conditions limiting yield');
      report.push('   ‚Ä¢ High Na_Sat indicates salinity problems');
      report.push('');
      report.push('3. MANAGEMENT PRACTICES');
      report.push('   ‚Ä¢ High-yielding areas may have depleted nutrients');
      report.push('   ‚Ä¢ Low-yielding areas may have accumulated unused fertilizer');
      report.push('   ‚Ä¢ Manure application patterns vs. yield patterns');
      report.push('');
      report.push('4. SPATIAL CONFOUNDING');
      report.push('   ‚Ä¢ Nutrient levels may correlate with other limiting factors');
      report.push('   ‚Ä¢ Example: Low spots have high nutrients but poor drainage');
      report.push('   ‚Ä¢ Hilltops may have low nutrients but better conditions');
      report.push('');
      report.push('5. SAMPLE SIZE & NOISE');
      report.push('   ‚Ä¢ Small sample sizes can show spurious correlations');
      report.push('   ‚Ä¢ Look for |r| > 0.3 and n > 20 for meaningful relationships');
      report.push('   ‚Ä¢ R¬≤ < 10% means the nutrient explains very little yield variation');
      report.push('');
      report.push('INTERPRETING THE RESULTS');
      report.push('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
      report.push('‚Ä¢ r = +1.0: Perfect positive (higher nutrient = higher yield)');
      report.push('‚Ä¢ r = +0.5: Moderate positive correlation');
      report.push('‚Ä¢ r =  0.0: No linear relationship');
      report.push('‚Ä¢ r = -0.5: Moderate negative correlation');
      report.push('‚Ä¢ r = -1.0: Perfect negative (higher nutrient = lower yield)');
      report.push('');
      report.push('‚Ä¢ R¬≤ (R-squared): % of yield variation explained by this nutrient');
      report.push('  - R¬≤ = 25% means 25% of yield differences relate to this nutrient');
      report.push('  - R¬≤ < 5% = very weak, likely not meaningful');
      report.push('  - R¬≤ > 20% = moderate, worth investigating');
      report.push('');
      report.push('NUTRIENTS EXPECTED TO BE NEGATIVE (Lower is Better):');
      report.push('  ‚Ä¢ H_Sat (Hydrogen Saturation) - indicates acidity');
      report.push('  ‚Ä¢ Na_Sat (Sodium Saturation) - indicates salinity');
      report.push('  ‚Ä¢ Mg_sat (when excessive) - can block calcium');
      report.push('  ‚Ä¢ Soluble_Salts - indicates salt stress');
      report.push('');
      report.push('‚ïê'.repeat(70));
      report.push(`Report generated: ${new Date().toLocaleString()}`);

      return report.join('\n');
    }

    // ========== EXPORT FUNCTIONS ==========
    function getReportStyles() {
      return `
        * { box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif; padding: 20px; font-size: 12px; color: #1e293b; line-height: 1.5; }
        h1 { color: #1e293b; border-bottom: 3px solid #3b82f6; padding-bottom: 12px; margin-bottom: 20px; font-size: 24px; }
        h2 { color: #334155; margin-top: 24px; margin-bottom: 16px; font-size: 18px; }
        h3 { color: #475569; margin: 0 0 8px 0; font-size: 16px; }
        p { color: #64748b; margin: 0 0 16px 0; }
        .summary { display: flex; gap: 20px; margin: 20px 0; flex-wrap: wrap; }
        .summary-box { background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%); padding: 16px 24px; border-radius: 10px; text-align: center; min-width: 120px; border: 1px solid #cbd5e1; }
        .summary-box .number { font-size: 28px; font-weight: bold; color: #3b82f6; }
        .summary-box .label { color: #64748b; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; margin-top: 4px; }
        table { width: 100%; border-collapse: collapse; margin: 16px 0; font-size: 11px; }
        th { background: #1e293b; color: white; padding: 10px 8px; text-align: left; font-weight: 600; }
        td { padding: 8px; border-bottom: 1px solid #e2e8f0; }
        tr:nth-child(even) { background: #f8fafc; }
        .positive { color: #16a34a; } .negative { color: #dc2626; }
        .card { background: #f8fafc; border-left: 4px solid #3b82f6; padding: 12px 16px; margin: 12px 0; border-radius: 6px; }
        .card.positive { border-left-color: #22c55e; background: #f0fdf4; }
        .card.negative { border-left-color: #ef4444; background: #fef2f2; }

        /* Trend Cards for Field Trends Report - PDF optimized */
        .trend-card { background: #fff; border: 2px solid #e2e8f0; border-radius: 10px; padding: 20px; margin-bottom: 20px; page-break-inside: avoid; box-shadow: 0 1px 4px rgba(0,0,0,0.08); }
        .trend-card.positive { background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%); border-color: #22c55e; }
        .trend-card.negative { background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%); border-color: #ef4444; }
        .trend-card.neutral { background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%); border-color: #94a3b8; }
        .trend-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid rgba(0,0,0,0.1); }
        .trend-title { font-size: 18px; font-weight: 700; color: #1e293b; margin: 0; }
        .trend-pct { font-size: 22px; font-weight: 700; text-align: right; }
        .trend-sub { font-size: 11px; color: #64748b; font-weight: 500; }

        /* Stacked layout for PDF - data table on top, full-width graph below */
        .trend-content { display: flex; flex-direction: column; gap: 16px; }
        .trend-values { background: rgba(255,255,255,0.8); border-radius: 6px; padding: 10px; width: 100%; }
        .trend-values-row { display: flex; flex-wrap: wrap; gap: 8px; }
        .trend-row { display: inline-flex; justify-content: space-between; gap: 8px; padding: 6px 12px; font-size: 11px; border-radius: 4px; min-width: 120px; }
        .trend-row.alt { background: rgba(0,0,0,0.04); }
        .trend-year { font-weight: 600; color: #475569; }
        .trend-value { font-weight: 700; color: #1e293b; }
        .trend-graph { width: 100%; padding: 10px; background: rgba(255,255,255,0.5); border-radius: 8px; }
        .trend-graph svg { width: 100%; height: auto; min-height: 200px; display: block; }
        .trend-graph.large svg { min-height: 240px; }
        .trend-graph.xlarge svg { min-height: 300px; }

        /* Nutrient cards for Year Comparison */
        .nutrient-card { background: #fff; border: 2px solid #e2e8f0; border-radius: 8px; padding: 12px; margin-bottom: 12px; }
        .nutrient-card.positive { background: #f0fdf4; border-color: #22c55e; }
        .nutrient-card.negative { background: #fef2f2; border-color: #ef4444; }
        .nutrient-header { display: flex; justify-content: space-between; margin-bottom: 8px; }
        .nutrient-name { font-weight: 700; font-size: 14px; }
        .nutrient-pct { font-weight: 700; font-size: 14px; }
        .nutrient-stats { display: flex; gap: 12px; margin-bottom: 8px; }
        .stat-box { text-align: center; padding: 6px 10px; background: rgba(0,0,0,0.03); border-radius: 4px; }
        .stat-box .label { font-size: 9px; color: #64748b; text-transform: uppercase; }
        .stat-box .value { font-size: 16px; font-weight: 700; color: #1e293b; }

        .footer { margin-top: 40px; padding-top: 16px; border-top: 1px solid #e2e8f0; color: #94a3b8; font-size: 10px; text-align: center; }

        /* Page break hints for PDF - use on section wrappers */
        .page-break-before { page-break-before: always; break-before: page; }
        .page-break-after { page-break-after: always; break-after: page; }
        .no-break { page-break-inside: avoid; break-inside: avoid; }

        @media print {
          body { padding: 10px; }

          /* Prevent breaking inside content cards and containers */
          .trend-card, .nutrient-card, .card, table, .summary,
          .model-summary, .key-findings, .data-table, .zone-summary,
          .chart-container, .interpretation-section, .findings-grid,
          .coef-table, .scatter-container, .threshold-box {
            page-break-inside: avoid;
            break-inside: avoid;
          }

          /* Keep headers with their following content */
          h1, h2, h3, h4 {
            page-break-after: avoid;
            break-after: avoid;
          }

          /* Force page breaks BEFORE major sections */
          .new-section, .report-section {
            page-break-before: always;
            break-before: page;
          }
          .new-section:first-of-type, .report-section:first-of-type {
            page-break-before: avoid;
            break-before: avoid;
          }

          /* Prevent orphaned/widowed lines */
          p, li, td {
            orphans: 3;
            widows: 3;
          }

          /* Tables - keep rows together */
          tr {
            page-break-inside: avoid;
            break-inside: avoid;
          }

          /* Keep table header visible if table spans pages */
          thead {
            display: table-header-group;
          }

          /* Ensure graphs and charts print properly */
          .trend-graph { width: 100%; }
          .trend-graph svg { min-height: 220px; width: 100%; }

          /* Charts and visualizations - don't cut */
          svg, canvas, .chart, .bar-chart {
            page-break-inside: avoid;
            break-inside: avoid;
            max-height: 400px;
          }

          /* Scatter plot and analysis boxes */
          canvas { page-break-inside: avoid; break-inside: avoid; }
          #thresholdAnalysis { page-break-inside: avoid; break-inside: avoid; }

          /* MVR specific elements */
          .significance-chart { page-break-inside: avoid; break-inside: avoid; }
          .mvr-coefficients { page-break-inside: avoid; break-inside: avoid; }

          /* Spatial Change elements */
          .zone-card { page-break-inside: avoid; break-inside: avoid; }
          .change-grid { page-break-inside: avoid; break-inside: avoid; }
        }
      `;
    }

    function exportYearComparison() {
      const y1 = document.getElementById('year1Select').value;
      const y2 = document.getElementById('year2Select').value;
      if (!y1 || !y2) { showStatus('Select both years first', false); return; }

      const operationName = localStorage.getItem('operationName') || 'Soil Analysis';
      const comparisonData = document.getElementById('comparisonGrid').innerHTML;

      const printWindow = window.open('', '_blank');
      printWindow.document.write(`<!DOCTYPE html><html><head><title>${operationName} - Year Comparison</title><style>${getReportStyles()}</style></head><body>
        <h1>${operationName} - Year-Over-Year Comparison</h1>
        <p>Generated: ${new Date().toLocaleString()}</p>
        <div class="summary">
          <div class="summary-box"><div class="number">${y1}</div><div class="label">From Year</div></div>
          <div class="summary-box"><div class="number">${y2}</div><div class="label">To Year</div></div>
          <div class="summary-box"><div class="number">${selectedComparisonFields.size}</div><div class="label">Fields Compared</div></div>
        </div>
        <h2>Nutrient Changes</h2>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 10px;">${comparisonData}</div>
        <div class="footer">Soil Sample Analysis App</div>
      </body></html>`);
      printWindow.document.close();
      printWindow.print();
    }

    function exportFieldTrends() {
      const field = document.getElementById('historyFieldSelect').value;
      if (!field) { showStatus('Select a field first', false); return; }

      const operationName = localStorage.getItem('operationName') || 'Soil Analysis';
      const trendData = document.getElementById('historyContent').innerHTML;

      const printWindow = window.open('', '_blank');
      printWindow.document.write(`<!DOCTYPE html><html><head><title>${operationName} - Field Trends</title><style>${getReportStyles()}</style></head><body>
        <h1>${operationName} - Field Trends: ${field}</h1>
        <p>Generated: ${new Date().toLocaleString()}</p>
        <h2>Historical Nutrient Trends</h2>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 10px;">${trendData}</div>
        <div class="footer">Soil Sample Analysis App</div>
      </body></html>`);
      printWindow.document.close();
      printWindow.print();
    }

    function exportFieldRankings() {
      const nutrient = document.getElementById('rankingAttrSelect').value;
      const year = document.getElementById('rankingYearSelect').value;
      const operationName = localStorage.getItem('operationName') || 'Soil Analysis';
      const rankingData = document.getElementById('rankingsContent').innerHTML;

      const printWindow = window.open('', '_blank');
      printWindow.document.write(`<!DOCTYPE html><html><head><title>${operationName} - Field Rankings</title><style>${getReportStyles()}</style></head><body>
        <h1>${operationName} - Field Rankings</h1>
        <p>Generated: ${new Date().toLocaleString()}</p>
        <div class="summary">
          <div class="summary-box"><div class="number">${CONFIG.NUTRIENT_NAMES[nutrient] || nutrient}</div><div class="label">Nutrient</div></div>
          <div class="summary-box"><div class="number">${year === 'most_recent' ? 'Most Recent' : year}</div><div class="label">Year</div></div>
        </div>
        <h2>Rankings</h2>
        ${rankingData}
        <div class="footer">Soil Sample Analysis App</div>
      </body></html>`);
      printWindow.document.close();
      printWindow.print();
    }

    function exportYieldCorrelation() {
      const crop = document.getElementById('yieldCropSelect').value;
      const year = document.getElementById('yieldYearSelect').value;
      const field = document.getElementById('yieldFieldSelect').value;
      const operationName = localStorage.getItem('operationName') || 'Soil Analysis';

      // Format year label
      let yearLabel = year;
      if (year === 'avg') yearLabel = 'All (Averaged)';
      else if (year === 'combined') yearLabel = 'All (Combined)';

      // Detect which tab is active
      const isMultiTab = document.getElementById('yieldMultiTab').style.display !== 'none';
      const isBucketsTab = document.getElementById('yieldBucketsTab').style.display !== 'none';

      let reportContent = '';
      let reportTitle = '';

      if (isBucketsTab) {
        // Export Yield by Nutrient Level results
        reportTitle = 'Yield by Nutrient Level';
        reportContent = document.getElementById('yieldBucketsContent').innerHTML;
      } else if (isMultiTab) {
        // Export MVR results
        reportTitle = 'Multivariate Regression Analysis';

        // Check if model has been run
        if (!lastMultiModel) {
          alert('Please run the regression analysis first before exporting.');
          return;
        }

        // Get selected variables
        const selectedVars = Array.from(document.querySelectorAll('.multi-var-checkbox:checked'))
          .map(cb => CONFIG.NUTRIENT_NAMES[cb.value] || cb.value);

        // Model Summary
        reportContent = `
          <div style="background: #f0fdf4; border: 2px solid #22c55e; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem;">
            <h3 style="margin: 0 0 0.75rem 0; color: #166534;">Model Summary</h3>
            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; text-align: center;">
              <div><div style="font-size: 1.5rem; font-weight: 700; color: #166534;">${(lastMultiModel.R2 * 100).toFixed(1)}%</div><div style="font-size: 0.8rem; color: #64748b;">R¬≤ (Variance Explained)</div></div>
              <div><div style="font-size: 1.5rem; font-weight: 700; color: #1e40af;">${(lastMultiModel.adjR2 * 100).toFixed(1)}%</div><div style="font-size: 0.8rem; color: #64748b;">Adjusted R¬≤</div></div>
              <div><div style="font-size: 1.5rem; font-weight: 700; color: #7c3aed;">${lastMultiModel.Fstat.toFixed(2)}</div><div style="font-size: 0.8rem; color: #64748b;">F-statistic</div></div>
              <div><div style="font-size: 1.5rem; font-weight: 700; color: #475569;">${lastMultiModel.n}</div><div style="font-size: 0.8rem; color: #64748b;">Observations</div></div>
            </div>
          </div>

          <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem;">
            <h3 style="margin: 0 0 0.5rem 0; color: #1e293b;">Variables Included</h3>
            <p style="margin: 0; color: #475569;">${selectedVars.join(', ')}</p>
          </div>

          ${document.getElementById('multiInterpretation').innerHTML}

          <div style="margin-top: 1rem;">
            <h3 style="margin: 0 0 0.75rem 0; color: #1e293b;">Regression Coefficients</h3>
            <table style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
              <thead>
                <tr style="background: #f1f5f9;">
                  <th style="padding: 0.75rem; text-align: left; border: 1px solid #e2e8f0;">Variable</th>
                  <th style="padding: 0.75rem; text-align: right; border: 1px solid #e2e8f0;">Coefficient</th>
                  <th style="padding: 0.75rem; text-align: right; border: 1px solid #e2e8f0;">Std Error</th>
                  <th style="padding: 0.75rem; text-align: right; border: 1px solid #e2e8f0;">t-value</th>
                  <th style="padding: 0.75rem; text-align: right; border: 1px solid #e2e8f0;">p-value</th>
                  <th style="padding: 0.75rem; text-align: center; border: 1px solid #e2e8f0;">Sig.</th>
                </tr>
              </thead>
              <tbody>
                ${lastMultiModel.vars.map((v, i) => {
                  const coef = lastMultiModel.beta[i];
                  const se = lastMultiModel.seBeta[i];
                  const t = lastMultiModel.tStats[i];
                  const p = lastMultiModel.pValues[i];
                  const sig = p < 0.001 ? '***' : p < 0.01 ? '**' : p < 0.05 ? '*' : p < 0.1 ? '.' : '-';
                  const bgColor = p < 0.05 ? '#f0fdf4' : '';
                  return `<tr style="background: ${bgColor};">
                    <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">${v === 'Intercept' ? '(Intercept)' : CONFIG.NUTRIENT_NAMES[v] || v}</td>
                    <td style="padding: 0.5rem; border: 1px solid #e2e8f0; text-align: right; font-family: monospace;">${coef >= 0 ? '+' : ''}${coef.toFixed(4)}</td>
                    <td style="padding: 0.5rem; border: 1px solid #e2e8f0; text-align: right; font-family: monospace;">${se.toFixed(4)}</td>
                    <td style="padding: 0.5rem; border: 1px solid #e2e8f0; text-align: right; font-family: monospace;">${t.toFixed(3)}</td>
                    <td style="padding: 0.5rem; border: 1px solid #e2e8f0; text-align: right; font-family: monospace;">${p < 0.0001 ? '<0.0001' : p.toFixed(4)}</td>
                    <td style="padding: 0.5rem; border: 1px solid #e2e8f0; text-align: center; font-weight: 700;">${sig}</td>
                  </tr>`;
                }).join('')}
              </tbody>
            </table>
            <p style="font-size: 0.75rem; color: #64748b; margin-top: 0.5rem;">Significance: *** p < 0.001, ** p < 0.01, * p < 0.05, . p < 0.1</p>
          </div>
        `;
      } else {
        // Export Individual Correlations
        reportTitle = 'Individual Correlations';
        reportContent = document.getElementById('yieldContent').innerHTML;
      }

      const printWindow = window.open('', '_blank');
      printWindow.document.write(`<!DOCTYPE html><html><head><title>${operationName} - Yield Correlation</title><style>${getReportStyles()}</style></head><body>
        <h1>${operationName} - Yield Correlation: ${reportTitle}</h1>
        <p>Generated: ${new Date().toLocaleString()}</p>
        <div class="summary">
          <div class="summary-box"><div class="number">${crop === 'all' ? 'All' : crop}</div><div class="label">Crop</div></div>
          <div class="summary-box"><div class="number">${yearLabel}</div><div class="label">Yield Year</div></div>
          <div class="summary-box"><div class="number">${field === 'all' ? 'All' : field}</div><div class="label">Field</div></div>
        </div>
        ${reportContent}
        <div class="footer">Soil Sample Analysis App</div>
      </body></html>`);
      printWindow.document.close();
      printWindow.print();
    }

    // ========== TAB 5: Spatial Change Analysis ==========
    function updateSpatialAnalysis() {
      const container = document.getElementById('spatialContent');
      const field = document.getElementById('spatialFieldSelect').value;
      const nutrient = document.getElementById('spatialNutrientSelect').value;
      const baseYearSelection = document.getElementById('spatialBaseYearSelect').value;
      const compareYear = document.getElementById('spatialCompareYearSelect').value;
      const radiusFt = parseInt(document.getElementById('spatialRadiusSelect').value);
      const useEarliestPerField = baseYearSelection === 'earliest';

      if (!field) {
        container.innerHTML = '<div class="no-data">Select a field to analyze spatial changes over time.</div>';
        return;
      }

      // Filter by active client/farm first
      const activeFieldsList = getActiveFields();
      const filteredSamples = sampleData.filter(s => activeFieldsList.includes(s.field));

      // Get all samples for this field (or all fields if __all__)
      const isAllFields = field === '__all__';
      const fieldDisplayName = isAllFields ? 'All Fields' : field;
      const fieldSamples = filteredSamples.filter(s => isAllFields || s.field === field);
      const years = [...new Set(fieldSamples.map(s => s.year).filter(y => y))].sort();

      if (years.length < 2) {
        container.innerHTML = '<div class="no-data">Need at least 2 years of data to analyze changes. ' + (isAllFields ? 'Operation' : 'This field') + ' only has data from: ' + years.join(', ') + '</div>';
        return;
      }

      // Calculate earliest year per field (for "Earliest Available" option)
      const earliestYearByField = {};
      if (useEarliestPerField) {
        const allFields = [...new Set(fieldSamples.map(s => s.field).filter(f => f))];
        allFields.forEach(f => {
          const fieldYears = fieldSamples
            .filter(s => s.field === f && s.year)
            .map(s => s.year)
            .sort((a, b) => a - b);
          if (fieldYears.length > 0) {
            earliestYearByField[f] = fieldYears[0];
          }
        });
      }

      // Get base year samples - either specific year or earliest per field
      let baseSamples;
      let baseYearDisplay;
      if (useEarliestPerField) {
        // Get samples from each field's earliest year
        baseSamples = fieldSamples.filter(s => s.field && earliestYearByField[s.field] === s.year);
        const uniqueBaseYears = [...new Set(Object.values(earliestYearByField))].sort();
        baseYearDisplay = uniqueBaseYears.length === 1 ? uniqueBaseYears[0] : `${Math.min(...uniqueBaseYears)}-${Math.max(...uniqueBaseYears)}`;
      } else {
        const baseYear = parseInt(baseYearSelection);
        baseSamples = fieldSamples.filter(s => s.year === baseYear);
        baseYearDisplay = baseYear;
      }

      if (baseSamples.length === 0) {
        container.innerHTML = `<div class="no-data">No samples found for ${fieldDisplayName} in baseline year(s)</div>`;
        return;
      }

      // Get valid nutrient values for base year
      const baseWithValues = baseSamples.filter(s => {
        const val = s[nutrient];
        return val !== undefined && val !== null && val !== '' && !isNaN(parseFloat(val));
      });

      if (baseWithValues.length < 4) {
        container.innerHTML = `<div class="no-data">Need at least 4 samples with ${nutrient} data in base year. Found: ${baseWithValues.length}</div>`;
        return;
      }

      // Calculate zone thresholds based on base year (quartiles)
      const baseValues = baseWithValues.map(s => parseFloat(s[nutrient])).sort((a, b) => a - b);
      const q1Index = Math.floor(baseValues.length * 0.25);
      const q3Index = Math.floor(baseValues.length * 0.75);
      const lowThreshold = baseValues[q1Index];
      const highThreshold = baseValues[q3Index];

      // Classify base year samples into zones
      const zonedSamples = baseWithValues.map(s => ({
        ...s,
        baseYear: useEarliestPerField ? earliestYearByField[s.field] : parseInt(baseYearSelection),
        baseValue: parseFloat(s[nutrient]),
        zone: parseFloat(s[nutrient]) <= lowThreshold ? 'low' :
              parseFloat(s[nutrient]) >= highThreshold ? 'high' : 'medium'
      }));

      // Determine which years to compare
      let compareYears;
      if (compareYear === 'all') {
        if (useEarliestPerField) {
          // Compare to all years after each field's baseline
          compareYears = years; // Will filter per-sample below
        } else {
          compareYears = years.filter(y => y !== parseInt(baseYearSelection));
        }
      } else {
        compareYears = [parseInt(compareYear)];
      }

      // For each zoned sample, find matching samples in compare years
      const radiusMeters = radiusFt * 0.3048;
      const matchedData = [];

      zonedSamples.forEach(baseSample => {
        const matches = { base: baseSample, years: {} };
        const sampleBaseYear = baseSample.baseYear;
        matches.years[sampleBaseYear] = baseSample.baseValue;

        // Get comparison years for this sample (only years after its baseline)
        const sampleCompareYears = compareYear === 'all'
          ? years.filter(y => y > sampleBaseYear)
          : compareYears.filter(y => y > sampleBaseYear);

        sampleCompareYears.forEach(year => {
          // Only look at samples from the same field for matching
          const yearSamples = fieldSamples.filter(s => s.year === year && (!isAllFields || s.field === baseSample.field));
          // Find closest sample within radius
          let closest = null;
          let closestDist = Infinity;

          yearSamples.forEach(s => {
            const dist = getDistanceMeters(baseSample.lat, baseSample.lon, s.lat, s.lon);
            if (dist <= radiusMeters && dist < closestDist) {
              const val = s[nutrient];
              if (val !== undefined && val !== null && val !== '' && !isNaN(parseFloat(val))) {
                closest = s;
                closestDist = dist;
              }
            }
          });

          if (closest) {
            matches.years[year] = parseFloat(closest[nutrient]);
          }
        });

        matchedData.push(matches);
      });

      // Calculate zone statistics for each year
      // Collect all unique years from matched data (handles per-field baselines)
      const allYearsSet = new Set();
      matchedData.forEach(m => {
        Object.keys(m.years).forEach(y => allYearsSet.add(parseInt(y)));
      });
      const allYears = [...allYearsSet].sort((a, b) => a - b);
      const zoneStats = { low: {}, medium: {}, high: {}, all: {} };

      allYears.forEach(year => {
        ['low', 'medium', 'high'].forEach(zone => {
          const zoneMatches = matchedData.filter(m => m.base.zone === zone && m.years[year] !== undefined);
          if (zoneMatches.length > 0) {
            const values = zoneMatches.map(m => m.years[year]);
            zoneStats[zone][year] = {
              avg: values.reduce((a, b) => a + b, 0) / values.length,
              count: values.length,
              min: Math.min(...values),
              max: Math.max(...values)
            };
          }
        });

        // Field average
        const allMatches = matchedData.filter(m => m.years[year] !== undefined);
        if (allMatches.length > 0) {
          const values = allMatches.map(m => m.years[year]);
          zoneStats.all[year] = {
            avg: values.reduce((a, b) => a + b, 0) / values.length,
            count: values.length
          };
        }
      });

      // Calculate match rates
      const lowCount = matchedData.filter(m => m.base.zone === 'low').length;
      const medCount = matchedData.filter(m => m.base.zone === 'medium').length;
      const highCount = matchedData.filter(m => m.base.zone === 'high').length;

      // Build the results HTML
      const nutrientName = CONFIG.NUTRIENT_NAMES[nutrient] || nutrient;
      const unit = CONFIG.NUTRIENT_UNITS[nutrient] || '';
      const decimals = getDecimals(nutrient);

      let html = `
        <div style="background: #f0f9ff; border: 1px solid #0ea5e9; border-radius: 0.5rem; padding: 0.75rem; margin-bottom: 1rem; font-size: 0.8rem; color: #0369a1;">
          <strong>Spatial Change Analysis: ${fieldDisplayName} - ${nutrientName}</strong><br>
          <strong>Base Year:</strong> ${baseYearDisplay} (zones defined by this year's values)<br>
          <strong>Comparing:</strong> ${compareYears.join(', ')}<br>
          <strong>Match Radius:</strong> ${radiusFt} ft | <strong>Matched Samples:</strong> ${matchedData.length} of ${baseSamples.length}
        </div>

        <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem; font-size: 0.8rem; color: #475569;">
          <strong style="color: #1e293b;">How Zones Are Defined:</strong><br>
          Samples from ${baseYearDisplay} are divided into three zones based on their ${nutrientName} values:
          <ul style="margin: 0.5rem 0 0.5rem 1.5rem; padding: 0;">
            <li><strong style="color: #dc2626;">Low Zone</strong> = Bottom 25% of samples (lowest quartile)</li>
            <li><strong style="color: #d97706;">Medium Zone</strong> = Middle 50% of samples (between 25th and 75th percentile)</li>
            <li><strong style="color: #16a34a;">High Zone</strong> = Top 25% of samples (highest quartile)</li>
          </ul>
          <strong style="color: #1e293b;">What This Analysis Shows:</strong><br>
          Once zones are defined by ${baseYearDisplay}, we track those <em>same GPS locations</em> across other years to see how values change over time. This answers: "Are my historically low-testing areas improving or staying low?"
        </div>

        <h3 style="margin: 0 0 0.5rem 0; color: #1e293b;">Zone Summary (${baseYearDisplay} Baseline)</h3>
        <p style="color: #64748b; font-size: 0.8rem; margin-bottom: 0.75rem;">Number of sample locations in each zone, based on ${baseYearDisplay} ${nutrientName} values:</p>

        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 0.75rem; margin-bottom: 1.5rem;">
          <div style="background: #fee2e2; border: 2px solid #ef4444; border-radius: 0.5rem; padding: 0.75rem; text-align: center;">
            <div style="font-size: 1.5rem; font-weight: 700; color: #991b1b;">${lowCount}</div>
            <div style="color: #991b1b; font-size: 0.75rem;">Low Zone Samples</div>
            <div style="color: #b91c1c; font-size: 0.7rem;">‚â§ ${lowThreshold.toFixed(decimals)} ${unit}</div>
          </div>
          <div style="background: #fef3c7; border: 2px solid #f59e0b; border-radius: 0.5rem; padding: 0.75rem; text-align: center;">
            <div style="font-size: 1.5rem; font-weight: 700; color: #92400e;">${medCount}</div>
            <div style="color: #92400e; font-size: 0.75rem;">Medium Zone Samples</div>
            <div style="color: #b45309; font-size: 0.7rem;">${lowThreshold.toFixed(decimals)} - ${highThreshold.toFixed(decimals)} ${unit}</div>
          </div>
          <div style="background: #dcfce7; border: 2px solid #22c55e; border-radius: 0.5rem; padding: 0.75rem; text-align: center;">
            <div style="font-size: 1.5rem; font-weight: 700; color: #166534;">${highCount}</div>
            <div style="color: #166534; font-size: 0.75rem;">High Zone Samples</div>
            <div style="color: #15803d; font-size: 0.7rem;">‚â• ${highThreshold.toFixed(decimals)} ${unit}</div>
          </div>
        </div>

        <h3 style="margin: 0 0 0.5rem 0; color: #1e293b;">Zone Tracking Over Time</h3>
        <p style="color: #64748b; font-size: 0.8rem; margin-bottom: 0.5rem;">
          <strong>How to read this table:</strong> Each row shows the <em>average ${nutrientName} value</em> for samples in that zone across years.
          The <strong>(n=X)</strong> shows how many samples had data for that year.
          The <strong>Change</strong> column shows the difference between the first and last year (+ is increase, - is decrease).
        </p>

        <table class="rankings-table" style="margin-bottom: 1.5rem;">
          <thead>
            <tr>
              <th>Zone (${baseYearDisplay} baseline)</th>
              ${allYears.map(y => `<th>${y} Avg</th>`).join('')}
              <th>Change</th>
            </tr>
          </thead>
          <tbody>`;

      // Add rows for each zone
      const firstYear = allYears[0];
      const lastYear = allYears[allYears.length - 1];

      ['low', 'medium', 'high'].forEach(zone => {
        const zoneName = zone === 'low' ? `Low (‚â§${lowThreshold.toFixed(decimals)})` :
                        zone === 'medium' ? `Medium (${lowThreshold.toFixed(decimals)}-${highThreshold.toFixed(decimals)})` :
                        `High (‚â•${highThreshold.toFixed(decimals)})`;
        const zoneColor = zone === 'low' ? '#dc2626' : zone === 'medium' ? '#d97706' : '#16a34a';

        html += `<tr>
          <td style="font-weight: 600; color: ${zoneColor};">${zoneName}</td>`;

        allYears.forEach(year => {
          const stat = zoneStats[zone][year];
          if (stat) {
            html += `<td>${stat.avg.toFixed(decimals)} <span style="color: #94a3b8; font-size: 0.7rem;">(n=${stat.count})</span></td>`;
          } else {
            html += `<td style="color: #94a3b8;">-</td>`;
          }
        });

        // Change column (compare first year to last year)
        const baseAvg = zoneStats[zone][firstYear]?.avg;
        const lastAvg = zoneStats[zone][lastYear]?.avg;
        if (baseAvg !== undefined && lastAvg !== undefined) {
          const change = lastAvg - baseAvg;
          const pctChange = baseAvg !== 0 ? ((change / baseAvg) * 100).toFixed(0) : 'N/A';
          const changeColor = change > 0 ? '#16a34a' : change < 0 ? '#dc2626' : '#64748b';
          const arrow = change > 0 ? '‚Üë' : change < 0 ? '‚Üì' : '‚Üí';
          html += `<td style="font-weight: 600; color: ${changeColor};">${change >= 0 ? '+' : ''}${change.toFixed(decimals)} ${arrow} <span style="font-size: 0.75rem;">(${pctChange}%)</span></td>`;
        } else {
          html += `<td style="color: #94a3b8;">-</td>`;
        }

        html += `</tr>`;
      });

      // Field average row
      html += `<tr style="background: #f1f5f9; font-weight: 600;">
        <td>Field Average</td>`;
      allYears.forEach(year => {
        const stat = zoneStats.all[year];
        if (stat) {
          html += `<td>${stat.avg.toFixed(decimals)}</td>`;
        } else {
          html += `<td style="color: #94a3b8;">-</td>`;
        }
      });

      const baseFieldAvg = zoneStats.all[firstYear]?.avg;
      const lastFieldAvg = zoneStats.all[lastYear]?.avg;
      if (baseFieldAvg !== undefined && lastFieldAvg !== undefined) {
        const change = lastFieldAvg - baseFieldAvg;
        const changeColor = change > 0 ? '#16a34a' : change < 0 ? '#dc2626' : '#64748b';
        const arrow = change > 0 ? '‚Üë' : change < 0 ? '‚Üì' : '‚Üí';
        html += `<td style="color: ${changeColor};">${change >= 0 ? '+' : ''}${change.toFixed(decimals)} ${arrow}</td>`;
      } else {
        html += `<td>-</td>`;
      }
      html += `</tr></tbody></table>`;

      // Generate insights
      html += generateSpatialInsights(zoneStats, firstYear, lastYear, nutrientName, decimals, unit);

      container.innerHTML = html;
    }

    function generateSpatialInsights(zoneStats, baseYear, lastYear, nutrientName, decimals, unit) {
      const insights = [];

      // Low zone insight
      const lowBase = zoneStats.low[baseYear]?.avg;
      const lowLast = zoneStats.low[lastYear]?.avg;
      if (lowBase !== undefined && lowLast !== undefined) {
        const lowChange = lowLast - lowBase;
        const lowPct = lowBase !== 0 ? Math.abs((lowChange / lowBase) * 100).toFixed(0) : 0;
        if (lowChange > 0) {
          insights.push({
            type: 'positive',
            icon: 'üìà',
            text: `Low ${nutrientName} areas improved ${lowPct}% (+${lowChange.toFixed(decimals)} ${unit} avg)`
          });
        } else if (lowChange < 0) {
          insights.push({
            type: 'negative',
            icon: 'üìâ',
            text: `Low ${nutrientName} areas declined ${lowPct}% (${lowChange.toFixed(decimals)} ${unit} avg)`
          });
        }
      }

      // High zone insight
      const highBase = zoneStats.high[baseYear]?.avg;
      const highLast = zoneStats.high[lastYear]?.avg;
      if (highBase !== undefined && highLast !== undefined) {
        const highChange = highLast - highBase;
        const highPct = highBase !== 0 ? Math.abs((highChange / highBase) * 100).toFixed(0) : 0;
        if (highChange < 0) {
          insights.push({
            type: 'neutral',
            icon: '‚öñÔ∏è',
            text: `High ${nutrientName} areas decreased ${highPct}% (${highChange.toFixed(decimals)} ${unit} avg)`
          });
        } else if (highChange > 0) {
          insights.push({
            type: 'warning',
            icon: '‚¨ÜÔ∏è',
            text: `High ${nutrientName} areas increased ${highPct}% (+${highChange.toFixed(decimals)} ${unit} avg)`
          });
        }
      }

      // Overall strategy insight
      if (lowBase !== undefined && lowLast !== undefined && highBase !== undefined && highLast !== undefined) {
        const lowChange = lowLast - lowBase;
        const highChange = highLast - highBase;

        if (lowChange > 0 && highChange <= 0) {
          insights.push({
            type: 'positive',
            icon: 'üéØ',
            text: `Your fertility strategy is successfully bringing up the low spots while maintaining high areas!`
          });
        } else if (lowChange > 0 && highChange > 0) {
          insights.push({
            type: 'neutral',
            icon: 'üìä',
            text: `All areas are increasing - consider variable rate application to target low spots more`
          });
        } else if (lowChange <= 0 && highChange > 0) {
          insights.push({
            type: 'warning',
            icon: '‚ö†Ô∏è',
            text: `High areas getting higher while low areas stagnate - review application targeting`
          });
        }
      }

      if (insights.length === 0) {
        return '';
      }

      let html = `
        <h3 style="margin: 1rem 0 0.75rem 0; color: #1e293b;">üí° Insights</h3>
        <div style="display: flex; flex-direction: column; gap: 0.5rem;">`;

      insights.forEach(insight => {
        const bgColor = insight.type === 'positive' ? '#f0fdf4' :
                       insight.type === 'negative' ? '#fef2f2' :
                       insight.type === 'warning' ? '#fffbeb' : '#f8fafc';
        const borderColor = insight.type === 'positive' ? '#22c55e' :
                           insight.type === 'negative' ? '#ef4444' :
                           insight.type === 'warning' ? '#f59e0b' : '#cbd5e1';

        html += `
          <div style="background: ${bgColor}; border-left: 4px solid ${borderColor}; padding: 0.75rem 1rem; border-radius: 0.375rem;">
            <span style="font-size: 1.1rem; margin-right: 0.5rem;">${insight.icon}</span>
            <span style="color: #1e293b;">${insight.text}</span>
          </div>`;
      });

      html += `</div>`;
      return html;
    }

    function getDistanceMeters(lat1, lon1, lat2, lon2) {
      // Haversine formula for distance between two GPS coordinates
      const R = 6371000; // Earth radius in meters
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }

    function exportSpatialAnalysis() {
      const field = document.getElementById('spatialFieldSelect').value;
      const fieldDisplayName = field === '__all__' ? 'All Fields' : field;
      const nutrient = document.getElementById('spatialNutrientSelect').value;
      const nutrientName = CONFIG.NUTRIENT_NAMES[nutrient] || nutrient;
      const operationName = localStorage.getItem('operationName') || 'Soil Analysis';
      const spatialData = document.getElementById('spatialContent').innerHTML;

      const printWindow = window.open('', '_blank');
      printWindow.document.write(`<!DOCTYPE html><html><head><title>${operationName} - Spatial Change Analysis</title><style>${getReportStyles()}</style></head><body>
        <h1>${operationName} - Spatial Change Analysis</h1>
        <p>Generated: ${new Date().toLocaleString()}</p>
        <div class="summary">
          <div class="summary-box"><div class="number">${fieldDisplayName}</div><div class="label">Field</div></div>
          <div class="summary-box"><div class="number">${nutrientName}</div><div class="label">Nutrient</div></div>
        </div>
        ${spatialData}
        <div class="footer">Soil Sample Analysis App</div>
      </body></html>`);
      printWindow.document.close();
      printWindow.print();
    }

    function showStatus(msg, ok) {
      const el = document.getElementById('statusMessage');
      el.textContent = msg;
      el.style.display = 'block';
      el.style.background = ok ? '#dcfce7' : '#fee2e2';
      el.style.color = ok ? '#166534' : '#991b1b';
      setTimeout(() => el.style.display = 'none', 4000);
    }

    function updateBackupFooter() {
      const backupTime = localStorage.getItem('soilDataBackupTime');
      const footer = document.getElementById('backupFooter');
      const buildDate = new Date(BUILD_DATE);
      const buildStr = buildDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) + ', ' +
                       buildDate.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
      const versionInfo = `App ${APP_VERSION} ‚Ä¢ Built: ${buildStr}`;
      const legalLinks = `<span style="margin: 0 0.5rem; color: #cbd5e1;">|</span> <a href="privacy-policy.html" style="color: #94a3b8; text-decoration: none;">Privacy</a> <span style="color: #cbd5e1;">¬∑</span> <a href="terms-of-service.html" style="color: #94a3b8; text-decoration: none;">Terms</a>`;

      const sampleData = JSON.parse(localStorage.getItem('soilSamples') || '[]');

      if (backupTime) {
        const date = new Date(parseInt(backupTime));
        const backupStr = date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
        footer.innerHTML = `${versionInfo} <span style="margin: 0 0.5rem; color: #cbd5e1;">|</span> <span style="color: #22c55e;">Data backup: ${backupStr}</span>${legalLinks}`;
      } else if (sampleData.length === 0) {
        // No data yet - don't show backup warning
        footer.innerHTML = versionInfo + legalLinks;
      } else {
        // Has data but no backup - show warning
        footer.innerHTML = `${versionInfo} <span style="margin: 0 0.5rem; color: #cbd5e1;">|</span> <span style="color: #f59e0b;">No backup yet</span>${legalLinks}`;
      }
    }
  </script>
  <div class="backup-footer" id="backupFooter"></div>
</body>
</html>
