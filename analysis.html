<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/svg+xml" href="favicon.svg">
  <link rel="apple-touch-icon" href="logo.png">
  <title>Soil Sample Analysis - Analysis</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f8fafc; color: #1e293b; min-height: 100vh; }
    .top-bar { background: linear-gradient(135deg, #1e293b 0%, #334155 100%); color: white; padding: 1rem 1.5rem; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem; }
    .top-bar h1 { font-size: 1.5rem; font-weight: 700; }
    .top-bar p { font-size: 0.875rem; opacity: 0.8; margin-top: 0.25rem; }
    .nav-links { display: flex; gap: 0.5rem; flex-wrap: wrap; }
    .nav-link { padding: 0.5rem 1rem; background: rgba(255,255,255,0.1); color: white; text-decoration: none; border-radius: 0.375rem; font-size: 0.875rem; font-weight: 500; }
    .nav-link:hover { background: rgba(255,255,255,0.2); }
    .nav-link.active { background: #3b82f6; }
    .auth-section { display: flex; align-items: center; gap: 1rem; }
    .user-info { font-size: 0.875rem; color: rgba(255,255,255,0.9); }
    .sign-in-btn { padding: 0.5rem 1rem; background: #4285f4; color: white; border: none; border-radius: 0.375rem; font-size: 0.875rem; cursor: pointer; }
    .sign-in-btn.signed-in { background: #22c55e; }
    
    .analysis-container { max-width: 1400px; margin: 0 auto; padding: 1.5rem; }
    
    /* Tabs */
    .tabs { display: flex; gap: 0.5rem; margin-bottom: 1.5rem; flex-wrap: wrap; }
    .tab { padding: 0.75rem 1.25rem; background: white; border: 1px solid #cbd5e1; border-radius: 0.5rem; cursor: pointer; font-weight: 500; font-size: 0.875rem; }
    .tab:hover { background: #f1f5f9; }
    .tab.active { background: #3b82f6; color: white; border-color: #3b82f6; }
    
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    
    /* Controls */
    .controls-bar { background: white; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1.5rem; box-shadow: 0 1px 3px rgba(0,0,0,0.1); display: flex; gap: 1.5rem; flex-wrap: wrap; align-items: flex-end; }
    .control-group { display: flex; flex-direction: column; gap: 0.25rem; }
    .control-group label { font-size: 0.75rem; font-weight: 600; color: #64748b; text-transform: uppercase; }
    .control-group select { padding: 0.5rem 0.75rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 0.375rem; min-width: 160px; }
    .export-btn { padding: 0.5rem 1rem; background: #8b5cf6; color: white; border: none; border-radius: 0.375rem; font-size: 0.875rem; font-weight: 500; cursor: pointer; margin-left: auto; }
    .export-btn:hover { background: #7c3aed; }

    /* Nutrient Grid for Year Comparison */
    .nutrient-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1rem; }
    
    .nutrient-card { background: white; border-radius: 0.5rem; padding: 1rem; box-shadow: 0 1px 3px rgba(0,0,0,0.1); border-left: 4px solid #94a3b8; }
    .nutrient-card.positive { border-left-color: #22c55e; background: linear-gradient(to right, #f0fdf4, white); }
    .nutrient-card.negative { border-left-color: #ef4444; background: linear-gradient(to right, #fef2f2, white); }
    .nutrient-card.no-comparison { border-left-color: #f59e0b; background: linear-gradient(to right, #fffbeb, white); }
    
    .nutrient-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem; }
    .nutrient-name { font-size: 1rem; font-weight: 700; color: #1e293b; }
    .nutrient-pct { font-size: 1.125rem; font-weight: 700; }
    .nutrient-pct.positive { color: #22c55e; }
    .nutrient-pct.negative { color: #ef4444; }
    .nutrient-pct.neutral { color: #64748b; }
    
    .nutrient-stats { display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem; margin-bottom: 0.75rem; }
    .stat-box { background: #f8fafc; border-radius: 0.375rem; padding: 0.5rem; text-align: center; }
    .stat-box .label { font-size: 0.625rem; font-weight: 600; color: #64748b; text-transform: uppercase; }
    .stat-box .value { font-size: 0.9375rem; font-weight: 700; color: #1e293b; }
    
    .year-comparison { display: flex; justify-content: space-between; align-items: center; background: #f1f5f9; border-radius: 0.375rem; padding: 0.5rem 0.75rem; margin-bottom: 0.5rem; }
    .year-val { text-align: center; }
    .year-val .yr { font-size: 0.625rem; font-weight: 600; color: #64748b; }
    .year-val .num { font-size: 1.125rem; font-weight: 700; color: #1e293b; }
    .year-arrow { font-size: 1.25rem; color: #94a3b8; }
    
    .change-row { display: flex; justify-content: center; gap: 1.5rem; font-size: 0.75rem; color: #64748b; }
    .change-row .val { font-weight: 600; }
    .change-row .val.positive { color: #22c55e; }
    .change-row .val.negative { color: #ef4444; }
    
    /* Historical Trends */
    .trend-card { background: white; border: 2px solid; border-radius: 0.75rem; padding: 1.25rem; margin-bottom: 1.25rem; box-shadow: 0 2px 8px rgba(0,0,0,0.06); }
    .trend-card.positive { background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%); border-color: #22c55e; }
    .trend-card.negative { background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%); border-color: #ef4444; }
    .trend-card.neutral { background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%); border-color: #94a3b8; }
    .trend-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 1rem; padding-bottom: 0.75rem; border-bottom: 1px solid rgba(0,0,0,0.08); }
    .trend-title { font-size: 1.25rem; font-weight: 700; color: #1e293b; }
    .trend-pct { font-size: 1.5rem; font-weight: 700; text-align: right; }
    .trend-sub { font-size: 0.75rem; color: #64748b; font-weight: 500; }
    .trend-content { display: flex; flex-wrap: nowrap; gap: 1rem; align-items: stretch; }
    .trend-values { background: rgba(255,255,255,0.7); border-radius: 0.5rem; padding: 0.5rem; min-width: 200px; flex: 0 0 auto; max-height: 400px; overflow-y: auto; }
    .trend-row { display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0.75rem; font-size: 0.875rem; border-radius: 0.25rem; }
    .trend-row.alt { background: rgba(0,0,0,0.03); }
    .trend-year { font-weight: 600; color: #475569; min-width: 50px; }
    .trend-value { font-weight: 700; color: #1e293b; }
    .trend-graph { flex: 1 1 auto; background: rgba(255,255,255,0.5); border-radius: 0.5rem; padding: 0.75rem; min-width: 400px; }
    .trend-graph svg { display: block; width: 100%; height: auto; min-height: 180px; }
    .trend-graph.large svg { min-height: 220px; }
    .trend-graph.xlarge svg { min-height: 280px; }
    @media (max-width: 900px) {
      .trend-content { flex-direction: column; }
      .trend-graph { min-width: 100%; width: 100%; }
      .trend-graph svg { min-height: 200px; }
    }
    
    /* Field Rankings */
    .rankings-table { width: 100%; border-collapse: collapse; background: white; border-radius: 0.5rem; overflow: hidden; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
    .rankings-table th, .rankings-table td { padding: 0.75rem 1rem; text-align: left; border-bottom: 1px solid #e2e8f0; }
    .rankings-table th { background: #f8fafc; font-weight: 600; color: #475569; font-size: 0.75rem; text-transform: uppercase; }
    .rankings-table th.sortable-header:hover { background: #e2e8f0; }
    .rankings-table tr:hover { background: #f8fafc; }
    .rankings-table .rank { font-weight: 700; color: #64748b; width: 60px; }
    .rankings-table .field { font-weight: 500; }
    .rankings-table .value { font-weight: 700; }
    .rankings-table .high { color: #22c55e; }
    .rankings-table .low { color: #ef4444; }
    
    .no-data { background: #fef3c7; border: 2px solid #f59e0b; border-radius: 0.5rem; padding: 2rem; text-align: center; color: #92400e; }
    #statusMessage { display: none; position: fixed; top: 1rem; left: 50%; transform: translateX(-50%); z-index: 9999; padding: 0.75rem 1rem; border-radius: 0.375rem; box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
    
    @media (max-width: 639px) {
      .nutrient-grid { grid-template-columns: 1fr; }
      .controls-bar { flex-direction: column; align-items: stretch; }
      .tabs { flex-direction: column; }
      .tab { text-align: center; }
    }
    .backup-footer { position: fixed; bottom: 0; left: 0; right: 0; background: #f8fafc; border-top: 1px solid #e2e8f0; padding: 0.25rem 1rem; font-size: 0.7rem; color: #64748b; text-align: center; z-index: 900; }

    /* ========== SAP VIEWER STYLES ========== */
    .sap-subtabs { display: flex; gap: 0.5rem; margin-bottom: 1rem; border-bottom: 2px solid #e2e8f0; padding-bottom: 0.5rem; }
    .sap-subtab { padding: 0.5rem 1rem; border: none; background: #f1f5f9; color: #64748b; border-radius: 0.375rem 0.375rem 0 0; font-weight: 500; cursor: pointer; }
    .sap-subtab.active { background: #f59e0b; color: white; }
    .sap-subtab-content { display: none; }
    .sap-subtab-content.active { display: block; }

    .sap-controls { background: white; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem; box-shadow: 0 1px 3px rgba(0,0,0,0.1); display: flex; gap: 1.5rem; flex-wrap: wrap; align-items: flex-end; }

    .sap-empty-state { background: #fef3c7; border: 2px solid #f59e0b; border-radius: 0.5rem; padding: 3rem 2rem; text-align: center; color: #92400e; }
    .sap-empty-state h3 { margin: 0 0 0.5rem 0; font-size: 1.25rem; }
    .sap-empty-state p { margin: 0; }
    .sap-empty-state a { color: #d97706; }

    .sap-site-header { display: flex; justify-content: space-between; align-items: flex-start; background: white; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
    .sap-site-info h3 { margin: 0 0 0.5rem 0; font-size: 1.25rem; color: #1e293b; }
    .sap-site-meta { display: flex; gap: 1rem; flex-wrap: wrap; font-size: 0.875rem; color: #64748b; }
    .sap-site-meta span { background: #f1f5f9; padding: 0.25rem 0.5rem; border-radius: 0.25rem; }
    .sap-ruleset-badge { background: #eff6ff; color: #3b82f6; padding: 0.25rem 0.75rem; border-radius: 1rem; font-size: 0.75rem; font-weight: 600; }

    .sap-summary-cards { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1.5rem; }
    .sap-summary-card { background: white; border: 2px solid #e2e8f0; border-radius: 0.5rem; padding: 1rem; }
    .sap-card-header { display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.75rem; }
    .sap-card-icon { font-size: 1.25rem; }
    .sap-card-title { font-weight: 600; color: #475569; font-size: 0.875rem; }
    .sap-card-status { display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem; }
    .sap-status-dot { width: 12px; height: 12px; border-radius: 50%; }
    .sap-status-text { font-size: 1.125rem; font-weight: 700; }
    .sap-card-reason { font-size: 0.875rem; color: #64748b; margin-bottom: 0.25rem; }
    .sap-card-confidence { font-size: 0.75rem; color: #94a3b8; }

    .sap-comparison-section { background: white; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1.5rem; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
    .sap-comparison-header { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem; margin-bottom: 1rem; padding-bottom: 0.75rem; border-bottom: 1px solid #e2e8f0; }
    .sap-comparison-header h4 { margin: 0; font-size: 1rem; color: #1e293b; }
    .sap-comparison-controls { display: flex; gap: 1rem; flex-wrap: wrap; align-items: center; }
    .sap-search-input { padding: 0.375rem 0.75rem; border: 1px solid #cbd5e1; border-radius: 0.375rem; font-size: 0.875rem; width: 150px; }
    .sap-view-toggle, .sap-display-toggle { display: flex; border: 1px solid #cbd5e1; border-radius: 0.375rem; overflow: hidden; }
    .sap-toggle-btn { padding: 0.375rem 0.75rem; border: none; background: white; font-size: 0.75rem; cursor: pointer; border-right: 1px solid #cbd5e1; }
    .sap-toggle-btn:last-child { border-right: none; }
    .sap-toggle-btn.active { background: #3b82f6; color: white; }
    .sap-toggle-btn:hover:not(.active) { background: #f1f5f9; }

    .sap-comparison-table-wrapper { overflow-x: auto; }
    .sap-comparison-table { width: 100%; border-collapse: collapse; font-size: 0.875rem; }
    .sap-comparison-table th { padding: 0.5rem 0.75rem; text-align: left; background: #f8fafc; border-bottom: 2px solid #e2e8f0; font-weight: 600; color: #475569; font-size: 0.75rem; text-transform: uppercase; }
    .sap-comparison-table td { padding: 0.5rem 0.75rem; border-bottom: 1px solid #f1f5f9; }
    .sap-group-row td { background: #f1f5f9; font-weight: 600; color: #475569; font-size: 0.8rem; padding: 0.375rem 0.75rem; }
    .sap-nutrient-name { font-weight: 500; color: #1e293b; min-width: 80px; }
    .sap-value { font-family: 'SF Mono', Monaco, monospace; text-align: right; min-width: 60px; }
    .sap-status { text-align: center; }
    .sap-status-chip { display: inline-block; padding: 0.125rem 0.5rem; border-radius: 1rem; font-size: 0.7rem; font-weight: 600; border: 1px solid; }
    .sap-delta { text-align: center; font-family: 'SF Mono', Monaco, monospace; font-size: 0.8rem; font-weight: 500; min-width: 70px; }
    .sap-col-new, .sap-col-old { min-width: 80px; }
    .sap-col-status { min-width: 70px; }
    .sap-col-delta { min-width: 80px; }

    .sap-trend-section { background: white; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1.5rem; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
    .sap-trend-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding-bottom: 0.75rem; border-bottom: 1px solid #e2e8f0; }
    .sap-trend-header h4 { margin: 0; font-size: 1rem; color: #1e293b; }
    .sap-expand-btn { padding: 0.375rem 0.75rem; border: 1px solid #cbd5e1; border-radius: 0.375rem; background: white; font-size: 0.8rem; cursor: pointer; }
    .sap-expand-btn:hover { background: #f1f5f9; }
    .sap-trend-table-wrapper { overflow-x: auto; }
    .sap-trend-table { width: 100%; border-collapse: collapse; font-size: 0.8rem; }
    .sap-trend-table th { padding: 0.5rem; text-align: center; background: #f8fafc; border-bottom: 2px solid #e2e8f0; font-weight: 600; color: #475569; }
    .sap-trend-table td { padding: 0.5rem; border-bottom: 1px solid #f1f5f9; }
    .sap-trend-metric { font-weight: 500; color: #1e293b; text-align: left; }
    .sap-trend-date { font-size: 0.7rem; white-space: nowrap; }
    .sap-stage { display: block; font-size: 0.65rem; color: #94a3b8; font-weight: normal; }
    .sap-trend-cell { text-align: center; }
    .sap-trend-values { display: flex; flex-direction: column; gap: 2px; align-items: center; }
    .sap-trend-new, .sap-trend-old { display: inline-block; padding: 0.125rem 0.375rem; border-radius: 0.25rem; font-family: 'SF Mono', Monaco, monospace; font-size: 0.7rem; border: 1px solid; }
    .sap-no-data { color: #94a3b8; }

    .sap-timeline-section { background: white; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1.5rem; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
    .sap-timeline-section h4 { margin: 0 0 1rem 0; font-size: 1rem; color: #1e293b; }
    .sap-timeline-grid { display: flex; flex-direction: column; gap: 2px; }
    .sap-timeline-header { display: flex; background: #f8fafc; border-radius: 0.25rem; font-weight: 600; font-size: 0.75rem; color: #475569; }
    .sap-timeline-row { display: flex; cursor: pointer; border-radius: 0.25rem; transition: background 0.15s; }
    .sap-timeline-row:hover { background: #f1f5f9; }
    .sap-timeline-row.selected { background: #eff6ff; border: 1px solid #3b82f6; }
    .sap-timeline-label, .sap-timeline-date { flex: 0 0 120px; padding: 0.5rem; font-size: 0.8rem; }
    .sap-timeline-sys, .sap-timeline-cell { flex: 1; padding: 0.5rem; text-align: center; min-width: 60px; }
    .sap-timeline-dot { display: inline-block; width: 10px; height: 10px; border-radius: 50%; }

    .sap-notes-section { background: white; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1.5rem; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
    .sap-notes-section h4 { margin: 0 0 0.75rem 0; font-size: 1rem; color: #1e293b; }
    .sap-note-input { width: 100%; min-height: 80px; padding: 0.75rem; border: 1px solid #cbd5e1; border-radius: 0.375rem; font-size: 0.875rem; font-family: inherit; resize: vertical; margin-bottom: 0.5rem; }
    .sap-note-save { padding: 0.5rem 1rem; background: #3b82f6; color: white; border: none; border-radius: 0.375rem; font-size: 0.875rem; cursor: pointer; }
    .sap-note-save:hover { background: #2563eb; }

    .sap-signal-chip { display: inline-block; padding: 0.125rem 0.375rem; border-radius: 0.25rem; font-size: 0.6rem; font-weight: 700; margin-top: 2px; text-transform: uppercase; letter-spacing: 0.02em; }
    .sap-sort-select { padding: 0.375rem 0.5rem; border: 1px solid #cbd5e1; border-radius: 0.375rem; font-size: 0.75rem; background: white; cursor: pointer; }
    .sap-group-toggle { display: inline-block; width: 1rem; margin-right: 0.25rem; }
    .sap-summary-card.clickable:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
    .sap-card-more { font-size: 0.65rem; color: #64748b; margin-left: 0.25rem; }

    /* Drawer styles */
    .sap-drawer { position: fixed; top: 0; right: 0; bottom: 0; left: 0; z-index: 1000; pointer-events: none; }
    .sap-drawer.open { pointer-events: auto; }
    .sap-drawer-overlay { position: absolute; top: 0; right: 0; bottom: 0; left: 0; background: rgba(0,0,0,0.3); opacity: 0; transition: opacity 0.3s; }
    .sap-drawer.open .sap-drawer-overlay { opacity: 1; }
    .sap-drawer-content { position: absolute; top: 0; right: 0; bottom: 0; width: 400px; max-width: 90vw; background: white; box-shadow: -4px 0 20px rgba(0,0,0,0.15); transform: translateX(100%); transition: transform 0.3s ease; display: flex; flex-direction: column; }
    .sap-drawer.open .sap-drawer-content { transform: translateX(0); }
    .sap-drawer-header { padding: 1rem 1.25rem; border-bottom: 1px solid #e2e8f0; display: flex; justify-content: space-between; align-items: center; background: #f8fafc; }
    .sap-drawer-header h3 { margin: 0; font-size: 1.1rem; color: #1e293b; }
    .sap-drawer-close { background: none; border: none; font-size: 1.5rem; color: #64748b; cursor: pointer; padding: 0; line-height: 1; }
    .sap-drawer-close:hover { color: #1e293b; }
    .sap-drawer-body { flex: 1; overflow-y: auto; padding: 0.75rem; }
    .sap-issue-item { padding: 0.75rem; margin-bottom: 0.5rem; background: #f8fafc; border-radius: 0.5rem; border: 1px solid #e2e8f0; cursor: pointer; transition: all 0.15s; }
    .sap-issue-item:hover { background: #f1f5f9; border-color: #cbd5e1; }
    .sap-issue-header { display: flex; justify-content: space-between; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem; }
    .sap-issue-label { font-weight: 600; font-size: 0.9rem; color: #1e293b; }
    .sap-issue-details { font-size: 0.8rem; color: #64748b; }
    .sap-issue-values { display: flex; gap: 1rem; margin-bottom: 0.25rem; }
    .sap-issue-reason { margin-bottom: 0.25rem; }
    .sap-issue-threshold { font-size: 0.75rem; color: #94a3b8; }

    /* Modal styles */
    .sap-modal { position: fixed; top: 0; right: 0; bottom: 0; left: 0; z-index: 1001; pointer-events: none; display: flex; align-items: center; justify-content: center; }
    .sap-modal.open { pointer-events: auto; }
    .sap-modal-overlay { position: absolute; top: 0; right: 0; bottom: 0; left: 0; background: rgba(0,0,0,0.4); opacity: 0; transition: opacity 0.2s; }
    .sap-modal.open .sap-modal-overlay { opacity: 1; }
    .sap-modal-content { position: relative; z-index: 1; background: white; border-radius: 0.75rem; box-shadow: 0 20px 50px rgba(0,0,0,0.2); max-width: 500px; width: 90vw; max-height: 85vh; overflow: hidden; transform: scale(0.95); opacity: 0; transition: all 0.2s ease; }
    .sap-modal.open .sap-modal-content { transform: scale(1); opacity: 1; }
    .sap-modal-header { padding: 1rem 1.25rem; border-bottom: 1px solid #e2e8f0; display: flex; justify-content: space-between; align-items: center; background: #f8fafc; }
    .sap-modal-header h3 { margin: 0; font-size: 1rem; color: #1e293b; }
    .sap-modal-close { background: none; border: none; font-size: 1.5rem; color: #64748b; cursor: pointer; padding: 0; line-height: 1; }
    .sap-modal-close:hover { color: #1e293b; }
    .sap-modal-body { padding: 1rem 1.25rem; overflow-y: auto; max-height: 60vh; }
    .sap-explain-row { display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem; margin-bottom: 0.75rem; padding-bottom: 0.75rem; border-bottom: 1px solid #f1f5f9; }
    .sap-explain-row:last-child { border-bottom: none; margin-bottom: 0; }
    .sap-explain-label { font-weight: 600; font-size: 0.85rem; color: #475569; min-width: 100px; }
    .sap-explain-value { font-size: 0.85rem; color: #1e293b; }
    .sap-explain-severity { font-size: 0.75rem; color: #94a3b8; }
    .sap-explain-footer { display: flex; gap: 1rem; margin-top: 1rem; padding-top: 0.75rem; border-top: 1px solid #e2e8f0; }
    .sap-explain-ruleset { font-size: 0.75rem; color: #64748b; background: #f1f5f9; padding: 0.25rem 0.5rem; border-radius: 0.25rem; }
    .sap-explain-ratio { font-size: 0.75rem; color: #6366f1; background: #eef2ff; padding: 0.25rem 0.5rem; border-radius: 0.25rem; }

    /* Row highlight animation */
    .sap-row-highlight { animation: rowFlash 2s ease; }
    @keyframes rowFlash {
      0%, 100% { background: transparent; }
      25%, 75% { background: #fef3c7; }
    }

    /* Trend Graph Styles */
    .sap-trend-controls { display: flex; gap: 0.75rem; align-items: center; }
    .sap-trend-legend { display: flex; gap: 1.5rem; margin-bottom: 1rem; font-size: 0.8rem; color: #64748b; justify-content: center; }
    .sap-legend-item { display: flex; align-items: center; gap: 0.5rem; }
    .sap-legend-line { display: inline-block; width: 24px; height: 2px; background: #64748b; }
    .sap-legend-line.dashed { background: repeating-linear-gradient(90deg, #64748b 0, #64748b 4px, transparent 4px, transparent 7px); }
    .sap-chart-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(380px, 1fr)); gap: 1rem; }
    .sap-chart-panel { background: white; border-radius: 0.5rem; padding: 1rem; border: 1px solid #e2e8f0; }
    .sap-chart-title { font-weight: 600; font-size: 0.95rem; color: #1e293b; margin-bottom: 0.75rem; text-align: center; }
    .sap-chart-container { display: flex; justify-content: center; position: relative; }
    .sap-chart-legend { display: flex; flex-wrap: wrap; gap: 0.75rem; justify-content: center; margin-top: 0.75rem; font-size: 0.8rem; }
    .sap-metric-legend { display: flex; align-items: center; gap: 0.25rem; }
    .sap-legend-dot { width: 10px; height: 10px; border-radius: 50%; }
    .sap-chart-empty { display: flex; align-items: center; justify-content: center; height: 180px; color: #94a3b8; font-size: 0.85rem; }
    .sap-trend-svg { overflow: visible; }
    .sap-chart-point { cursor: pointer; transition: r 0.15s; }
    .sap-chart-point:hover { r: 6; }

    /* Chart Tooltip */
    .sap-chart-tooltip { position: fixed; z-index: 1002; background: #1e293b; color: white; padding: 0.5rem 0.75rem; border-radius: 0.375rem; font-size: 0.75rem; pointer-events: none; transform: translate(-50%, -100%); margin-top: -8px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); white-space: nowrap; }
    .sap-chart-tooltip::after { content: ''; position: absolute; top: 100%; left: 50%; transform: translateX(-50%); border: 6px solid transparent; border-top-color: #1e293b; }
    .sap-tooltip-metric { font-weight: 600; margin-bottom: 0.25rem; }
    .sap-tooltip-values { display: flex; gap: 0.75rem; }
    .sap-tooltip-leaf { color: #94a3b8; }

    /* Collapsible chart panels */
    .sap-chart-collapsible { grid-column: 1 / -1; }
    .sap-chart-title-collapsible { cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 0.5rem; }
    .sap-collapse-icon { font-size: 0.7rem; transition: transform 0.2s; }
    .sap-chart-collapsible.collapsed .sap-collapse-icon { transform: rotate(-90deg); }
    .sap-chart-collapsible.collapsed .sap-collapsible-content { display: none; }
    .sap-collapsible-content { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 0.75rem; margin-top: 0.5rem; }

    /* Ratio line legend */
    .sap-legend-line-mini { display: inline-block; width: 16px; height: 0; border-top: 2px dashed; margin-right: 0.25rem; }

    /* Table trend indicators */
    .sap-trend-arrow-col { width: 40px; }
    .sap-trend-arrow { text-align: center; font-size: 1rem; }
    .sap-trend-up { color: #22c55e; }
    .sap-trend-down { color: #ef4444; }
    .sap-trend-flat { color: #94a3b8; }
    .sap-row-muted { opacity: 0.5; }
    .sap-row-muted:hover { opacity: 0.8; }

    /* Expandable charts */
    .sap-chart-expandable { cursor: pointer; transition: transform 0.15s, box-shadow 0.15s; }
    .sap-chart-panel.sap-chart-expandable:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
    .sap-chart-container.sap-chart-expandable:hover { opacity: 0.9; }

    /* Chart expand modal */
    .sap-chart-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1100; display: flex; align-items: center; justify-content: center; padding: 1rem; }
    .sap-chart-modal-content { background: white; border-radius: 0.75rem; padding: 1.5rem; max-width: 900px; width: 100%; max-height: 90vh; overflow: auto; position: relative; }
    .sap-expanded-chart { display: flex; justify-content: center; margin: 1rem 0; overflow-x: auto; }
    .sap-expanded-legend { justify-content: center; padding: 1rem 0; border-top: 1px solid #e2e8f0; margin-top: 1rem; flex-wrap: wrap; }

    @media (max-width: 639px) {
      .sap-summary-cards { grid-template-columns: 1fr 1fr; }
      .sap-comparison-controls { flex-direction: column; align-items: stretch; }
      .sap-search-input { width: 100%; }
    }
  </style>
</head>
<body>
  <div class="top-bar">
    <div>
      <h1>üìä Soil Analysis</h1>
      <p>Trends, Comparisons & Rankings</p>
    </div>
    <nav class="nav-links">
      <a href="index.html" class="nav-link">üìç Map</a>
      <a href="analysis.html" class="nav-link active">üìä Analysis</a>
      <a href="import.html" class="nav-link">üìÅ Import</a>
      <a href="settings.html" class="nav-link">‚öôÔ∏è Settings</a>
    </nav>
    <div class="auth-section">
      <span class="user-info" id="userInfo"></span>
      <button class="sign-in-btn" id="authBtn" onclick="handleAuth()">Sign In to Edit</button>
    </div>
  </div>

  <!-- Active Operation Indicator (shown when filtering by client/farm) -->
  <div id="activeOperationIndicator" style="display: none; padding: 0.35rem 1rem; background: #f5f3ff; border-bottom: 1px solid #ddd6fe; font-size: 0.75rem; color: #6b21a8;"></div>

  <div class="analysis-container">
    <div class="tabs">
      <div class="tab active" data-tab="history">üìà Field Trends</div>
      <div class="tab" data-tab="comparison">üìä Year-Over-Year</div>
      <div class="tab" data-tab="rankings">üèÜ Field Rankings</div>
      <div class="tab" data-tab="yield">üåæ Yield Correlation</div>
      <div class="tab" data-tab="spatial">üó∫Ô∏è Spatial Change</div>
      <div class="tab" data-tab="inseason">üß™ In-Season</div>
    </div>
    
    <!-- Tab: Year Comparison (Operation-wide) -->
    <div id="comparison" class="tab-content">
      <div class="controls-bar">
        <div class="control-group">
          <label>From Year</label>
          <select id="year1Select"></select>
        </div>
        <div class="control-group">
          <label>To Year</label>
          <select id="year2Select"></select>
        </div>
        <button onclick="exportYearComparison()" class="export-btn">üìÑ Export Report</button>
      </div>
      
      <!-- Year Stats Section -->
      <div id="yearStats" style="display: flex; gap: 1rem; margin-bottom: 1rem; flex-wrap: wrap;">
        <div id="fromYearStats" style="flex: 1; min-width: 250px; background: #f8fafc; border: 2px solid #cbd5e1; border-radius: 0.5rem; padding: 1rem;">
          <h4 style="margin: 0 0 0.5rem 0; color: #64748b; font-size: 0.875rem;">From Year Stats</h4>
          <div id="fromYearInfo"></div>
        </div>
        <div id="toYearStats" style="flex: 1; min-width: 250px; background: #f0fdf4; border: 2px solid #22c55e; border-radius: 0.5rem; padding: 1rem;">
          <h4 style="margin: 0 0 0.5rem 0; color: #166534; font-size: 0.875rem;">To Year Stats</h4>
          <div id="toYearInfo"></div>
        </div>
      </div>
      
      <!-- Field Selection & Mismatch Warning -->
      <div id="fieldSelectionSection" style="background: white; border: 2px solid #e2e8f0; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1.5rem;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
          <h4 style="margin: 0; color: #475569; font-size: 0.875rem;">üìã Fields Included in Comparison</h4>
          <div>
            <button onclick="selectMatchingComparisonFields()" style="padding: 0.25rem 0.5rem; font-size: 0.75rem; border: 1px solid #cbd5e1; border-radius: 0.25rem; background: white; cursor: pointer; margin-right: 0.25rem;">Select Matching</button>
            <button onclick="selectAllComparisonFields()" style="padding: 0.25rem 0.5rem; font-size: 0.75rem; border: 1px solid #cbd5e1; border-radius: 0.25rem; background: white; cursor: pointer;">Select All</button>
          </div>
        </div>
        <div id="fieldCheckboxes" style="display: flex; flex-wrap: wrap; gap: 0.5rem;"></div>
        <div id="fieldMismatchWarning" style="margin-top: 0.75rem;"></div>
      </div>
      
      <div id="comparisonGrid" class="nutrient-grid"></div>
    </div>
    
    <!-- Tab: Historical Field Trends -->
    <div id="history" class="tab-content active">
      <div class="controls-bar">
        <div class="control-group">
          <label>Select Field</label>
          <select id="historyFieldSelect"><option value="">Select a field...</option></select>
        </div>
        <button onclick="exportFieldTrends()" class="export-btn">üìÑ Export Report</button>
      </div>
      <div id="historyContent"></div>
    </div>

    <!-- Tab 3: Field Rankings -->
    <div id="rankings" class="tab-content">
      <div class="controls-bar">
        <div class="control-group">
          <label>Nutrient</label>
          <select id="rankingAttrSelect"></select>
        </div>
        <div class="control-group">
          <label>Year</label>
          <select id="rankingYearSelect"></select>
        </div>
        <button onclick="exportFieldRankings()" class="export-btn">üìÑ Export Report</button>
      </div>
      <div id="rankingsContent"></div>
    </div>

    <!-- Tab 4: Yield Correlation -->
    <div id="yield" class="tab-content">
      <div class="controls-bar">
        <div class="control-group">
          <label>Crop</label>
          <select id="yieldCropSelect">
            <option value="corn">üåΩ Corn</option>
            <option value="soybeans">ü´ò Soybeans</option>
            <option value="amylose">üçö Amylose</option>
          </select>
        </div>
        <div class="control-group">
          <label>Yield Year <span onclick="toggleYieldYearInfo()" style="cursor: pointer; font-size: 0.9rem; color: #3b82f6;" title="Learn about yield year options">‚ÑπÔ∏è</span></label>
          <select id="yieldYearSelect" onchange="updateYieldYearDescription()"></select>
        </div>
        <div class="control-group">
          <label>Soil Sample Year</label>
          <select id="soilYearSelect">
            <option value="recent">Most Recent</option>
          </select>
        </div>
        <div class="control-group">
          <label>Field</label>
          <select id="yieldFieldSelect">
            <option value="all">All Fields</option>
          </select>
        </div>
        <div class="control-group" style="display: flex; align-items: center; gap: 0.5rem;">
          <input type="checkbox" id="yieldNormalizeToggle" style="width: 18px; height: 18px; cursor: pointer;" title="Convert yield to % of field average to isolate nutrient effect from field productivity">
          <label style="margin: 0; white-space: nowrap;">Normalize by Field</label>
          <span onclick="toggleNormalizeInfo()" style="cursor: pointer; font-size: 1rem; color: #3b82f6; margin-left: -0.25rem;" title="Learn about normalization">‚ÑπÔ∏è</span>
        </div>
        <button onclick="exportYieldCorrelation()" class="export-btn">üìÑ Export Report</button>
      </div>

      <!-- Yield Year Description (shows based on selection) -->
      <div id="yieldYearDescription" style="display: none; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 0.5rem; padding: 0.75rem 1rem; margin-bottom: 0.75rem; font-size: 0.8rem;">
        <div id="yieldYearDescText" style="color: #475569;"></div>
        <div id="yieldYearWarning" style="display: none; margin-top: 0.5rem; padding: 0.5rem; background: #fef3c7; border: 1px solid #f59e0b; border-radius: 0.375rem; color: #92400e;">
          <strong>‚ö†Ô∏è Warning:</strong> <span id="yieldYearWarningText"></span>
        </div>
        <div id="yieldYearAverages" style="display: none; margin-top: 0.5rem; padding: 0.5rem; background: #eff6ff; border-radius: 0.375rem; color: #1e40af; font-size: 0.75rem;"></div>
      </div>

      <!-- Yield Year explanation (hidden by default) -->
      <div id="yieldYearInfoBox" style="display: none; background: linear-gradient(to right, #f0fdf4, #ecfdf5); border: 1px solid #22c55e; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem; font-size: 0.85rem; color: #166534;">
        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 0.75rem;">
          <strong style="font-size: 1rem;">üìÖ Understanding Yield Year Options</strong>
          <span onclick="toggleYieldYearInfo()" style="cursor: pointer; color: #64748b; font-size: 1.2rem;">&times;</span>
        </div>

        <div style="display: grid; gap: 0.75rem;">
          <div style="background: white; border-radius: 0.375rem; padding: 0.75rem; border-left: 4px solid #3b82f6;">
            <div style="font-weight: 600; color: #1e40af; margin-bottom: 0.25rem;">All Years (Averaged)</div>
            <p style="font-size: 0.8rem; color: #475569; margin: 0;">
              Averages yield across all years at each location. A sample with 180 bu in 2024 and 220 bu in 2025 becomes 200 bu.<br>
              <strong>Best for:</strong> Finding patterns that persist across years. Smooths out weather variation.
            </p>
          </div>

          <div style="background: white; border-radius: 0.375rem; padding: 0.75rem; border-left: 4px solid #8b5cf6;">
            <div style="font-weight: 600; color: #6d28d9; margin-bottom: 0.25rem;">All Years (Combined)</div>
            <p style="font-size: 0.8rem; color: #475569; margin: 0;">
              Each year treated as separate data point. Same location counted multiple times (once per year).<br>
              <strong>Best for:</strong> Maximum sample size when years had similar growing conditions.<br>
              <span style="color: #b45309;">‚ö†Ô∏è Combines good and bad years together - results may be misleading if yields varied significantly.</span>
            </p>
          </div>

          <div style="background: white; border-radius: 0.375rem; padding: 0.75rem; border-left: 4px solid #22c55e;">
            <div style="font-weight: 600; color: #166534; margin-bottom: 0.25rem;">All Years (Year-Normalized)</div>
            <p style="font-size: 0.8rem; color: #475569; margin: 0;">
              Each year treated separately, but yields converted to % of that year's average.<br>
              <em>Example: 200 bu yield in a 180 bu avg year = 111%. 250 bu yield in a 250 bu avg year = 100%.</em><br>
              <strong>Best for:</strong> Comparing across years with different weather. Isolates nutrient effect from seasonal variation.
            </p>
          </div>

          <div style="background: white; border-radius: 0.375rem; padding: 0.75rem; border-left: 4px solid #f59e0b;">
            <div style="font-weight: 600; color: #b45309; margin-bottom: 0.25rem;">Individual Year (e.g., "2024")</div>
            <p style="font-size: 0.8rem; color: #475569; margin: 0;">
              Only uses yield from that specific harvest year.<br>
              <strong>Best for:</strong> Analyzing a specific season's results.
            </p>
          </div>
        </div>

        <div style="margin-top: 1rem; padding: 0.75rem; background: white; border-radius: 0.375rem; border: 1px dashed #22c55e;">
          <div style="font-weight: 600; color: #166534; margin-bottom: 0.5rem;">ü§î How should I choose?</div>
          <ul style="font-size: 0.8rem; color: #475569; margin: 0; padding-left: 1.25rem;">
            <li><strong>Similar yields across years?</strong> ‚Üí "Combined" gives you more data points</li>
            <li><strong>Very different yields (drought vs good year)?</strong> ‚Üí "Year-Normalized" controls for weather</li>
            <li><strong>Want simplicity?</strong> ‚Üí "Averaged" is most straightforward</li>
            <li><strong>Analyzing specific season?</strong> ‚Üí Select individual year</li>
          </ul>
        </div>
      </div>

      <!-- Normalization explanation (hidden by default) -->
      <div id="normalizeInfoBox" style="display: none; background: linear-gradient(to right, #eff6ff, #f0f9ff); border: 1px solid #3b82f6; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem; font-size: 0.85rem; color: #1e40af;">
        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 0.75rem;">
          <strong style="font-size: 1rem;">üìä Understanding Field Normalization</strong>
          <span onclick="toggleNormalizeInfo()" style="cursor: pointer; color: #64748b; font-size: 1.2rem;">&times;</span>
        </div>

        <p style="margin-bottom: 0.75rem;"><strong>Why do correlations change when normalized?</strong></p>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
          <div style="background: white; border-radius: 0.375rem; padding: 0.75rem;">
            <div style="font-weight: 600; color: #dc2626; margin-bottom: 0.5rem;">WITHOUT normalization:</div>
            <p style="font-size: 0.8rem; color: #475569;">Correlations include differences between fields. A high-yielding field with high P will inflate the P-yield correlation, even if P isn't the reason that field yields well (could be better soil type, drainage, etc.)</p>
          </div>
          <div style="background: white; border-radius: 0.375rem; padding: 0.75rem;">
            <div style="font-weight: 600; color: #16a34a; margin-bottom: 0.5rem;">WITH normalization:</div>
            <p style="font-size: 0.8rem; color: #475569;">Yields are converted to "% of field average", removing field-to-field differences. This isolates the nutrient effect by asking: "Within each field, do higher nutrient levels produce above-average yields?"</p>
          </div>
        </div>

        <div style="background: #fef3c7; border-radius: 0.375rem; padding: 0.75rem; margin-bottom: 0.75rem;">
          <div style="font-weight: 600; color: #92400e; margin-bottom: 0.5rem;">Why correlations often decrease:</div>
          <p style="font-size: 0.8rem; color: #78350f;">Some of the original correlation was driven by field productivity differences, not the nutrient itself. The normalized correlation is stricter but more trustworthy for fertilizer decisions.</p>
        </div>

        <div style="background: white; border-radius: 0.375rem; padding: 0.75rem; margin-bottom: 0.75rem;">
          <div style="font-weight: 600; color: #1e40af; margin-bottom: 0.5rem;">Example:</div>
          <ul style="font-size: 0.8rem; color: #475569; margin: 0; padding-left: 1.25rem;">
            <li>Raw correlation: P = <strong>+0.35</strong> (includes field effects)</li>
            <li>Normalized: P = <strong>+0.18</strong> (nutrient effect only)</li>
            <li>The 0.18 is more reliable for predicting if adding P will help within a field.</li>
          </ul>
        </div>

        <div style="background: #dcfce7; border-radius: 0.375rem; padding: 0.75rem;">
          <div style="font-weight: 600; color: #166534;">üí° Recommendation:</div>
          <p style="font-size: 0.8rem; color: #166534; margin: 0;">Use <strong>normalized correlations</strong> when deciding on variable-rate fertilizer applications within fields. Use <strong>raw correlations</strong> when comparing overall field performance.</p>
        </div>
      </div>

      <!-- Sub-tabs for Yield Correlation -->
      <div class="yield-subtabs" style="display: flex; gap: 0.5rem; margin-bottom: 1rem; border-bottom: 2px solid #e2e8f0; padding-bottom: 0.5rem;">
        <button class="yield-subtab active" data-subtab="single" onclick="switchYieldSubtab('single')" style="padding: 0.5rem 1rem; border: none; background: #3b82f6; color: white; border-radius: 0.375rem 0.375rem 0 0; font-weight: 500; cursor: pointer;">
          üìä Individual Correlations
        </button>
        <button class="yield-subtab" data-subtab="multi" onclick="switchYieldSubtab('multi')" style="padding: 0.5rem 1rem; border: none; background: #f1f5f9; color: #64748b; border-radius: 0.375rem 0.375rem 0 0; font-weight: 500; cursor: pointer;">
          üî¨ Multivariate Regression
        </button>
        <button class="yield-subtab" data-subtab="buckets" onclick="switchYieldSubtab('buckets')" style="padding: 0.5rem 1rem; border: none; background: #f1f5f9; color: #64748b; border-radius: 0.375rem 0.375rem 0 0; font-weight: 500; cursor: pointer;">
          üìà Yield by Nutrient Level
        </button>
      </div>

      <!-- Single Nutrient Tab Content -->
      <div id="yieldSingleTab" class="yield-subtab-content">
        <div style="background: #f0fdf4; border: 1px solid #86efac; border-radius: 0.375rem; padding: 0.75rem; margin-bottom: 1rem; font-size: 0.8rem; color: #166534;">
          <strong>Individual Correlations:</strong> Analyzes each nutrient separately. Shows how each nutrient relates to yield independently - useful for exploring individual relationships.
        </div>
        <div id="yieldContent">
        <div class="no-data">No yield data available. Import yield maps on the Import page to see correlations.</div>
      </div>

      <!-- Scatter Plot Section -->
      <div id="scatterSection" style="margin-top: 1.5rem; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 0.5rem; padding: 1rem;">
        <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem; margin-bottom: 1rem;">
          <div style="display: flex; align-items: center; gap: 1rem;">
            <h3 id="scatterTitle" style="margin: 0; color: #1e293b;">Scatter Plot: Nutrient vs Yield</h3>
            <button onclick="toggleScatterAxes()" id="swapAxesBtn" style="padding: 0.375rem 0.75rem; border-radius: 0.375rem; border: 1px solid #3b82f6; background: #eff6ff; color: #1d4ed8; font-size: 0.8rem; cursor: pointer; display: flex; align-items: center; gap: 0.25rem;">
              <span style="font-size: 1rem;">‚áÑ</span> Swap Axes
            </button>
          </div>
          <div style="display: flex; gap: 1rem; align-items: center; flex-wrap: wrap;">
            <div>
              <label style="margin-right: 0.5rem;">Nutrient:</label>
              <select id="scatterNutrientSelect" onchange="drawScatterPlot()" style="padding: 0.375rem 0.75rem; border-radius: 0.375rem; border: 1px solid #cbd5e1;"></select>
            </div>
            <div style="display: flex; align-items: center; gap: 0.5rem;">
              <label>Yield Threshold:</label>
              <input type="range" id="yieldThresholdSlider" min="100" max="400" value="200" step="10" onchange="updateThresholdDisplay(); drawScatterPlot();" style="width: 120px;">
              <input type="number" id="yieldThresholdInput" value="200" min="50" max="500" step="5" onchange="syncThresholdSlider(); drawScatterPlot();" style="width: 70px; padding: 0.25rem; border-radius: 0.25rem; border: 1px solid #cbd5e1;">
              <span style="color: #64748b;">bu/ac</span>
            </div>
          </div>
        </div>
        <!-- Outlier Filter -->
        <div style="margin-bottom: 0.75rem; display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;">
          <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; padding: 0.375rem 0.75rem; background: #fef2f2; border: 1px solid #fca5a5; border-radius: 0.375rem;">
            <input type="checkbox" id="hideOutliersCheckbox" checked onchange="drawScatterPlot();" style="width: 16px; height: 16px;">
            <span style="font-size: 0.85rem; color: #991b1b; font-weight: 500;">Hide outliers</span>
          </label>
          <span id="outlierFilterInfo" style="font-size: 0.8rem; color: #dc2626;"></span>
        </div>
        <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
          <div style="flex: 1; min-width: 600px;">
            <canvas id="scatterCanvas" width="900" height="500" style="background: white; border: 1px solid #e2e8f0; border-radius: 0.375rem; width: 100%; height: auto;"></canvas>
          </div>
          <div id="thresholdAnalysis" style="min-width: 280px; background: white; border: 1px solid #e2e8f0; border-radius: 0.375rem; padding: 1rem;">
            <h4 style="margin: 0 0 0.75rem 0; color: #1e293b; font-size: 0.95rem;">Threshold Analysis</h4>
            <div id="thresholdContent" style="font-size: 0.85rem; color: #475569;"></div>
          </div>
        </div>
        <div id="scatterStats" style="margin-top: 0.75rem; font-size: 0.875rem; color: #64748b;"></div>

        <!-- Data Verification Button -->
        <div style="margin-top: 1rem; text-align: center;">
          <button onclick="toggleYieldDebug()" class="export-btn" style="background: #f1f5f9; color: #475569; border: 1px solid #cbd5e1;">üîç Data Verification Check</button>
        </div>
      </div>

      <!-- Debug Panel (hidden by default) -->
      <div id="yieldDebugPanel" style="display: none; margin-top: 1rem; background: #fffbeb; border: 2px solid #f59e0b; border-radius: 0.5rem; padding: 1rem;">
        <h4 style="margin: 0 0 1rem 0; color: #92400e;">Data Verification Report</h4>
        <div id="yieldDebugContent" style="font-family: monospace; font-size: 0.75rem; white-space: pre-wrap; color: #78350f; max-height: 500px; overflow-y: auto;"></div>
      </div>
      </div><!-- End yieldSingleTab -->

      <!-- Multivariate Model Tab Content -->
      <div id="yieldMultiTab" class="yield-subtab-content" style="display: none;">
        <div style="background: #eff6ff; border: 1px solid #93c5fd; border-radius: 0.375rem; padding: 0.75rem; margin-bottom: 1rem; font-size: 0.8rem; color: #1e40af;">
          <strong>Multivariate Regression:</strong> Analyzes all nutrients together. Shows which nutrients significantly affect yield <em>after controlling for the others</em> - answers "What matters when everything is considered?"
        </div>

        <!-- Variable Selection -->
        <div style="background: white; border: 1px solid #e2e8f0; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
            <h4 style="margin: 0; color: #1e293b; font-size: 0.95rem;">üìã Select Variables for Model</h4>
            <div>
              <button onclick="selectAllMultiVars()" style="padding: 0.25rem 0.5rem; font-size: 0.75rem; border: 1px solid #cbd5e1; border-radius: 0.25rem; background: white; cursor: pointer; margin-right: 0.25rem;">Select All</button>
              <button onclick="selectCoreMultiVars()" style="padding: 0.25rem 0.5rem; font-size: 0.75rem; border: 1px solid #cbd5e1; border-radius: 0.25rem; background: white; cursor: pointer;">Core Only</button>
            </div>
          </div>
          <div id="multiVarCheckboxes" style="display: flex; flex-wrap: wrap; gap: 0.5rem;"></div>
          <div id="multiVarWarning" style="margin-top: 0.75rem; font-size: 0.8rem; color: #92400e;"></div>
        </div>

        <!-- Run Model Button -->
        <div style="margin-bottom: 1rem;">
          <button onclick="runMultivariateRegression()" style="padding: 0.75rem 1.5rem; background: #3b82f6; color: white; border: none; border-radius: 0.375rem; font-weight: 600; cursor: pointer; font-size: 0.95rem;">
            üî¨ Run Multivariate Regression
          </button>
        </div>

        <!-- Model Results -->
        <div id="multiModelResults" style="display: none;">
          <!-- Model Summary -->
          <div id="multiModelSummary" style="background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%); border: 2px solid #22c55e; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem;">
            <h4 style="margin: 0 0 0.75rem 0; color: #166534;">üìä Model Summary</h4>
            <div id="multiSummaryContent" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem;"></div>
          </div>

          <!-- Interpretation / Key Findings - BEFORE the table -->
          <div id="multiInterpretation" style="margin-bottom: 1rem;"></div>

          <!-- Collinearity Warning -->
          <div id="multiCollinearityWarning" style="display: none; background: #fef3c7; border: 1px solid #f59e0b; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem;">
            <h4 style="margin: 0 0 0.5rem 0; color: #92400e; font-size: 0.9rem;">‚ö†Ô∏è Collinearity Warning</h4>
            <p style="margin: 0 0 0.5rem 0; font-size: 0.8rem; color: #78350f;">Some variables are highly correlated with each other, which can make coefficient estimates unreliable.</p>
            <div id="collinearityDetails" style="font-size: 0.8rem; color: #78350f;"></div>
          </div>

          <!-- Coefficients Table - AFTER interpretation -->
          <div id="multiCoeffTableContainer" style="background: white; border: 1px solid #e2e8f0; border-radius: 0.5rem; overflow: hidden; margin-bottom: 1rem;">
            <div style="background: #f8fafc; padding: 0.75rem 1rem; border-bottom: 1px solid #e2e8f0;">
              <h4 style="margin: 0; color: #1e293b; font-size: 0.95rem;">üìà Regression Coefficients</h4>
              <p style="margin: 0.25rem 0 0 0; font-size: 0.75rem; color: #64748b;">Each coefficient shows the nutrient's effect on yield while holding other nutrients constant</p>
            </div>
            <div style="overflow-x: auto;">
              <table id="multiCoeffTable" style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
                <thead>
                  <tr style="background: #f1f5f9;">
                    <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e2e8f0;">Variable</th>
                    <th style="padding: 0.75rem; text-align: right; border-bottom: 2px solid #e2e8f0;">Coefficient</th>
                    <th style="padding: 0.75rem; text-align: right; border-bottom: 2px solid #e2e8f0;">Std Error</th>
                    <th style="padding: 0.75rem; text-align: right; border-bottom: 2px solid #e2e8f0;">t-value</th>
                    <th style="padding: 0.75rem; text-align: right; border-bottom: 2px solid #e2e8f0;">p-value</th>
                    <th style="padding: 0.75rem; text-align: center; border-bottom: 2px solid #e2e8f0;">Sig.</th>
                  </tr>
                </thead>
                <tbody id="multiCoeffBody"></tbody>
              </table>
            </div>
            <div style="padding: 0.5rem 1rem; background: #f8fafc; font-size: 0.75rem; color: #64748b;">
              Significance: *** p < 0.001, ** p < 0.01, * p < 0.05, . p < 0.1
            </div>
          </div>

          <!-- Yield Predictor -->
          <div style="background: linear-gradient(135deg, #faf5ff 0%, #f3e8ff 100%); border: 2px solid #a855f7; border-radius: 0.5rem; padding: 1rem;">
            <h4 style="margin: 0 0 0.75rem 0; color: #7c3aed; font-size: 0.95rem;">üéØ Yield Predictor</h4>
            <p style="margin: 0 0 0.75rem 0; font-size: 0.8rem; color: #6b21a8;">Enter nutrient values to predict yield based on the model.</p>
            <div id="predictorInputs" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 0.75rem; margin-bottom: 0.75rem;"></div>
            <button onclick="predictYield()" style="padding: 0.5rem 1rem; background: #a855f7; color: white; border: none; border-radius: 0.375rem; cursor: pointer; font-weight: 500;">
              Predict Yield
            </button>
            <div id="predictionResult" style="margin-top: 0.75rem; padding: 0.75rem; background: white; border-radius: 0.375rem; display: none;"></div>
          </div>
        </div>
      </div><!-- End yieldMultiTab -->

      <!-- Yield by Nutrient Level Tab Content -->
      <div id="yieldBucketsTab" class="yield-subtab-content" style="display: none;">
        <div style="background: #fef3c7; border: 1px solid #fcd34d; border-radius: 0.375rem; padding: 0.75rem; margin-bottom: 1rem; font-size: 0.8rem; color: #92400e;">
          <strong>Yield by Nutrient Level:</strong> Groups soil samples into Low, Medium, and High categories for each nutrient, then shows the average yield for each group. Helps identify which nutrient levels are associated with the best yields.
        </div>

        <!-- Filters -->
        <div class="controls-bar" style="margin-bottom: 1rem;">
          <div class="control-group">
            <label>Field</label>
            <select id="bucketFieldSelect" onchange="updateYieldBucketAnalysis()"></select>
          </div>
          <div class="control-group">
            <label>Yield Year</label>
            <select id="bucketYieldYearSelect" onchange="updateYieldBucketAnalysis()"></select>
          </div>
          <div class="control-group">
            <label>Crop</label>
            <select id="bucketCropSelect" onchange="updateYieldBucketAnalysis()">
              <option value="all">All Crops</option>
              <option value="corn">Corn</option>
              <option value="soybeans">Soybeans</option>
            </select>
          </div>
        </div>

        <div id="yieldBucketsContent">
          <div class="no-data">Loading yield bucket analysis...</div>
        </div>
      </div><!-- End yieldBucketsTab -->
    </div>

    <!-- Tab: Spatial Change Analysis -->
    <div id="spatial" class="tab-content">
      <div class="controls-bar">
        <div class="control-group">
          <label>Field</label>
          <select id="spatialFieldSelect"></select>
        </div>
        <div class="control-group">
          <label>Nutrient</label>
          <select id="spatialNutrientSelect"></select>
        </div>
        <div class="control-group">
          <label>Base Year</label>
          <select id="spatialBaseYearSelect"></select>
        </div>
        <div class="control-group">
          <label>Compare To</label>
          <select id="spatialCompareYearSelect"></select>
        </div>
        <div class="control-group">
          <label>Match Radius</label>
          <select id="spatialRadiusSelect">
            <option value="50">50 ft</option>
            <option value="100" selected>100 ft (default)</option>
            <option value="150">150 ft</option>
            <option value="200">200 ft</option>
          </select>
        </div>
        <button onclick="exportSpatialAnalysis()" class="export-btn">üìÑ Export Report</button>
      </div>
      <div id="spatialContent">
        <div class="no-data">Select a field and nutrient to analyze spatial changes over time.</div>
      </div>
    </div>

    <!-- Tab: In-Season Analysis -->
    <div id="inseason" class="tab-content">
      <!-- Sub-tabs for different in-season analysis types -->
      <div class="sap-subtabs">
        <button class="sap-subtab active" data-subtab="sap" onclick="switchInSeasonSubtab('sap')">üß™ Sap Analysis</button>
        <button class="sap-subtab" data-subtab="tissue" onclick="switchInSeasonSubtab('tissue')" disabled title="Coming soon">üåø Tissue</button>
        <button class="sap-subtab" data-subtab="water" onclick="switchInSeasonSubtab('water')" disabled title="Coming soon">üíß Water</button>
        <button class="sap-subtab" data-subtab="inseasonsoil" onclick="switchInSeasonSubtab('inseasonsoil')" disabled title="Coming soon">üå± In-Season Soil</button>
      </div>

      <!-- Sap Analysis Content -->
      <div id="sapSubtab" class="sap-subtab-content active">
        <div class="sap-controls">
          <div class="control-group">
            <label>Sample Site</label>
            <select id="sapSiteSelect">
              <option value="">Select a site...</option>
            </select>
          </div>
          <div class="control-group">
            <label>Sample Date</label>
            <select id="sapDateSelect">
              <option value="">Select a date...</option>
            </select>
          </div>
        </div>

        <div id="sapViewerContent">
          <div class="sap-empty-state">
            <div style="font-size: 3rem; margin-bottom: 1rem;">üß™</div>
            <h3>Loading Sap Analysis Data...</h3>
            <p>Please wait while we load your data.</p>
          </div>
        </div>
      </div>

      <!-- Tissue Analysis Content (placeholder) -->
      <div id="tissueSubtab" class="sap-subtab-content">
        <div class="sap-empty-state">
          <div style="font-size: 3rem; margin-bottom: 1rem;">üåø</div>
          <h3>Tissue Analysis Coming Soon</h3>
          <p>This feature is under development.</p>
        </div>
      </div>

      <!-- Water Analysis Content (placeholder) -->
      <div id="waterSubtab" class="sap-subtab-content">
        <div class="sap-empty-state">
          <div style="font-size: 3rem; margin-bottom: 1rem;">üíß</div>
          <h3>Water Analysis Coming Soon</h3>
          <p>This feature is under development.</p>
        </div>
      </div>

      <!-- In-Season Soil Content (placeholder) -->
      <div id="inseasonsoilSubtab" class="sap-subtab-content">
        <div class="sap-empty-state">
          <div style="font-size: 3rem; margin-bottom: 1rem;">üå±</div>
          <h3>In-Season Soil Analysis Coming Soon</h3>
          <p>This feature is under development.</p>
        </div>
      </div>
    </div>
  </div>

  <div id="statusMessage"></div>

  <script src="https://apis.google.com/js/api.js"></script>
  <script src="https://accounts.google.com/gsi/client"></script>
  <script src="js/core/data.js"></script>
  <script src="js/core/utils.js"></script>
  <script src="js/sap/rulesets/v1.js"></script>
  <script src="js/sap/logic.js"></script>
  <script src="js/sap/viewer.js"></script>
  <script>
    // ========== APP VERSION ==========
    const APP_VERSION = "v1.0.189";
    const BUILD_DATE = "2026-01-26T16:35:07";

    // Reference shared data config with analysis-specific additions
    const CONFIG = {
      get CLIENT_ID() { return DataCore.config.CLIENT_ID; },
      get API_KEY() { return DataCore.config.API_KEY; },
      get SHEET_ID() { return DataCore.config.SHEET_ID; },

      NUTRIENTS: ['pH', 'CEC', 'OM', 'P', 'K', 'P_Zn_Ratio', 'Zn', 'K_Sat', 'Ca_sat', 'Mg_sat', 'H_Sat', 'S', 'Mn', 'Cu', 'Boron', 'Fe', 'Buffer_pH', 'P2', 'Na_Sat', 'Na', 'Ca', 'Mg', 'NO3', 'NH4', 'Soluble_Salts', 'EC'],

      NUTRIENT_NAMES: {
        pH: 'pH', P_Zn_Ratio: 'P:Zn Ratio', P: 'Phosphorus (P)', P2: 'Phosphorus P2', K: 'Potassium (K)', OM: 'Organic Matter',
        CEC: 'CEC', Ca_sat: 'Calcium Sat %', Mg_sat: 'Magnesium Sat %',
        K_Sat: 'K Base Sat %', H_Sat: 'H Base Sat %', Na_Sat: 'Na Base Sat %', Zn: 'Zinc', Cu: 'Copper',
        Mn: 'Manganese', Fe: 'Iron', Boron: 'Boron', S: 'Sulfur', Buffer_pH: 'Buffer pH',
        Na: 'Sodium', Ca: 'Calcium', Mg: 'Magnesium', NO3: 'Nitrate', NH4: 'Ammonium', Soluble_Salts: 'Soluble Salts', EC: 'EC'
      },

      NUTRIENT_UNITS: {
        pH: '', P_Zn_Ratio: '', P: 'ppm', P2: 'ppm', K: 'ppm', OM: '%', CEC: 'meq/100g',
        Ca_sat: '%', Mg_sat: '%', K_Sat: '%', H_Sat: '%', Na_Sat: '%',
        Zn: 'ppm', Cu: 'ppm', Mn: 'ppm', Fe: 'ppm', Boron: 'ppm', S: 'ppm', Buffer_pH: '',
        Na: 'ppm', Ca: 'ppm', Mg: 'ppm', NO3: 'ppm', NH4: 'ppm', Soluble_Salts: 'mmhos/cm', EC: 'dS/m'
      },

      LOWER_IS_BETTER: ['Mg_sat', 'H_Sat', 'Na_Sat', 'Soluble_Salts'],

      // Default visibility for nutrients (used if no settings saved)
      DEFAULT_VISIBLE: ['pH', 'P_Zn_Ratio', 'P', 'K', 'OM', 'CEC', 'Ca_sat', 'Mg_sat', 'K_Sat', 'H_Sat', 'Zn', 'Cu', 'Mn', 'Fe', 'Boron', 'S', 'Buffer_pH'],

      // Default decimal places for each attribute
      DECIMAL_PLACES: {
        pH: 2, Buffer_pH: 2, OM: 2, P: 0, P2: 0, K: 0, CEC: 1,
        Ca_sat: 1, Mg_sat: 1, K_Sat: 1, H_Sat: 1, Na_Sat: 1,
        Zn: 2, Cu: 2, Mn: 1, Fe: 1, Boron: 2, S: 1,
        Ca: 0, Mg: 0, Na: 0, NO3: 1, NH4: 1, Soluble_Salts: 2, EC: 2,
        P_Zn_Ratio: 1
      }
    };

    // Use shared getDecimals and formatValue from Utils
    function getDecimals(attr) {
      return window.Utils.getDecimals(attr, CONFIG.DECIMAL_PLACES);
    }
    function formatValue(value, attr) {
      return window.Utils.formatValue(value, attr, CONFIG.DECIMAL_PLACES);
    }

    // Get visible nutrients based on settings
    function getVisibleNutrients() {
      const saved = JSON.parse(localStorage.getItem('nutrientVisibility') || '{}');
      return CONFIG.NUTRIENTS.filter(n => {
        if (saved[n] !== undefined) return saved[n];
        return CONFIG.DEFAULT_VISIBLE.includes(n);
      });
    }

    let sampleData = [];
    let yieldData = []; // Raw yield points (for getting available yield years)
    let year1 = null, year2 = null;
    let selectedComparisonFields = new Set(); // Track which fields are included in comparison

    // Yield correlation table state
    let yieldCorrelationsData = [];
    let yieldSortColumn = 'r'; // Default sort by correlation
    let yieldSortDirection = 'desc'; // desc = highest first

    // ========== CLIENT/FARM DATA ==========
    let clientsData = [];
    let farmsData = [];
    let fieldBoundaries = {};
    let activeClientId = 'all';
    let activeFarmId = 'all';

    // Use shared functions from DataCore
    function loadClientsData() {
      clientsData = DataCore.loadClientsData();
      return clientsData;
    }

    function loadFarmsData() {
      farmsData = DataCore.loadFarmsData();
      return farmsData;
    }

    function loadFieldBoundaries() {
      fieldBoundaries = DataCore.loadFieldBoundaries();
      return fieldBoundaries;
    }

    function loadActiveSelection() {
      const selection = DataCore.loadActiveSelection();
      activeClientId = selection.clientId;
      activeFarmId = selection.farmId;
    }

    function getActiveFields() {
      return DataCore.getActiveFields(fieldBoundaries, farmsData, activeClientId, activeFarmId);
    }

    // Update active operation indicator
    function updateActiveOperationIndicator() {
      const indicator = document.getElementById('activeOperationIndicator');
      if (!indicator) return;

      if (activeClientId === 'all') {
        indicator.style.display = 'none';
        return;
      }

      const client = clientsData.find(c => c.id === activeClientId);
      let text = client?.name || 'Unknown Client';

      if (activeFarmId !== 'all') {
        const farm = farmsData.find(f => f.id === activeFarmId);
        text += ` > ${farm?.name || 'Unknown Farm'}`;
      }

      indicator.innerHTML = `<span style="margin-right: 0.5rem;">üë§</span>${text} <a href="settings.html" style="color: #3b82f6; margin-left: 0.5rem;">[change]</a>`;
      indicator.style.display = 'block';
    }

    // Use shared SheetsAPI from DataCore
    const SheetsAPI = DataCore.SheetsAPI;

    document.addEventListener('DOMContentLoaded', async () => {
      // Run migration first to ensure data structures are up to date
      DataCore.migrateDataIfNeeded();
      loadClientsData();
      loadFarmsData();
      loadFieldBoundaries();
      loadActiveSelection();

      try { await SheetsAPI.init(); SheetsAPI.onSignInChange = handleSignInChange; handleSignInChange(SheetsAPI.isSignedIn); } catch (e) {}
      await loadLocalData();
      setupTabs();
      setupEventListeners();
      updateBackupFooter();
      updateActiveOperationIndicator();
    });

    async function handleAuth() { if (SheetsAPI.isSignedIn) await SheetsAPI.signOut(); else await SheetsAPI.signIn(); }
    
    function handleSignInChange(isSignedIn) {
      const authBtn = document.getElementById('authBtn'), userInfo = document.getElementById('userInfo');
      if (isSignedIn) { userInfo.textContent = 'Connected'; authBtn.textContent = '‚úì Signed In'; authBtn.classList.add('signed-in'); }
      else { userInfo.textContent = ''; authBtn.textContent = 'Sign In to Edit'; authBtn.classList.remove('signed-in'); }
    }

    // IndexedDB - use shared openDB from DataCore
    const openDB = DataCore.openDB;

    async function loadFromIndexedDB() {
      try {
        const db = await openDB();
        // Check which stores exist
        const storeNames = Array.from(db.objectStoreNames);
        const hasYield = storeNames.includes('yield');
        const hasBoundaries = storeNames.includes('boundaries');
        const stores = ['samples'];
        if (hasBoundaries) stores.push('boundaries');
        if (hasYield) stores.push('yield');
        const tx = db.transaction(stores, 'readonly');

        const samplesData = await new Promise((resolve, reject) => {
          const req = tx.objectStore('samples').get('all');
          req.onsuccess = () => resolve(req.result?.data || []);
          req.onerror = reject;
        });

        let boundariesData = {};
        if (hasBoundaries) {
          boundariesData = await new Promise((resolve, reject) => {
            const req = tx.objectStore('boundaries').get('all');
            req.onsuccess = () => resolve(req.result?.data || {});
            req.onerror = reject;
          });
        }

        let yieldDataResult = [];
        if (hasYield) {
          yieldDataResult = await new Promise((resolve, reject) => {
            const req = tx.objectStore('yield').get('all');
            req.onsuccess = () => resolve(req.result?.data || []);
            req.onerror = reject;
          });
        }

        db.close();
        return { samples: samplesData, boundaries: boundariesData, yield: yieldDataResult };
      } catch (e) { return null; }
    }

    async function loadLocalData() {
      try {
        // Check IndexedDB first if flagged
        if (localStorage.getItem('usingIndexedDB') === 'true') {
          const idbData = await loadFromIndexedDB();
          if (idbData) {
            // Load samples, boundaries, and yield independently
            if (idbData.samples && idbData.samples.length > 0) {
              sampleData = idbData.samples;
            }
            if (idbData.boundaries && Object.keys(idbData.boundaries).length > 0) {
              fieldBoundaries = idbData.boundaries;
            }
            if (idbData.yield && idbData.yield.length > 0) {
              yieldData = idbData.yield;
            }
            console.log('Loaded from IndexedDB:', sampleData.length, 'samples,', Object.keys(fieldBoundaries).length, 'fields,', yieldData.length, 'yield points');
          }
        } else {
          const saved = localStorage.getItem('soilSamples');
          const yieldSaved = localStorage.getItem('yieldData');
          const boundariesSaved = localStorage.getItem('fieldBoundaries');
          if (saved) sampleData = JSON.parse(saved);
          if (yieldSaved) yieldData = JSON.parse(yieldSaved);
          if (boundariesSaved) fieldBoundaries = JSON.parse(boundariesSaved);
          console.log('Loaded from localStorage:', sampleData.length, 'samples,', Object.keys(fieldBoundaries).length, 'fields,', yieldData.length, 'yield points');
        }
      } catch (e) { console.error(e); }
      // Calculate P_Zn_Ratio on-the-fly for samples that have P and Zn
      sampleData.forEach(s => {
        if (s.P !== undefined && s.Zn !== undefined && s.Zn > 0) {
          s.P_Zn_Ratio = s.P / s.Zn;
        }
      });
      populateSelectors();
      updateComparison();
      updateHistory('__all__');  // Default to All Fields view
      updateRankings();
      updateYieldAnalysis();
    }

    function populateSelectors() {
      // Filter by active client/farm
      const activeFields = getActiveFields();
      const filteredSamples = sampleData.filter(s => activeFields.includes(s.field));

      const years = [...new Set(filteredSamples.map(s => s.year).filter(y => y))].sort((a, b) => b - a);
      const fields = [...new Set(filteredSamples.map(s => s.field).filter(f => f && f !== 'Unknown'))].sort();
      
      // Year comparison selectors - year1 is earlier (FROM), year2 is later (TO)
      const year1Sel = document.getElementById('year1Select');
      const year2Sel = document.getElementById('year2Select');
      year1Sel.innerHTML = ''; year2Sel.innerHTML = '';
      years.forEach((y, i) => {
        year1Sel.innerHTML += `<option value="${y}" ${i === 1 ? 'selected' : ''}>${y}</option>`;
        year2Sel.innerHTML += `<option value="${y}" ${i === 0 ? 'selected' : ''}>${y}</option>`;
      });
      year1 = years[1] || years[0] || null;  // Earlier year (second most recent)
      year2 = years[0] || null;               // Later year (most recent)
      
      // History field selector - default to All Fields (Operation Average)
      const historyFieldSel = document.getElementById('historyFieldSelect');
      historyFieldSel.innerHTML = '<option value="__all__" style="font-weight: bold;">üìä All Fields (Operation Average)</option>';
      fields.forEach(f => { historyFieldSel.innerHTML += `<option value="${f}">${f}</option>`; });
      historyFieldSel.value = '__all__';
      
      // Rankings selectors
      const rankAttrSel = document.getElementById('rankingAttrSelect');
      rankAttrSel.innerHTML = '';
      const visibleNutrients = getVisibleNutrients();
      visibleNutrients.forEach(n => { rankAttrSel.innerHTML += `<option value="${n}">${CONFIG.NUTRIENT_NAMES[n] || n}</option>`; });
      
      const rankYearSel = document.getElementById('rankingYearSelect');
      rankYearSel.innerHTML = '<option value="most_recent" selected>Most Recent</option>';
      years.forEach(y => { rankYearSel.innerHTML += `<option value="${y}">${y}</option>`; });
      
      // Yield year selector - filtered by selected crop
      updateYieldYearSelector();

      // Soil sample year selector
      const soilYearSel = document.getElementById('soilYearSelect');
      const soilYears = getSoilYearsWithYield();
      soilYearSel.innerHTML = '<option value="recent">Most Recent (default)</option><option value="all">All Years</option>';
      soilYears.forEach(y => { soilYearSel.innerHTML += `<option value="${y}">${y}</option>`; });

      // Yield field selector - will be populated by updateYieldFieldSelector based on selected crop
      updateYieldFieldSelector();

      // Spatial Change Analysis selectors
      const spatialFieldSel = document.getElementById('spatialFieldSelect');
      spatialFieldSel.innerHTML = '<option value="__all__">All Fields (Operation-Wide)</option>';
      fields.forEach(f => { spatialFieldSel.innerHTML += `<option value="${f}">${f}</option>`; });

      // Default to All Fields (Operation-Wide)
      spatialFieldSel.value = '__all__';

      const spatialNutrientSel = document.getElementById('spatialNutrientSelect');
      spatialNutrientSel.innerHTML = '';
      visibleNutrients.forEach(n => { spatialNutrientSel.innerHTML += `<option value="${n}">${CONFIG.NUTRIENT_NAMES[n] || n}</option>`; });

      // Initialize year selectors with All Fields selection
      updateSpatialYearSelectors('__all__');
    }

    function updateSpatialYearSelectors(field) {
      // Filter by active client/farm first
      const activeFieldsList = getActiveFields();
      const filteredSamples = sampleData.filter(s => activeFieldsList.includes(s.field));

      // Get years that have data for the selected field (or all fields if __all__)
      const fieldYears = [...new Set(
        filteredSamples
          .filter(s => (field === '__all__' || s.field === field) && s.year)
          .map(s => s.year)
      )].sort((a, b) => a - b); // Sort ascending (oldest first for base year)

      const spatialBaseYearSel = document.getElementById('spatialBaseYearSelect');
      const spatialCompareYearSel = document.getElementById('spatialCompareYearSelect');

      if (fieldYears.length === 0) {
        spatialBaseYearSel.innerHTML = '<option value="">No data for field</option>';
        spatialCompareYearSel.innerHTML = '<option value="">No data for field</option>';
        return;
      }

      // Base year dropdown - "Earliest Available" as default, then specific years
      spatialBaseYearSel.innerHTML = '<option value="earliest">Earliest Available (per field)</option>';
      fieldYears.forEach(y => { spatialBaseYearSel.innerHTML += `<option value="${y}">${y}</option>`; });

      // Compare year dropdown - includes "All Years" option (default), newest first (descending)
      const descendingYears = [...fieldYears].sort((a, b) => b - a);
      spatialCompareYearSel.innerHTML = '<option value="all">All Years</option>';
      descendingYears.forEach(y => { spatialCompareYearSel.innerHTML += `<option value="${y}">${y}</option>`; });
    }

    function updateYieldFieldSelector() {
      // Get selected crop and filter fields to only those with yield data for that crop
      const cropFilter = document.getElementById('yieldCropSelect').value;
      const yieldFieldSel = document.getElementById('yieldFieldSelect');
      const currentValue = yieldFieldSel.value;

      // Find fields that have yield data for the selected crop
      const fieldsWithYield = [...new Set(
        sampleData
          .filter(s => s.yieldCorrelations && Object.keys(s.yieldCorrelations).length > 0)
          .filter(s => {
            // Check if any yield correlation matches the crop filter
            return Object.values(s.yieldCorrelations).some(yieldInfo => yieldInfo.crop === cropFilter);
          })
          .map(s => s.field)
          .filter(f => f && f !== 'Unknown')
      )].sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));

      yieldFieldSel.innerHTML = '<option value="all">All Fields</option>';
      fieldsWithYield.forEach(f => { yieldFieldSel.innerHTML += `<option value="${f}">${f}</option>`; });

      // Try to restore previous selection if still valid
      if (currentValue && (currentValue === 'all' || fieldsWithYield.includes(currentValue))) {
        yieldFieldSel.value = currentValue;
      }
    }

    function getSoilYearsWithYield() {
      // Get soil sample years that have yield correlations
      const years = new Set();
      sampleData.forEach(s => {
        if (s.yieldCorrelations && Object.keys(s.yieldCorrelations).length > 0 && s.year) {
          years.add(s.year);
        }
      });
      return [...years].sort((a, b) => b - a);
    }
    
    function getYieldYears(cropFilter = null) {
      const yearCounts = {};  // Matched samples with yield correlations
      const rawYearCounts = {}; // Raw yield points by year (may not be matched)

      // Count matched yield correlations on soil samples - filter by crop if specified
      sampleData.forEach(s => {
        if (s.yieldCorrelations) {
          Object.entries(s.yieldCorrelations).forEach(([y, yieldInfo]) => {
            // Only count if crop matches (or no filter)
            if (!cropFilter || yieldInfo.crop === cropFilter) {
              const year = parseInt(y);
              yearCounts[year] = (yearCounts[year] || 0) + 1;
            }
          });
        }
      });

      // Also check raw yieldData for unmatched years - filter by crop if specified
      if (yieldData && yieldData.length > 0) {
        yieldData.forEach(y => {
          if (y.year && (!cropFilter || y.crop === cropFilter)) {
            rawYearCounts[y.year] = (rawYearCounts[y.year] || 0) + 1;
          }
        });
      }

      // Debug logging
      console.log('=== YIELD YEARS DEBUG ===');
      console.log('Crop filter:', cropFilter);
      console.log('Years in yieldCorrelations (matched):', yearCounts);
      console.log('Years in raw yieldData:', rawYearCounts);

      // Merge: include years from both matched and raw data
      const allYears = new Set([...Object.keys(yearCounts), ...Object.keys(rawYearCounts)]);
      return Array.from(allYears)
        .map(y => parseInt(y))
        .sort((a, b) => b - a) // Sort newest first
        .map(year => ({
          year,
          count: yearCounts[year] || 0,
          rawCount: rawYearCounts[year] || 0
        }));
    }

    function updateYieldYearSelector() {
      const cropFilter = document.getElementById('yieldCropSelect').value;
      const yieldYearSel = document.getElementById('yieldYearSelect');
      const yieldYears = getYieldYears(cropFilter);

      yieldYearSel.innerHTML = `<option value="avg">All Years (Averaged)</option>`;
      yieldYearSel.innerHTML += `<option value="combined">All Years (Combined)</option>`;
      yieldYearSel.innerHTML += `<option value="normalized">All Years (Year-Normalized)</option>`;

      yieldYears.forEach(y => {
        if (y.count > 0) {
          yieldYearSel.innerHTML += `<option value="${y.year}">${y.year} (${y.count.toLocaleString()} samples)</option>`;
        } else if (y.rawCount > 0) {
          yieldYearSel.innerHTML += `<option value="${y.year}" disabled>${y.year} - ${y.rawCount.toLocaleString()} yield pts (not matched)</option>`;
        }
      });

      updateYieldYearDescription();
    }

    let sapViewerInitialized = false;

    function setupTabs() {
      document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', () => {
          document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
          tab.classList.add('active');
          document.getElementById(tab.dataset.tab).classList.add('active');

          // Auto-run analysis when switching to spatial tab
          if (tab.dataset.tab === 'spatial') {
            updateSpatialAnalysis();
          }

          // Initialize sap viewer when switching to in-season tab
          if (tab.dataset.tab === 'inseason' && !sapViewerInitialized) {
            sapViewerInitialized = true;
            if (window.SapViewer) {
              SapViewer.init();
            }
          }
        });
      });
    }

    // Switch in-season subtabs
    function switchInSeasonSubtab(subtab) {
      document.querySelectorAll('.sap-subtab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.sap-subtab-content').forEach(c => c.classList.remove('active'));

      document.querySelector(`.sap-subtab[data-subtab="${subtab}"]`).classList.add('active');
      document.getElementById(`${subtab}Subtab`).classList.add('active');
    }

    function setupEventListeners() {
      document.getElementById('year1Select').addEventListener('change', (e) => { year1 = e.target.value; selectedComparisonFields.clear(); updateComparison(); });
      document.getElementById('year2Select').addEventListener('change', (e) => { year2 = e.target.value; selectedComparisonFields.clear(); updateComparison(); });
      document.getElementById('historyFieldSelect').addEventListener('change', (e) => { updateHistory(e.target.value); });
      document.getElementById('rankingAttrSelect').addEventListener('change', updateRankings);
      document.getElementById('rankingYearSelect').addEventListener('change', updateRankings);
      document.getElementById('yieldCropSelect').addEventListener('change', () => {
        updateYieldYearSelector();  // Update year dropdown to show only years with data for selected crop
        updateYieldFieldSelector();
        updateYieldAnalysis();
        resetMultiModel();
      });
      document.getElementById('yieldYearSelect').addEventListener('change', () => {
        updateYieldAnalysis();
        resetMultiModel();
      });
      document.getElementById('soilYearSelect').addEventListener('change', () => {
        updateYieldAnalysis();
        resetMultiModel();
      });
      document.getElementById('yieldFieldSelect').addEventListener('change', () => {
        updateYieldAnalysis();
        resetMultiModel();
      });
      document.getElementById('yieldNormalizeToggle').addEventListener('change', () => {
        updateYieldAnalysis();
        resetMultiModel();
      });
      // Spatial Change Analysis listeners
      document.getElementById('spatialFieldSelect').addEventListener('change', (e) => {
        updateSpatialYearSelectors(e.target.value);
        updateSpatialAnalysis();
      });
      document.getElementById('spatialNutrientSelect').addEventListener('change', updateSpatialAnalysis);
      document.getElementById('spatialBaseYearSelect').addEventListener('change', updateSpatialAnalysis);
      document.getElementById('spatialCompareYearSelect').addEventListener('change', updateSpatialAnalysis);
      document.getElementById('spatialRadiusSelect').addEventListener('change', updateSpatialAnalysis);
    }

    function getStats(samples, attr) {
      // Filter to only valid numeric values - exclude undefined, null, empty strings, and NaN
      const values = samples.map(s => s[attr])
        .filter(v => v !== undefined && v !== null && v !== '' && !isNaN(parseFloat(v)))
        .map(v => parseFloat(v));
      if (values.length === 0) return null;
      const sorted = [...values].sort((a, b) => a - b);
      const mid = Math.floor(sorted.length / 2);
      const median = sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
      return {
        avg: values.reduce((a, b) => a + b, 0) / values.length,
        median: median,
        high: Math.max(...values),
        low: Math.min(...values),
        count: values.length
      };
    }
    
    function updateYearStatsBox(container, year, samples) {
      if (!year || samples.length === 0) {
        container.innerHTML = '<p style="color: #94a3b8; font-style: italic;">No data</p>';
        return;
      }

      // Get unique fields
      const fields = [...new Set(samples.map(s => s.field).filter(f => f && f !== 'Unknown'))].sort();

      let html = `
        <div style="display: flex; gap: 1.5rem; flex-wrap: wrap; align-items: center;">
          <div>
            <div style="font-size: 1.5rem; font-weight: 700; color: #1e293b;">${year}</div>
            <div style="font-size: 0.875rem; color: #64748b;">${samples.length} samples across ${fields.length} fields</div>
          </div>
        </div>
      `;

      container.innerHTML = html;
    }
    
    window.toggleComparisonField = function(field) {
      if (selectedComparisonFields.has(field)) {
        selectedComparisonFields.delete(field);
      } else {
        selectedComparisonFields.add(field);
      }
      updateComparison();
    };
    
    window.selectMatchingComparisonFields = function() {
      const allSamplesFrom = year1 ? sampleData.filter(s => String(s.year) === String(year1)) : [];
      const allSamplesTo = sampleData.filter(s => String(s.year) === String(year2));
      const excludeFields = ['Unknown', 'Unassigned', 'unknown', 'unassigned', null, undefined, ''];
      const fieldsFrom = new Set(allSamplesFrom.map(s => s.field).filter(f => f && !excludeFields.includes(f)));
      const fieldsTo = new Set(allSamplesTo.map(s => s.field).filter(f => f && !excludeFields.includes(f)));
      const allFields = [...new Set([...fieldsFrom, ...fieldsTo])];
      // Clear first, then only select fields that have data in both years (matching fields)
      selectedComparisonFields.clear();
      allFields.forEach(f => {
        if (fieldsFrom.has(f) && fieldsTo.has(f)) {
          selectedComparisonFields.add(f);
        }
      });
      updateComparison();
    };

    window.selectAllComparisonFields = function() {
      const allSamplesFrom = year1 ? sampleData.filter(s => String(s.year) === String(year1)) : [];
      const allSamplesTo = sampleData.filter(s => String(s.year) === String(year2));
      const excludeFields = ['Unknown', 'Unassigned', 'unknown', 'unassigned', null, undefined, ''];
      const fieldsFrom = new Set(allSamplesFrom.map(s => s.field).filter(f => f && !excludeFields.includes(f)));
      const fieldsTo = new Set(allSamplesTo.map(s => s.field).filter(f => f && !excludeFields.includes(f)));
      const allFields = [...new Set([...fieldsFrom, ...fieldsTo])];
      // Select all fields from both years
      selectedComparisonFields.clear();
      allFields.forEach(f => selectedComparisonFields.add(f));
      updateComparison();
    };

    // ========== 5-TRIGGER FRAMEWORK ==========
    // Unified insight system: LOW_STABLE, LOW_VOLATILE, HIGH_STABLE, HIGH_VOLATILE, FLAT

    // --- PART 1: Stability Definitions ---
    function getStabilityFromCV(cv) {
      if (cv < 20) return 'Stable';
      if (cv <= 30) return 'Moderate';
      return 'Volatile';
    }

    function getStabilityFromSD(sd) {  // For pH only (logarithmic scale)
      if (sd < 0.20) return 'Stable';
      if (sd <= 0.35) return 'Moderate';
      return 'Volatile';
    }

    function getStabilityFromOMCV(cv) {  // For OM - stricter thresholds due to sensitivity
      if (cv < 10) return 'Stable';
      if (cv <= 20) return 'Moderate';
      return 'Volatile';
    }

    // --- Nutrient-Specific CV Explanations ---
    // Returns { title, explanation, drivers, suggestion } for high-variability warnings
    function getNutrientCVExplanation(nutrient, cvValue) {
      const cv = cvValue ? cvValue.toFixed(0) : '?';

      // Micronutrients: Zn, B, Cu, Fe, Mn
      const micronutrients = ['Zn', 'B', 'Cu', 'Fe', 'Mn', 'Boron'];
      if (micronutrients.includes(nutrient)) {
        const isFeMn = ['Fe', 'Mn'].includes(nutrient);
        return {
          title: `High variability detected (CV = ${cv}%)`,
          explanation: isFeMn
            ? `${nutrient} tests are sensitive to soil moisture and redox conditions at sampling. Wet vs dry sampling can cause large swings.`
            : `This micronutrient commonly shows high variability due to low concentrations, strong pH effects, and localized soil chemistry. Small absolute differences can produce large CV values.`,
          drivers: isFeMn
            ? ['Soil moisture at sampling', 'Redox conditions', 'pH zone differences', 'Organic matter distribution']
            : ['pH changes between zones', 'Organic matter differences', 'Manure or banded fertilizer history', 'Lab extraction sensitivity'],
          suggestion: isFeMn
            ? `Use ${nutrient} trends as contextual indicators, not standalone decision drivers.`
            : 'High CV is common for this nutrient. Interpret trends cautiously and confirm with consistent sampling or tissue tests.'
        };
      }

      // Phosphorus
      if (nutrient === 'P') {
        return {
          title: `High variability detected (CV = ${cv}%)`,
          explanation: 'High variability in P is often linked to placement history (banded fertilizer or manure) and sampling path differences.',
          drivers: ['Banded P vs broadcast', 'Manure application patterns', 'Sampling depth inconsistency', 'Soil pH effects on availability'],
          suggestion: 'If P has been banded or manure-applied, consider zone or grid sampling to better capture true distribution.'
        };
      }

      // Potassium
      if (nutrient === 'K') {
        return {
          title: `High variability detected (CV = ${cv}%)`,
          explanation: 'Potassium variability often reflects soil texture differences and moisture conditions at sampling.',
          drivers: ['Clay vs sand zones', 'Soil moisture at sampling', 'Cation exchange differences', 'Crop removal patterns'],
          suggestion: 'Resample at similar moisture conditions and consider texture-based zones.'
        };
      }

      // pH - uses SD not CV, but include for completeness
      if (nutrient === 'pH') {
        return {
          title: `High variability detected (SD = ${cvValue ? cvValue.toFixed(2) : '?'})`,
          explanation: 'pH is typically stable across a field. High variability often indicates real spatial differences rather than noise.',
          drivers: ['Past lime application patterns', 'Soil type boundaries', 'Topography and erosion', 'Variable rate lime history'],
          suggestion: 'High pH variability is a strong signal for zone-based management.'
        };
      }

      // Organic Matter
      if (nutrient === 'OM') {
        return {
          title: `High variability detected (CV = ${cv}%)`,
          explanation: 'Organic matter normally changes slowly. High variability usually reflects soil type, erosion, or sampling depth differences.',
          drivers: ['Topsoil depth differences', 'Erosion and deposition zones', 'Sampling depth inconsistency', 'Different lab methods between years'],
          suggestion: 'Manage OM by landscape position rather than uniform field averages. Keep sampling depth and lab consistent.'
        };
      }

      // CEC
      if (nutrient === 'CEC') {
        return {
          title: `High variability detected (CV = ${cv}%)`,
          explanation: 'CEC reflects soil texture and organic matter. High variability often indicates real soil type differences across the field.',
          drivers: ['Soil texture changes', 'Organic matter differences', 'Erosion patterns', 'Sampling depth variation'],
          suggestion: 'CEC variability often mirrors soil type boundaries. Consider texture-based management zones.'
        };
      }

      // Base Saturations (Ca_sat, Mg_sat, K_sat, H_sat)
      if (['Ca_sat', 'Mg_sat', 'K_sat', 'H_sat'].includes(nutrient)) {
        return {
          title: `High variability detected (CV = ${cv}%)`,
          explanation: 'Base saturation variability usually reflects CEC differences and liming history across the field.',
          drivers: ['Soil texture zones', 'Variable lime applications', 'CEC differences', 'pH management history'],
          suggestion: 'Consider whether CEC varies similarly. Zone-based management may be warranted.'
        };
      }

      // Sulfur
      if (nutrient === 'S') {
        return {
          title: `High variability detected (CV = ${cv}%)`,
          explanation: 'Sulfur is mobile in soil and can vary significantly with drainage, organic matter, and recent rainfall.',
          drivers: ['Drainage patterns', 'Organic matter distribution', 'Recent rainfall/leaching', 'Atmospheric deposition patterns'],
          suggestion: 'Sulfur tests are best interpreted alongside organic matter and drainage conditions.'
        };
      }

      // P:Zn Ratio
      if (nutrient === 'P_Zn_Ratio') {
        return {
          title: `High variability detected (CV = ${cv}%)`,
          explanation: 'P:Zn ratio variability often amplifies the variability of both P and Zn measurements.',
          drivers: ['P placement history', 'Zn micronutrient variability', 'pH zone differences', 'Combined measurement noise'],
          suggestion: 'Review P and Zn trends individually. If both are stable, ratio variability may be less concerning.'
        };
      }

      // Default fallback for any other nutrient
      return {
        title: `High variability detected (CV = ${cv}%)`,
        explanation: 'Field averages are inconsistent across samples. When variability is high, trends may reflect sampling or spatial effects rather than true nutrient change.',
        drivers: ['Sampling path changed between years', 'Inconsistent sampling depth', 'Different soil moisture at sampling', 'Lab or test method changes'],
        suggestion: 'When variability is high, confirm trends with consistent sampling methodology before making major adjustments.'
      };
    }

    // --- PART 2: Flat Thresholds (slope thresholds for "no real change") ---
    const FLAT_THRESHOLDS = {
      pH: 0.03,     // units/yr (tightened: 0.05 implies 0.5 pH in 10 years)
      P: 1.0,       // ppm/yr
      K: 5.0,       // ppm/yr
      OM: 0.05,     // %/yr (tightened: 0.1 is too aggressive, labels working management as flat)
      Zn: 0.1,      // ppm/yr
      S: 1.0,       // ppm/yr
      B: 0.05,      // ppm/yr
      Cu: 0.1,      // ppm/yr
      Fe: 2.0,      // ppm/yr
      Mn: 2.0,      // ppm/yr
      Ca_sat: 1.0,  // %/yr
      Mg_sat: 0.5,  // %/yr
      K_sat: 0.2,   // %/yr
      H_sat: 1.0,   // %/yr
      CEC: 0.5,     // meq/100g/yr
      P_Zn_Ratio: 1.0,   // ratio units/yr
    };

    function getTrendDirection(slope, nutrient) {
      const flat = FLAT_THRESHOLDS[nutrient] || 1.0;
      if (slope > flat) return 'Up';
      if (slope < -flat) return 'Down';
      return 'Flat';
    }

    // --- PART 3: 5-Trigger Picker ---
    function pickTrigger(level, stability, trendDir) {
      // Flat overrides everything
      if (trendDir === 'Flat') return 'FLAT';

      const isVolatile = stability === 'Volatile';

      if (level === 'Low' && !isVolatile) return 'LOW_STABLE';
      if (level === 'Low' && isVolatile) return 'LOW_VOLATILE';
      if (level === 'High' && !isVolatile) return 'HIGH_STABLE';
      return 'HIGH_VOLATILE';
    }

    // --- PART 4: Settings-Based Thresholds ---
    function getNutrientThresholds(nutrient) {
      // Load from Settings (localStorage)
      const savedSettings = localStorage.getItem('nutrientSettings');
      const settings = savedSettings ? JSON.parse(savedSettings) : {};
      const s = settings[nutrient] || {};

      // Defaults if not set in Settings
      const defaults = {
        pH:     { critical: 5.5, optimalMin: 6.3, optimalMax: 7.0 },
        P:      { critical: 15, optimalMin: 25, optimalMax: 50 },
        K:      { critical: 120, optimalMin: 150, optimalMax: 250 },
        OM:     { critical: 2.0, optimalMin: 3.0, optimalMax: 5.0 },
        Zn:     { critical: 0.5, optimalMin: 1.0, optimalMax: 3.0 },
        S:      { critical: 8, optimalMin: 12, optimalMax: 30 },
        B:      { critical: 0.3, optimalMin: 0.5, optimalMax: 2.0 },
        Cu:     { critical: 0.3, optimalMin: 0.5, optimalMax: 2.0 },
        Fe:     { critical: 5, optimalMin: 10, optimalMax: 50 },
        Mn:     { critical: 5, optimalMin: 10, optimalMax: 50 },
        Ca_sat: { critical: 55, optimalMin: 65, optimalMax: 75 },
        Mg_sat: { critical: 8, optimalMin: 10, optimalMax: 15 },
        K_sat:  { critical: 2.0, optimalMin: 3.0, optimalMax: 5.0 },
        H_sat:  { critical: 15, optimalMin: 0, optimalMax: 10 },
        CEC:    { critical: 5, optimalMin: 10, optimalMax: 30 },
      };

      const def = defaults[nutrient] || { critical: 0, optimalMin: 0, optimalMax: 100 };

      return {
        critical: s.critical ?? s.min ?? def.critical,
        optimalMin: s.optimalMin ?? s.min ?? def.optimalMin,
        optimalMax: s.optimalMax ?? s.max ?? def.optimalMax,
      };
    }

    function getPHThresholds() {
      const base = getNutrientThresholds('pH');
      return {
        veryLow: base.critical,
        low: base.optimalMin,
        optimalMin: base.optimalMin,
        optimalMax: base.optimalMax,
        high: base.optimalMax,
        veryHigh: base.optimalMax + 0.8,
      };
    }

    function getZnThresholds() {
      const base = getNutrientThresholds('Zn');
      return {
        low: base.critical,
        marginal: base.optimalMin,
        adequate: base.optimalMin,
      };
    }

    function getPThresholds() {
      const base = getNutrientThresholds('P');
      return {
        critical: base.critical,
        belowOpt: base.optimalMin,
        optHigh: base.optimalMax,
      };
    }

    function getRatioThresholds() {
      return { normal: 12, highRisk: 20 };
    }

    // --- PART 5: pH Flags ---
    function getPHFlags(pH, calcareous = false) {
      const thresh = getPHThresholds();

      const flags = {
        veryLow: pH < thresh.veryLow,
        low: pH < thresh.low,
        inOptimal: pH >= thresh.optimalMin && pH <= thresh.optimalMax,
        high: pH > thresh.high,
        veryHigh: pH >= thresh.veryHigh || calcareous,
        thresholds: thresh,
        warnings: [],
      };

      if (flags.veryLow) {
        flags.warnings.push(`Very low pH (below ${thresh.veryLow}) can restrict roots (Al toxicity risk) and reduce P efficiency.`);
      }
      if (flags.veryHigh) {
        flags.warnings.push(`Very high pH (above ${thresh.veryHigh.toFixed(1)}) reduces Zn availability even when soil Zn is moderate.`);
      }

      return flags;
    }

    // --- PART 6: Confidence Scoring ---
    function getConfidence(years, stability) {
      if (years >= 4 && stability === 'Stable') return 'High';
      if (years >= 4 && stability === 'Moderate') return 'Medium';
      if (years === 3) return 'Medium';
      return 'Low';
    }

    // --- PART 7: Dynamic Zn Target ---
    // Guardrail: Cap at 5.0 ppm to prevent unrealistic targets (e.g., P=75 ‚Üí Zn target 7.5 is too aggressive)
    function getDynamicZnTarget(P_ppm) {
      const baseMin = getNutrientThresholds('Zn').optimalMin;
      const ratioTarget = P_ppm / 10;
      const dynamicTarget = Math.max(baseMin, ratioTarget);
      return Math.min(dynamicTarget, 5.0); // Cap at 5.0 ppm max
    }

    function getZnStatus(Zn_ppm, P_ppm) {
      const target = getDynamicZnTarget(P_ppm);
      const thresh = getZnThresholds();

      if (Zn_ppm < thresh.low) return 'Low';
      if (Zn_ppm < target) return 'Marginal';
      return 'Adequate';
    }

    // --- PART 7b: Interaction Notes System ---
    // Collects interaction-based notes for Fe/Mn/B and stacked risk scenarios
    // These are returned as interactionNotes[] on cards - shown only when relevant
    function collectInteractionNotes(x) {
      const notes = [];

      // Get pH thresholds from settings
      const phThresh = getPHThresholds();
      const pH_high = x.pH > phThresh.optimalMax;
      const pH_very_high = x.pH >= (phThresh.optimalMax + 0.8) || !!x.calcareous;
      const pH_very_low = x.pH < phThresh.veryLow;

      const P_high = x.P_ppm > getNutrientThresholds('P').optimalMax;

      const znThresh = getZnThresholds();
      const Zn_low = x.Zn_ppm < znThresh.low;
      const Zn_marg = x.Zn_ppm >= znThresh.low && x.Zn_ppm <= znThresh.marginal;

      const ratioThresh = getRatioThresholds();
      const ratio_elev = x.PZn_ratio > ratioThresh.normal;
      const ratio_high = x.PZn_ratio > ratioThresh.highRisk;

      // ---- High pH: micronutrient availability cluster (Zn/Fe/Mn) ----
      if (pH_high && !notes.some(n => n.code === 'PH_HIGH_MICRO_AVAIL')) {
        notes.push({
          code: 'PH_HIGH_MICRO_AVAIL',
          severity: pH_very_high ? 3 : 2,
          message: 'High pH increases risk of micronutrient limitation (Zn/Fe/Mn availability). Confirm with tissue/scouting; placement often matters more than rate.'
        });
      }

      // ---- Very low pH: root restriction + P efficiency + Mn toxicity risk ----
      if (pH_very_low) {
        notes.push({
          code: 'PH_VERY_LOW_ROOT_P',
          severity: 3,
          message: 'Very low pH can restrict roots (Al toxicity risk) and reduce P efficiency (strong fixation). Mn toxicity risk may increase in wet areas.'
        });
      }

      // ---- P:Zn ratio + Zn status ----
      if (ratio_high && (Zn_low || Zn_marg)) {
        notes.push({
          code: 'RATIO_HIGH_ZN_LOW',
          severity: 3,
          message: 'High P:Zn ratio with low/marginal Zn = high Zn limitation risk (especially corn). Prioritize starter/banded Zn; use foliar only as rescue when confirmed.'
        });
      } else if (ratio_high && !(Zn_low || Zn_marg)) {
        notes.push({
          code: 'RATIO_HIGH_ZN_OK',
          severity: 2,
          message: 'High P:Zn ratio can still signal Zn uptake risk even if soil Zn is adequate‚Äîespecially under high pH. Monitor/tissue test before adding Zn.'
        });
      } else if (ratio_elev && (Zn_low || Zn_marg)) {
        notes.push({
          code: 'RATIO_ELEV_ZN_LOW',
          severity: 2,
          message: 'Elevated P:Zn ratio plus low/marginal Zn increases early-season Zn risk. Placement and verification recommended.'
        });
      }

      // ---- High P + elevated ratio guardrail ----
      if (P_high && ratio_elev) {
        notes.push({
          code: 'P_HIGH_RATIO_GUARD',
          severity: ratio_high ? 2 : 1,
          message: 'P is above optimal and P:Zn is elevated‚Äîavoid additional P inputs; focus on Zn access/placement if risk is present.'
        });
      }

      // ---- Fe (availability warning: pH-driven) ----
      if (pH_high) {
        notes.push({
          code: 'FE_CHLOROSIS_RISK',
          severity: pH_very_high ? 3 : 2,
          message: 'High pH/calcareous zones increase iron chlorosis risk (availability-limited). Soil Fe tests may not predict plant response.'
        });
      }
      if (typeof x.Fe_ppm === 'number' && x.Fe_ppm < 10 && pH_high) {
        notes.push({
          code: 'FE_LOW_SUPPORT',
          severity: 2,
          message: 'Low soil Fe + high pH increases confidence of Fe limitation risk in high pH zones. Confirm with tissue/symptoms.'
        });
      }

      // ---- Mn (deficiency at high pH, toxicity at very low pH) ----
      if (pH_high && !notes.some(n => n.code === 'MN_DEF_RISK')) {
        notes.push({
          code: 'MN_DEF_RISK',
          severity: pH_very_high ? 2 : 1,
          message: 'High pH increases Mn deficiency risk; can co-occur with Zn/Fe issues.'
        });
      }
      if (pH_very_low) {
        notes.push({
          code: 'MN_TOX_RISK',
          severity: 3,
          message: 'Very low pH increases risk of Mn toxicity, especially in wet/poorly drained zones.'
        });
      }
      if (typeof x.Mn_ppm === 'number' && x.Mn_ppm < 10 && pH_high) {
        notes.push({
          code: 'MN_LOW_SUPPORT',
          severity: 2,
          message: 'Low soil Mn + high pH increases confidence of Mn deficiency risk. Confirm before applying.'
        });
      }

      // ---- Boron: narrow window + Zn guardrail ----
      if (typeof x.B_ppm === 'number') {
        if (x.B_ppm < 0.5) {
          notes.push({
            code: 'B_LOW',
            severity: 2,
            message: 'Soil B is low. Boron has a narrow safe range‚Äîconfirm with tissue/symptoms before correcting.'
          });
        }
        if (x.B_ppm > 2.0) {
          notes.push({
            code: 'B_HIGH_TOX',
            severity: 3,
            message: 'Soil B is high‚Äîboron toxicity risk. Avoid additional B inputs.'
          });
        }
        if ((Zn_low || Zn_marg) && x.B_ppm >= 1.0) {
          notes.push({
            code: 'ZN_LOW_B_GUARD',
            severity: 2,
            message: 'When Zn is low/marginal, plants can be more sensitive to B‚Äîavoid applying B unless tissue confirms deficiency.'
          });
        }
      }

      // ---- Stacked interaction: High pH + elevated ratio + low Zn ----
      if ((ratio_elev || ratio_high) && (Zn_low || Zn_marg) && (pH_high || pH_very_high)) {
        notes.push({
          code: 'STACKED_MICRO_RISK',
          severity: 3,
          message: 'Stacked interaction: High pH + elevated ratio + low Zn strongly increases micronutrient limitation risk. Prioritize starter/banded Zn in high-risk zones.'
        });
      }

      // ---- Dynamic Zn target guardrail (risk overlay, not deficiency reclass) ----
      const dynamicZnTarget = getDynamicZnTarget(x.P_ppm || 30);
      if (x.Zn_ppm < dynamicZnTarget && x.P_ppm > 25 && !Zn_low) {
        notes.push({
          code: 'ZN_DYNAMIC_TARGET_OVERLAY',
          severity: 1,
          message: `Relative to P level, Zn is below balance target (${dynamicZnTarget.toFixed(1)} ppm). Focus on placement + confirmation rather than building to this target.`
        });
      }

      // De-duplicate by code
      const seen = new Set();
      return notes.filter(n => (seen.has(n.code) ? false : (seen.add(n.code), true)));
    }

    // --- PART 8: Build pH Card ---
    function buildPHCard(inputs) {
      const { pH, pH_sd, pH_slope, calcareous, years } = inputs;

      const thresh = getPHThresholds();
      const stab = getStabilityFromSD(pH_sd || 0.25);
      const tdir = getTrendDirection(pH_slope || 0, 'pH');
      const flags = getPHFlags(pH, calcareous);
      const conf = getConfidence(years || 1, stab);

      let level;
      if (pH < thresh.optimalMin) level = 'Low';
      else if (pH > thresh.optimalMax) level = 'High';
      else level = 'Optimal';

      const trig = level === 'Optimal' ? 'OPTIMAL' : pickTrigger(level, stab, tdir);

      let badge = '‚úì On Track';
      let background = 'green';
      let insight = '‚úì Soil pH is in a favorable range.';
      let tips = [];
      let warnings = [...flags.warnings];

      if (level === 'Optimal') {
        if (stab === 'Volatile') {
          badge = '‚ö†Ô∏è Watch'; background = 'yellow';
          insight = '‚ö†Ô∏è pH is in range but variable across the field. Consider zone management.';
          tips = ['Zone-sample and consider variable-rate lime if correcting.', 'Confirm consistent sampling depth and timing.'];
        } else if (tdir === 'Down' && pH < thresh.optimalMin + 0.3) {
          badge = '‚ö†Ô∏è Watch'; background = 'yellow';
          insight = '‚ö†Ô∏è pH is in range but trending down toward the lower limit.';
          tips = ['Plan lime application before pH drops below optimal.'];
        } else {
          badge = '‚úì On Track'; background = 'green';
          insight = '‚úì pH is in the target range. Maintain current management.';
        }
      } else if (level === 'Low') {
        if (trig === 'LOW_STABLE') {
          badge = 'üî¥ Action Needed'; background = 'red';
          insight = 'üî¥ Soil pH is consistently low. Nutrient efficiency and root performance are limited.';
          tips = ['Apply lime to move pH toward target range.', 'If P is low, band P and correct acidity for best response.', 'Prioritize the lowest pH zones first if variability exists.'];
        } else if (trig === 'LOW_VOLATILE') {
          badge = '‚ö†Ô∏è Watch'; background = 'yellow';
          insight = '‚ö†Ô∏è pH is low but highly variable. Uniform correction may be inefficient.';
          tips = ['Zone/grid sample before liming.', 'Consider variable-rate lime to avoid over-liming higher pH zones.'];
        } else if (trig === 'FLAT') {
          badge = '‚ö†Ô∏è Watch'; background = 'orange';
          insight = '‚ö†Ô∏è pH is low and holding steady. Plan gradual correction.';
          tips = ['Plan lime application.', 'Recheck pH after correction window.'];
        }
      } else if (level === 'High') {
        if (trig === 'HIGH_STABLE') {
          badge = '‚ö†Ô∏è Watch'; background = 'orange';
          insight = 'üü† Soil pH is consistently high. Micronutrient availability (Zn, Fe, Mn) can be limited.';
          tips = ['Use starter/banded micronutrients (especially Zn) when risk is confirmed.', 'Use tissue tests to confirm availability issues.', 'Maintain/build organic matter to support micronutrient cycling.'];
        } else if (trig === 'HIGH_VOLATILE') {
          badge = '‚ö†Ô∏è Watch'; background = 'yellow';
          insight = '‚ö†Ô∏è pH is high and variable. Manage risk by zones.';
          tips = ['Zone manage micronutrient risk; avoid blanket applications.', 'Target the highest pH areas first.'];
        } else if (trig === 'FLAT') {
          badge = '‚ö†Ô∏è Watch'; background = 'neutral';
          insight = '‚ö†Ô∏è pH is high and holding steady. Focus on micronutrient management.';
          tips = ['Monitor Zn/Fe/Mn with tissue tests.', 'Use placement strategies for Zn in high-risk crops (corn).'];
        }
      }

      if (tdir === 'Up' && level !== 'Low') warnings.push('pH is trending upward.');
      if (tdir === 'Down' && level !== 'High') warnings.push('pH is trending downward.');

      return { key: 'pH', badge, background, insight, tips, warnings, show: { pH, stability: stab, trend: tdir, confidence: conf, optimalRange: `${thresh.optimalMin} - ${thresh.optimalMax}` } };
    }

    // --- PART 9: Build P Card ---
    function buildPCard(inputs) {
      const { P_ppm, P_cv, P_slope, pH, Zn_ppm, PZn_ratio, years } = inputs;

      const thresh = getPThresholds();
      const stab = getStabilityFromCV(P_cv || 20);
      const tdir = getTrendDirection(P_slope || 0, 'P');
      const flags = getPHFlags(pH || 6.5);
      const conf = getConfidence(years || 1, stab);

      const P_critical = P_ppm < thresh.critical;
      const P_below = P_ppm >= thresh.critical && P_ppm < thresh.belowOpt;
      const P_opt = P_ppm >= thresh.belowOpt && P_ppm <= thresh.optHigh;
      const P_above = P_ppm > thresh.optHigh;

      const level = (P_critical || P_below) ? 'Low' : (P_above ? 'High' : 'Optimal');
      const trig = level === 'Optimal' ? 'OPTIMAL' : pickTrigger(level, stab, tdir);

      let badge = '‚úì On Track';
      let background = 'green';
      let insight = '‚úÖ Phosphorus is sufficient.';
      let tips = [];
      let warnings = [];

      if (P_critical) {
        badge = 'üî¥ Action Needed'; background = 'red';
        insight = 'üî¥ Phosphorus is critically low. Yield potential is likely limited.';
        tips = ['Apply P (banding is most efficient on low-P soils).', 'If pH is low, correct acidity to improve P efficiency.', 'If Zn is low/marginal or P:Zn ratio is elevated, include Zn in starter/band.'];
        warnings.push(...flags.warnings);
      } else if (P_below) {
        if (trig === 'LOW_STABLE' || (tdir === 'Down' && stab !== 'Volatile')) {
          badge = 'üî¥ Action Needed'; background = 'pink';
          insight = 'üî¥ P is below optimal and declining reliably. Action recommended.';
          tips = ['Apply P at build rates (above removal) until target range is reached.', 'Band P for efficiency, especially if pH is low or high.', 'If Zn is low/marginal or P:Zn ratio > 12, include Zn in starter/band.'];
          if (tdir === 'Down' && stab !== 'Volatile' && P_slope) {
            const yearsToCritical = Math.abs((P_ppm - thresh.critical) / P_slope);
            if (yearsToCritical <= 15) {
              warnings.push(`‚è±Ô∏è At current rate (${P_slope.toFixed(1)} ppm/yr), will reach critical level (${thresh.critical} ppm) in ~${Math.round(yearsToCritical)} years.`);
            }
          }
        } else if (trig === 'LOW_VOLATILE') {
          badge = '‚ö†Ô∏è Watch'; background = 'yellow';
          insight = '‚ö†Ô∏è P is below optimal, but variability is high. Confirm zones before major changes.';
          tips = ['Zone/grid sample to confirm where P is truly low.', 'Consider VR P rather than blanket rates.'];
        } else if (tdir === 'Up') {
          badge = '‚úì On Track'; background = 'green';
          insight = '‚úì P is below optimal but improving. Continue current management.';
        } else if (trig === 'FLAT') {
          badge = '‚ö†Ô∏è Watch'; background = 'neutral';
          insight = '‚ö†Ô∏è P is below optimal and holding steady. Consider a build adjustment.';
          tips = ['Consider modest build rates if yield goals justify.', 'Recheck next sampling cycle.'];
        }
        warnings.push(...flags.warnings);
      } else if (P_opt) {
        badge = '‚úì On Track'; background = 'green';
        insight = '‚úÖ Phosphorus is in the optimal range.';
        if (tdir === 'Down' && P_ppm < thresh.belowOpt + 3) {
          warnings.push('P is trending down toward the bottom of optimal. Monitor next sample.');
        }
      } else if (P_above) {
        badge = '‚úì On Track'; background = 'green';
        insight = '‚úì Phosphorus is above optimal. Additional P is not needed.';
        if (tdir === 'Up') warnings.push('P is increasing further above optimal‚Äîavoid additional P inputs.');
      }

      const ratioThresh = getRatioThresholds();
      const znThresh = getZnThresholds();
      if (PZn_ratio && PZn_ratio > ratioThresh.normal && (Zn_ppm <= znThresh.marginal || flags.high || flags.veryHigh)) {
        warnings.push('P:Zn balance suggests increased Zn limitation risk‚Äîprotect early Zn uptake (starter/band).');
      }

      return { key: 'P', badge, background, insight, tips, warnings, show: { P_ppm, stability: stab, trend: tdir, confidence: conf } };
    }

    // --- PART 10: Build Zn Card ---
    function buildZnCard(inputs) {
      const { Zn_ppm, Zn_cv, Zn_slope, P_ppm, PZn_ratio, pH, years } = inputs;

      const thresh = getZnThresholds();
      const stab = getStabilityFromCV(Zn_cv || 25);
      const tdir = getTrendDirection(Zn_slope || 0, 'Zn');
      const flags = getPHFlags(pH || 6.5);
      const ratioThresh = getRatioThresholds();
      const conf = getConfidence(years || 1, stab);

      const dynamicTarget = getDynamicZnTarget(P_ppm || 30);
      const Zn_low = Zn_ppm < thresh.low;
      const Zn_marginal = Zn_ppm >= thresh.low && Zn_ppm < dynamicTarget;
      const Zn_adequate = Zn_ppm >= dynamicTarget;

      const level = Zn_adequate ? 'High' : 'Low';
      const trig = pickTrigger(level, stab, tdir);

      const ratioElev = PZn_ratio && PZn_ratio > ratioThresh.normal;
      const ratioHigh = PZn_ratio && PZn_ratio > ratioThresh.highRisk;

      let badge = '‚úì On Track';
      let background = 'green';
      let insight = '‚úÖ Zinc is sufficient.';
      let tips = [];
      let warnings = [];

      if (Zn_low) {
        badge = 'üî¥ Action Needed'; background = 'red';
        insight = 'üî¥ Zinc is deficient. Yield risk is likely, especially in corn.';
        tips = ['Apply Zn with placement (starter/band) for best early uptake.', 'Use foliar Zn for in-season rescue if tissue/symptoms confirm deficiency.', 'Build long-term with small annual soil Zn additions.'];
      } else if (Zn_marginal) {
        badge = '‚ö†Ô∏è Watch'; background = 'yellow';
        insight = `üü° Zinc is marginal (target: ${dynamicTarget.toFixed(1)} ppm based on P level). Monitor and consider maintenance strategy.`;
        tips = ['Consider starter/banded Zn in corn or where history suggests response.', 'Use tissue tests to confirm in-season Zn status.'];
      } else if (Zn_adequate) {
        badge = '‚úì On Track'; background = 'green';
        insight = '‚úÖ Zinc is adequate.';
      }

      if (trig === 'LOW_VOLATILE') {
        badge = Zn_low ? 'üî¥ Action Needed' : '‚ö†Ô∏è Watch';
        background = Zn_low ? 'pink' : 'yellow';
        warnings.push('Zn is spatially variable‚Äîconsider zone/VR application rather than a uniform rate.');
      }
      if (trig === 'HIGH_VOLATILE') {
        badge = '‚ö†Ô∏è Watch'; background = 'neutral';
        warnings.push('Zn is generally adequate but variable‚Äîavoid blanket Zn; target low zones if present.');
      }
      if (trig === 'FLAT' && (Zn_low || Zn_marginal)) {
        warnings.push('Zn is holding steady at a low level‚Äîwithout change, deficiency risk will persist.');
      }

      if (tdir === 'Down') warnings.push('Zn is declining, increasing deficiency risk.');
      if (tdir === 'Up' && !Zn_adequate) warnings.push('Zn is improving toward sufficiency.');

      if (flags.high || flags.veryHigh) {
        warnings.push('High pH can limit Zn availability even when soil Zn is moderate‚Äîplacement and tissue confirmation are important.');
      }

      if (ratioElev) warnings.push(`P:Zn ratio is elevated (${PZn_ratio.toFixed(0)}:1) which increases Zn limitation risk.`);
      if (ratioHigh && (Zn_low || Zn_marginal || flags.high || flags.veryHigh)) {
        tips = ['Prioritize starter/banded Zn (protect early growth under high ratio/high pH).', 'Use tissue tests; add foliar Zn only when deficiency is confirmed.', 'Avoid additional P if P is already above optimal; focus on Zn access.'];
      }

      return { key: 'Zn', badge, background, insight, tips, warnings, show: { Zn_ppm, P_ppm, ratio: PZn_ratio, dynamicTarget, stability: stab, trend: tdir, confidence: conf } };
    }

    // --- PART 11: Build P:Zn Ratio Card ---
    function buildRatioCard(inputs) {
      const { P_ppm, Zn_ppm, PZn_ratio, ratio_cv, ratio_slope, pH, years } = inputs;

      const thresh = getRatioThresholds();
      const stab = getStabilityFromCV(ratio_cv || 25);
      const tdir = getTrendDirection(ratio_slope || 0, 'P_Zn_Ratio');
      const flags = getPHFlags(pH || 6.5);
      const conf = getConfidence(years || 1, stab);

      const normal = PZn_ratio <= thresh.normal;
      const elevated = PZn_ratio > thresh.normal && PZn_ratio <= thresh.highRisk;
      const high = PZn_ratio > thresh.highRisk;

      const level = normal ? 'Low' : 'High';
      const trig = pickTrigger(level, stab, tdir);

      let badge = '‚úì On Track';
      let background = 'green';
      let insight = '‚úÖ P:Zn ratio is balanced.';
      let tips = [];
      let warnings = [];

      if (normal) {
        badge = '‚úì On Track'; background = 'green';
        insight = '‚úÖ Balanced P and Zn relationship (lower risk of interaction).';
      } else if (elevated) {
        badge = '‚ö†Ô∏è Watch'; background = 'yellow';
        insight = 'üü° P:Zn ratio is elevated. Zn limitation risk increases, especially in corn.';
        tips = ['If Zn is marginal/low, prioritize starter/banded Zn.', 'Monitor with tissue tests where practical.'];
      } else if (high) {
        badge = 'üî¥ Action Needed'; background = 'red';
        insight = 'üî¥ High P:Zn ratio indicates high risk of Zn limitation.';
        tips = ['If Zn is low/marginal, treat with starter/banded Zn.', 'If P is above optimal, avoid additional P inputs; focus on Zn access.', 'If pH is high, expect stronger micronutrient availability limits.'];
      }

      if (trig === 'HIGH_VOLATILE') {
        badge = '‚ö†Ô∏è Watch'; background = 'orange';
        warnings.push('Ratio is spatially variable‚Äîconfirm zones before major changes.');
      }
      if (trig === 'FLAT' && !normal) warnings.push('Ratio has remained consistently elevated.');
      if (tdir === 'Up' && !normal) warnings.push('Ratio is increasing, which may raise Zn limitation risk over time.');
      if (tdir === 'Down' && !normal) warnings.push('Ratio is improving but remains above the balanced range.');

      if (flags.veryHigh) warnings.push('Very high pH amplifies Zn/Fe/Mn availability limitations.');
      if (flags.veryLow) warnings.push('Very low pH may reduce P efficiency; interpret ratio in context of overall plant health.');

      return { key: 'P_Zn_Ratio', badge, background, insight, tips, warnings, show: { P_ppm, Zn_ppm, ratio: PZn_ratio, stability: stab, trend: tdir, confidence: conf } };
    }

    // --- PART 11b: Build OM (Organic Matter) Card ---
    function buildOMCard(inputs) {
      const { value, cv, slope, years } = inputs;

      const thresh = getNutrientThresholds('OM');
      const stab = getStabilityFromOMCV(cv || 10);  // OM uses stricter thresholds
      const tdir = getTrendDirection(slope || 0, 'OM');
      const conf = getConfidence(years || 1, stab);

      const OM_critical = value < thresh.critical;
      const OM_low = value >= thresh.critical && value < thresh.optimalMin;
      const OM_optimal = value >= thresh.optimalMin && value <= thresh.optimalMax;
      const OM_high = value > thresh.optimalMax;

      const level = (OM_critical || OM_low) ? 'Low' : 'Optimal';
      const trig = level === 'Optimal' ? 'OPTIMAL' : pickTrigger(level, stab, tdir);

      let badge = '‚úì On Track';
      let background = 'green';
      let insight = '‚úÖ Organic matter is in a healthy range.';
      let tips = [];
      let warnings = [];

      // Multi-year expectation note (always shown for OM)
      const omNote = 'OM changes slowly in most corn/soy systems. Treat OM trends as multi-year signals, not year-to-year decisions.';

      if (OM_critical) {
        badge = 'üî¥ Action Needed'; background = 'red';
        insight = 'üî¥ Organic matter is critically low. Building OM requires increasing carbon inputs.';
        tips = [
          'Add high-biomass cover crops (cereal rye, triticale) to increase carbon inputs.',
          'Reduce tillage intensity (strip-till ‚Üí no-till) to slow oxidation.',
          'Apply manure or compost to lowest OM zones; credit nutrients properly (especially P).'
        ];
        warnings.push(omNote);
      } else if (OM_low) {
        if (trig === 'LOW_STABLE' || (tdir === 'Down' && stab !== 'Volatile')) {
          badge = 'üî¥ Action Needed'; background = 'pink';
          insight = 'üî¥ OM is consistently below optimal. Building organic matter requires increasing carbon inputs.';
          tips = [
            'Add high-biomass cover crops (cereal rye, triticale) to increase carbon inputs.',
            'Reduce tillage intensity to slow oxidation‚Äîeach pass accelerates OM loss.',
            'Apply manure or compost to lowest OM zones; credit nutrients properly (especially P).',
            'Extend living roots earlier in spring or later in fall.',
            'Maintain full residue return (avoid aggressive residue removal).'
          ];
          if (tdir === 'Down' && stab !== 'Volatile' && slope) {
            warnings.push(`‚è±Ô∏è OM is declining at ${Math.abs(slope).toFixed(2)}%/yr. Without intervention, levels will continue to drop.`);
          }
          warnings.push(omNote);
        } else if (trig === 'LOW_VOLATILE') {
          badge = '‚ö†Ô∏è Watch'; background = 'yellow';
          insight = '‚ö†Ô∏è OM is below optimal but variable. Confirm sampling consistency before making major changes.';
          tips = [
            'Zone-sample to identify true low-OM areas within the field.',
            'Ensure consistent sampling depth and lab method across years.',
            'Target carbon imports (manure/compost) to confirmed low zones.',
            'Once confirmed, add cover crops to build OM in problem areas.'
          ];
          warnings.push('High variability may reflect sampling inconsistency rather than true field differences.');
          warnings.push(omNote);
        } else if (tdir === 'Up') {
          badge = '‚úì On Track'; background = 'green';
          insight = '‚úì OM is below optimal but improving. Continue current management practices.';
          tips = [
            'Continue cover crop and residue management practices.',
            'Monitor trend over multiple years to confirm sustained improvement.'
          ];
          warnings.push(omNote);
        } else if (trig === 'FLAT') {
          badge = '‚ö†Ô∏è Watch'; background = 'neutral';
          insight = '‚ö†Ô∏è OM is below optimal and holding steady. Current practices are maintaining but not building.';
          tips = [
            'To build OM, increase carbon inputs: add or diversify cover crops.',
            'Reduce tillage intensity if feasible to slow oxidation.',
            'Consider manure or compost applications to accelerate gains.'
          ];
          warnings.push(omNote);
        }
      } else if (OM_optimal || OM_high) {
        badge = '‚úì On Track'; background = 'green';
        insight = '‚úÖ Organic matter is in a healthy range. Maintain solid agronomic practices to preserve high OM.';
        tips = ['Continue cover crop and residue management practices to protect current OM levels.'];
        if (tdir === 'Down' && value < thresh.optimalMin + 0.3) {
          warnings.push('OM is trending down toward the bottom of optimal. Monitor and consider increasing carbon inputs.');
        }
        warnings.push(omNote);
      }

      return { key: 'OM', badge, background, insight, tips, warnings, show: { value, stability: stab, trend: tdir, confidence: conf } };
    }

    // --- PART 12: Generic Nutrient Card Builder ---
    function buildGenericNutrientCard(nutrient, inputs) {
      const { value, cv, slope, years } = inputs;

      const thresh = getNutrientThresholds(nutrient);
      // OM uses stricter stability thresholds due to sensitivity to sampling depth and lab method
      const stab = nutrient === 'OM' ? getStabilityFromOMCV(cv || 10) : getStabilityFromCV(cv || 20);
      const tdir = getTrendDirection(slope || 0, nutrient);
      const conf = getConfidence(years || 1, stab);

      // Determine behavior type
      const lowerIsBetter = ['H_sat'].includes(nutrient);
      const moreIsOk = ['K', 'OM', 'S', 'Ca', 'Mg', 'Fe', 'Mn', 'Cu', 'B'].includes(nutrient);

      let level;
      if (lowerIsBetter) {
        if (value > thresh.critical) level = 'High';
        else if (value > thresh.optimalMax) level = 'Elevated';
        else level = 'Optimal';
      } else {
        if (value < thresh.critical) level = 'Critical';
        else if (value < thresh.optimalMin) level = 'Low';
        else if (value > thresh.optimalMax) level = 'High';
        else level = 'Optimal';
      }

      const trig = (level === 'Optimal' || level === 'Elevated') ? 'OPTIMAL' : pickTrigger(level === 'Critical' ? 'Low' : level, stab, tdir);

      let badge = '‚úì On Track';
      let background = 'green';
      let insight = `‚úÖ ${CONFIG.NUTRIENT_NAMES[nutrient] || nutrient} is in a good range.`;
      let tips = [];
      let warnings = [];

      if (level === 'Critical') {
        badge = 'üî¥ Action Needed'; background = 'red';
        insight = `üî¥ ${CONFIG.NUTRIENT_NAMES[nutrient] || nutrient} is critically low.`;
        tips = [`Apply ${nutrient} to build levels.`];
      } else if (level === 'Low') {
        if (trig === 'LOW_STABLE') {
          badge = 'üî¥ Action Needed'; background = 'pink';
          insight = `üî¥ ${CONFIG.NUTRIENT_NAMES[nutrient] || nutrient} is below optimal and declining.`;
          tips = [`Consider building ${nutrient} levels.`];
        } else if (trig === 'LOW_VOLATILE') {
          badge = '‚ö†Ô∏è Watch'; background = 'yellow';
          insight = `‚ö†Ô∏è ${CONFIG.NUTRIENT_NAMES[nutrient] || nutrient} is below optimal but variable.`;
          tips = ['Zone-sample to confirm where levels are truly low.'];
        } else if (tdir === 'Up') {
          badge = '‚úì On Track'; background = 'green';
          insight = `‚úì ${CONFIG.NUTRIENT_NAMES[nutrient] || nutrient} is below optimal but improving.`;
        } else {
          badge = '‚ö†Ô∏è Watch'; background = 'neutral';
          insight = `‚ö†Ô∏è ${CONFIG.NUTRIENT_NAMES[nutrient] || nutrient} is below optimal and holding steady.`;
        }
      } else if (level === 'High' && lowerIsBetter) {
        badge = '‚ö†Ô∏è Watch'; background = 'orange';
        insight = `‚ö†Ô∏è ${CONFIG.NUTRIENT_NAMES[nutrient] || nutrient} is elevated.`;
        if (nutrient === 'H_sat') tips = ['High H saturation indicates acidity‚Äîconsider lime.'];
      } else if (level === 'High' && !moreIsOk) {
        badge = '‚ö†Ô∏è Watch'; background = 'neutral';
        insight = `‚ö†Ô∏è ${CONFIG.NUTRIENT_NAMES[nutrient] || nutrient} is above optimal.`;
        if (tdir === 'Up') warnings.push(`${nutrient} is increasing further above optimal.`);
      }

      return { key: nutrient, badge, background, insight, tips, warnings, show: { value, stability: stab, trend: tdir, confidence: conf } };
    }

    // --- PART 13: Render Insight Card HTML ---
    function renderInsightCard(card, interactionNotes = []) {
      if (!card || (!card.insight && card.tips.length === 0 && card.warnings.length === 0)) return '';

      const bgColors = {
        green: '#dcfce7', red: '#fee2e2', pink: '#fce7f3', yellow: '#fef3c7',
        orange: '#ffedd5', neutral: '#f1f5f9'
      };
      const borderColors = {
        green: '#22c55e', red: '#ef4444', pink: '#ec4899', yellow: '#f59e0b',
        orange: '#f97316', neutral: '#94a3b8'
      };

      const bg = bgColors[card.background] || bgColors.neutral;
      const border = borderColors[card.background] || borderColors.neutral;

      let html = `<div style="margin-top: 0.75rem; padding: 0.75rem; background: ${bg}; border-left: 4px solid ${border}; border-radius: 0.375rem; font-size: 0.8rem;">`;
      html += `<div style="font-weight: 600; margin-bottom: 0.5rem;">${card.insight}</div>`;

      if (card.tips && card.tips.length > 0) {
        html += `<ul style="margin: 0.5rem 0; padding-left: 1.25rem; color: #374151;">`;
        card.tips.forEach(tip => { html += `<li style="margin-bottom: 0.25rem;">${tip}</li>`; });
        html += `</ul>`;
      }

      if (card.warnings && card.warnings.length > 0) {
        html += `<div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid rgba(0,0,0,0.1); font-size: 0.75rem; color: #6b7280;">`;
        card.warnings.forEach(w => { html += `<div style="margin-bottom: 0.25rem;">‚ö†Ô∏è ${w}</div>`; });
        html += `</div>`;
      }

      // Render interaction notes (Fe/Mn/B risk overlays) if relevant to this card
      const relevantNotes = filterInteractionNotesForCard(card.key, interactionNotes);
      if (relevantNotes.length > 0) {
        html += `<div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px dashed #94a3b8; font-size: 0.75rem;">`;
        html += `<div style="font-weight: 600; color: #7c3aed; margin-bottom: 0.25rem;">üîó Potential Interactions:</div>`;
        relevantNotes.forEach(note => {
          const severityIcon = note.severity === 3 ? 'üî¥' : (note.severity === 2 ? 'üü°' : 'üí°');
          html += `<div style="margin-bottom: 0.25rem; color: #475569;">${severityIcon} ${note.message}</div>`;
        });
        html += `</div>`;
      }

      html += `</div>`;
      return html;
    }

    // Filter interaction notes relevant to a specific card
    function filterInteractionNotesForCard(cardKey, notes) {
      if (!notes || notes.length === 0) return [];

      // Map card keys to relevant interaction note codes
      const relevance = {
        'pH': ['PH_HIGH_MICRO_AVAIL', 'PH_VERY_LOW_ROOT_P', 'FE_CHLOROSIS_RISK', 'MN_DEF_RISK', 'MN_TOX_RISK', 'STACKED_MICRO_RISK'],
        'P': ['PH_VERY_LOW_ROOT_P', 'RATIO_HIGH_ZN_LOW', 'RATIO_HIGH_ZN_OK', 'RATIO_ELEV_ZN_LOW', 'P_HIGH_RATIO_GUARD'],
        'Zn': ['PH_HIGH_MICRO_AVAIL', 'RATIO_HIGH_ZN_LOW', 'RATIO_HIGH_ZN_OK', 'RATIO_ELEV_ZN_LOW', 'P_HIGH_RATIO_GUARD', 'ZN_DYNAMIC_TARGET_OVERLAY', 'ZN_LOW_B_GUARD', 'STACKED_MICRO_RISK'],
        'P_Zn_Ratio': ['RATIO_HIGH_ZN_LOW', 'RATIO_HIGH_ZN_OK', 'RATIO_ELEV_ZN_LOW', 'P_HIGH_RATIO_GUARD', 'STACKED_MICRO_RISK'],
        'Fe': ['PH_HIGH_MICRO_AVAIL', 'FE_CHLOROSIS_RISK', 'FE_LOW_SUPPORT', 'STACKED_MICRO_RISK'],
        'Mn': ['PH_HIGH_MICRO_AVAIL', 'MN_DEF_RISK', 'MN_TOX_RISK', 'MN_LOW_SUPPORT', 'STACKED_MICRO_RISK'],
        'Boron': ['B_LOW', 'B_HIGH_TOX', 'ZN_LOW_B_GUARD'],
        'B': ['B_LOW', 'B_HIGH_TOX', 'ZN_LOW_B_GUARD']
      };

      const relevantCodes = relevance[cardKey] || [];
      return notes.filter(n => relevantCodes.includes(n.code));
    }

    // ========== TAB 1: Year Comparison ==========
    // year1 = FROM (earlier year), year2 = TO (later year)
    // Stats shown are for year2, change = year2 - year1
    function updateComparison() {
      const grid = document.getElementById('comparisonGrid');
      const fromYearInfo = document.getElementById('fromYearInfo');
      const toYearInfo = document.getElementById('toYearInfo');
      const fieldCheckboxes = document.getElementById('fieldCheckboxes');
      const mismatchWarning = document.getElementById('fieldMismatchWarning');

      // Filter samples by active client/farm
      const activeFields = getActiveFields();
      const filteredSampleData = sampleData.filter(s => activeFields.includes(s.field));

      if (!year2 || filteredSampleData.length === 0) {
        grid.innerHTML = '<div class="no-data">No data available. Import soil samples to see analysis.</div>';
        fromYearInfo.innerHTML = '';
        toYearInfo.innerHTML = '';
        fieldCheckboxes.innerHTML = '';
        mismatchWarning.innerHTML = '';
        return;
      }

      const allSamplesFrom = year1 ? filteredSampleData.filter(s => String(s.year) === String(year1)) : [];
      const allSamplesTo = filteredSampleData.filter(s => String(s.year) === String(year2));
      
      // Get all fields from both years (exclude Unknown and Unassigned)
      const excludeFields = ['Unknown', 'Unassigned', 'unknown', 'unassigned', null, undefined, ''];
      const fieldsFrom = new Set(allSamplesFrom.map(s => s.field).filter(f => f && !excludeFields.includes(f)));
      const fieldsTo = new Set(allSamplesTo.map(s => s.field).filter(f => f && !excludeFields.includes(f)));
      const allFields = [...new Set([...fieldsFrom, ...fieldsTo])].sort();
      
      // Initialize selectedComparisonFields if empty - only select fields in BOTH years by default
      if (selectedComparisonFields.size === 0) {
        allFields.forEach(f => {
          // Only check fields that have data in both years
          if (fieldsFrom.has(f) && fieldsTo.has(f)) {
            selectedComparisonFields.add(f);
          }
        });
      }
      
      // Update field checkboxes
      fieldCheckboxes.innerHTML = allFields.map(field => {
        const inFrom = fieldsFrom.has(field);
        const inTo = fieldsTo.has(field);
        const checked = selectedComparisonFields.has(field);
        const mismatch = (inFrom && !inTo) || (!inFrom && inTo);
        const bgColor = mismatch ? '#fef3c7' : (checked ? '#dcfce7' : '#f8fafc');
        const borderColor = mismatch ? '#f59e0b' : (checked ? '#22c55e' : '#cbd5e1');
        
        return `
          <label style="display: flex; align-items: center; gap: 0.375rem; padding: 0.375rem 0.625rem; background: ${bgColor}; border: 1px solid ${borderColor}; border-radius: 0.375rem; cursor: pointer; font-size: 0.8125rem;">
            <input type="checkbox" ${checked ? 'checked' : ''} onchange="toggleComparisonField('${field}')" style="cursor: pointer;">
            <span>${field}</span>
            ${mismatch ? '<span style="color: #f59e0b;" title="Not in both years">‚ö†Ô∏è</span>' : ''}
          </label>
        `;
      }).join('');
      
      // Check for mismatches
      const onlyInFrom = [...fieldsFrom].filter(f => !fieldsTo.has(f));
      const onlyInTo = [...fieldsTo].filter(f => !fieldsFrom.has(f));
      
      if (onlyInFrom.length > 0 || onlyInTo.length > 0) {
        let warningHtml = '<div style="background: #fef3c7; border: 1px solid #f59e0b; border-radius: 0.375rem; padding: 0.75rem; font-size: 0.8125rem;">';
        warningHtml += '<strong style="color: #92400e;">‚ö†Ô∏è Field Mismatch Detected</strong><br>';
        if (onlyInFrom.length > 0) {
          warningHtml += `<span style="color: #92400e;">Only in ${year1}: ${onlyInFrom.join(', ')}</span><br>`;
        }
        if (onlyInTo.length > 0) {
          warningHtml += `<span style="color: #92400e;">Only in ${year2}: ${onlyInTo.join(', ')}</span>`;
        }
        warningHtml += '</div>';
        mismatchWarning.innerHTML = warningHtml;
      } else {
        mismatchWarning.innerHTML = '';
      }
      
      // Filter samples by selected fields
      const samplesFrom = allSamplesFrom.filter(s => selectedComparisonFields.has(s.field));
      const samplesTo = allSamplesTo.filter(s => selectedComparisonFields.has(s.field));
      
      // Update year stats boxes
      updateYearStatsBox(fromYearInfo, year1, samplesFrom);
      updateYearStatsBox(toYearInfo, year2, samplesTo);
      
      if (samplesTo.length === 0) {
        // Check if the issue is no matching fields
        const matchingFields = allFields.filter(f => fieldsFrom.has(f) && fieldsTo.has(f));
        if (matchingFields.length === 0 && allFields.length > 0) {
          grid.innerHTML = `<div class="no-data">No matching fields between ${year1} and ${year2}.<br><small style="color: #64748b;">Fields may have different names. Try "Reassign samples to boundaries" on the Import page, or select fields manually above.</small></div>`;
        } else {
          grid.innerHTML = `<div class="no-data">No samples found for ${year2} with selected fields.<br><small style="color: #64748b;">Select fields above to include in comparison.</small></div>`;
        }
        return;
      }
      
      let html = '';
      
      const visibleNutrients = getVisibleNutrients();
      visibleNutrients.forEach(attr => {
        const statsTo = getStats(samplesTo, attr);
        const statsFrom = year1 ? getStats(samplesFrom, attr) : null;
        
        if (!statsTo) return;
        
        const name = CONFIG.NUTRIENT_NAMES[attr] || attr;
        const unit = CONFIG.NUTRIENT_UNITS[attr] || '';
        const decimals = getDecimals(attr);
        const isLowerBetter = CONFIG.LOWER_IS_BETTER.includes(attr);
        
        let pointChange = 0, pctChange = 0, cardClass = '', pctClass = 'neutral';
        
        if (statsFrom && statsFrom.avg !== undefined) {
          pointChange = statsTo.avg - statsFrom.avg;
          pctChange = statsFrom.avg !== 0 ? (pointChange / statsFrom.avg) * 100 : 0;
          const isPositive = isLowerBetter ? pointChange < 0 : pointChange > 0;
          const isSignificant = Math.abs(pctChange) > 2;
          if (isSignificant) {
            cardClass = isPositive ? 'positive' : 'negative';
            pctClass = isPositive ? 'positive' : 'negative';
          }
        } else if (year1 && samplesFrom.length === 0) {
          // No data from year1 for selected fields - show warning style
          cardClass = 'no-comparison';
        }
        
        html += `
          <div class="nutrient-card ${cardClass}">
            <div class="nutrient-header">
              <span class="nutrient-name">${name}</span>
              ${statsFrom ? `<span class="nutrient-pct ${pctClass}">${pctChange >= 0 ? '+' : ''}${pctChange.toFixed(1)}%</span>` : ''}
            </div>
            <div class="nutrient-stats">
              <div class="stat-box"><div class="label">Average</div><div class="value">${statsTo.avg.toFixed(decimals)}</div></div>
              <div class="stat-box"><div class="label">High</div><div class="value">${statsTo.high.toFixed(decimals)}</div></div>
              <div class="stat-box"><div class="label">Low</div><div class="value">${statsTo.low.toFixed(decimals)}</div></div>
            </div>
            ${statsFrom ? `
              <div class="year-comparison">
                <div class="year-val"><div class="yr">${year1}</div><div class="num">${statsFrom.avg.toFixed(decimals)}</div></div>
                <div class="year-arrow">‚Üí</div>
                <div class="year-val"><div class="yr">${year2}</div><div class="num">${statsTo.avg.toFixed(decimals)}</div></div>
              </div>
              <div class="change-row">
                <span>Point: <span class="val ${pctClass}">${pointChange >= 0 ? '+' : ''}${pointChange.toFixed(decimals)}</span></span>
                <span>%: <span class="val ${pctClass}">${pctChange >= 0 ? '+' : ''}${pctChange.toFixed(1)}%</span></span>
              </div>
            ` : `<div class="year-comparison" style="justify-content:center; flex-direction:column; align-items:center;">
              <div class="year-val"><div class="yr">${year2}</div><div class="num">${statsTo.avg.toFixed(decimals)} ${unit}</div></div>
              ${year1 && samplesFrom.length === 0 ? `<div style="font-size:0.75rem;color:#92400e;margin-top:0.5rem;">‚ö†Ô∏è No ${year1} data for selected fields</div>` : ''}
            </div>`}
          </div>
        `;
      });
      
      grid.innerHTML = html || '<div class="no-data">No nutrient data available</div>';
    }

    // ========== TAB 2: Historical Field Trends ==========
    function updateHistory(fieldName) {
      const container = document.getElementById('historyContent');

      if (!fieldName) {
        container.innerHTML = '<div class="no-data">Select a field to view nutrient trends over time</div>';
        return;
      }

      // Handle "All Fields" operation-wide trends
      if (fieldName === '__all__') {
        renderOperationTrends(container);
        return;
      }

      console.log('=== Field Trends Debug ===');
      console.log('Selected field:', JSON.stringify(fieldName), 'length:', fieldName.length);

      const fieldSamples = sampleData.filter(s => s.field === fieldName);
      console.log('Samples found:', fieldSamples.length);

      const years = [...new Set(fieldSamples.map(s => s.year).filter(y => y))].sort();
      console.log('Years found:', years);

      if (fieldSamples.length > 0) {
        console.log('First sample:', JSON.stringify(fieldSamples[0]));
        console.log('Sample years breakdown:', years.map(y => ({ year: y, count: fieldSamples.filter(s => String(s.year) === String(y)).length })));
      }

      if (years.length < 1) {
        container.innerHTML = '<div class="no-data">No data available for this field</div>';
        return;
      }

      let html = `<div style="background:#f8fafc;border:2px solid #cbd5e1;border-radius:0.5rem;padding:1rem;margin-bottom:1rem;"><h3 style="margin:0 0 0.25rem 0;">${fieldName}</h3><p style="margin:0;color:#64748b;">Years: ${years.join(', ')} (${fieldSamples.length} samples)</p></div>`;

      try {
        const visibleNutrients = getVisibleNutrients();
        console.log('Visible nutrients:', visibleNutrients.length);

        visibleNutrients.forEach(attr => {
          try {
            const yearData = [];
            let hasData = false;

            years.forEach(year => {
              const yearSamples = fieldSamples.filter(s => String(s.year) === String(year));
              const stats = getStats(yearSamples, attr);
              if (stats) { yearData.push({ year, avg: stats.avg, median: stats.median, count: stats.count }); hasData = true; }
            });

            if (!hasData || yearData.length < 1) return;

            const first = yearData[0], last = yearData[yearData.length - 1];
            const avgChange = last.avg - first.avg;
            const medianChange = last.median - first.median;
            const pctChange = first.avg !== 0 ? (avgChange / first.avg) * 100 : 0;
            const isLowerBetter = CONFIG.LOWER_IS_BETTER.includes(attr);
            const isPositive = isLowerBetter ? avgChange < 0 : avgChange > 0;
            const decimals = getDecimals(attr);
            const unit = CONFIG.NUTRIENT_UNITS[attr] || '';
            const name = CONFIG.NUTRIENT_NAMES[attr] || attr;

            let cardClass = 'neutral', color = '#64748b';
            if (yearData.length > 1) {
              cardClass = isPositive ? 'positive' : 'negative';
              color = isPositive ? '#22c55e' : '#ef4444';
            }

            const graph = createDualLineGraph(yearData, color, attr);

            // Skip trend analysis for Buffer_pH and CEC (diagnostic measurements, not nutrients to manage)
            const skipTrendAnalysis = attr === 'Buffer_pH' || attr === 'CEC';

            // Calculate linear regression for trend slope
            const regressionData = yearData.map(d => ({ x: parseInt(d.year), y: d.avg }));
            const regression = !skipTrendAnalysis ? window.Utils.calculateLinearRegression(regressionData) : null;
            const slope = regression ? regression.slope : null;

            // Get comprehensive trend insight (skip for Buffer_pH)
            let trendInsight = null;
            let urgencyBadge = null;
            if (!skipTrendAnalysis && yearData.length > 1) {
              // Get critical levels from Settings (with defaults)
              const criticalLevels = window.Utils.getCriticalLevels();
              trendInsight = window.Utils.getTrendInsight(yearData, attr, slope, criticalLevels);
              urgencyBadge = trendInsight ? window.Utils.getUrgencyBadge(trendInsight.urgency) : null;
            }

            // --- 5-Trigger Framework Integration ---
            // Collect cross-nutrient data from most recent year
            const mostRecentYear = last.year;
            const recentSamples = fieldSamples.filter(s => String(s.year) === String(mostRecentYear));

            const getAvgValue = (samples, nutrient) => {
              const vals = samples.map(s => s[nutrient]).filter(v => v !== null && v !== undefined && !isNaN(v));
              return vals.length > 0 ? vals.reduce((a, b) => a + b, 0) / vals.length : null;
            };

            const currentPH = getAvgValue(recentSamples, 'pH');
            const currentP = getAvgValue(recentSamples, 'P');
            const currentZn = getAvgValue(recentSamples, 'Zn');
            const currentFe = getAvgValue(recentSamples, 'Fe');
            const currentMn = getAvgValue(recentSamples, 'Mn');
            const currentB = getAvgValue(recentSamples, 'Boron') || getAvgValue(recentSamples, 'B');
            const currentPZnRatio = (currentP !== null && currentZn !== null && currentZn > 0) ? currentP / currentZn : null;

            // Collect interaction notes for Fe/Mn/B risk overlays
            const interactionNotes = collectInteractionNotes({
              pH: currentPH || 6.5,
              calcareous: false,
              P_ppm: currentP || 0,
              Zn_ppm: currentZn || 0,
              PZn_ratio: currentPZnRatio || 0,
              Fe_ppm: currentFe,
              Mn_ppm: currentMn,
              B_ppm: currentB
            });

            // Get CV/SD from trendInsight if available
            const stabilityValue = trendInsight ? trendInsight.stability.value : null;

            // Build the 5-Trigger card based on nutrient type
            let triggerCard = null;
            let triggerCardHtml = '';

            if (!skipTrendAnalysis && yearData.length > 1) {
              if (attr === 'pH') {
                triggerCard = buildPHCard({
                  pH: last.avg,
                  pH_sd: stabilityValue,
                  pH_slope: slope,
                  calcareous: false,
                  years: yearData.length
                });
              } else if (attr === 'P') {
                triggerCard = buildPCard({
                  P_ppm: last.avg,
                  P_cv: stabilityValue,
                  P_slope: slope,
                  pH: currentPH,
                  Zn_ppm: currentZn,
                  PZn_ratio: currentPZnRatio,
                  years: yearData.length
                });
              } else if (attr === 'Zn') {
                triggerCard = buildZnCard({
                  Zn_ppm: last.avg,
                  Zn_cv: stabilityValue,
                  Zn_slope: slope,
                  P_ppm: currentP,
                  PZn_ratio: currentPZnRatio,
                  pH: currentPH,
                  years: yearData.length
                });
              } else if (attr === 'P_Zn_Ratio') {
                triggerCard = buildRatioCard({
                  P_ppm: currentP,
                  Zn_ppm: currentZn,
                  PZn_ratio: last.avg,
                  ratio_cv: stabilityValue,
                  ratio_slope: slope,
                  pH: currentPH,
                  years: yearData.length
                });
              } else if (attr === 'OM') {
                // Dedicated OM card with agronomic recommendations
                triggerCard = buildOMCard({
                  value: last.avg,
                  cv: stabilityValue,
                  slope: slope,
                  years: yearData.length
                });
              } else if (attr !== 'Buffer_pH' && attr !== 'CEC') {
                // Generic nutrient card for K, S, etc.
                triggerCard = buildGenericNutrientCard(attr, {
                  value: last.avg,
                  cv: stabilityValue,
                  slope: slope,
                  years: yearData.length
                });
              }

              if (triggerCard) {
                triggerCardHtml = renderInsightCard(triggerCard, interactionNotes);
                // Override the urgency badge with the trigger card badge
                if (triggerCard.badge) {
                  const badgeColors = {
                    green: { color: '#16a34a', bg: '#dcfce7' },
                    red: { color: '#dc2626', bg: '#fee2e2' },
                    pink: { color: '#db2777', bg: '#fce7f3' },
                    yellow: { color: '#ca8a04', bg: '#fef9c3' },
                    orange: { color: '#ea580c', bg: '#ffedd5' },
                    neutral: { color: '#64748b', bg: '#f1f5f9' }
                  };
                  const bc = badgeColors[triggerCard.background] || badgeColors.neutral;
                  urgencyBadge = { emoji: triggerCard.badge.split(' ')[0], label: triggerCard.badge.replace(/^[^\s]+\s*/, ''), color: bc.color, bg: bc.bg };
                }
              }
            }
            // --- End 5-Trigger Framework Integration ---

            // Get moisture warnings for P and K
            let moistureWarning = '';
            if ((attr === 'P' || attr === 'K') && fieldSamples.length > 0) {
              const moistureConditions = fieldSamples
                .filter(s => s.soilMoistureCondition)
                .map(s => ({ year: s.year, moisture: s.soilMoistureCondition }));

              const hasDry = moistureConditions.some(m => m.moisture === 'dry');
              const moistureByYear = {};
              moistureConditions.forEach(m => {
                if (!moistureByYear[m.year]) moistureByYear[m.year] = new Set();
                moistureByYear[m.year].add(m.moisture);
              });

              const yearsWithMoisture = Object.keys(moistureByYear);
              const hasMixedMoisture = yearsWithMoisture.length > 1 &&
                new Set(yearsWithMoisture.flatMap(y => [...moistureByYear[y]])).size > 1;

              if (hasDry) {
                const pctHigher = attr === 'P' ? '15-25%' : '20-40%';
                moistureWarning = `<div style="margin-top: 0.5rem; font-size: 0.75rem; color: #92400e;">üåµ Dry sampling: ${attr} may test ${pctHigher} higher than actual</div>`;
              }
              if (hasMixedMoisture && trendInsight && trendInsight.stability.label === 'Volatile') {
                moistureWarning += `<div style="margin-top: 0.25rem; font-size: 0.75rem; color: #64748b;">‚ÑπÔ∏è Some variability may be due to different moisture conditions at sampling</div>`;
              }
            }

            // Variability causes expandable section for volatile data - NUTRIENT-SPECIFIC
            let volatilityTooltip = '';
            if (trendInsight && trendInsight.stability.label === 'Volatile') {
              const cvInfo = getNutrientCVExplanation(attr, trendInsight.stability.value);
              const driversHtml = cvInfo.drivers.map(d => `<li>${d}</li>`).join('');

              volatilityTooltip = `
                <details style="margin-top: 0.5rem; font-size: 0.75rem; color: #64748b;" open>
                  <summary style="cursor: pointer; color: #dc2626; font-weight: 500;">‚ö†Ô∏è ${cvInfo.title}</summary>
                  <div style="margin-top: 0.5rem; padding: 0.75rem; background: #fef2f2; border-radius: 0.375rem; border: 1px solid #fecaca;">
                    <p style="margin-bottom: 0.5rem; color: #991b1b;">${cvInfo.explanation}</p>
                    <p style="margin: 0.5rem 0 0.25rem 0; font-weight: 600; color: #475569; font-size: 0.7rem;">Common drivers:</p>
                    <ul style="margin: 0; padding-left: 1.25rem; color: #64748b; font-size: 0.7rem;">
                      ${driversHtml}
                    </ul>
                    <p style="margin-top: 0.75rem; padding: 0.5rem; background: #f0fdf4; border-radius: 0.25rem; color: #166534; font-weight: 500;">üí° ${cvInfo.suggestion}</p>
                  </div>
                </details>`;
            }

            // P:Zn Ratio insight box - NOW HANDLED BY 5-TRIGGER FRAMEWORK (buildRatioCard)
            // Legacy code disabled - see triggerCardHtml above
            let pznInsight = '';  // No longer used - replaced by triggerCardHtml
            let pznBadgeOverride = null;  // No longer used
            if (false && attr === 'P_Zn_Ratio' && yearData.length > 0) {  // DISABLED
              const mostRecentRatio = last.avg;
              const mostRecentYear = last.year;

              // Get current P and Zn values from most recent year's samples
              const recentSamples__disabled = fieldSamples.filter(s => String(s.year) === String(mostRecentYear));
              const pValues = recentSamples.map(s => s.P).filter(v => v !== null && v !== undefined && !isNaN(v));
              const znValues = recentSamples.map(s => s.Zn).filter(v => v !== null && v !== undefined && !isNaN(v));
              const currentP = pValues.length > 0 ? pValues.reduce((a, b) => a + b, 0) / pValues.length : null;
              const currentZn = znValues.length > 0 ? znValues.reduce((a, b) => a + b, 0) / znValues.length : null;

              // Get Zn sufficiency threshold from settings (default 1.0 ppm)
              const settings = JSON.parse(localStorage.getItem('soilSettings') || '{}');
              const znOptimalMin = settings.Zn_min ?? 1.0;
              const znIsLow = currentZn !== null && currentZn < znOptimalMin;
              const znIsAdequate = currentZn !== null && currentZn >= znOptimalMin;

              // Determine ratio status
              const ratioIsNormal = mostRecentRatio <= 12;
              const ratioIsElevated = mostRecentRatio > 12 && mostRecentRatio <= 20;
              const ratioIsHighRisk = mostRecentRatio > 20;

              // Determine trend direction
              const trendUp = slope !== null && slope > 0.5;
              const trendDown = slope !== null && slope < -0.5;

              // Build trend message
              let trendMsg = '';
              if (trendUp) {
                trendMsg = '<div style="margin-top: 0.5rem; font-size: 0.8rem; color: #64748b;">üìà Ratio is trending upward, which may increase risk of zinc limitation in future seasons.</div>';
              } else if (trendDown) {
                trendMsg = '<div style="margin-top: 0.5rem; font-size: 0.8rem; color: #64748b;">üìâ Ratio is improving, suggesting nutrient balance is moving in a favorable direction.</div>';
              }

              // Stability warning
              let stabilityMsg = '';
              if (trendInsight && trendInsight.stability.label === 'Volatile') {
                stabilityMsg = '<div style="margin-top: 0.5rem; font-size: 0.8rem; color: #92400e;">‚ö†Ô∏è Year-to-year variability is high. Confirm trends with consistent sampling methods before making major adjustments.</div>';
              }

              // Current values display
              const valuesDisplay = `<div style="margin-top: 0.75rem; padding-top: 0.5rem; border-top: 1px solid #e2e8f0; font-size: 0.75rem; color: #64748b;">
                <strong>Current values:</strong> P: ${currentP !== null ? currentP.toFixed(0) : '?'} ppm | Zn: ${currentZn !== null ? currentZn.toFixed(1) : '?'} ppm | Ratio: ${mostRecentRatio.toFixed(0)}:1
              </div>`;

              // Generate insight based on case
              let bgColor, borderColor, textColor, emoji, insight, recommendation;

              if (ratioIsHighRisk && znIsLow) {
                // CASE 1: High ratio + Low Zn (Highest Risk)
                bgColor = '#fee2e2'; borderColor = '#fca5a5'; textColor = '#991b1b';
                emoji = 'üî¥';
                insight = 'High risk of zinc deficiency. The P:Zn ratio is elevated and soil zinc is below sufficiency. High phosphorus relative to zinc can reduce plant Zn uptake and limit crop performance.';
                recommendation = 'Consider zinc fertilization to correct deficiency and reduce imbalance. Placement and product choice should match crop and soil conditions.';
                pznBadgeOverride = { emoji: 'üî¥', label: 'Action Required', color: '#dc2626', bg: '#fee2e2' };
              } else if (ratioIsHighRisk && znIsAdequate) {
                // CASE 2: High ratio + Adequate Zn
                bgColor = '#fed7aa'; borderColor = '#fdba74'; textColor = '#9a3412';
                emoji = 'üü†';
                insight = 'Imbalance present, zinc currently sufficient. While zinc levels are currently adequate, high P relative to Zn can increase future deficiency risk, especially in high-yielding crops.';
                recommendation = 'Monitor zinc levels and maintain balanced fertility. Correcting ratio may be beneficial if Zn begins trending downward.';
                pznBadgeOverride = { emoji: '‚ö†Ô∏è', label: 'Review', color: '#ca8a04', bg: '#fef9c3' };
              } else if (ratioIsElevated && znIsLow) {
                // CASE 3: Elevated ratio + Low Zn
                bgColor = '#fef9c3'; borderColor = '#fde047'; textColor = '#854d0e';
                emoji = 'üü°';
                insight = 'Zinc supply may limit phosphorus utilization. Moderate P:Zn imbalance combined with low zinc can reduce plant Zn uptake and limit crop response to phosphorus.';
                recommendation = 'Consider zinc supplementation and monitor ratio trends in future samples.';
                pznBadgeOverride = { emoji: '‚ö†Ô∏è', label: 'Review', color: '#ca8a04', bg: '#fef9c3' };
              } else if (ratioIsElevated && znIsAdequate) {
                // CASE 4: Elevated ratio + Adequate Zn
                bgColor = '#ecfdf5'; borderColor = '#a7f3d0'; textColor = '#065f46';
                emoji = 'üü¢';
                insight = 'Slight imbalance, no current deficiency indicated. The P:Zn ratio is above typical balance ranges, but zinc supply appears sufficient.';
                recommendation = 'Continue monitoring zinc and ratio trends. No immediate correction needed if Zn remains adequate.';
                pznBadgeOverride = { emoji: '‚úì', label: 'Good', color: '#16a34a', bg: '#dcfce7' };
              } else {
                // CASE 5: Normal ratio (‚â§12:1)
                bgColor = '#dcfce7'; borderColor = '#86efac'; textColor = '#166534';
                emoji = '‚úÖ';
                insight = 'Balanced P and Zn relationship. The P:Zn ratio is within commonly accepted balance ranges, reducing risk of nutrient interaction issues.';
                recommendation = 'Maintain current fertility strategy and monitor trends over time.';
                pznBadgeOverride = { emoji: '‚úì', label: 'Good', color: '#16a34a', bg: '#dcfce7' };
              }

              pznInsight = `
                <div style="margin-top: 0.75rem; padding: 0.75rem; background: ${bgColor}; border-radius: 0.375rem; border: 1px solid ${borderColor};">
                  <div style="font-size: 0.85rem; color: ${textColor};">
                    <strong>${emoji} ${insight}</strong>
                  </div>
                  <div style="margin-top: 0.5rem; font-size: 0.8rem; color: ${textColor};">
                    üí° <strong>Recommendation:</strong> ${recommendation}
                  </div>
                  ${trendMsg}
                  ${stabilityMsg}
                  ${valuesDisplay}
                </div>`;

              // Override the badge for P:Zn ratio
              if (pznBadgeOverride) {
                urgencyBadge = pznBadgeOverride;
              }
            }

            // Build the trend insight box - NOW HANDLED BY 5-TRIGGER FRAMEWORK
            // Legacy code disabled - see triggerCardHtml above
            let trendInsightBox = '';  // No longer used - replaced by triggerCardHtml
            if (false && trendInsight && attr !== 'P_Zn_Ratio') {  // DISABLED
              trendInsightBox = `
                <div style="margin-top: 0.75rem; padding: 0.75rem; background: ${trendInsight.background}; border-radius: 0.375rem; border: 1px solid ${trendInsight.stability.color}40;">
                  <div style="font-size: 0.85rem; color: #1e293b;">
                    ${trendInsight.message}
                  </div>
                  ${trendInsight.yearsToCritical ? `
                    <div style="margin-top: 0.5rem; font-size: 0.8rem; color: #b91c1c; font-weight: 500;">
                      ‚è±Ô∏è ${trendInsight.yearsToCritical.message}
                    </div>
                  ` : ''}
                  ${moistureWarning}
                  ${volatilityTooltip}
                </div>`;
            }

            // pznTooltip moved to 5-Trigger Framework integration section above

            // OM improvement tips - NOW HANDLED BY 5-TRIGGER FRAMEWORK (buildGenericNutrientCard)
            // Legacy code disabled - see triggerCardHtml above
            let omTips = '';  // No longer used - replaced by triggerCardHtml
            if (false && attr === 'OM' && yearData.length > 0) {  // DISABLED
              const currentOM = last.avg;
              const omSettings = JSON.parse(localStorage.getItem('soilSettings') || '{}');
              const omCritical = omSettings.OM_critical ?? 2.0;
              const omOptimalMin = omSettings.OM_min ?? 3.0;
              const trendIsDown = slope !== null && slope < 0;
              const trendIsFlat = slope !== null && slope >= -0.02 && slope <= 0.02;
              const isGoodBadge = urgencyBadge && urgencyBadge.label === 'Good';
              const isAboveOptimal = currentOM >= omOptimalMin;

              // Show tips when: OM < critical OR (OM < optimalMin AND trend flat/down)
              // Don't show when: OM above optimal AND badge is Good
              const showTips = (currentOM < omCritical) ||
                               (currentOM < omOptimalMin && (trendIsFlat || trendIsDown));
              const hideTips = isAboveOptimal && isGoodBadge;

              if (showTips && !hideTips) {
                omTips = `
                <div style="margin-top: 0.75rem; padding: 0.75rem; background: #eff6ff; border-radius: 0.375rem; border: 1px solid #bfdbfe; font-size: 0.8rem;">
                  <div style="font-weight: 500; color: #1e40af; margin-bottom: 0.5rem;">üí° How to improve OM</div>
                  <div style="margin-bottom: 0.5rem; color: #475569;">
                    <strong>üå± Cover crops:</strong> Multi-species mixes with maximum growing days. Fields below 2% respond strongly. Expect +0.1‚Äì0.3% OM/year with consistent use.
                  </div>
                  <div style="margin-bottom: 0.5rem; color: #475569;">
                    <strong>üöú Reduce tillage:</strong> No-till or strip-till slows carbon loss. Most effective when combined with residue retention and covers.
                  </div>
                  <div style="margin-bottom: 0.5rem; color: #475569;">
                    <strong>‚ôªÔ∏è Add organic carbon:</strong> Manure, compost, or high-residue rotations (corn, small grains) provide direct carbon inputs.
                  </div>
                  <div style="color: #64748b; font-style: italic;">
                    <strong>‚è±Ô∏è Expect gradual change:</strong> Realistic gains are 0.1‚Äì0.2% per year. OM building requires consistent multi-year practices.
                  </div>
                </div>`;
              }
            }

            // Zn improvement insights - NOW HANDLED BY 5-TRIGGER FRAMEWORK (buildZnCard)
            // Legacy code disabled - see triggerCardHtml above
            let znInsight = '';  // No longer used - replaced by triggerCardHtml
            let znBadgeOverride = null;  // No longer used
            if (false && attr === 'Zn' && yearData.length > 0) {  // DISABLED
              const currentZn__disabled = last.avg;
              const mostRecentYear__disabled = last.year;

              // Get current P value to calculate P:Zn ratio and dynamic target
              const recentSamples__disabled = fieldSamples.filter(s => String(s.year) === String(mostRecentYear__disabled));
              const pValues = recentSamples.map(s => s.P).filter(v => v !== null && v !== undefined && !isNaN(v));
              const currentP = pValues.length > 0 ? pValues.reduce((a, b) => a + b, 0) / pValues.length : null;
              const pznRatio = (currentP !== null && currentZn > 0) ? currentP / currentZn : null;

              // Dynamic Zn target based on P level (to maintain 10:1 ratio)
              const standardMin = 1.5;
              const ratioBasedTarget = currentP !== null ? currentP / 10 : standardMin;
              const znTarget = Math.max(standardMin, ratioBasedTarget);
              const targetIsElevated = znTarget > standardMin;

              // Determine trend direction
              const trendUp = slope !== null && slope > 0.02;
              const trendDown = slope !== null && slope < -0.02;
              const trendFlat = slope !== null && slope >= -0.02 && slope <= 0.02;

              // Zn status based on dynamic target
              const znLow = currentZn < znTarget * 0.5;  // Below 50% of target
              const znMarginal = currentZn >= znTarget * 0.5 && currentZn < znTarget;  // 50-100% of target
              const znAdequate = currentZn >= znTarget;  // At or above target

              // Target display text
              const targetText = targetIsElevated
                ? `Target: ${znTarget.toFixed(1)} ppm (to maintain 10:1 ratio with P at ${currentP.toFixed(0)} ppm)`
                : `Target: ${znTarget.toFixed(1)} ppm (standard minimum)`;

              // Current values display (always shown)
              const valuesDisplay = `<div style="margin-top: 0.75rem; padding-top: 0.5rem; border-top: 1px solid #e2e8f0; font-size: 0.75rem; color: #64748b;">
                <strong>Current Zn:</strong> ${currentZn.toFixed(1)} ppm | <strong>Current P:</strong> ${currentP !== null ? currentP.toFixed(0) : '?'} ppm | <strong>P:Zn Ratio:</strong> ${pznRatio !== null ? pznRatio.toFixed(0) + ':1' : '?'}
                <div style="margin-top: 0.25rem;"><strong>${targetText}</strong></div>
              </div>`;

              let bgColor, borderColor, textColor, emoji, insight, ratioNote, tips, trendMsg;

              if (znLow) {
                // CASE 1: Zn LOW (below 50% of target)
                bgColor = '#fee2e2'; borderColor = '#fca5a5'; textColor = '#991b1b';
                emoji = 'üî¥';
                insight = `Zinc is deficient (${currentZn.toFixed(1)} ppm vs target ${znTarget.toFixed(1)} ppm). Zn deficiency limits yield potential, especially in corn, beans, and wheat.`;
                znBadgeOverride = { emoji: 'üî¥', label: 'Action Needed', color: '#dc2626', bg: '#fee2e2' };

                ratioNote = (pznRatio !== null && pznRatio > 12)
                  ? `<div style="margin-top: 0.5rem; color: ${textColor};">High P:Zn ratio (${pznRatio.toFixed(0)}:1) further reduces plant Zn uptake.</div>`
                  : '';

                if (trendDown) {
                  trendMsg = '<div style="margin-top: 0.5rem; font-size: 0.8rem; color: #991b1b;">üìâ Zn is declining, increasing deficiency risk.</div>';
                } else if (trendUp) {
                  trendMsg = '<div style="margin-top: 0.5rem; font-size: 0.8rem; color: #166534;">üìà Zn is improving but remains deficient.</div>';
                } else {
                  trendMsg = '';
                }

                tips = `
                  <div style="margin-top: 0.75rem; padding: 0.75rem; background: #fef2f2; border-radius: 0.375rem; border: 1px solid #fecaca; font-size: 0.8rem;">
                    <div style="font-weight: 500; color: #991b1b; margin-bottom: 0.5rem;">üí° How to raise Zn</div>
                    <div style="margin-bottom: 0.5rem; color: #475569;">
                      <strong>üöú Starter or banded Zn is most effective:</strong> Zinc is immobile in soil. Placing Zn near seed improves early uptake more reliably than broadcast‚Äîespecially important when P is high.
                    </div>
                    <div style="margin-bottom: 0.5rem; color: #475569;">
                      <strong>üåø Foliar Zn for in-season rescue:</strong> Foliar application quickly corrects plant deficiency when soil uptake is limited. Helps current crop but doesn't build soil Zn.
                    </div>
                    <div style="color: #475569;">
                      <strong>üß± Build long-term with small annual additions:</strong> Repeated small soil applications build Zn more safely than one large dose. Verify improvement with consistent sampling.
                    </div>
                  </div>`;

              } else if (znMarginal) {
                // CASE 2: Zn MARGINAL (50-100% of target)
                bgColor = '#fef9c3'; borderColor = '#fde047'; textColor = '#854d0e';
                emoji = 'üü°';
                insight = `Zn is below target (${currentZn.toFixed(1)} ppm vs target ${znTarget.toFixed(1)} ppm). Sensitive crops (corn, beans, wheat) may show response to Zn application.`;
                znBadgeOverride = { emoji: '‚ö†Ô∏è', label: 'Watch', color: '#ca8a04', bg: '#fef9c3' };

                if (targetIsElevated) {
                  ratioNote = `<div style="margin-top: 0.5rem; color: ${textColor};">Target elevated due to high P (${currentP.toFixed(0)} ppm). Higher Zn needed to maintain 10:1 ratio.</div>`;
                } else if (pznRatio !== null && pznRatio > 12) {
                  ratioNote = `<div style="margin-top: 0.5rem; color: ${textColor};">P:Zn ratio (${pznRatio.toFixed(0)}:1) increases risk of P-induced Zn limitation.</div>`;
                } else {
                  ratioNote = '';
                }

                if (trendDown) {
                  trendMsg = '<div style="margin-top: 0.5rem; font-size: 0.8rem; color: #b91c1c;">üìâ Zn is declining away from target.</div>';
                } else if (trendUp) {
                  trendMsg = '<div style="margin-top: 0.5rem; font-size: 0.8rem; color: #166534;">üìà Zn is improving toward target.</div>';
                } else if (trendFlat) {
                  trendMsg = '<div style="margin-top: 0.5rem; font-size: 0.8rem; color: #64748b;">‚û°Ô∏è Zn is holding steady below target.</div>';
                } else {
                  trendMsg = '';
                }

                tips = `
                  <div style="margin-top: 0.75rem; padding: 0.75rem; background: #fefce8; border-radius: 0.375rem; border: 1px solid #fde047; font-size: 0.8rem;">
                    <div style="font-weight: 500; color: #854d0e; margin-bottom: 0.5rem;">üí° Managing below-target Zn</div>
                    <div style="margin-bottom: 0.5rem; color: #475569;">
                      <strong>üöú Consider starter or banded Zn:</strong> With below-target Zn, banded placement ensures early-season availability. Especially valuable when P is high.
                    </div>
                    <div style="margin-bottom: 0.5rem; color: #475569;">
                      <strong>üìä Monitor tissue tests mid-season:</strong> Tissue testing confirms if plant is accessing enough Zn. If low, foliar Zn can correct in-season.
                    </div>
                    <div style="color: #475569;">
                      <strong>üß± Build toward target with annual additions:</strong> Small annual Zn applications build levels toward target over time.
                    </div>
                  </div>`;

              } else {
                // CASE 3: Zn ADEQUATE (at or above target)
                bgColor = '#dcfce7'; borderColor = '#86efac'; textColor = '#166534';
                emoji = '‚úÖ';
                insight = `Zinc is sufficient (${currentZn.toFixed(1)} ppm meets target of ${znTarget.toFixed(1)} ppm).`;
                ratioNote = '';
                trendMsg = '';
                tips = '';
                znBadgeOverride = { emoji: '‚úì', label: 'Good', color: '#16a34a', bg: '#dcfce7' };

                // Add note if target was elevated due to high P
                if (targetIsElevated) {
                  ratioNote = `<div style="margin-top: 0.5rem; color: #166534;">Target was elevated to ${znTarget.toFixed(1)} ppm due to high P (${currentP.toFixed(0)} ppm). Zn level is adequate for balanced uptake.</div>`;
                }

                // Watch for decline if at edge of target
                if (trendDown && currentZn < znTarget * 1.2) {
                  trendMsg = '<div style="margin-top: 0.5rem; font-size: 0.8rem; color: #92400e;">üìâ Zn is declining. Monitor to ensure it stays above target.</div>';
                }
              }

              znInsight = `
                <div style="margin-top: 0.75rem; padding: 0.75rem; background: ${bgColor}; border-radius: 0.375rem; border: 1px solid ${borderColor};">
                  <div style="font-size: 0.85rem; color: ${textColor};">
                    <strong>${emoji} ${insight}</strong>
                  </div>
                  ${ratioNote}
                  ${trendMsg}
                  ${valuesDisplay}
                </div>
                ${tips}`;

              // Override the badge for Zn (legacy - now handled by 5-Trigger Framework)
              // if (znBadgeOverride) {
              //   urgencyBadge = znBadgeOverride;
              // }
            }

            // Add "Why ratios matter" tooltip for P:Zn Ratio
            const pznTooltip = attr === 'P_Zn_Ratio' ? `<span style="margin-left: 0.5rem; cursor: help; color: #64748b;" title="High phosphorus relative to zinc can reduce zinc uptake by plants even when soil Zn levels are moderate. This interaction is more likely in high-yield systems, sandy soils, and soils with low organic matter.">‚ÑπÔ∏è</span>` : '';

            html += `
              <div class="trend-card ${cardClass}">
                <div class="trend-header">
                  <h4 class="trend-title">${name}${pznTooltip}</h4>
                  <div style="display: flex; align-items: center; gap: 0.75rem;">
                    ${urgencyBadge ? `<span style="padding: 0.15rem 0.5rem; background: ${urgencyBadge.bg}; color: ${urgencyBadge.color}; font-size: 0.65rem; font-weight: 600; border-radius: 0.25rem; white-space: nowrap;">${urgencyBadge.emoji} ${urgencyBadge.label}</span>` : ''}
                    ${yearData.length > 1 ? `<div class="trend-pct" style="color:${color}; text-align: right;">${pctChange >= 0 ? '+' : ''}${pctChange.toFixed(1)}%<div class="trend-sub">${first.year} ‚Üí ${last.year}</div></div>` : ''}
                  </div>
                </div>
                <div class="trend-content">
                  <div class="trend-values">
                    <div style="font-size:0.7rem;color:#64748b;margin-bottom:0.25rem;display:flex;justify-content:space-between;padding:0 0.75rem;"><span></span><span style="width:70px;text-align:center;">Avg</span><span style="width:70px;text-align:center;">Median</span></div>
                    ${yearData.map((d, i) => `<div class="trend-row ${i % 2 === 0 ? 'alt' : ''}"><span class="trend-year">${d.year}:</span><span class="trend-value" style="width:70px;text-align:center;">${d.avg.toFixed(decimals)}</span><span class="trend-value" style="width:70px;text-align:center;color:#8b5cf6;">${d.median.toFixed(decimals)}</span></div>`).join('')}
                    ${yearData.length > 1 ? `<div class="trend-row" style="margin-top:0.5rem;border-top:2px solid ${color};padding-top:0.5rem;"><span>Change:</span><span style="width:70px;text-align:center;color:${color};font-weight:700;">${avgChange >= 0 ? '+' : ''}${avgChange.toFixed(decimals)}</span><span style="width:70px;text-align:center;color:#8b5cf6;font-weight:700;">${medianChange >= 0 ? '+' : ''}${medianChange.toFixed(decimals)}</span></div>` : ''}
                  </div>
                  <div class="trend-graph ${yearData.length > 10 ? 'xlarge' : (yearData.length > 5 ? 'large' : '')}">
                    <div style="display:flex;gap:1rem;font-size:0.7rem;margin-bottom:0.25rem;justify-content:center;">
                      <span><span style="color:${color};">‚óè</span> Average</span>
                      <span><span style="color:#8b5cf6;">‚óè</span> Median</span>
                    </div>
                    ${graph}
                  </div>
                </div>
                ${trendInsight ? `
                <div style="margin: 0.5rem 0; padding: 0.5rem 0.75rem; background: #f8fafc; border-radius: 0.375rem; font-size: 0.75rem;">
                  <div style="display: flex; flex-wrap: wrap; gap: 0.75rem; align-items: center;">
                    <span><strong>Trend:</strong> ${slope !== null ? `${slope >= 0 ? '+' : ''}${slope.toFixed(2)} ${attr === 'pH' ? '' : unit || 'ppm'}/yr` : 'N/A'}</span>
                    <span><strong>Stability:</strong> ${trendInsight.stability.metric} ${trendInsight.stability.value.toFixed(attr === 'pH' ? 2 : 1)}${attr === 'pH' ? '' : '%'} (${trendInsight.stability.label})</span>
                    <span><strong>Confidence:</strong> ${trendInsight.confidence} (${yearData.length} yrs)</span>
                  </div>
                </div>
                ` : ''}
                ${triggerCardHtml}
                ${moistureWarning}
                ${volatilityTooltip}
              </div>
            `;
          } catch (attrError) {
            console.error('Error processing attribute', attr, ':', attrError);
          }
        });

        console.log('Generated HTML length:', html.length);
        container.innerHTML = html || '<div class="no-data">No nutrient data available</div>';
      } catch (error) {
        console.error('Error in updateHistory:', error);
        container.innerHTML = `<div class="no-data" style="color: red;">Error loading data: ${error.message}</div>`;
      }
    }

    // Operation-wide trends (All Fields)
    function renderOperationTrends(container) {
      // Filter samples by active client/farm
      const activeFieldsList = getActiveFields();
      const filteredSamples = sampleData.filter(s => activeFieldsList.includes(s.field));

      const years = [...new Set(filteredSamples.map(s => s.year).filter(y => y))].sort();
      const allFields = [...new Set(filteredSamples.map(s => s.field).filter(f => f && f !== 'Unknown' && f !== 'Unassigned'))];

      if (years.length < 1) {
        container.innerHTML = '<div class="no-data">No data available for selected client/farm</div>';
        return;
      }

      // Calculate per-year statistics
      const yearStats = years.map(year => {
        const yearSamples = filteredSamples.filter(s => String(s.year) === String(year));
        const fieldsInYear = [...new Set(yearSamples.map(s => s.field).filter(f => f && f !== 'Unknown' && f !== 'Unassigned'))];
        return {
          year,
          sampleCount: yearSamples.length,
          fieldCount: fieldsInYear.length,
          fields: fieldsInYear
        };
      });

      const totalSamples = filteredSamples.length;
      const operationName = localStorage.getItem('operationName') || 'Operation';

      let html = `
        <div style="background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%); border: 2px solid #3b82f6; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem;">
          <h3 style="margin: 0 0 0.5rem 0; color: #1e40af;">üìä ${operationName} - All Fields Average</h3>
          <p style="margin: 0 0 0.5rem 0; color: #64748b; font-size: 0.875rem;">
            Operation-wide nutrient trends across <strong>${allFields.length} fields</strong> and <strong>${totalSamples.toLocaleString()} total samples</strong>
          </p>
          <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; font-size: 0.75rem;">
            ${yearStats.map(ys => `
              <span style="background: white; padding: 0.25rem 0.5rem; border-radius: 0.25rem; border: 1px solid #93c5fd;">
                <strong>${ys.year}:</strong> ${ys.sampleCount} samples, ${ys.fieldCount} fields
              </span>
            `).join('')}
          </div>
        </div>
      `;

      try {
        const visibleNutrients = getVisibleNutrients();

        visibleNutrients.forEach(attr => {
          try {
            const yearData = [];
            let hasData = false;

            years.forEach(year => {
              const yearSamples = filteredSamples.filter(s => String(s.year) === String(year));
              const stats = getStats(yearSamples, attr);

              // Calculate per-field averages for range band
              const fieldsInYear = [...new Set(yearSamples.map(s => s.field).filter(f => f && f !== 'Unknown' && f !== 'Unassigned'))];
              const fieldAvgs = fieldsInYear.map(field => {
                const fieldSamples = yearSamples.filter(s => s.field === field);
                const fieldStats = getStats(fieldSamples, attr);
                return fieldStats ? fieldStats.avg : null;
              }).filter(v => v !== null);

              if (stats) {
                yearData.push({
                  year,
                  avg: stats.avg,
                  median: stats.median,
                  count: stats.count,
                  fieldCount: fieldsInYear.length,
                  minFieldAvg: fieldAvgs.length > 0 ? Math.min(...fieldAvgs) : stats.avg,
                  maxFieldAvg: fieldAvgs.length > 0 ? Math.max(...fieldAvgs) : stats.avg
                });
                hasData = true;
              }
            });

            if (!hasData || yearData.length < 1) return;

            const first = yearData[0], last = yearData[yearData.length - 1];
            const avgChange = last.avg - first.avg;
            const medianChange = last.median - first.median;
            const pctChange = first.avg !== 0 ? (avgChange / first.avg) * 100 : 0;
            const isLowerBetter = CONFIG.LOWER_IS_BETTER.includes(attr);
            const isPositive = isLowerBetter ? avgChange < 0 : avgChange > 0;
            const decimals = getDecimals(attr);
            const name = CONFIG.NUTRIENT_NAMES[attr] || attr;

            let cardClass = 'neutral', color = '#64748b';
            if (yearData.length > 1) {
              cardClass = isPositive ? 'positive' : 'negative';
              color = isPositive ? '#22c55e' : '#ef4444';
            }

            const graph = createOperationTrendGraph(yearData, color);

            // Skip trend analysis for Buffer_pH and CEC (diagnostic measurements, not nutrients to manage)
            const skipTrendAnalysis = attr === 'Buffer_pH' || attr === 'CEC';

            // Calculate linear regression for trend slope
            const regressionData = yearData.map(d => ({ x: parseInt(d.year), y: d.avg }));
            const regression = !skipTrendAnalysis ? window.Utils.calculateLinearRegression(regressionData) : null;
            const slope = regression ? regression.slope : null;

            // Get comprehensive trend insight (skip for Buffer_pH)
            let trendInsight = null;
            let urgencyBadge = null;
            const unit = CONFIG.NUTRIENT_UNITS[attr] || '';
            if (!skipTrendAnalysis && yearData.length > 1) {
              // Get critical levels from Settings (with defaults)
              const criticalLevels = window.Utils.getCriticalLevels();
              trendInsight = window.Utils.getTrendInsight(yearData, attr, slope, criticalLevels);
              urgencyBadge = trendInsight ? window.Utils.getUrgencyBadge(trendInsight.urgency) : null;
            }

            // Get moisture warnings for P and K (operation-wide)
            let moistureWarning = '';
            if ((attr === 'P' || attr === 'K') && filteredSamples.length > 0) {
              const moistureConditions = filteredSamples
                .filter(s => s.soilMoistureCondition)
                .map(s => ({ year: s.year, moisture: s.soilMoistureCondition }));

              const hasDry = moistureConditions.some(m => m.moisture === 'dry');

              if (hasDry) {
                const pctHigher = attr === 'P' ? '15-25%' : '20-40%';
                moistureWarning = `<div style="margin-top: 0.5rem; font-size: 0.75rem; color: #92400e;">üåµ Includes dry samples - ${attr} may test ${pctHigher} higher than actual</div>`;
              }
            }

            // Variability causes expandable section for volatile data - NUTRIENT-SPECIFIC
            let volatilityTooltip = '';
            if (trendInsight && trendInsight.stability.label === 'Volatile') {
              const cvInfo = getNutrientCVExplanation(attr, trendInsight.stability.value);
              const driversHtml = cvInfo.drivers.map(d => `<li>${d}</li>`).join('');

              volatilityTooltip = `
                <details style="margin-top: 0.5rem; font-size: 0.75rem; color: #64748b;" open>
                  <summary style="cursor: pointer; color: #dc2626; font-weight: 500;">‚ö†Ô∏è ${cvInfo.title}</summary>
                  <div style="margin-top: 0.5rem; padding: 0.75rem; background: #fef2f2; border-radius: 0.375rem; border: 1px solid #fecaca;">
                    <p style="margin-bottom: 0.5rem; color: #991b1b;">${cvInfo.explanation}</p>
                    <p style="margin: 0.5rem 0 0.25rem 0; font-weight: 600; color: #475569; font-size: 0.7rem;">Common drivers:</p>
                    <ul style="margin: 0; padding-left: 1.25rem; color: #64748b; font-size: 0.7rem;">
                      ${driversHtml}
                    </ul>
                    <p style="margin-top: 0.75rem; padding: 0.5rem; background: #f0fdf4; border-radius: 0.25rem; color: #166534; font-weight: 500;">üí° ${cvInfo.suggestion}</p>
                  </div>
                </details>`;
            }

            // P:Zn Ratio insight box (comprehensive tiered system)
            let pznInsight = '';
            let pznBadgeOverride = null;
            if (attr === 'P_Zn_Ratio' && yearData.length > 0) {
              const mostRecentRatio = last.avg;
              const mostRecentYear = last.year;

              // Get current P and Zn values from most recent year's samples (operation-wide)
              const recentSamples = filteredSamples.filter(s => String(s.year) === String(mostRecentYear));
              const pValues = recentSamples.map(s => s.P).filter(v => v !== null && v !== undefined && !isNaN(v));
              const znValues = recentSamples.map(s => s.Zn).filter(v => v !== null && v !== undefined && !isNaN(v));
              const currentP = pValues.length > 0 ? pValues.reduce((a, b) => a + b, 0) / pValues.length : null;
              const currentZn = znValues.length > 0 ? znValues.reduce((a, b) => a + b, 0) / znValues.length : null;

              // Get Zn sufficiency threshold from settings (default 1.0 ppm)
              const settings = JSON.parse(localStorage.getItem('soilSettings') || '{}');
              const znOptimalMin = settings.Zn_min ?? 1.0;
              const znIsLow = currentZn !== null && currentZn < znOptimalMin;
              const znIsAdequate = currentZn !== null && currentZn >= znOptimalMin;

              // Determine ratio status
              const ratioIsNormal = mostRecentRatio <= 12;
              const ratioIsElevated = mostRecentRatio > 12 && mostRecentRatio <= 20;
              const ratioIsHighRisk = mostRecentRatio > 20;

              // Determine trend direction
              const trendUp = slope !== null && slope > 0.5;
              const trendDown = slope !== null && slope < -0.5;

              // Build trend message
              let trendMsg = '';
              if (trendUp) {
                trendMsg = '<div style="margin-top: 0.5rem; font-size: 0.8rem; color: #64748b;">üìà Ratio is trending upward, which may increase risk of zinc limitation in future seasons.</div>';
              } else if (trendDown) {
                trendMsg = '<div style="margin-top: 0.5rem; font-size: 0.8rem; color: #64748b;">üìâ Ratio is improving, suggesting nutrient balance is moving in a favorable direction.</div>';
              }

              // Stability warning
              let stabilityMsg = '';
              if (trendInsight && trendInsight.stability.label === 'Volatile') {
                stabilityMsg = '<div style="margin-top: 0.5rem; font-size: 0.8rem; color: #92400e;">‚ö†Ô∏è Year-to-year variability is high. Confirm trends with consistent sampling methods before making major adjustments.</div>';
              }

              // Current values display
              const valuesDisplay = `<div style="margin-top: 0.75rem; padding-top: 0.5rem; border-top: 1px solid #e2e8f0; font-size: 0.75rem; color: #64748b;">
                <strong>Operation averages:</strong> P: ${currentP !== null ? currentP.toFixed(0) : '?'} ppm | Zn: ${currentZn !== null ? currentZn.toFixed(1) : '?'} ppm | Ratio: ${mostRecentRatio.toFixed(0)}:1
              </div>`;

              // Generate insight based on case
              let bgColor, borderColor, textColor, emoji, insight, recommendation;

              if (ratioIsHighRisk && znIsLow) {
                // CASE 1: High ratio + Low Zn (Highest Risk)
                bgColor = '#fee2e2'; borderColor = '#fca5a5'; textColor = '#991b1b';
                emoji = 'üî¥';
                insight = 'High risk of zinc deficiency across operation. The P:Zn ratio is elevated and average zinc is below sufficiency.';
                recommendation = 'Consider zinc fertilization to correct deficiency and reduce imbalance. Review individual field reports for specific recommendations.';
                pznBadgeOverride = { emoji: 'üî¥', label: 'Action Required', color: '#dc2626', bg: '#fee2e2' };
              } else if (ratioIsHighRisk && znIsAdequate) {
                // CASE 2: High ratio + Adequate Zn
                bgColor = '#fed7aa'; borderColor = '#fdba74'; textColor = '#9a3412';
                emoji = 'üü†';
                insight = 'Imbalance present, zinc currently sufficient across operation. While zinc levels are currently adequate, high P relative to Zn can increase future deficiency risk.';
                recommendation = 'Monitor zinc levels and maintain balanced fertility. Review individual field P:Zn ratios for targeted adjustments.';
                pznBadgeOverride = { emoji: '‚ö†Ô∏è', label: 'Review', color: '#ca8a04', bg: '#fef9c3' };
              } else if (ratioIsElevated && znIsLow) {
                // CASE 3: Elevated ratio + Low Zn
                bgColor = '#fef9c3'; borderColor = '#fde047'; textColor = '#854d0e';
                emoji = 'üü°';
                insight = 'Zinc supply may limit phosphorus utilization. Moderate P:Zn imbalance combined with low zinc can reduce plant Zn uptake.';
                recommendation = 'Consider zinc supplementation and monitor ratio trends. Review individual field reports for priorities.';
                pznBadgeOverride = { emoji: '‚ö†Ô∏è', label: 'Review', color: '#ca8a04', bg: '#fef9c3' };
              } else if (ratioIsElevated && znIsAdequate) {
                // CASE 4: Elevated ratio + Adequate Zn
                bgColor = '#ecfdf5'; borderColor = '#a7f3d0'; textColor = '#065f46';
                emoji = 'üü¢';
                insight = 'Slight imbalance, no current deficiency indicated across operation. The P:Zn ratio is above typical balance ranges, but zinc supply appears sufficient.';
                recommendation = 'Continue monitoring zinc and ratio trends. No immediate correction needed if Zn remains adequate.';
                pznBadgeOverride = { emoji: '‚úì', label: 'Good', color: '#16a34a', bg: '#dcfce7' };
              } else {
                // CASE 5: Normal ratio (‚â§12:1)
                bgColor = '#dcfce7'; borderColor = '#86efac'; textColor = '#166534';
                emoji = '‚úÖ';
                insight = 'Balanced P and Zn relationship across operation. The P:Zn ratio is within commonly accepted balance ranges.';
                recommendation = 'Maintain current fertility strategy and monitor trends over time.';
                pznBadgeOverride = { emoji: '‚úì', label: 'Good', color: '#16a34a', bg: '#dcfce7' };
              }

              pznInsight = `
                <div style="margin-top: 0.75rem; padding: 0.75rem; background: ${bgColor}; border-radius: 0.375rem; border: 1px solid ${borderColor};">
                  <div style="font-size: 0.85rem; color: ${textColor};">
                    <strong>${emoji} ${insight}</strong>
                  </div>
                  <div style="margin-top: 0.5rem; font-size: 0.8rem; color: ${textColor};">
                    üí° <strong>Recommendation:</strong> ${recommendation}
                  </div>
                  ${trendMsg}
                  ${stabilityMsg}
                  ${valuesDisplay}
                </div>`;

              // Override the badge for P:Zn ratio
              if (pznBadgeOverride) {
                urgencyBadge = pznBadgeOverride;
              }
            }

            // Build the trend insight box (for non-P:Zn attributes)
            let trendInsightBox = '';
            if (trendInsight && attr !== 'P_Zn_Ratio') {
              trendInsightBox = `
                <div style="margin-top: 0.75rem; padding: 0.75rem; background: ${trendInsight.background}; border-radius: 0.375rem; border: 1px solid ${trendInsight.stability.color}40;">
                  <div style="font-size: 0.85rem; color: #1e293b;">
                    ${trendInsight.message}
                  </div>
                  ${trendInsight.yearsToCritical ? `
                    <div style="margin-top: 0.5rem; font-size: 0.8rem; color: #b91c1c; font-weight: 500;">
                      ‚è±Ô∏è ${trendInsight.yearsToCritical.message}
                    </div>
                  ` : ''}
                  ${moistureWarning}
                  ${volatilityTooltip}
                </div>`;
            }

            // Add "Why ratios matter" tooltip for P:Zn Ratio (operation-wide)
            const pznTooltip = attr === 'P_Zn_Ratio' ? `<span style="margin-left: 0.5rem; cursor: help; color: #64748b;" title="High phosphorus relative to zinc can reduce zinc uptake by plants even when soil Zn levels are moderate. This interaction is more likely in high-yield systems, sandy soils, and soils with low organic matter.">‚ÑπÔ∏è</span>` : '';

            // OM improvement tips (collapsible section) - operation-wide
            let omTips = '';
            if (attr === 'OM' && yearData.length > 0) {
              const currentOM = last.avg;
              const omSettings = JSON.parse(localStorage.getItem('soilSettings') || '{}');
              const omCritical = omSettings.OM_critical ?? 2.0;
              const omOptimalMin = omSettings.OM_min ?? 3.0;
              const trendIsDown = slope !== null && slope < 0;
              const trendIsFlat = slope !== null && slope >= -0.02 && slope <= 0.02;
              const isGoodBadge = urgencyBadge && urgencyBadge.label === 'Good';
              const isAboveOptimal = currentOM >= omOptimalMin;

              // Show tips when: OM < critical OR (OM < optimalMin AND trend flat/down)
              // Don't show when: OM above optimal AND badge is Good
              const showTips = (currentOM < omCritical) ||
                               (currentOM < omOptimalMin && (trendIsFlat || trendIsDown));
              const hideTips = isAboveOptimal && isGoodBadge;

              if (showTips && !hideTips) {
                omTips = `
                <div style="margin-top: 0.75rem; padding: 0.75rem; background: #eff6ff; border-radius: 0.375rem; border: 1px solid #bfdbfe; font-size: 0.8rem;">
                  <div style="font-weight: 500; color: #1e40af; margin-bottom: 0.5rem;">üí° How to improve OM</div>
                  <div style="margin-bottom: 0.5rem; color: #475569;">
                    <strong>üå± Cover crops:</strong> Multi-species mixes with maximum growing days. Fields below 2% respond strongly. Expect +0.1‚Äì0.3% OM/year with consistent use.
                  </div>
                  <div style="margin-bottom: 0.5rem; color: #475569;">
                    <strong>üöú Reduce tillage:</strong> No-till or strip-till slows carbon loss. Most effective when combined with residue retention and covers.
                  </div>
                  <div style="margin-bottom: 0.5rem; color: #475569;">
                    <strong>‚ôªÔ∏è Add organic carbon:</strong> Manure, compost, or high-residue rotations (corn, small grains) provide direct carbon inputs.
                  </div>
                  <div style="color: #64748b; font-style: italic;">
                    <strong>‚è±Ô∏è Expect gradual change:</strong> Realistic gains are 0.1‚Äì0.2% per year. OM building requires consistent multi-year practices.
                  </div>
                </div>`;
              }
            }

            // Zn improvement insights - operation-wide
            let znInsight = '';
            let znBadgeOverride = null;
            if (attr === 'Zn' && yearData.length > 0) {
              const currentZn = last.avg;
              const mostRecentYear = last.year;

              // Get current P value to calculate P:Zn ratio and dynamic target (operation-wide averages)
              const recentSamples = filteredSamples.filter(s => String(s.year) === String(mostRecentYear));
              const pValues = recentSamples.map(s => s.P).filter(v => v !== null && v !== undefined && !isNaN(v));
              const currentP = pValues.length > 0 ? pValues.reduce((a, b) => a + b, 0) / pValues.length : null;
              const pznRatio = (currentP !== null && currentZn > 0) ? currentP / currentZn : null;

              // Dynamic Zn target based on P level (to maintain 10:1 ratio)
              const standardMin = 1.5;
              const ratioBasedTarget = currentP !== null ? currentP / 10 : standardMin;
              const znTarget = Math.max(standardMin, ratioBasedTarget);
              const targetIsElevated = znTarget > standardMin;

              // Determine trend direction
              const trendUp = slope !== null && slope > 0.02;
              const trendDown = slope !== null && slope < -0.02;
              const trendFlat = slope !== null && slope >= -0.02 && slope <= 0.02;

              // Zn status based on dynamic target
              const znLow = currentZn < znTarget * 0.5;  // Below 50% of target
              const znMarginal = currentZn >= znTarget * 0.5 && currentZn < znTarget;  // 50-100% of target
              const znAdequate = currentZn >= znTarget;  // At or above target

              // Target display text
              const targetText = targetIsElevated
                ? `Target: ${znTarget.toFixed(1)} ppm (to maintain 10:1 ratio with P at ${currentP.toFixed(0)} ppm)`
                : `Target: ${znTarget.toFixed(1)} ppm (standard minimum)`;

              // Current values display (always shown)
              const valuesDisplay = `<div style="margin-top: 0.75rem; padding-top: 0.5rem; border-top: 1px solid #e2e8f0; font-size: 0.75rem; color: #64748b;">
                <strong>Operation avg Zn:</strong> ${currentZn.toFixed(1)} ppm | <strong>P:</strong> ${currentP !== null ? currentP.toFixed(0) : '?'} ppm | <strong>P:Zn Ratio:</strong> ${pznRatio !== null ? pznRatio.toFixed(0) + ':1' : '?'}
                <div style="margin-top: 0.25rem;"><strong>${targetText}</strong></div>
              </div>`;

              let bgColor, borderColor, textColor, emoji, insight, ratioNote, tips, trendMsg;

              if (znLow) {
                // CASE 1: Zn LOW (below 50% of target)
                bgColor = '#fee2e2'; borderColor = '#fca5a5'; textColor = '#991b1b';
                emoji = 'üî¥';
                insight = `Zinc is deficient across operation (${currentZn.toFixed(1)} ppm vs target ${znTarget.toFixed(1)} ppm).`;
                znBadgeOverride = { emoji: 'üî¥', label: 'Action Needed', color: '#dc2626', bg: '#fee2e2' };

                ratioNote = (pznRatio !== null && pznRatio > 12)
                  ? `<div style="margin-top: 0.5rem; color: ${textColor};">High P:Zn ratio (${pznRatio.toFixed(0)}:1) further reduces plant Zn uptake.</div>`
                  : '';

                if (trendDown) {
                  trendMsg = '<div style="margin-top: 0.5rem; font-size: 0.8rem; color: #991b1b;">üìâ Zn is declining, increasing deficiency risk.</div>';
                } else if (trendUp) {
                  trendMsg = '<div style="margin-top: 0.5rem; font-size: 0.8rem; color: #166534;">üìà Zn is improving but remains deficient.</div>';
                } else {
                  trendMsg = '';
                }

                tips = `
                  <div style="margin-top: 0.75rem; padding: 0.75rem; background: #fef2f2; border-radius: 0.375rem; border: 1px solid #fecaca; font-size: 0.8rem;">
                    <div style="font-weight: 500; color: #991b1b; margin-bottom: 0.5rem;">üí° How to raise Zn</div>
                    <div style="margin-bottom: 0.5rem; color: #475569;">
                      <strong>üöú Starter or banded Zn is most effective:</strong> Zinc is immobile in soil. Placing Zn near seed improves early uptake more reliably than broadcast.
                    </div>
                    <div style="margin-bottom: 0.5rem; color: #475569;">
                      <strong>üåø Foliar Zn for in-season rescue:</strong> Foliar application quickly corrects plant deficiency when soil uptake is limited.
                    </div>
                    <div style="color: #475569;">
                      <strong>üß± Build long-term with small annual additions:</strong> Repeated small soil applications build Zn more safely than one large dose.
                    </div>
                  </div>`;

              } else if (znMarginal) {
                // CASE 2: Zn MARGINAL (50-100% of target)
                bgColor = '#fef9c3'; borderColor = '#fde047'; textColor = '#854d0e';
                emoji = 'üü°';
                insight = `Zn is below target across operation (${currentZn.toFixed(1)} ppm vs target ${znTarget.toFixed(1)} ppm).`;
                znBadgeOverride = { emoji: '‚ö†Ô∏è', label: 'Watch', color: '#ca8a04', bg: '#fef9c3' };

                if (targetIsElevated) {
                  ratioNote = `<div style="margin-top: 0.5rem; color: ${textColor};">Target elevated due to high P (${currentP.toFixed(0)} ppm). Higher Zn needed to maintain 10:1 ratio.</div>`;
                } else if (pznRatio !== null && pznRatio > 12) {
                  ratioNote = `<div style="margin-top: 0.5rem; color: ${textColor};">P:Zn ratio (${pznRatio.toFixed(0)}:1) increases risk of P-induced Zn limitation.</div>`;
                } else {
                  ratioNote = '';
                }

                if (trendDown) {
                  trendMsg = '<div style="margin-top: 0.5rem; font-size: 0.8rem; color: #b91c1c;">üìâ Zn is declining away from target.</div>';
                } else if (trendUp) {
                  trendMsg = '<div style="margin-top: 0.5rem; font-size: 0.8rem; color: #166534;">üìà Zn is improving toward target.</div>';
                } else if (trendFlat) {
                  trendMsg = '<div style="margin-top: 0.5rem; font-size: 0.8rem; color: #64748b;">‚û°Ô∏è Zn is holding steady below target.</div>';
                } else {
                  trendMsg = '';
                }

                tips = `
                  <div style="margin-top: 0.75rem; padding: 0.75rem; background: #fefce8; border-radius: 0.375rem; border: 1px solid #fde047; font-size: 0.8rem;">
                    <div style="font-weight: 500; color: #854d0e; margin-bottom: 0.5rem;">üí° Managing below-target Zn</div>
                    <div style="margin-bottom: 0.5rem; color: #475569;">
                      <strong>üöú Consider starter or banded Zn:</strong> With below-target Zn, banded placement ensures early-season availability.
                    </div>
                    <div style="margin-bottom: 0.5rem; color: #475569;">
                      <strong>üìä Monitor tissue tests mid-season:</strong> Tissue testing confirms if plant is accessing enough Zn.
                    </div>
                    <div style="color: #475569;">
                      <strong>üß± Build toward target with annual additions:</strong> Small annual Zn applications build levels toward target over time.
                    </div>
                  </div>`;

              } else {
                // CASE 3: Zn ADEQUATE (at or above target)
                bgColor = '#dcfce7'; borderColor = '#86efac'; textColor = '#166534';
                emoji = '‚úÖ';
                insight = `Zinc is sufficient across operation (${currentZn.toFixed(1)} ppm meets target of ${znTarget.toFixed(1)} ppm).`;
                ratioNote = '';
                trendMsg = '';
                tips = '';
                znBadgeOverride = { emoji: '‚úì', label: 'Good', color: '#16a34a', bg: '#dcfce7' };

                // Add note if target was elevated due to high P
                if (targetIsElevated) {
                  ratioNote = `<div style="margin-top: 0.5rem; color: #166534;">Target was elevated to ${znTarget.toFixed(1)} ppm due to high P (${currentP.toFixed(0)} ppm). Zn level is adequate for balanced uptake.</div>`;
                }

                // Watch for decline if at edge of target
                if (trendDown && currentZn < znTarget * 1.2) {
                  trendMsg = '<div style="margin-top: 0.5rem; font-size: 0.8rem; color: #92400e;">üìâ Zn is declining. Monitor to ensure it stays above target.</div>';
                }
              }

              znInsight = `
                <div style="margin-top: 0.75rem; padding: 0.75rem; background: ${bgColor}; border-radius: 0.375rem; border: 1px solid ${borderColor};">
                  <div style="font-size: 0.85rem; color: ${textColor};">
                    <strong>${emoji} ${insight}</strong>
                  </div>
                  ${ratioNote}
                  ${trendMsg}
                  ${valuesDisplay}
                </div>
                ${tips}`;

              // Override the badge for Zn
              if (znBadgeOverride) {
                urgencyBadge = znBadgeOverride;
              }
            }

            html += `
              <div class="trend-card ${cardClass}">
                <div class="trend-header">
                  <h4 class="trend-title">${name}${pznTooltip}</h4>
                  <div style="display: flex; align-items: center; gap: 0.75rem;">
                    ${urgencyBadge ? `<span style="padding: 0.15rem 0.5rem; background: ${urgencyBadge.bg}; color: ${urgencyBadge.color}; font-size: 0.65rem; font-weight: 600; border-radius: 0.25rem; white-space: nowrap;">${urgencyBadge.emoji} ${urgencyBadge.label}</span>` : ''}
                    ${yearData.length > 1 ? `<div class="trend-pct" style="color:${color}; text-align: right;">${pctChange >= 0 ? '+' : ''}${pctChange.toFixed(1)}%<div class="trend-sub">${first.year} ‚Üí ${last.year}</div></div>` : ''}
                  </div>
                </div>
                <div class="trend-content">
                  <div class="trend-values">
                    <div style="font-size:0.65rem;color:#64748b;margin-bottom:0.25rem;display:flex;justify-content:space-between;padding:0 0.5rem;">
                      <span></span>
                      <span style="width:50px;text-align:center;">Avg</span>
                      <span style="width:50px;text-align:center;">Med</span>
                      <span style="width:70px;text-align:center;font-size:0.6rem;">Range</span>
                    </div>
                    ${yearData.map((d, i) => `
                      <div class="trend-row ${i % 2 === 0 ? 'alt' : ''}" style="font-size:0.8rem;">
                        <span class="trend-year">${d.year}:</span>
                        <span style="width:50px;text-align:center;">${d.avg.toFixed(decimals)}</span>
                        <span style="width:50px;text-align:center;color:#8b5cf6;">${d.median.toFixed(decimals)}</span>
                        <span style="width:70px;text-align:center;font-size:0.65rem;color:#94a3b8;">${d.minFieldAvg.toFixed(decimals)}-${d.maxFieldAvg.toFixed(decimals)}</span>
                      </div>
                    `).join('')}
                    ${yearData.length > 1 ? `
                      <div class="trend-row" style="margin-top:0.5rem;border-top:2px solid ${color};padding-top:0.5rem;">
                        <span>Change:</span>
                        <span style="width:50px;text-align:center;color:${color};font-weight:700;">${avgChange >= 0 ? '+' : ''}${avgChange.toFixed(decimals)}</span>
                        <span style="width:50px;text-align:center;color:#8b5cf6;font-weight:700;">${medianChange >= 0 ? '+' : ''}${medianChange.toFixed(decimals)}</span>
                        <span style="width:70px;"></span>
                      </div>
                    ` : ''}
                  </div>
                  <div class="trend-graph ${yearData.length > 10 ? 'xlarge' : (yearData.length > 5 ? 'large' : '')}">
                    <div style="display:flex;gap:0.75rem;font-size:0.65rem;margin-bottom:0.25rem;justify-content:center;">
                      <span><span style="color:${color};">‚óè</span> Avg</span>
                      <span><span style="color:#8b5cf6;">‚óè</span> Median</span>
                      <span style="color:#cbd5e1;">‚ñà Field Range</span>
                    </div>
                    ${graph}
                  </div>
                </div>
                ${trendInsight ? `
                <div style="margin: 0.5rem 0; padding: 0.5rem 0.75rem; background: #f8fafc; border-radius: 0.375rem; font-size: 0.75rem;">
                  <div style="display: flex; flex-wrap: wrap; gap: 0.75rem; align-items: center;">
                    <span><strong>Trend:</strong> ${slope !== null ? `${slope >= 0 ? '+' : ''}${slope.toFixed(2)} ${attr === 'pH' ? '' : unit || 'ppm'}/yr` : 'N/A'}</span>
                    <span><strong>Stability:</strong> ${trendInsight.stability.metric} ${trendInsight.stability.value.toFixed(attr === 'pH' ? 2 : 1)}${attr === 'pH' ? '' : '%'} (${trendInsight.stability.label})</span>
                    <span><strong>Confidence:</strong> ${trendInsight.confidence} (${yearData.length} yrs)</span>
                  </div>
                </div>
                ` : ''}
                ${trendInsightBox}
                ${pznInsight}
                ${omTips}
                ${znInsight}
              </div>
            `;
          } catch (attrError) {
            console.error('Error processing attribute', attr, ':', attrError);
          }
        });

        container.innerHTML = html || '<div class="no-data">No nutrient data available</div>';
      } catch (error) {
        console.error('Error in renderOperationTrends:', error);
        container.innerHTML = `<div class="no-data" style="color: red;">Error loading data: ${error.message}</div>`;
      }
    }

    // Graph with range band for operation trends
    function createOperationTrendGraph(yearData, avgColor) {
      if (yearData.length < 1) return '';
      const medianColor = '#8b5cf6';
      const numYears = yearData.length;

      // Get all values including range to determine scale
      const allValues = [
        ...yearData.map(d => d.avg),
        ...yearData.map(d => d.median),
        ...yearData.map(d => d.minFieldAvg),
        ...yearData.map(d => d.maxFieldAvg)
      ];
      const minVal = Math.min(...allValues) * 0.9, maxVal = Math.max(...allValues) * 1.1;
      const range = maxVal - minVal || 1;

      // Dynamic dimensions based on year count - larger for PDF readability
      const baseWidth = 450;
      const width = numYears <= 5 ? baseWidth : Math.max(baseWidth, numYears * 60);
      const height = numYears <= 5 ? 190 : (numYears <= 10 ? 230 : 290);
      const padLeft = 35, padRight = 35, padTop = 30, padBottom = 40;
      const gw = width - padLeft - padRight;
      const gh = height - padTop - padBottom;

      // Determine label skip interval - only skip for very many years
      const labelSkip = numYears > 15 ? 2 : (numYears > 10 ? 1 : 0);

      // Calculate points
      const avgPts = yearData.map((d, i) => {
        const x = padLeft + (yearData.length > 1 ? (i / (yearData.length - 1)) * gw : gw / 2);
        const y = padTop + gh - ((d.avg - minVal) / range) * gh;
        return { x, y, year: d.year, val: d.avg };
      });

      const medianPts = yearData.map((d, i) => {
        const x = padLeft + (yearData.length > 1 ? (i / (yearData.length - 1)) * gw : gw / 2);
        const y = padTop + gh - ((d.median - minVal) / range) * gh;
        return { x, y, year: d.year, val: d.median };
      });

      // Range band (min/max field averages)
      const rangePts = yearData.map((d, i) => {
        const x = padLeft + (yearData.length > 1 ? (i / (yearData.length - 1)) * gw : gw / 2);
        const yMin = padTop + gh - ((d.minFieldAvg - minVal) / range) * gh;
        const yMax = padTop + gh - ((d.maxFieldAvg - minVal) / range) * gh;
        return { x, yMin, yMax };
      });

      // Create range band path (polygon)
      let rangePath = '';
      if (yearData.length > 1) {
        const topPoints = rangePts.map(p => `${p.x},${p.yMax}`).join(' L');
        const bottomPoints = [...rangePts].reverse().map(p => `${p.x},${p.yMin}`).join(' L');
        rangePath = `<path d="M${topPoints} L${bottomPoints} Z" fill="#e2e8f0" opacity="0.5"/>`;
      } else {
        // Single point - draw a vertical line
        const p = rangePts[0];
        rangePath = `<line x1="${p.x}" y1="${p.yMin}" x2="${p.x}" y2="${p.yMax}" stroke="#cbd5e1" stroke-width="8" opacity="0.5"/>`;
      }

      // Create lines
      const avgLine = avgPts.map((p, i) => `${i === 0 ? 'M' : 'L'}${p.x},${p.y}`).join(' ');
      const medianLine = medianPts.map((p, i) => `${i === 0 ? 'M' : 'L'}${p.x},${p.y}`).join(' ');

      // Create dots
      const dotRadius = numYears > 10 ? 4 : 5;
      const avgDots = avgPts.map(p => `<circle cx="${p.x}" cy="${p.y}" r="${dotRadius}" fill="${avgColor}" stroke="white" stroke-width="2"/>`).join('');
      const medianDots = medianPts.map(p => `<circle cx="${p.x}" cy="${p.y}" r="${dotRadius}" fill="${medianColor}" stroke="white" stroke-width="2"/>`).join('');

      // Year labels - always show all for small datasets
      const yearLabels = avgPts.map((p, i) => {
        const showLabel = i === 0 || i === avgPts.length - 1 || (labelSkip === 0) || (labelSkip === 1 && i % 2 === 0) || (labelSkip === 2 && i % 3 === 0);
        if (!showLabel) return '';
        const fontSize = numYears > 12 ? 10 : 11;
        return `<text x="${p.x}" y="${height - 12}" text-anchor="middle" font-size="${fontSize}" font-weight="600" fill="#475569">${p.year}</text>`;
      }).join('');

      const sizeClass = numYears > 10 ? 'xlarge' : (numYears > 5 ? 'large' : '');

      return `<svg width="100%" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet" style="width:100%;height:auto;min-height:${height}px;" data-size="${sizeClass}">
        ${rangePath}
        <path d="${avgLine}" fill="none" stroke="${avgColor}" stroke-width="3" stroke-linecap="round"/>
        <path d="${medianLine}" fill="none" stroke="${medianColor}" stroke-width="2.5" stroke-linecap="round" stroke-dasharray="4,2"/>
        ${avgDots}
        ${medianDots}
        ${yearLabels}
      </svg>`;
    }

    function createLineGraph(yearData, color, attr = 'P') {
      if (yearData.length < 1) return '';
      const decimals = getDecimals(attr);
      const values = yearData.map(d => d.avg);
      const minVal = Math.min(...values) * 0.9, maxVal = Math.max(...values) * 1.1;
      const range = maxVal - minVal || 1;
      const width = 400, height = 140, pad = 20;
      const gw = width - pad * 2, gh = height - pad * 2 - 20;

      const pts = yearData.map((d, i) => {
        const x = pad + (yearData.length > 1 ? (i / (yearData.length - 1)) * gw : gw / 2);
        const y = pad + gh - ((d.avg - minVal) / range) * gh;
        return { x, y, year: d.year, val: d.avg };
      });

      const line = pts.map((p, i) => `${i === 0 ? 'M' : 'L'}${p.x},${p.y}`).join(' ');
      const dots = pts.map(p => `<circle cx="${p.x}" cy="${p.y}" r="6" fill="${color}" stroke="white" stroke-width="2"/><text x="${p.x}" y="${height - 5}" text-anchor="middle" font-size="11" fill="#64748b">${p.year}</text><text x="${p.x}" y="${p.y - 12}" text-anchor="middle" font-size="12" font-weight="700" fill="#1e293b">${p.val.toFixed(decimals)}</text>`).join('');

      return `<svg width="100%" height="${height}" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet"><path d="${line}" fill="none" stroke="${color}" stroke-width="3" stroke-linecap="round"/>${dots}</svg>`;
    }

    function createDualLineGraph(yearData, avgColor, attr = 'P') {
      if (yearData.length < 1) return '';
      const medianColor = '#8b5cf6'; // Purple for median
      const numYears = yearData.length;
      const decimals = getDecimals(attr);

      // Get all values to determine scale
      const allValues = [...yearData.map(d => d.avg), ...yearData.map(d => d.median)];
      const minVal = Math.min(...allValues) * 0.85, maxVal = Math.max(...allValues) * 1.15;
      const range = maxVal - minVal || 1;

      // Dynamic dimensions based on year count - larger for PDF readability
      const baseWidth = 450;  // Wider base for better label spacing
      const width = numYears <= 5 ? baseWidth : Math.max(baseWidth, numYears * 60);
      const height = numYears <= 5 ? 180 : (numYears <= 10 ? 220 : 280);
      const padLeft = 35, padRight = 35, padTop = 30, padBottom = 40; // More padding for labels
      const gw = width - padLeft - padRight;
      const gh = height - padTop - padBottom;

      // Determine label skip interval - only skip for very many years
      const labelSkip = numYears > 15 ? 2 : (numYears > 10 ? 1 : 0);

      // Calculate points for both lines
      const avgPts = yearData.map((d, i) => {
        const x = padLeft + (yearData.length > 1 ? (i / (yearData.length - 1)) * gw : gw / 2);
        const y = padTop + gh - ((d.avg - minVal) / range) * gh;
        return { x, y, year: d.year, val: d.avg, idx: i };
      });

      const medianPts = yearData.map((d, i) => {
        const x = padLeft + (yearData.length > 1 ? (i / (yearData.length - 1)) * gw : gw / 2);
        const y = padTop + gh - ((d.median - minVal) / range) * gh;
        return { x, y, year: d.year, val: d.median, idx: i };
      });

      // Create path lines
      const avgLine = avgPts.map((p, i) => `${i === 0 ? 'M' : 'L'}${p.x},${p.y}`).join(' ');
      const medianLine = medianPts.map((p, i) => `${i === 0 ? 'M' : 'L'}${p.x},${p.y}`).join(' ');

      // Create dots - smaller for many years
      const dotRadius = numYears > 10 ? 4 : 5;
      const avgDots = avgPts.map(p => `<circle cx="${p.x}" cy="${p.y}" r="${dotRadius}" fill="${avgColor}" stroke="white" stroke-width="2"/>`).join('');
      const medianDots = medianPts.map(p => `<circle cx="${p.x}" cy="${p.y}" r="${dotRadius}" fill="${medianColor}" stroke="white" stroke-width="2"/>`).join('');

      // Year labels at bottom - always show all for small datasets
      const yearLabels = avgPts.map((p, i) => {
        // Always show first and last, skip middle ones only for very many years
        const showLabel = i === 0 || i === avgPts.length - 1 || (labelSkip === 0) || (labelSkip === 1 && i % 2 === 0) || (labelSkip === 2 && i % 3 === 0);
        if (!showLabel) return '';
        const fontSize = numYears > 12 ? 10 : 11;
        return `<text x="${p.x}" y="${height - 12}" text-anchor="middle" font-size="${fontSize}" font-weight="600" fill="#475569">${p.year}</text>`;
      }).join('');

      // Value labels - show for up to 10 years
      let avgLabels = '', medianLabels = '';
      if (numYears <= 10) {
        avgLabels = avgPts.map((p, i) => {
          const medianY = medianPts[i].y;
          const gap = Math.abs(p.y - medianY);
          let offset = gap < 20 ? (p.y < medianY ? -12 : 16) : -12;
          const fontSize = numYears > 6 ? 9 : 10;
          return `<text x="${p.x}" y="${p.y + offset}" text-anchor="middle" font-size="${fontSize}" font-weight="700" fill="${avgColor}">${p.val.toFixed(decimals)}</text>`;
        }).join('');

        medianLabels = medianPts.map((p, i) => {
          const avgY = avgPts[i].y;
          const gap = Math.abs(p.y - avgY);
          let offset = gap < 20 ? (p.y <= avgY ? -12 : 16) : 16;
          const fontSize = numYears > 6 ? 9 : 10;
          return `<text x="${p.x}" y="${p.y + offset}" text-anchor="middle" font-size="${fontSize}" font-weight="700" fill="${medianColor}">${p.val.toFixed(decimals)}</text>`;
        }).join('');
      }

      // Add size class hint via data attribute
      const sizeClass = numYears > 10 ? 'xlarge' : (numYears > 5 ? 'large' : '');

      return `<svg viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet" style="width:100%;height:auto;min-height:${height}px;" data-size="${sizeClass}">
        <path d="${avgLine}" fill="none" stroke="${avgColor}" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
        <path d="${medianLine}" fill="none" stroke="${medianColor}" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" stroke-dasharray="6,3"/>
        ${avgDots}${medianDots}
        ${yearLabels}
        ${avgLabels}${medianLabels}
      </svg>`;
    }

    // ========== TAB 3: Field Rankings ==========
    function updateRankings() {
      const container = document.getElementById('rankingsContent');
      const attr = document.getElementById('rankingAttrSelect').value;
      const yearOption = document.getElementById('rankingYearSelect').value;

      if (!attr) {
        container.innerHTML = '<div class="no-data">Select nutrient</div>';
        return;
      }

      // Filter samples by active client/farm
      const activeFieldsList = getActiveFields();
      const filteredSamples = sampleData.filter(s => activeFieldsList.includes(s.field));

      // Get all unique fields from filtered samples
      const allFields = [...new Set(filteredSamples.map(s => s.field).filter(f => f && f !== 'Unknown'))];

      const fieldStats = allFields.map(field => {
        // Get samples for this field
        let fieldSamples = filteredSamples.filter(s => s.field === field);
        
        if (yearOption === 'most_recent') {
          // Find most recent year for this field
          const fieldYears = [...new Set(fieldSamples.map(s => s.year).filter(y => y))].sort((a, b) => b - a);
          if (fieldYears.length === 0) return null;
          const mostRecentYear = fieldYears[0];
          fieldSamples = fieldSamples.filter(s => String(s.year) === String(mostRecentYear));
          const stats = getStats(fieldSamples, attr);
          return stats ? { field, avg: stats.avg, high: stats.high, low: stats.low, count: stats.count, year: mostRecentYear } : null;
        } else {
          // Filter by selected year
          fieldSamples = fieldSamples.filter(s => String(s.year) === String(yearOption));
          const stats = getStats(fieldSamples, attr);
          return stats ? { field, avg: stats.avg, high: stats.high, low: stats.low, count: stats.count, year: yearOption } : null;
        }
      }).filter(f => f);
      
      const isLowerBetter = CONFIG.LOWER_IS_BETTER.includes(attr);
      fieldStats.sort((a, b) => isLowerBetter ? a.avg - b.avg : b.avg - a.avg);
      
      const name = CONFIG.NUTRIENT_NAMES[attr] || attr;
      const unit = CONFIG.NUTRIENT_UNITS[attr] || '';
      const decimals = getDecimals(attr);
      const maxAvg = Math.max(...fieldStats.map(f => f.avg));
      const minAvg = Math.min(...fieldStats.map(f => f.avg));
      
      // Add Year column if using Most Recent
      const showYearCol = yearOption === 'most_recent';
      
      let html = `<table class="rankings-table"><thead><tr><th>Rank</th><th>Field</th>${showYearCol ? '<th>Year</th>' : ''}<th>Average</th><th>High</th><th>Low</th><th>Samples</th></tr></thead><tbody>`;
      
      fieldStats.forEach((f, i) => {
        const isTop = f.avg === (isLowerBetter ? minAvg : maxAvg);
        const isBottom = f.avg === (isLowerBetter ? maxAvg : minAvg);
        html += `<tr><td class="rank">#${i + 1}</td><td class="field">${f.field}</td>${showYearCol ? `<td>${f.year}</td>` : ''}<td class="value ${isTop ? 'high' : isBottom ? 'low' : ''}">${f.avg.toFixed(decimals)} ${unit}</td><td>${f.high.toFixed(decimals)}</td><td>${f.low.toFixed(decimals)}</td><td>${f.count}</td></tr>`;
      });
      
      html += '</tbody></table>';
      container.innerHTML = fieldStats.length > 0 ? html : '<div class="no-data">No data available</div>';
    }
    
    // ========== TAB 4: Yield Correlation ==========
    function updateYieldAnalysis() {
      const container = document.getElementById('yieldContent');
      const cropFilter = document.getElementById('yieldCropSelect').value;
      const yearFilter = document.getElementById('yieldYearSelect').value;
      const soilYearFilter = document.getElementById('soilYearSelect').value;
      const fieldFilter = document.getElementById('yieldFieldSelect').value;

      // Filter by active client/farm first
      const activeFieldsList = getActiveFields();
      const filteredSamples = sampleData.filter(s => activeFieldsList.includes(s.field));

      // Get samples with yield correlations
      let samplesWithYield = filteredSamples.filter(s => s.yieldCorrelations && Object.keys(s.yieldCorrelations).length > 0);

      if (samplesWithYield.length === 0) {
        container.innerHTML = '<div class="no-data">No yield data available. Import yield maps on the Import page to see correlations.</div>';
        return;
      }

      // Filter by field
      if (fieldFilter !== 'all') {
        samplesWithYield = samplesWithYield.filter(s => s.field === fieldFilter);
      }

      // Filter by soil sample year
      let soilYearDescription = '';
      if (soilYearFilter === 'recent') {
        // Use only the most recent soil sample at each location
        // Group by approximate location (rounded to 5 decimal places ~1m precision)
        const locationMap = new Map();
        samplesWithYield.forEach(sample => {
          const locKey = `${sample.lat.toFixed(5)},${sample.lon.toFixed(5)}`;
          const existing = locationMap.get(locKey);
          if (!existing || (sample.year && sample.year > existing.year)) {
            locationMap.set(locKey, sample);
          }
        });
        samplesWithYield = Array.from(locationMap.values());
        soilYearDescription = 'Most recent at each location';
      } else if (soilYearFilter === 'all') {
        // Use all soil samples (may have multiple per location)
        soilYearDescription = 'All years (may include duplicates)';
      } else {
        // Filter to specific soil sample year
        const selectedYear = parseInt(soilYearFilter);
        samplesWithYield = samplesWithYield.filter(s => s.year === selectedYear);
        soilYearDescription = `${selectedYear} only`;
      }

      // Get soil sample year range (after filtering)
      const soilYears = [...new Set(samplesWithYield.map(s => s.year).filter(y => y))].sort();
      const soilYearRange = soilYears.length > 0
        ? (soilYears.length === 1 ? `${soilYears[0]}` : `${Math.min(...soilYears)}-${Math.max(...soilYears)}`)
        : 'N/A';

      // Get all available yield years (before filtering)
      const allYieldYears = new Set();
      samplesWithYield.forEach(sample => {
        Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
          if (cropFilter === 'all' || yieldInfo.crop === cropFilter) {
            allYieldYears.add(parseInt(year));
          }
        });
      });
      const sortedYieldYears = [...allYieldYears].sort();

      // Build correlation data points based on yearFilter mode
      const dataPoints = [];
      const uniqueLocations = samplesWithYield.length;

      if (yearFilter === 'avg') {
        // ALL YEARS (AVERAGE): Average yield across all years at each location
        samplesWithYield.forEach(sample => {
          const validYields = [];
          Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
            if (cropFilter === 'all' || yieldInfo.crop === cropFilter) {
              validYields.push({
                yield: yieldInfo.avgYield,
                crop: yieldInfo.crop,
                pointCount: yieldInfo.pointCount
              });
            }
          });

          if (validYields.length > 0) {
            const avgYield = validYields.reduce((sum, v) => sum + v.yield, 0) / validYields.length;
            dataPoints.push({
              ...sample,
              yieldYear: 'avg',
              avgYield: avgYield,
              crop: validYields[0].crop,
              yieldPointCount: validYields.reduce((sum, v) => sum + v.pointCount, 0),
              yearsAveraged: validYields.length
            });
          }
        });
      } else if (yearFilter === 'combined') {
        // ALL YEARS (COMBINED): Each year is a separate data point
        samplesWithYield.forEach(sample => {
          Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
            if (cropFilter === 'all' || yieldInfo.crop === cropFilter) {
              dataPoints.push({
                ...sample,
                yieldYear: parseInt(year),
                avgYield: yieldInfo.avgYield,
                crop: yieldInfo.crop,
                yieldPointCount: yieldInfo.pointCount
              });
            }
          });
        });
      } else if (yearFilter === 'normalized') {
        // ALL YEARS (YEAR-NORMALIZED): Each year separate, but yields as % of year average
        // First calculate year averages
        const yearTotals = {};
        const yearCounts = {};
        samplesWithYield.forEach(sample => {
          Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
            if (cropFilter === 'all' || yieldInfo.crop === cropFilter) {
              const yr = parseInt(year);
              if (!yearTotals[yr]) {
                yearTotals[yr] = 0;
                yearCounts[yr] = 0;
              }
              yearTotals[yr] += yieldInfo.avgYield;
              yearCounts[yr]++;
            }
          });
        });

        const yearAverages = {};
        Object.keys(yearTotals).forEach(yr => {
          yearAverages[yr] = yearTotals[yr] / yearCounts[yr];
        });

        // Now create data points with normalized yields
        samplesWithYield.forEach(sample => {
          Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
            if (cropFilter === 'all' || yieldInfo.crop === cropFilter) {
              const yr = parseInt(year);
              const yearAvg = yearAverages[yr];
              const normalizedYield = (yieldInfo.avgYield / yearAvg) * 100; // % of year average

              dataPoints.push({
                ...sample,
                yieldYear: yr,
                avgYield: normalizedYield, // This is now % of year average
                rawYield: yieldInfo.avgYield, // Store original
                yearAvg: yearAvg,
                crop: yieldInfo.crop,
                yieldPointCount: yieldInfo.pointCount,
                isYearNormalized: true
              });
            }
          });
        });
      } else {
        // SPECIFIC YEAR: Only use yield from that year
        samplesWithYield.forEach(sample => {
          const yieldInfo = sample.yieldCorrelations[yearFilter];
          if (yieldInfo && (cropFilter === 'all' || yieldInfo.crop === cropFilter)) {
            dataPoints.push({
              ...sample,
              yieldYear: parseInt(yearFilter),
              avgYield: yieldInfo.avgYield,
              crop: yieldInfo.crop,
              yieldPointCount: yieldInfo.pointCount
            });
          }
        });
      }

      if (dataPoints.length === 0) {
        container.innerHTML = '<div class="no-data">No matching yield data for selected filters.</div>';
        return;
      }

      // Check if year-normalized mode - adjust label
      const isYearNormalized = yearFilter === 'normalized';

      // Check if normalization is enabled
      const normalizeByField = document.getElementById('yieldNormalizeToggle').checked;
      let fieldAverages = {};
      let fieldAvgRange = { min: Infinity, max: -Infinity };
      let yieldLabel = isYearNormalized ? 'Yield (% of Year Avg)' : 'Yield (bu/ac)';
      let normalizeNote = '';

      if (normalizeByField) {
        // Calculate average yield for each field
        const fieldYields = {};
        dataPoints.forEach(dp => {
          const field = dp.field || 'Unknown';
          if (!fieldYields[field]) fieldYields[field] = [];
          fieldYields[field].push(dp.avgYield);
        });

        // Calculate field averages
        Object.entries(fieldYields).forEach(([field, yields]) => {
          const avg = yields.reduce((a, b) => a + b, 0) / yields.length;
          fieldAverages[field] = avg;
          if (avg < fieldAvgRange.min) fieldAvgRange.min = avg;
          if (avg > fieldAvgRange.max) fieldAvgRange.max = avg;
        });

        // Convert yields to % of field average
        dataPoints.forEach(dp => {
          const field = dp.field || 'Unknown';
          const fieldAvg = fieldAverages[field];
          dp.rawYield = dp.avgYield; // Store original
          dp.avgYield = (dp.avgYield / fieldAvg) * 100; // Convert to %
          dp.fieldAvg = fieldAvg;
        });

        yieldLabel = 'Yield (% of Field Avg)';
        const fieldCount = Object.keys(fieldAverages).length;
        normalizeNote = `<div style="background: #fef3c7; border: 1px solid #f59e0b; border-radius: 0.375rem; padding: 0.5rem; margin-bottom: 0.75rem; font-size: 0.8rem; color: #92400e;">
          <strong>üìä Normalized by Field Productivity</strong><br>
          Yields converted to % of each field's average to isolate nutrient effect.<br>
          Field averages range from <strong>${fieldAvgRange.min.toFixed(0)}</strong> to <strong>${fieldAvgRange.max.toFixed(0)}</strong> bu/ac across ${fieldCount} fields.
          <br><span style="font-size: 0.75rem; color: #b45309;">100% = field average ‚Ä¢ >100% = above average ‚Ä¢ <100% = below average</span>
        </div>`;
      }

      // Calculate correlations for each nutrient
      const visibleNutrients = getVisibleNutrients();
      const correlations = [];

      console.log('=== YIELD CORRELATION DEBUG ===');
      console.log('Crop filter:', cropFilter);
      console.log('Year filter:', yearFilter);
      console.log('Yield years found for this crop:', sortedYieldYears);
      console.log('Data points:', dataPoints.length);
      console.log('Unique locations:', uniqueLocations);
      // Debug: show sample yieldCorrelations structure
      if (samplesWithYield.length > 0) {
        const sampleYC = samplesWithYield[0].yieldCorrelations;
        console.log('Sample yieldCorrelations keys:', Object.keys(sampleYC));
        console.log('Sample yieldCorrelations crops:', Object.values(sampleYC).map(v => v.crop));
      }

      visibleNutrients.forEach(nutrient => {
        // Filter for valid numeric values - must handle strings, empty values, etc.
        const pairs = dataPoints.filter(d => {
          const val = d[nutrient];
          if (val === undefined || val === null || val === '') return false;
          const num = parseFloat(val);
          return isFinite(num);
        });
        console.log(`  ${nutrient}: ${pairs.length} valid pairs (need 5+)`);
        if (pairs.length < 5) return; // Need at least 5 points

        const correlation = calculateCorrelation(
          pairs.map(p => parseFloat(p[nutrient])),
          pairs.map(p => p.avgYield)
        );

        if (correlation !== null && !isNaN(correlation.r)) {
          correlations.push({
            nutrient,
            name: CONFIG.NUTRIENT_NAMES[nutrient] || nutrient,
            r: correlation.r,
            r2: correlation.r2,
            n: pairs.length,
            significance: getSignificance(correlation.r, pairs.length)
          });
        }
      });

      // Store correlations globally for re-sorting
      yieldCorrelationsData = correlations;

      // Apply current sort
      sortYieldCorrelations();

      // Get summary stats
      const avgYield = dataPoints.reduce((sum, d) => sum + d.avgYield, 0) / dataPoints.length;
      const crops = [...new Set(dataPoints.map(d => d.crop))];
      const usedYieldYears = yearFilter === 'avg' || yearFilter === 'combined'
        ? sortedYieldYears
        : [parseInt(yearFilter)];

      // Get yield search radius values for selected crop only
      const radiusValues = new Set();
      samplesWithYield.forEach(sample => {
        Object.values(sample.yieldCorrelations).forEach(yieldInfo => {
          if (yieldInfo.radiusFt && yieldInfo.crop === cropFilter) {
            radiusValues.add(yieldInfo.radiusFt);
          }
        });
      });
      const radiusNote = radiusValues.size > 0
        ? `<br><strong>Yield Search Radius (${cropFilter}):</strong> ${[...radiusValues].sort((a,b) => a-b).join(', ')} ft`
        : '';

      const getSortIcon = (col) => {
        if (yieldSortColumn !== col) return '<span style="opacity: 0.3; font-size: 0.75rem;">&#9650;&#9660;</span>';
        return yieldSortDirection === 'asc' ? '<span style="color: #3b82f6;">&#9650;</span>' : '<span style="color: #3b82f6;">&#9660;</span>';
      };

      // Build description based on mode
      let modeDescription = '';
      if (yearFilter === 'avg') {
        modeDescription = `<div style="font-size: 0.8rem; color: #64748b;">${uniqueLocations} locations √ó avg of ${sortedYieldYears.length} yield years</div>`;
      } else if (yearFilter === 'combined') {
        modeDescription = `<div style="font-size: 0.8rem; color: #64748b;">${uniqueLocations} locations √ó ${sortedYieldYears.length} yield years</div>`;
      } else {
        modeDescription = `<div style="font-size: 0.8rem; color: #64748b;">${dataPoints.length} locations with ${yearFilter} yield</div>`;
      }

      let html = `
        <div style="background: #f0f9ff; border: 1px solid #0ea5e9; border-radius: 0.5rem; padding: 0.75rem; margin-bottom: 1rem; font-size: 0.8rem; color: #0369a1;">
          <strong>Data Selection:</strong><br>
          <strong>Soil Samples:</strong> ${soilYearDescription} (${soilYearRange})<br>
          <strong>Yield Years:</strong> ${usedYieldYears.join(', ')}
          ${yearFilter === 'avg' ? ' <em>(averaged at each location)</em>' : yearFilter === 'combined' ? ' <em>(each year = separate data point)</em>' : ''}${radiusNote}
        </div>

        ${normalizeNote}

        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1.5rem;">
          <div style="background: #fef3c7; border: 2px solid #f59e0b; border-radius: 0.5rem; padding: 1rem; text-align: center;">
            <div style="font-size: 2rem; font-weight: 700; color: #92400e;">${dataPoints.length}</div>
            <div style="color: #92400e; font-size: 0.875rem;">Data Points</div>
            ${modeDescription}
          </div>
          <div style="background: #f0fdf4; border: 2px solid #22c55e; border-radius: 0.5rem; padding: 1rem; text-align: center;">
            <div style="font-size: 2rem; font-weight: 700; color: #166534;">${avgYield.toFixed(1)}${normalizeByField ? '%' : ''}</div>
            <div style="color: #166534; font-size: 0.875rem;">${normalizeByField ? 'Avg Yield (% of Field)' : 'Avg Yield (bu/ac)'}</div>
          </div>
          <div style="background: #eff6ff; border: 2px solid #3b82f6; border-radius: 0.5rem; padding: 1rem; text-align: center;">
            <div style="font-size: 1.25rem; font-weight: 600; color: #1e40af;">${crops.map(c => c === 'corn' ? 'üåΩ' : 'ü´ò').join(' ')}</div>
            <div style="color: #1e40af; font-size: 0.875rem;">Yield Years: ${usedYieldYears.join(', ')}</div>
          </div>
        </div>

        <h3 style="margin: 0 0 1rem 0; color: #1e293b;">Nutrient-Yield Correlations</h3>
        <p style="color: #64748b; font-size: 0.875rem; margin-bottom: 0.5rem;">Shows how each soil nutrient correlates with crop yield at matched sample locations. Click column headers to sort.</p>
        <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 0.375rem; padding: 0.75rem; margin-bottom: 1rem; font-size: 0.8rem; color: #475569;">
          <strong>How to read this table:</strong><br>
          <strong>r (Correlation)</strong> ranges from -1 to +1. Positive = higher nutrient, higher yield. Negative = higher nutrient, lower yield. Values closer to +/-1 indicate stronger relationships.<br>
          <strong>R¬≤ (R-squared)</strong> shows what % of yield variation is explained by this nutrient. Example: R¬≤=25% means 25% of yield differences can be attributed to this nutrient.<br>
          <strong>Significance:</strong> *** = strong (|r| > 0.7), ** = moderate (|r| > 0.4), * = weak (|r| > 0.2), - = no meaningful correlation
        </div>

        <table class="rankings-table" id="yieldCorrelationTable">
          <thead>
            <tr>
              <th class="sortable-header" onclick="sortYieldTable('name')" style="cursor: pointer;">Nutrient ${getSortIcon('name')}</th>
              <th class="sortable-header" onclick="sortYieldTable('r')" style="cursor: pointer;">Correlation (r) ${getSortIcon('r')}</th>
              <th class="sortable-header" onclick="sortYieldTable('r2')" style="cursor: pointer;">R¬≤ ${getSortIcon('r2')}</th>
              <th class="sortable-header" onclick="sortYieldTable('significance')" style="cursor: pointer;">Significance ${getSortIcon('significance')}</th>
              <th class="sortable-header" onclick="sortYieldTable('n')" style="cursor: pointer;">Samples ${getSortIcon('n')}</th>
            </tr>
          </thead>
          <tbody id="yieldCorrelationBody">
      `;

      html += renderYieldCorrelationRows();

      html += '</tbody></table>';

      if (yieldCorrelationsData.length === 0) {
        html = '<div class="no-data">Not enough data points to calculate correlations. Need at least 5 samples with yield data.</div>';
      }

      container.innerHTML = html;

      // Initialize scatter plot
      populateScatterSelect();
      drawScatterPlot();
    }

    function calculateCorrelation(x, y) {
      const n = x.length;
      if (n < 3) return null;
      
      const sumX = x.reduce((a, b) => a + b, 0);
      const sumY = y.reduce((a, b) => a + b, 0);
      const sumXY = x.reduce((total, xi, i) => total + xi * y[i], 0);
      const sumX2 = x.reduce((total, xi) => total + xi * xi, 0);
      const sumY2 = y.reduce((total, yi) => total + yi * yi, 0);
      
      const numerator = n * sumXY - sumX * sumY;
      const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
      
      if (denominator === 0) return null;
      
      const r = numerator / denominator;
      return { r, r2: r * r };
    }
    
    function getSignificance(r, n) {
      // Simplified significance based on r value and sample size
      const absR = Math.abs(r);
      if (n < 10) return 'insufficient';
      if (absR > 0.7) return 'high';
      if (absR > 0.4) return 'medium';
      if (absR > 0.2) return 'low';
      return 'none';
    }

    // Sort the yield correlations data array
    function sortYieldCorrelations() {
      const sigOrder = { 'high': 3, 'medium': 2, 'low': 1, 'none': 0, 'insufficient': -1 };

      yieldCorrelationsData.sort((a, b) => {
        let aVal, bVal;

        switch (yieldSortColumn) {
          case 'name':
            aVal = a.name.toLowerCase();
            bVal = b.name.toLowerCase();
            return yieldSortDirection === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
          case 'r':
            // Sort by absolute value for correlation
            aVal = Math.abs(a.r);
            bVal = Math.abs(b.r);
            break;
          case 'r2':
            aVal = a.r2;
            bVal = b.r2;
            break;
          case 'significance':
            aVal = sigOrder[a.significance] || 0;
            bVal = sigOrder[b.significance] || 0;
            break;
          case 'n':
            aVal = a.n;
            bVal = b.n;
            break;
          default:
            aVal = Math.abs(a.r);
            bVal = Math.abs(b.r);
        }

        if (yieldSortDirection === 'asc') {
          return aVal - bVal;
        } else {
          return bVal - aVal;
        }
      });
    }

    // Render just the table rows (for re-sorting without rebuilding header)
    function renderYieldCorrelationRows() {
      let rows = '';
      yieldCorrelationsData.forEach(c => {
        const color = c.r > 0 ? '#22c55e' : '#ef4444';
        const barWidth = Math.abs(c.r) * 100;
        const significance = c.significance === 'high' ? '***' : c.significance === 'medium' ? '**' : c.significance === 'low' ? '*' : '-';
        const sigColor = c.significance === 'high' ? '#22c55e' : c.significance === 'medium' ? '#f59e0b' : '#94a3b8';

        rows += `
          <tr>
            <td class="field">${c.name}</td>
            <td>
              <div style="display: flex; align-items: center; gap: 0.5rem;">
                <div style="width: 80px; height: 12px; background: #e2e8f0; border-radius: 6px; overflow: hidden;">
                  <div style="width: ${barWidth}%; height: 100%; background: ${color}; ${c.r < 0 ? 'margin-left: auto;' : ''}"></div>
                </div>
                <span style="font-weight: 600; color: ${color};">${c.r > 0 ? '+' : ''}${c.r.toFixed(3)}</span>
              </div>
            </td>
            <td>${(c.r2 * 100).toFixed(1)}%</td>
            <td style="color: ${sigColor};">${significance}</td>
            <td>${c.n}</td>
          </tr>
        `;
      });
      return rows;
    }

    // Handle column header click to sort (attached to window for inline onclick)
    window.sortYieldTable = function(column) {
      if (yieldSortColumn === column) {
        // Toggle direction if same column
        yieldSortDirection = yieldSortDirection === 'asc' ? 'desc' : 'asc';
      } else {
        // New column, default to desc (highest first)
        yieldSortColumn = column;
        yieldSortDirection = 'desc';
      }

      // Re-run the full update to rebuild with new sort
      updateYieldAnalysis();
    };

    // ========== SCATTER PLOT & DEBUG ==========
    let currentYieldDataPoints = []; // Store for scatter plot

    function populateScatterSelect() {
      const select = document.getElementById('scatterNutrientSelect');
      const visibleNutrients = getVisibleNutrients();
      select.innerHTML = visibleNutrients.map(n =>
        `<option value="${n}"${n === 'P' ? ' selected' : ''}>${CONFIG.NUTRIENT_NAMES[n] || n}</option>`
      ).join('');
    }

    // Get crop-specific yield outlier limits
    function getYieldOutlierLimits(cropFilter) {
      const cropLower = (cropFilter || '').toLowerCase();
      if (cropLower.includes('soy') || cropLower.includes('bean')) {
        return { min: 20, max: 100 };  // Soybeans: 20-100 bu/ac
      } else if (cropLower === 'amylose') {
        return { min: 40, max: 280 };  // Amylose corn: 40-280 bu/ac (typically 15-30% lower than regular corn)
      } else if (cropLower.includes('corn') || cropLower.includes('maize')) {
        return { min: 50, max: 350 };  // Corn: 50-350 bu/ac
      }
      // Default to corn limits for unknown crops
      return { min: 50, max: 350 };
    }

    function getYieldDataPoints() {
      const cropFilter = document.getElementById('yieldCropSelect').value;
      const yearFilter = document.getElementById('yieldYearSelect').value;
      const fieldFilter = document.getElementById('yieldFieldSelect').value;

      let samplesWithYield = sampleData.filter(s => s.yieldCorrelations && Object.keys(s.yieldCorrelations).length > 0);
      if (fieldFilter !== 'all') samplesWithYield = samplesWithYield.filter(s => s.field === fieldFilter);

      const locationMap = new Map();
      samplesWithYield.forEach(sample => {
        const locKey = `${sample.lat.toFixed(5)},${sample.lon.toFixed(5)}`;
        const existing = locationMap.get(locKey);
        if (!existing || (sample.year && sample.year > existing.year)) {
          locationMap.set(locKey, sample);
        }
      });
      samplesWithYield = Array.from(locationMap.values());

      const dataPoints = [];

      if (yearFilter === 'avg') {
        // ALL YEARS (AVERAGE): Average yield across all years at each location
        samplesWithYield.forEach(sample => {
          const validYields = [];
          Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
            if (cropFilter === 'all' || yieldInfo.crop === cropFilter) {
              validYields.push({
                yield: yieldInfo.avgYield,
                crop: yieldInfo.crop,
                pointCount: yieldInfo.pointCount
              });
            }
          });
          if (validYields.length > 0) {
            const avgYield = validYields.reduce((sum, v) => sum + v.yield, 0) / validYields.length;
            dataPoints.push({
              ...sample,
              yieldYear: 'avg',
              avgYield: avgYield,
              crop: validYields[0].crop,
              yieldPointCount: validYields.reduce((sum, v) => sum + v.pointCount, 0),
              yearsAveraged: validYields.length
            });
          }
        });
      } else if (yearFilter === 'combined') {
        // ALL YEARS (COMBINED): Each year is a separate data point
        samplesWithYield.forEach(sample => {
          Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
            if (cropFilter === 'all' || yieldInfo.crop === cropFilter) {
              dataPoints.push({
                ...sample,
                yieldYear: parseInt(year),
                avgYield: yieldInfo.avgYield,
                crop: yieldInfo.crop,
                yieldPointCount: yieldInfo.pointCount
              });
            }
          });
        });
      } else if (yearFilter === 'normalized') {
        // ALL YEARS (YEAR-NORMALIZED): Each year separate, but yields as % of year average
        const yearTotals = {};
        const yearCounts = {};
        samplesWithYield.forEach(sample => {
          Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
            if (cropFilter === 'all' || yieldInfo.crop === cropFilter) {
              const yr = parseInt(year);
              if (!yearTotals[yr]) { yearTotals[yr] = 0; yearCounts[yr] = 0; }
              yearTotals[yr] += yieldInfo.avgYield;
              yearCounts[yr]++;
            }
          });
        });
        const yearAverages = {};
        Object.keys(yearTotals).forEach(yr => { yearAverages[yr] = yearTotals[yr] / yearCounts[yr]; });

        samplesWithYield.forEach(sample => {
          Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
            if (cropFilter === 'all' || yieldInfo.crop === cropFilter) {
              const yr = parseInt(year);
              const normalizedYield = (yieldInfo.avgYield / yearAverages[yr]) * 100;
              dataPoints.push({
                ...sample,
                yieldYear: yr,
                avgYield: normalizedYield,
                rawYield: yieldInfo.avgYield,
                yearAvg: yearAverages[yr],
                crop: yieldInfo.crop,
                yieldPointCount: yieldInfo.pointCount,
                isYearNormalized: true
              });
            }
          });
        });
      } else {
        // SPECIFIC YEAR: Only use yield from that year
        samplesWithYield.forEach(sample => {
          const yieldInfo = sample.yieldCorrelations[yearFilter];
          if (yieldInfo && (cropFilter === 'all' || yieldInfo.crop === cropFilter)) {
            dataPoints.push({
              ...sample,
              yieldYear: parseInt(yearFilter),
              avgYield: yieldInfo.avgYield,
              crop: yieldInfo.crop,
              yieldPointCount: yieldInfo.pointCount
            });
          }
        });
      }

      // Apply normalization if enabled
      const normalizeByField = document.getElementById('yieldNormalizeToggle').checked;
      if (normalizeByField && dataPoints.length > 0) {
        // Calculate average yield for each field
        const fieldYields = {};
        dataPoints.forEach(dp => {
          const field = dp.field || 'Unknown';
          if (!fieldYields[field]) fieldYields[field] = [];
          fieldYields[field].push(dp.avgYield);
        });

        const fieldAverages = {};
        Object.entries(fieldYields).forEach(([field, yields]) => {
          fieldAverages[field] = yields.reduce((a, b) => a + b, 0) / yields.length;
        });

        // Convert yields to % of field average
        dataPoints.forEach(dp => {
          const field = dp.field || 'Unknown';
          const fieldAvg = fieldAverages[field];
          dp.rawYield = dp.avgYield;
          dp.avgYield = (dp.avgYield / fieldAvg) * 100;
          dp.fieldAvg = fieldAvg;
        });
      }

      return dataPoints;
    }

    // Scatter plot axis state
    let scatterAxesFlipped = false;

    function toggleScatterAxes() {
      scatterAxesFlipped = !scatterAxesFlipped;
      const btn = document.getElementById('swapAxesBtn');
      const title = document.getElementById('scatterTitle');
      const nutrient = document.getElementById('scatterNutrientSelect').value;
      const nutrientName = CONFIG.NUTRIENT_NAMES[nutrient] || nutrient;

      if (scatterAxesFlipped) {
        btn.style.background = '#3b82f6';
        btn.style.color = 'white';
        title.textContent = `Scatter Plot: Yield vs ${nutrientName}`;
      } else {
        btn.style.background = '#eff6ff';
        btn.style.color = '#1d4ed8';
        title.textContent = `Scatter Plot: ${nutrientName} vs Yield`;
      }
      drawScatterPlot();
    }

    // Threshold slider sync functions
    function updateThresholdDisplay() {
      const slider = document.getElementById('yieldThresholdSlider');
      const input = document.getElementById('yieldThresholdInput');
      input.value = slider.value;
    }

    function syncThresholdSlider() {
      const slider = document.getElementById('yieldThresholdSlider');
      const input = document.getElementById('yieldThresholdInput');
      slider.value = Math.max(100, Math.min(400, input.value));
    }

    function drawScatterPlot() {
      const canvas = document.getElementById('scatterCanvas');
      const ctx = canvas.getContext('2d');
      const nutrient = document.getElementById('scatterNutrientSelect').value;
      const yieldThreshold = parseFloat(document.getElementById('yieldThresholdInput').value) || 200;
      const hideOutliers = document.getElementById('hideOutliersCheckbox').checked;
      let dataPoints = getYieldDataPoints();

      // Get crop-specific yield thresholds for outlier filtering
      const cropFilter = document.getElementById('yieldCropSelect').value;
      const yieldLimits = getYieldOutlierLimits(cropFilter);

      // Filter out outliers if checkbox is checked
      let outliersRemoved = 0;
      if (hideOutliers) {
        const beforeCount = dataPoints.length;
        dataPoints = dataPoints.filter(d => {
          return d.avgYield >= yieldLimits.min && d.avgYield <= yieldLimits.max;
        });
        outliersRemoved = beforeCount - dataPoints.length;
      }

      // Update outlier info display
      const outlierInfoEl = document.getElementById('outlierFilterInfo');
      if (outliersRemoved > 0) {
        outlierInfoEl.textContent = `(${outliersRemoved} outliers hidden: yield <${yieldLimits.min} or >${yieldLimits.max} bu/ac)`;
        outlierInfoEl.style.color = '#dc2626';
      } else if (hideOutliers) {
        outlierInfoEl.textContent = `(no outliers found)`;
        outlierInfoEl.style.color = '#16a34a';
      } else {
        outlierInfoEl.textContent = '';
        outlierInfoEl.style.color = '#dc2626';
      }

      // Filter for valid data
      const validPoints = dataPoints.filter(d => {
        const val = d[nutrient];
        if (val === undefined || val === null || val === '') return false;
        return isFinite(parseFloat(val));
      });

      // Clear canvas
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      if (validPoints.length < 3) {
        ctx.fillStyle = '#64748b';
        ctx.font = '14px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('Not enough data points', canvas.width / 2, canvas.height / 2);
        document.getElementById('thresholdContent').innerHTML = '<p style="color: #94a3b8;">Not enough data</p>';
        return;
      }

      // Get data ranges - swap if axes are flipped
      const nutrientValues = validPoints.map(p => parseFloat(p[nutrient]));
      const yieldValues = validPoints.map(p => p.avgYield);

      // When flipped: X = Yield, Y = Nutrient
      const xValues = scatterAxesFlipped ? yieldValues : nutrientValues;
      const yValues = scatterAxesFlipped ? nutrientValues : yieldValues;
      const xMin = Math.min(...xValues);
      const xMax = Math.max(...xValues);
      const yMin = Math.min(...yValues);
      const yMax = Math.max(...yValues);

      // Labels for axes - check if normalized
      const normalizeByField = document.getElementById('yieldNormalizeToggle').checked;
      const yieldAxisLabel = normalizeByField ? 'Yield (% of Field Avg)' : 'Yield (bu/ac)';
      const nutrientName = CONFIG.NUTRIENT_NAMES[nutrient] || nutrient;
      const xLabel = scatterAxesFlipped ? yieldAxisLabel : nutrientName;
      const yLabel = scatterAxesFlipped ? nutrientName : yieldAxisLabel;

      // Padding for axes
      const padding = { left: 70, right: 40, top: 40, bottom: 60 };
      const plotWidth = canvas.width - padding.left - padding.right;
      const plotHeight = canvas.height - padding.top - padding.bottom;

      // Scale functions
      const xScale = (val) => padding.left + ((val - xMin) / (xMax - xMin || 1)) * plotWidth;
      const yScale = (val) => canvas.height - padding.bottom - ((val - yMin) / (yMax - yMin || 1)) * plotHeight;

      // Calculate regression
      const n = xValues.length;
      const meanX = xValues.reduce((a, b) => a + b, 0) / n;
      const meanY = yValues.reduce((a, b) => a + b, 0) / n;
      const ssX = xValues.reduce((sum, xi) => sum + (xi - meanX) ** 2, 0);
      const ssY = yValues.reduce((sum, yi) => sum + (yi - meanY) ** 2, 0);
      const ssXY = xValues.reduce((sum, xi, i) => sum + (xi - meanX) * (yValues[i] - meanY), 0);
      const slope = ssX > 0 ? ssXY / ssX : 0;
      const intercept = meanY - slope * meanX;
      const correlation = calculateCorrelation(xValues, yValues);
      const r = correlation ? correlation.r : 0;
      const r2 = r * r;

      // Calculate standard error for confidence bands
      const predictions = xValues.map(x => slope * x + intercept);
      const residuals = yValues.map((y, i) => y - predictions[i]);
      const sse = residuals.reduce((sum, r) => sum + r * r, 0);
      const mse = sse / (n - 2);
      const se = Math.sqrt(mse);

      // Draw axes
      ctx.strokeStyle = '#cbd5e1';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding.left, padding.top);
      ctx.lineTo(padding.left, canvas.height - padding.bottom);
      ctx.lineTo(canvas.width - padding.right, canvas.height - padding.bottom);
      ctx.stroke();

      // Draw grid lines
      ctx.strokeStyle = '#f1f5f9';
      ctx.lineWidth = 1;
      for (let i = 0; i <= 5; i++) {
        const y = padding.top + (i * plotHeight / 5);
        ctx.beginPath();
        ctx.moveTo(padding.left, y);
        ctx.lineTo(canvas.width - padding.right, y);
        ctx.stroke();
        const x = padding.left + (i * plotWidth / 5);
        ctx.beginPath();
        ctx.moveTo(x, padding.top);
        ctx.lineTo(x, canvas.height - padding.bottom);
        ctx.stroke();
      }

      // Draw confidence bands (95% CI)
      if (n > 5 && ssX > 0) {
        const tValue = 1.96; // ~95% CI
        ctx.fillStyle = 'rgba(59, 130, 246, 0.1)';
        ctx.beginPath();
        const bandPoints = 50;
        // Upper band
        for (let i = 0; i <= bandPoints; i++) {
          const x = xMin + (i / bandPoints) * (xMax - xMin);
          const yPred = slope * x + intercept;
          const seY = se * Math.sqrt(1 + 1/n + (x - meanX)**2 / ssX);
          const yUpper = yPred + tValue * seY;
          const px = xScale(x);
          const py = yScale(Math.min(yMax * 1.1, Math.max(yMin * 0.9, yUpper)));
          if (i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        // Lower band (reverse)
        for (let i = bandPoints; i >= 0; i--) {
          const x = xMin + (i / bandPoints) * (xMax - xMin);
          const yPred = slope * x + intercept;
          const seY = se * Math.sqrt(1 + 1/n + (x - meanX)**2 / ssX);
          const yLower = yPred - tValue * seY;
          const px = xScale(x);
          const py = yScale(Math.min(yMax * 1.1, Math.max(yMin * 0.9, yLower)));
          ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();
      }

      // Draw yield threshold line (vertical when flipped, horizontal when normal)
      if (scatterAxesFlipped) {
        // Flipped: X = Yield, so threshold is a vertical line
        if (yieldThreshold >= xMin && yieldThreshold <= xMax) {
          const thresholdX = xScale(yieldThreshold);
          ctx.strokeStyle = '#f59e0b';
          ctx.lineWidth = 2;
          ctx.setLineDash([8, 4]);
          ctx.beginPath();
          ctx.moveTo(thresholdX, padding.top);
          ctx.lineTo(thresholdX, canvas.height - padding.bottom);
          ctx.stroke();
          ctx.setLineDash([]);

          // Label the threshold line
          const thresholdUnit = normalizeByField ? '%' : 'bu/ac';
          ctx.fillStyle = '#92400e';
          ctx.font = 'bold 12px system-ui';
          ctx.save();
          ctx.translate(thresholdX + 5, padding.top + 60);
          ctx.rotate(Math.PI / 2);
          ctx.textAlign = 'left';
          ctx.fillText(`${yieldThreshold} ${thresholdUnit} threshold`, 0, 0);
          ctx.restore();
        }
      } else {
        // Normal: Y = Yield, so threshold is a horizontal line
        if (yieldThreshold >= yMin && yieldThreshold <= yMax) {
          const thresholdY = yScale(yieldThreshold);
          ctx.strokeStyle = '#f59e0b';
          ctx.lineWidth = 2;
          ctx.setLineDash([8, 4]);
          ctx.beginPath();
          ctx.moveTo(padding.left, thresholdY);
          ctx.lineTo(canvas.width - padding.right, thresholdY);
          ctx.stroke();
          ctx.setLineDash([]);

          // Label the threshold line
          const thresholdUnit = normalizeByField ? '%' : 'bu/ac';
          ctx.fillStyle = '#92400e';
          ctx.font = 'bold 12px system-ui';
          ctx.textAlign = 'left';
          ctx.fillText(`${yieldThreshold} ${thresholdUnit} threshold`, padding.left + 5, thresholdY - 5);
        }
      }

      // Separate points above/below threshold (always based on yield, not axis position)
      const aboveThreshold = validPoints.filter(p => p.avgYield >= yieldThreshold);
      const belowThreshold = validPoints.filter(p => p.avgYield < yieldThreshold);

      // Draw points below threshold (gray/muted)
      belowThreshold.forEach(p => {
        const px = scatterAxesFlipped ? xScale(p.avgYield) : xScale(parseFloat(p[nutrient]));
        const py = scatterAxesFlipped ? yScale(parseFloat(p[nutrient])) : yScale(p.avgYield);
        ctx.beginPath();
        ctx.arc(px, py, 4, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(148, 163, 184, 0.4)';
        ctx.fill();
        ctx.strokeStyle = '#94a3b8';
        ctx.lineWidth = 1;
        ctx.stroke();
      });

      // Draw points above threshold (highlighted)
      aboveThreshold.forEach(p => {
        const px = scatterAxesFlipped ? xScale(p.avgYield) : xScale(parseFloat(p[nutrient]));
        const py = scatterAxesFlipped ? yScale(parseFloat(p[nutrient])) : yScale(p.avgYield);
        ctx.beginPath();
        ctx.arc(px, py, 6, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(34, 197, 94, 0.7)';
        ctx.fill();
        ctx.strokeStyle = '#16a34a';
        ctx.lineWidth = 2;
        ctx.stroke();
      });

      // Draw trend line
      if (ssX > 0) {
        const y1 = slope * xMin + intercept;
        const y2 = slope * xMax + intercept;

        ctx.strokeStyle = '#3b82f6';
        ctx.lineWidth = 2.5;
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.moveTo(xScale(xMin), yScale(y1));
        ctx.lineTo(xScale(xMax), yScale(y2));
        ctx.stroke();
      }

      // Draw axis labels
      ctx.fillStyle = '#64748b';
      ctx.font = '12px system-ui';
      ctx.textAlign = 'center';

      // X-axis labels (format based on what's on X axis)
      for (let i = 0; i <= 5; i++) {
        const val = xMin + (i * (xMax - xMin) / 5);
        const x = xScale(val);
        ctx.fillText(scatterAxesFlipped ? val.toFixed(0) : val.toFixed(1), x, canvas.height - padding.bottom + 20);
      }
      ctx.font = 'bold 13px system-ui';
      ctx.fillText(xLabel, canvas.width / 2, canvas.height - 12);

      // Y-axis labels (format based on what's on Y axis)
      ctx.font = '12px system-ui';
      ctx.textAlign = 'right';
      for (let i = 0; i <= 5; i++) {
        const val = yMin + (i * (yMax - yMin) / 5);
        const y = yScale(val);
        ctx.fillText(scatterAxesFlipped ? val.toFixed(1) : val.toFixed(0), padding.left - 10, y + 4);
      }
      ctx.save();
      ctx.translate(18, canvas.height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.textAlign = 'center';
      ctx.font = 'bold 13px system-ui';
      ctx.fillText(yLabel, 0, 0);
      ctx.restore();

      // Draw equation and R¬≤ on chart
      ctx.fillStyle = '#1e293b';
      ctx.font = 'bold 13px system-ui';
      ctx.textAlign = 'left';
      const eqY = padding.top + 20;
      const slopeSign = slope >= 0 ? '+' : '';
      ctx.fillText(`y = ${slope.toFixed(2)}x ${slopeSign}${intercept.toFixed(1)}`, padding.left + 10, eqY);
      ctx.fillText(`R¬≤ = ${(r2 * 100).toFixed(1)}%`, padding.left + 10, eqY + 18);
      ctx.font = '12px system-ui';
      ctx.fillStyle = '#64748b';
      ctx.fillText(`n = ${n}`, padding.left + 10, eqY + 36);

      // Draw legend
      const legendX = canvas.width - padding.right - 180;
      const legendY = padding.top + 10;
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.fillRect(legendX - 10, legendY - 5, 190, 85);
      ctx.strokeStyle = '#e2e8f0';
      ctx.lineWidth = 1;
      ctx.strokeRect(legendX - 10, legendY - 5, 190, 85);

      ctx.font = '11px system-ui';
      ctx.textAlign = 'left';

      // Above threshold legend
      ctx.beginPath();
      ctx.arc(legendX + 6, legendY + 10, 5, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(34, 197, 94, 0.7)';
      ctx.fill();
      ctx.strokeStyle = '#16a34a';
      ctx.stroke();
      const yieldUnit = normalizeByField ? '%' : 'bu/ac';
      ctx.fillStyle = '#1e293b';
      ctx.fillText(`Above ${yieldThreshold} ${yieldUnit} (${aboveThreshold.length})`, legendX + 18, legendY + 14);

      // Below threshold legend
      ctx.beginPath();
      ctx.arc(legendX + 6, legendY + 30, 4, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(148, 163, 184, 0.4)';
      ctx.fill();
      ctx.strokeStyle = '#94a3b8';
      ctx.stroke();
      ctx.fillStyle = '#64748b';
      ctx.fillText(`Below ${yieldThreshold} ${yieldUnit} (${belowThreshold.length})`, legendX + 18, legendY + 34);

      // Trend line legend
      ctx.strokeStyle = '#3b82f6';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(legendX, legendY + 50);
      ctx.lineTo(legendX + 20, legendY + 50);
      ctx.stroke();
      ctx.fillStyle = '#1e293b';
      ctx.fillText('Trend line', legendX + 28, legendY + 54);

      // Confidence band legend
      ctx.fillStyle = 'rgba(59, 130, 246, 0.3)';
      ctx.fillRect(legendX, legendY + 63, 20, 10);
      ctx.fillStyle = '#64748b';
      ctx.fillText('95% prediction interval', legendX + 28, legendY + 72);

      // Update threshold analysis panel
      updateThresholdAnalysis(nutrient, validPoints, yieldThreshold, aboveThreshold, belowThreshold, scatterAxesFlipped);

      // Update stats bar
      const statsDiv = document.getElementById('scatterStats');
      const corrDirection = r >= 0 ? '‚Üó Positive' : '‚Üò Negative';
      const corrColor = r >= 0 ? '#16a34a' : '#dc2626';
      const nutrientMin = Math.min(...nutrientValues);
      const nutrientMax = Math.max(...nutrientValues);
      const yieldMin = Math.min(...yieldValues);
      const yieldMax = Math.max(...yieldValues);
      const axisNote = scatterAxesFlipped
        ? '<span style="color: #3b82f6; font-weight: 600;">[Axes Flipped: X=Yield, Y=Nutrient]</span>'
        : '';
      statsDiv.innerHTML = `
        <strong>${nutrientName}:</strong>
        n=${validPoints.length} |
        r=${r.toFixed(3)} |
        R¬≤=${(r2 * 100).toFixed(1)}% |
        ${nutrient} Range: ${nutrientMin.toFixed(1)} - ${nutrientMax.toFixed(1)} |
        Yield Range: ${yieldMin.toFixed(0)} - ${yieldMax.toFixed(0)} bu/ac |
        <span style="color: ${corrColor};">${corrDirection} correlation</span>
        ${axisNote}
      `;
    }

    function updateThresholdAnalysis(nutrient, validPoints, threshold, aboveThreshold, belowThreshold, isFlipped = false) {
      const content = document.getElementById('thresholdContent');
      const nutrientName = CONFIG.NUTRIENT_NAMES[nutrient] || nutrient;
      const normalizeByField = document.getElementById('yieldNormalizeToggle').checked;
      const yieldUnit = normalizeByField ? '%' : 'bu/ac';
      const yieldDesc = normalizeByField ? '% of field avg' : 'bu/ac';

      if (aboveThreshold.length === 0) {
        content.innerHTML = `
          <p style="color: #dc2626; font-weight: 600;">No samples above ${threshold} ${yieldUnit}</p>
          <p>Try lowering the yield threshold to analyze high-yielding samples.</p>
        `;
        return;
      }

      // Calculate stats for points above threshold
      const aboveNutrientValues = aboveThreshold.map(p => parseFloat(p[nutrient]));
      const minAbove = Math.min(...aboveNutrientValues);
      const maxAbove = Math.max(...aboveNutrientValues);
      const avgAbove = aboveNutrientValues.reduce((a, b) => a + b, 0) / aboveNutrientValues.length;
      const sortedAbove = [...aboveNutrientValues].sort((a, b) => a - b);
      const p10Above = sortedAbove[Math.floor(sortedAbove.length * 0.1)] || minAbove;

      // Calculate stats for points below threshold
      let belowStats = '';
      if (belowThreshold.length > 0) {
        const belowNutrientValues = belowThreshold.map(p => parseFloat(p[nutrient]));
        const avgBelow = belowNutrientValues.reduce((a, b) => a + b, 0) / belowNutrientValues.length;
        const diff = avgAbove - avgBelow;
        const diffPct = avgBelow > 0 ? ((diff / avgBelow) * 100).toFixed(0) : 'N/A';
        belowStats = `
          <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #e2e8f0;">
            <div style="font-weight: 600; color: #64748b; margin-bottom: 0.5rem;">Below ${threshold} ${yieldUnit}:</div>
            <div>Avg ${nutrient}: <strong>${avgBelow.toFixed(1)}</strong></div>
            <div style="margin-top: 0.5rem; color: ${diff >= 0 ? '#16a34a' : '#dc2626'};">
              Difference: ${diff >= 0 ? '+' : ''}${diff.toFixed(1)} (${diffPct}%)
            </div>
          </div>
        `;
      }

      // Different interpretation based on axis orientation and normalization
      const thresholdDesc = normalizeByField ? `${threshold}% of field average` : `${threshold} bu/ac`;
      const interpretationText = isFlipped
        ? `<strong>Key insight:</strong> At yields ‚â•${thresholdDesc}, ${nutrient} levels ranged from <strong>${minAbove.toFixed(1)}</strong> to <strong>${maxAbove.toFixed(1)}</strong>. The minimum ${nutrient} observed at this yield level was <strong>${minAbove.toFixed(1)}</strong> - you never see ${nutrient} below this at high yields.`
        : `<strong>Interpretation:</strong> For high yields (‚â•${thresholdDesc}), the minimum ${nutrientName} observed was <strong>${minAbove.toFixed(1)}</strong>. This suggests ${nutrient} levels below this may limit yield potential.`;

      content.innerHTML = `
        ${isFlipped ? '<div style="background: #eff6ff; border: 1px solid #3b82f6; border-radius: 0.375rem; padding: 0.5rem; margin-bottom: 0.75rem; font-size: 0.75rem; color: #1d4ed8;"><strong>Flipped View:</strong> X=Yield, Y=${nutrientName}. Look left of the threshold line to see nutrient levels at high yields.</div>' : ''}
        <div style="background: #f0fdf4; border: 1px solid #22c55e; border-radius: 0.375rem; padding: 0.75rem; margin-bottom: 0.75rem;">
          <div style="font-weight: 700; color: #166534; margin-bottom: 0.5rem;">
            üéØ For yields ‚â• ${threshold} ${yieldUnit}:
          </div>
          <div style="font-size: 0.8rem; color: #166534;">
            <strong>Minimum ${nutrient}:</strong> ${minAbove.toFixed(1)}<br>
            <strong>10th percentile:</strong> ${p10Above.toFixed(1)}<br>
            <strong>Average ${nutrient}:</strong> ${avgAbove.toFixed(1)}<br>
            <strong>Maximum ${nutrient}:</strong> ${maxAbove.toFixed(1)}
          </div>
        </div>

        <div style="font-size: 0.8rem; color: #475569;">
          <strong>${aboveThreshold.length}</strong> samples above threshold<br>
          <strong>${belowThreshold.length}</strong> samples below threshold
        </div>

        ${belowStats}

        <div style="margin-top: 0.75rem; padding: 0.5rem; background: #fef3c7; border-radius: 0.25rem; font-size: 0.75rem; color: #92400e;">
          ${interpretationText}
        </div>
      `;
    }

    // Toggle yield year explanation info box
    function toggleYieldYearInfo() {
      const box = document.getElementById('yieldYearInfoBox');
      box.style.display = box.style.display === 'none' ? 'block' : 'none';
    }

    // Calculate year averages for yield data
    function calculateYearAverages() {
      const yearTotals = {};
      const yearCounts = {};
      const cropFilter = document.getElementById('yieldCropSelect').value;

      sampleData.forEach(sample => {
        if (sample.yieldCorrelations) {
          Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
            if (cropFilter === 'all' || yieldInfo.crop === cropFilter) {
              const yr = parseInt(year);
              if (!yearTotals[yr]) {
                yearTotals[yr] = 0;
                yearCounts[yr] = 0;
              }
              yearTotals[yr] += yieldInfo.avgYield;
              yearCounts[yr]++;
            }
          });
        }
      });

      const yearAverages = {};
      Object.keys(yearTotals).forEach(yr => {
        yearAverages[yr] = yearTotals[yr] / yearCounts[yr];
      });
      return yearAverages;
    }

    // Update description below dropdown based on selection
    function updateYieldYearDescription() {
      const yearFilter = document.getElementById('yieldYearSelect').value;
      const descBox = document.getElementById('yieldYearDescription');
      const descText = document.getElementById('yieldYearDescText');
      const warningBox = document.getElementById('yieldYearWarning');
      const warningText = document.getElementById('yieldYearWarningText');
      const avgBox = document.getElementById('yieldYearAverages');

      descBox.style.display = 'block';
      warningBox.style.display = 'none';
      avgBox.style.display = 'none';

      const yearAverages = calculateYearAverages();
      const years = Object.keys(yearAverages).map(Number).sort();

      if (yearFilter === 'avg') {
        descText.innerHTML = `<strong>Averaged:</strong> Averages yield across all years at each location. A sample with 180 bu in 2024 and 220 bu in 2025 becomes 200 bu.<br><em>Best for finding patterns that persist across years. Smooths out weather variation.</em>`;
      } else if (yearFilter === 'combined') {
        descText.innerHTML = `<strong>Combined:</strong> Each year treated as separate data point. Same location counted multiple times (once per year).<br><em>Best for maximum sample size when years had similar growing conditions.</em>`;

        // Check if year averages differ by >15%
        if (years.length >= 2) {
          const avgValues = years.map(yr => yearAverages[yr]);
          const minAvg = Math.min(...avgValues);
          const maxAvg = Math.max(...avgValues);
          const diffPercent = ((maxAvg - minAvg) / minAvg) * 100;

          if (diffPercent > 15) {
            warningBox.style.display = 'block';
            warningText.textContent = `Yields varied by ${Math.round(diffPercent)}% between years. Consider using Year-Normalized to control for weather differences.`;
          }

          // Show year averages
          avgBox.style.display = 'block';
          avgBox.innerHTML = `<strong>Year averages:</strong> ${years.map(yr => `${yr}: ${Math.round(yearAverages[yr])} bu/ac`).join(' | ')}`;
        }
      } else if (yearFilter === 'normalized') {
        descText.innerHTML = `<strong>Year-Normalized:</strong> Each year treated separately, but yields converted to % of that year's average. A 200 bu yield in a 180 bu avg year = 111%.<br><em>Best for comparing across years with different weather. Isolates nutrient effect from seasonal variation.</em>`;

        // Show year averages
        if (years.length > 0) {
          avgBox.style.display = 'block';
          avgBox.innerHTML = `<strong>Year averages being normalized:</strong> ${years.map(yr => `${yr}: ${Math.round(yearAverages[yr])} bu/ac`).join(' | ')}`;
        }
      } else {
        // Individual year
        descText.innerHTML = `<strong>${yearFilter}:</strong> Only uses yield from this specific harvest year.<br><em>Best for analyzing that season's results specifically.</em>`;
        if (yearAverages[yearFilter]) {
          avgBox.style.display = 'block';
          avgBox.innerHTML = `<strong>${yearFilter} average:</strong> ${Math.round(yearAverages[yearFilter])} bu/ac`;
        }
      }
    }

    // Toggle normalization explanation info box
    function toggleNormalizeInfo() {
      const box = document.getElementById('normalizeInfoBox');
      box.style.display = box.style.display === 'none' ? 'block' : 'none';
    }

    // ========== YIELD BY NUTRIENT LEVEL (BUCKET ANALYSIS) ==========

    // Initialize selectors for bucket analysis
    function initYieldBucketSelectors() {
      // Filter by active client/farm
      const activeFieldsList = getActiveFields();
      const filteredSamples = sampleData.filter(s => activeFieldsList.includes(s.field));

      // Get samples with yield data
      const samplesWithYield = filteredSamples.filter(s => s.yieldCorrelations && Object.keys(s.yieldCorrelations).length > 0);

      // Populate field selector
      const fieldSelect = document.getElementById('bucketFieldSelect');
      const fields = [...new Set(samplesWithYield.map(s => s.field).filter(f => f))].sort();
      fieldSelect.innerHTML = '<option value="all">All Fields</option>' +
        fields.map(f => `<option value="${f}">${f}</option>`).join('');

      // Populate yield year selector
      const yearSelect = document.getElementById('bucketYieldYearSelect');
      const yieldYears = new Set();
      samplesWithYield.forEach(s => {
        Object.keys(s.yieldCorrelations).forEach(y => yieldYears.add(y));
      });
      const sortedYears = [...yieldYears].sort((a, b) => b - a);
      yearSelect.innerHTML = '<option value="all">All Years</option>' +
        sortedYears.map(y => `<option value="${y}">${y}</option>`).join('');
    }

    // Main bucket analysis function
    function updateYieldBucketAnalysis() {
      const container = document.getElementById('yieldBucketsContent');
      const fieldFilter = document.getElementById('bucketFieldSelect')?.value || 'all';
      const yearFilter = document.getElementById('bucketYieldYearSelect')?.value || 'all';
      const cropFilter = document.getElementById('bucketCropSelect')?.value || 'all';

      // Filter by active client/farm
      const activeFieldsList = getActiveFields();
      const filteredSamples = sampleData.filter(s => activeFieldsList.includes(s.field));

      // Get samples with yield data
      let samplesWithYield = filteredSamples.filter(s => s.yieldCorrelations && Object.keys(s.yieldCorrelations).length > 0);

      if (samplesWithYield.length === 0) {
        container.innerHTML = '<div class="no-data">No yield data available. Import yield maps on the Import page first.</div>';
        return;
      }

      // Apply field filter
      if (fieldFilter !== 'all') {
        samplesWithYield = samplesWithYield.filter(s => s.field === fieldFilter);
      }

      // Build data points with yield values
      const dataPoints = [];
      samplesWithYield.forEach(sample => {
        Object.entries(sample.yieldCorrelations).forEach(([yieldYear, yieldInfo]) => {
          // Year filter
          if (yearFilter !== 'all' && String(yieldYear) !== String(yearFilter)) return;
          // Crop filter
          if (cropFilter !== 'all' && yieldInfo.crop !== cropFilter) return;

          const yieldValue = yieldInfo.avgYield;
          if (typeof yieldValue !== 'number' || isNaN(yieldValue)) return;

          // Apply crop-specific outlier filtering
          const isCorn = yieldInfo.crop === 'corn';
          const minYield = isCorn ? 50 : 20;
          const maxYield = isCorn ? 350 : 100;
          if (yieldValue < minYield || yieldValue > maxYield) return;

          dataPoints.push({
            ...sample,
            yieldValue,
            yieldYear,
            crop: yieldInfo.crop
          });
        });
      });

      if (dataPoints.length === 0) {
        container.innerHTML = '<div class="no-data">No yield data matches the selected filters.</div>';
        return;
      }

      // Get settings for thresholds
      const settings = JSON.parse(localStorage.getItem('soilSettings') || '{}');

      // Define nutrients to analyze
      const nutrients = ['pH', 'P', 'K', 'OM', 'Ca_sat', 'Mg_sat', 'K_Sat', 'CEC', 'Zn', 'S'];
      const results = [];

      nutrients.forEach(nutrient => {
        // Get valid values for this nutrient
        const validPoints = dataPoints.filter(p => {
          const val = p[nutrient];
          return typeof val === 'number' && !isNaN(val) && val !== 0;
        });

        if (validPoints.length < 10) return; // Need enough data

        // Get threshold settings for this nutrient
        const thresholds = getSpatialNutrientThresholds(nutrient, settings);
        if (!thresholds) return;

        // Bucket the samples
        const buckets = { low: [], medium: [], high: [] };
        validPoints.forEach(p => {
          const val = p[nutrient];
          const bucket = getBucketForValue(val, nutrient, thresholds);
          buckets[bucket].push(p);
        });

        // Calculate average yield for each bucket
        const calcAvg = (arr) => arr.length > 0 ? arr.reduce((sum, p) => sum + p.yieldValue, 0) / arr.length : null;

        const lowAvg = calcAvg(buckets.low);
        const medAvg = calcAvg(buckets.medium);
        const highAvg = calcAvg(buckets.high);

        // Calculate yield difference (high - low)
        const yieldDiff = (lowAvg !== null && highAvg !== null) ? highAvg - lowAvg : null;

        results.push({
          nutrient,
          name: CONFIG.NUTRIENT_NAMES[nutrient] || nutrient,
          unit: CONFIG.NUTRIENT_UNITS[nutrient] || '',
          thresholds,
          low: { count: buckets.low.length, avgYield: lowAvg },
          medium: { count: buckets.medium.length, avgYield: medAvg },
          high: { count: buckets.high.length, avgYield: highAvg },
          yieldDiff,
          totalSamples: validPoints.length
        });
      });

      // Sort by yield difference (biggest impact first)
      results.sort((a, b) => {
        const diffA = a.yieldDiff !== null ? Math.abs(a.yieldDiff) : 0;
        const diffB = b.yieldDiff !== null ? Math.abs(b.yieldDiff) : 0;
        return diffB - diffA;
      });

      // Build HTML
      let html = `
        <div style="background: #f0fdf4; border: 1px solid #86efac; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem;">
          <strong>Summary:</strong> Analyzing <strong>${dataPoints.length}</strong> sample-yield pairs across <strong>${results.length}</strong> nutrients.
          Sorted by yield impact (biggest differences first).
        </div>

        <table class="rankings-table" style="width: 100%; font-size: 0.85rem;">
          <thead>
            <tr style="background: #f1f5f9;">
              <th style="text-align: left; padding: 0.75rem;">Nutrient</th>
              <th style="text-align: center; padding: 0.75rem; background: #fee2e2; color: #991b1b;">Low<br><span style="font-weight: normal; font-size: 0.7rem;">Avg Yield</span></th>
              <th style="text-align: center; padding: 0.75rem; background: #fef3c7; color: #92400e;">Medium<br><span style="font-weight: normal; font-size: 0.7rem;">Avg Yield</span></th>
              <th style="text-align: center; padding: 0.75rem; background: #dcfce7; color: #166534;">High<br><span style="font-weight: normal; font-size: 0.7rem;">Avg Yield</span></th>
              <th style="text-align: center; padding: 0.75rem;">Yield Impact<br><span style="font-weight: normal; font-size: 0.7rem;">(High - Low)</span></th>
            </tr>
          </thead>
          <tbody>
      `;

      results.forEach((r, idx) => {
        const formatYield = (bucket) => {
          if (bucket.avgYield === null) return '<span style="color: #9ca3af;">-</span>';
          return `<strong>${bucket.avgYield.toFixed(1)}</strong> <span style="color: #64748b; font-size: 0.75rem;">bu/ac</span><br><span style="color: #64748b; font-size: 0.7rem;">(n=${bucket.count})</span>`;
        };

        const impactColor = r.yieldDiff !== null ? (r.yieldDiff > 0 ? '#166534' : '#991b1b') : '#64748b';
        const impactText = r.yieldDiff !== null ? `${r.yieldDiff > 0 ? '+' : ''}${r.yieldDiff.toFixed(1)} bu/ac` : '-';

        // Show threshold ranges
        const rangeText = getThresholdRangeText(r.nutrient, r.thresholds);

        html += `
          <tr style="${idx % 2 === 0 ? '' : 'background: #f8fafc;'}">
            <td style="padding: 0.75rem;">
              <strong>${r.name}</strong>
              <div style="font-size: 0.7rem; color: #64748b; margin-top: 0.25rem;">${rangeText}</div>
            </td>
            <td style="text-align: center; padding: 0.75rem; background: rgba(254, 226, 226, 0.3);">${formatYield(r.low)}</td>
            <td style="text-align: center; padding: 0.75rem; background: rgba(254, 243, 199, 0.3);">${formatYield(r.medium)}</td>
            <td style="text-align: center; padding: 0.75rem; background: rgba(220, 252, 231, 0.3);">${formatYield(r.high)}</td>
            <td style="text-align: center; padding: 0.75rem; font-weight: 600; color: ${impactColor}; font-size: 1rem;">${impactText}</td>
          </tr>
        `;
      });

      html += '</tbody></table>';

      // Add interpretation guide
      html += `
        <div style="margin-top: 1.5rem; padding: 1rem; background: #eff6ff; border: 1px solid #93c5fd; border-radius: 0.5rem; font-size: 0.85rem;">
          <strong>üìñ How to Read This:</strong>
          <ul style="margin: 0.5rem 0 0 1.5rem; padding: 0; line-height: 1.8;">
            <li><strong>Low/Medium/High</strong> - Samples grouped by nutrient level using your threshold settings</li>
            <li><strong>Avg Yield</strong> - Average yield (bu/ac) for samples in each group</li>
            <li><strong>Yield Impact</strong> - Difference between High and Low groups (positive = higher nutrient = higher yield)</li>
            <li><strong>Large positive impact</strong> - Consider increasing fertilizer applications</li>
            <li><strong>Negative impact</strong> - May indicate over-application or toxicity at high levels</li>
          </ul>
        </div>
      `;

      container.innerHTML = html;
    }

    // Get threshold values for a nutrient (Spatial Analysis version)
    function getSpatialNutrientThresholds(nutrient, settings) {
      const defaults = {
        pH: { low: 6.0, high: 7.0 },
        P: { low: 15, high: 30 },
        K: { low: 120, high: 180 },
        OM: { low: 2.5, high: 4.0 },
        Ca_sat: { low: 60, high: 70 },
        Mg_sat: { low: 10, high: 15 },
        K_Sat: { low: 2.5, high: 4.0 },
        CEC: { low: 10, high: 20 },
        Zn: { low: 1.0, high: 3.0 },
        S: { low: 8, high: 15 }
      };

      // Use settings if available, otherwise defaults
      if (settings[`${nutrient}_min`] !== undefined) {
        return {
          low: settings[`${nutrient}_min`],
          high: settings[`${nutrient}_max`] || defaults[nutrient]?.high || settings[`${nutrient}_min`] * 1.5
        };
      }

      return defaults[nutrient] || null;
    }

    // Determine which bucket a value falls into
    function getBucketForValue(value, nutrient, thresholds) {
      // Handle "lower is better" nutrients (inverted)
      const lowerIsBetter = CONFIG.LOWER_IS_BETTER.includes(nutrient);

      if (lowerIsBetter) {
        // For lower-is-better: low values are "high" quality, high values are "low" quality
        if (value <= thresholds.low) return 'high';
        if (value >= thresholds.high) return 'low';
        return 'medium';
      } else {
        // Normal: low values are "low", high values are "high"
        if (value < thresholds.low) return 'low';
        if (value > thresholds.high) return 'high';
        return 'medium';
      }
    }

    // Get human-readable threshold range text
    function getThresholdRangeText(nutrient, thresholds) {
      const unit = CONFIG.NUTRIENT_UNITS[nutrient] || '';
      const lowerIsBetter = CONFIG.LOWER_IS_BETTER.includes(nutrient);

      if (lowerIsBetter) {
        return `Low: >${thresholds.high}${unit}, Med: ${thresholds.low}-${thresholds.high}${unit}, High: <${thresholds.low}${unit}`;
      } else {
        return `Low: <${thresholds.low}${unit}, Med: ${thresholds.low}-${thresholds.high}${unit}, High: >${thresholds.high}${unit}`;
      }
    }

    // ========== MULTIVARIATE REGRESSION ==========
    let lastMultiModel = null;
    const CORE_NUTRIENTS = ['P', 'K', 'pH', 'OM'];

    // Switch between yield correlation sub-tabs
    function switchYieldSubtab(tab) {
      // Update tab buttons
      document.querySelectorAll('.yield-subtab').forEach(btn => {
        if (btn.dataset.subtab === tab) {
          btn.style.background = '#3b82f6';
          btn.style.color = 'white';
          btn.classList.add('active');
        } else {
          btn.style.background = '#f1f5f9';
          btn.style.color = '#64748b';
          btn.classList.remove('active');
        }
      });

      // Show/hide content
      document.getElementById('yieldSingleTab').style.display = tab === 'single' ? 'block' : 'none';
      document.getElementById('yieldMultiTab').style.display = tab === 'multi' ? 'block' : 'none';
      document.getElementById('yieldBucketsTab').style.display = tab === 'buckets' ? 'block' : 'none';

      // Initialize tabs when switching to them
      if (tab === 'multi') {
        initMultiVariableCheckboxes();
      } else if (tab === 'buckets') {
        initYieldBucketSelectors();
        updateYieldBucketAnalysis();
      }
    }

    // Reset multivariate model when data filters change
    function resetMultiModel() {
      const resultsDiv = document.getElementById('multiModelResults');
      if (resultsDiv && resultsDiv.style.display !== 'none') {
        resultsDiv.style.display = 'none';
        // Show message that filters changed
        const warningDiv = document.getElementById('multiVarWarning');
        if (warningDiv) {
          const dataPoints = getYieldDataPoints();
          warningDiv.innerHTML = `<span style="color: #0369a1;">‚ÑπÔ∏è Data filters changed. ${dataPoints.length} data points available. Click "Run Multivariate Regression" to update results.</span>`;
        }
      }
      // Also update warning to show current data point count
      updateMultiVarWarning();
    }

    // Initialize checkboxes for variable selection in multivariate model
    function initMultiVariableCheckboxes() {
      const container = document.getElementById('multiVarCheckboxes');
      const nutrients = CONFIG.NUTRIENTS.filter(n => {
        const vis = JSON.parse(localStorage.getItem('nutrientVisibility') || '{}');
        return vis[n] !== false;
      });

      container.innerHTML = nutrients.map(n => {
        const checked = CORE_NUTRIENTS.includes(n) ? 'checked' : '';
        return `
          <label style="display: flex; align-items: center; gap: 0.25rem; padding: 0.375rem 0.75rem; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 0.375rem; cursor: pointer; font-size: 0.8rem;">
            <input type="checkbox" class="multi-var-checkbox" value="${n}" ${checked} onchange="updateMultiVarWarning()">
            ${CONFIG.NUTRIENT_NAMES[n] || n}
          </label>
        `;
      }).join('');

      updateMultiVarWarning();
    }

    function selectAllMultiVars() {
      document.querySelectorAll('.multi-var-checkbox').forEach(cb => cb.checked = true);
      updateMultiVarWarning();
    }

    function selectCoreMultiVars() {
      document.querySelectorAll('.multi-var-checkbox').forEach(cb => {
        cb.checked = CORE_NUTRIENTS.includes(cb.value);
      });
      updateMultiVarWarning();
    }

    function updateMultiVarWarning() {
      const selected = document.querySelectorAll('.multi-var-checkbox:checked').length;
      const dataPoints = getYieldDataPoints();
      const n = dataPoints.length;
      const warningDiv = document.getElementById('multiVarWarning');
      const crop = document.getElementById('yieldCropSelect').value;
      const cropLabel = crop === 'all' ? 'all crops' : crop;

      if (n === 0) {
        warningDiv.innerHTML = `<span style="color: #dc2626;">‚ö†Ô∏è No data available for ${cropLabel}. Check your filter selections.</span>`;
      } else if (selected === 0) {
        warningDiv.innerHTML = `<span style="color: #dc2626;">‚ö†Ô∏è ${n} data points for ${cropLabel}. Select at least one variable.</span>`;
      } else if (n < selected * 10) {
        warningDiv.innerHTML = `<span style="color: #f59e0b;">‚ö†Ô∏è ${n} data points for ${cropLabel}, ${selected} variables. Sample size warning: need ~${selected * 10} for reliable results.</span>`;
      } else {
        warningDiv.innerHTML = `<span style="color: #166534;">‚úì ${n} data points for ${cropLabel}, ${selected} variables selected. Good sample size.</span>`;
      }
    }

    // Matrix operations for regression
    function matrixMultiply(A, B) {
      const rowsA = A.length, colsA = A[0].length, colsB = B[0].length;
      const result = Array(rowsA).fill().map(() => Array(colsB).fill(0));
      for (let i = 0; i < rowsA; i++) {
        for (let j = 0; j < colsB; j++) {
          for (let k = 0; k < colsA; k++) {
            result[i][j] += A[i][k] * B[k][j];
          }
        }
      }
      return result;
    }

    function matrixTranspose(A) {
      return A[0].map((_, i) => A.map(row => row[i]));
    }

    function matrixInverse(A) {
      const n = A.length;
      const augmented = A.map((row, i) => [...row, ...Array(n).fill(0).map((_, j) => i === j ? 1 : 0)]);

      // Gaussian elimination with partial pivoting
      for (let i = 0; i < n; i++) {
        // Find pivot
        let maxRow = i;
        for (let k = i + 1; k < n; k++) {
          if (Math.abs(augmented[k][i]) > Math.abs(augmented[maxRow][i])) maxRow = k;
        }
        [augmented[i], augmented[maxRow]] = [augmented[maxRow], augmented[i]];

        if (Math.abs(augmented[i][i]) < 1e-10) {
          throw new Error('Matrix is singular');
        }

        // Scale row
        const scale = augmented[i][i];
        for (let j = 0; j < 2 * n; j++) augmented[i][j] /= scale;

        // Eliminate column
        for (let k = 0; k < n; k++) {
          if (k !== i) {
            const factor = augmented[k][i];
            for (let j = 0; j < 2 * n; j++) augmented[k][j] -= factor * augmented[i][j];
          }
        }
      }

      return augmented.map(row => row.slice(n));
    }

    // t-distribution CDF approximation for p-values
    function tCDF(t, df) {
      // Approximation using the incomplete beta function
      const x = df / (df + t * t);
      const a = df / 2;
      const b = 0.5;

      // Simple approximation for large df
      if (df > 100) {
        // Use normal approximation
        return 0.5 * (1 + erf(t / Math.sqrt(2)));
      }

      // Incomplete beta function approximation
      let result = Math.pow(x, a) * Math.pow(1 - x, b) / (a * beta(a, b));
      return t > 0 ? 1 - result / 2 : result / 2;
    }

    function erf(x) {
      const a1 =  0.254829592, a2 = -0.284496736, a3 =  1.421413741;
      const a4 = -1.453152027, a5 =  1.061405429, p  =  0.3275911;
      const sign = x < 0 ? -1 : 1;
      x = Math.abs(x);
      const t = 1 / (1 + p * x);
      const y = 1 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
      return sign * y;
    }

    function beta(a, b) {
      return Math.exp(lnGamma(a) + lnGamma(b) - lnGamma(a + b));
    }

    function lnGamma(x) {
      const cof = [76.18009172947146, -86.50532032941677, 24.01409824083091,
                   -1.231739572450155, 0.1208650973866179e-2, -0.5395239384953e-5];
      let y = x, tmp = x + 5.5;
      tmp -= (x + 0.5) * Math.log(tmp);
      let ser = 1.000000000190015;
      for (let j = 0; j < 6; j++) ser += cof[j] / ++y;
      return -tmp + Math.log(2.5066282746310005 * ser / x);
    }

    // Calculate p-value from t-statistic
    function pValueFromT(t, df) {
      // Two-tailed test
      const absT = Math.abs(t);
      // Approximation for p-value
      if (df > 100) {
        // Normal approximation
        return 2 * (1 - 0.5 * (1 + erf(absT / Math.sqrt(2))));
      }
      // Use t-distribution approximation
      const x = df / (df + absT * absT);
      return x; // Simplified - would need proper beta function for accuracy
    }

    // Simple but more accurate p-value calculation
    function calculatePValue(t, df) {
      // Using normal approximation for simplicity (good for df > 30)
      const absT = Math.abs(t);
      const p = 2 * (1 - normalCDF(absT));
      return Math.max(0.0001, Math.min(0.9999, p));
    }

    function normalCDF(x) {
      return 0.5 * (1 + erf(x / Math.sqrt(2)));
    }

    // Run multiple linear regression
    function runMultivariateRegression() {
      const selectedVars = Array.from(document.querySelectorAll('.multi-var-checkbox:checked')).map(cb => cb.value);

      if (selectedVars.length === 0) {
        showStatus('Select at least one variable', false);
        return;
      }

      const dataPoints = getYieldDataPoints();
      if (dataPoints.length < selectedVars.length + 2) {
        showStatus('Not enough data points for regression', false);
        return;
      }

      // Build X matrix (with intercept) and Y vector
      const n = dataPoints.length;
      const p = selectedVars.length + 1; // +1 for intercept

      const X = [];
      const Y = [];
      const validRows = [];

      dataPoints.forEach((dp, idx) => {
        const row = [1]; // Intercept
        let valid = true;

        selectedVars.forEach(v => {
          const val = parseFloat(dp[v]);
          if (isNaN(val) || val === 0) valid = false;
          row.push(val);
        });

        if (valid && dp.avgYield && !isNaN(dp.avgYield)) {
          X.push(row);
          Y.push([dp.avgYield]);
          validRows.push(idx);
        }
      });

      if (X.length < p + 1) {
        showStatus('Not enough valid data points after filtering missing values', false);
        return;
      }

      try {
        // Calculate regression: Œ≤ = (X'X)^(-1) X'Y
        const Xt = matrixTranspose(X);
        const XtX = matrixMultiply(Xt, X);
        const XtXinv = matrixInverse(XtX);
        const XtY = matrixMultiply(Xt, Y);
        const beta = matrixMultiply(XtXinv, XtY);

        // Calculate predictions and residuals
        const Yhat = matrixMultiply(X, beta);
        const residuals = Y.map((y, i) => y[0] - Yhat[i][0]);

        // Calculate statistics
        const yMean = Y.reduce((sum, y) => sum + y[0], 0) / Y.length;
        const SST = Y.reduce((sum, y) => sum + Math.pow(y[0] - yMean, 2), 0);
        const SSE = residuals.reduce((sum, r) => sum + r * r, 0);
        const SSR = SST - SSE;

        const R2 = 1 - SSE / SST;
        const adjR2 = 1 - (1 - R2) * (n - 1) / (n - p);
        const MSE = SSE / (X.length - p);
        const RMSE = Math.sqrt(MSE);

        // F-statistic
        const MSR = SSR / (p - 1);
        const Fstat = MSR / MSE;

        // Standard errors of coefficients
        const varBeta = XtXinv.map(row => row.map(val => val * MSE));
        const seBeta = varBeta.map((row, i) => Math.sqrt(Math.max(0, row[i])));

        // t-statistics and p-values
        const tStats = beta.map((b, i) => seBeta[i] > 0 ? b[0] / seBeta[i] : 0);
        const pValues = tStats.map(t => calculatePValue(t, X.length - p));

        // Store model for predictions
        lastMultiModel = {
          beta: beta.map(b => b[0]),
          vars: ['Intercept', ...selectedVars],
          seBeta,
          tStats,
          pValues,
          R2,
          adjR2,
          Fstat,
          RMSE,
          n: X.length,
          p: p
        };

        // Calculate VIF for collinearity check
        const vifs = calculateVIF(X, selectedVars);

        // Display results
        displayMultiResults(lastMultiModel, vifs);

      } catch (e) {
        console.error('Regression error:', e);
        showStatus('Regression failed: ' + e.message, false);
      }
    }

    // Calculate Variance Inflation Factor for collinearity detection
    function calculateVIF(X, vars) {
      const vifs = {};

      // Skip intercept column
      for (let j = 1; j < X[0].length; j++) {
        // Regress Xj on all other X variables
        const y = X.map(row => row[j]);
        const otherX = X.map(row => [1, ...row.slice(1, j), ...row.slice(j + 1)]);

        try {
          const Xt = matrixTranspose(otherX);
          const XtX = matrixMultiply(Xt, otherX);
          const XtXinv = matrixInverse(XtX);
          const Xty = matrixMultiply(Xt, y.map(v => [v]));
          const b = matrixMultiply(XtXinv, Xty);

          // Calculate R¬≤ for this regression
          const yhat = otherX.map(row => row.reduce((sum, x, i) => sum + x * b[i][0], 0));
          const yMean = y.reduce((a, b) => a + b, 0) / y.length;
          const SST = y.reduce((sum, yi) => sum + Math.pow(yi - yMean, 2), 0);
          const SSE = y.reduce((sum, yi, i) => sum + Math.pow(yi - yhat[i], 2), 0);
          const R2 = 1 - SSE / SST;

          vifs[vars[j - 1]] = 1 / (1 - R2);
        } catch (e) {
          vifs[vars[j - 1]] = Infinity;
        }
      }

      return vifs;
    }

    // Display multivariate regression results
    function displayMultiResults(model, vifs) {
      document.getElementById('multiModelResults').style.display = 'block';

      // Model Summary
      const summaryHtml = `
        <div style="text-align: center; padding: 0.5rem; background: white; border-radius: 0.375rem;">
          <div style="font-size: 1.5rem; font-weight: 700; color: #166534;">${(model.R2 * 100).toFixed(1)}%</div>
          <div style="font-size: 0.75rem; color: #64748b;">R¬≤ (Variance Explained)</div>
        </div>
        <div style="text-align: center; padding: 0.5rem; background: white; border-radius: 0.375rem;">
          <div style="font-size: 1.5rem; font-weight: 700; color: #1e40af;">${(model.adjR2 * 100).toFixed(1)}%</div>
          <div style="font-size: 0.75rem; color: #64748b;">Adjusted R¬≤</div>
        </div>
        <div style="text-align: center; padding: 0.5rem; background: white; border-radius: 0.375rem;">
          <div style="font-size: 1.5rem; font-weight: 700; color: #7c3aed;">${model.Fstat.toFixed(2)}</div>
          <div style="font-size: 0.75rem; color: #64748b;">F-statistic</div>
        </div>
        <div style="text-align: center; padding: 0.5rem; background: white; border-radius: 0.375rem;">
          <div style="font-size: 1.5rem; font-weight: 700; color: #475569;">${model.n}</div>
          <div style="font-size: 0.75rem; color: #64748b;">Observations</div>
        </div>
      `;
      document.getElementById('multiSummaryContent').innerHTML = summaryHtml;

      // Build interpretation section FIRST (before table)
      const r2Pct = (model.R2 * 100).toFixed(0);
      const remainingPct = (100 - model.R2 * 100).toFixed(0);

      // Sort variables by significance (excluding intercept)
      const varResults = model.vars.slice(1).map((v, i) => ({
        name: v,
        displayName: CONFIG.NUTRIENT_NAMES[v] || v,
        coef: model.beta[i + 1],
        pValue: model.pValues[i + 1],
        sig: model.pValues[i + 1] < 0.001 ? '***' : model.pValues[i + 1] < 0.01 ? '**' : model.pValues[i + 1] < 0.05 ? '*' : ''
      })).sort((a, b) => a.pValue - b.pValue);

      const sigVars = varResults.filter(v => v.pValue < 0.05);
      const marginalVars = varResults.filter(v => v.pValue >= 0.05 && v.pValue < 0.1);

      // Build key findings list
      let keyFindings = '';
      varResults.forEach(v => {
        if (v.pValue < 0.05) {
          const effect = v.coef >= 0 ? 'positive' : 'negative';
          const effectDesc = v.coef >= 0 ? 'Higher values = higher yields' : 'Higher values = lower yields';
          const noteText = v.coef < 0 ? ` <span style="color: #92400e; font-size: 0.75rem;">(Note: This may indicate high-${v.displayName} soils have other limiting factors, not that ${v.displayName} hurts yield)</span>` : '';
          keyFindings += `<div style="padding: 0.5rem; background: #f0fdf4; border-left: 3px solid #22c55e; margin-bottom: 0.5rem; border-radius: 0 0.25rem 0.25rem 0;">
            <strong style="color: #166534;">${v.displayName}</strong> <span style="color: #166534;">(${v.sig})</span> - Strong ${effect} effect. ${effectDesc}.${v.coef < 0 ? noteText : ''}
          </div>`;
        } else if (v.pValue < 0.1) {
          keyFindings += `<div style="padding: 0.5rem; background: #fefce8; border-left: 3px solid #eab308; margin-bottom: 0.5rem; border-radius: 0 0.25rem 0.25rem 0;">
            <strong style="color: #a16207;">${v.displayName}</strong> <span style="color: #a16207;">(.)</span> - Marginal effect. May be meaningful but not conclusive.
          </div>`;
        }
      });

      const notSigVars = varResults.filter(v => v.pValue >= 0.1).map(v => v.displayName).join(', ');
      if (notSigVars) {
        keyFindings += `<div style="padding: 0.5rem; background: #f8fafc; border-left: 3px solid #94a3b8; margin-bottom: 0.5rem; border-radius: 0 0.25rem 0.25rem 0; color: #64748b;">
          <strong>${notSigVars}</strong> - Not significant in this model when other nutrients are considered.
        </div>`;
      }

      // Significance bar chart
      let barChart = '<div style="margin-top: 1rem;"><strong style="font-size: 0.85rem;">Variable Significance:</strong>';
      barChart += '<div style="margin-top: 0.5rem;">';
      varResults.forEach(v => {
        const maxWidth = 200;
        // Use -log10(pValue) for bar width, capped at 4 (-log10(0.0001))
        const logP = Math.min(-Math.log10(Math.max(v.pValue, 0.0001)), 4);
        const width = (logP / 4) * maxWidth;
        const barColor = v.pValue < 0.05 ? (v.coef >= 0 ? '#22c55e' : '#ef4444') : v.pValue < 0.1 ? '#eab308' : '#cbd5e1';
        const textColor = v.pValue < 0.05 ? '#166534' : v.pValue < 0.1 ? '#a16207' : '#64748b';
        barChart += `
          <div style="display: flex; align-items: center; margin-bottom: 0.375rem; gap: 0.5rem;">
            <div style="width: 80px; font-size: 0.75rem; color: ${textColor}; text-align: right;">${v.displayName}</div>
            <div style="flex: 1; background: #f1f5f9; border-radius: 0.25rem; height: 20px; position: relative; max-width: ${maxWidth}px;">
              <div style="width: ${width}px; height: 100%; background: ${barColor}; border-radius: 0.25rem;"></div>
            </div>
            <div style="font-size: 0.7rem; color: ${textColor}; width: 40px;">${v.sig || 'n.s.'}</div>
          </div>`;
      });
      barChart += '</div></div>';

      // Interpretation section
      const interp = document.getElementById('multiInterpretation');
      interp.innerHTML = `
        <div style="margin-bottom: 1rem; padding: 1rem; background: #f8fafc; border-radius: 0.5rem;">
          <h4 style="margin: 0 0 0.75rem 0; color: #1e293b; font-size: 1rem;">What This Means</h4>
          <p style="margin: 0 0 0.75rem 0; color: #475569; font-size: 0.875rem;">
            This model explains <strong>${r2Pct}%</strong> of yield variation using soil nutrients.
            The remaining <strong>${remainingPct}%</strong> is due to other factors (weather, genetics, management, soil properties not measured, etc.).
          </p>
          ${sigVars.length > 0 ? `
            <h5 style="margin: 0 0 0.5rem 0; color: #1e293b; font-size: 0.9rem;">Key Findings:</h5>
            ${keyFindings}
          ` : `
            <div style="padding: 0.75rem; background: #fef3c7; border-radius: 0.375rem; color: #92400e;">
              <strong>No significant relationships found.</strong> This doesn't mean nutrients don't matter - it may mean:
              <ul style="margin: 0.5rem 0 0 1rem; padding: 0;">
                <li>Sample size may be too small to detect effects</li>
                <li>Other factors are more important in this dataset</li>
                <li>Nutrient levels may not vary enough to show effect</li>
              </ul>
            </div>
          `}
          ${barChart}
          <div style="margin-top: 1rem; padding-top: 0.75rem; border-top: 1px solid #e2e8f0;">
            <strong style="font-size: 0.8rem; color: #64748b;">How to read the table below:</strong>
            <ul style="margin: 0.25rem 0 0 1rem; padding: 0; font-size: 0.75rem; color: #64748b;">
              <li><strong>Coefficient:</strong> Yield change (bu/ac) for each 1-unit increase in that nutrient</li>
              <li><strong>p-value:</strong> Lower = more confident the effect is real (&lt;0.05 = significant)</li>
              <li><strong>Sig:</strong> *** = very strong, ** = strong, * = moderate, . = marginal, - = not significant</li>
            </ul>
          </div>
        </div>
      `;

      // Coefficients Table
      const tbody = document.getElementById('multiCoeffBody');
      tbody.innerHTML = model.vars.map((v, i) => {
        const coef = model.beta[i];
        const se = model.seBeta[i];
        const t = model.tStats[i];
        const p = model.pValues[i];
        const sig = p < 0.001 ? '***' : p < 0.01 ? '**' : p < 0.05 ? '*' : p < 0.1 ? '.' : '';
        const sigColor = p < 0.05 ? '#166534' : p < 0.1 ? '#ca8a04' : '#64748b';
        const bgColor = p < 0.05 ? '#f0fdf4' : '';

        return `
          <tr style="background: ${bgColor};">
            <td style="padding: 0.75rem; border-bottom: 1px solid #e2e8f0; font-weight: 500;">${v === 'Intercept' ? '(Intercept)' : CONFIG.NUTRIENT_NAMES[v] || v}</td>
            <td style="padding: 0.75rem; border-bottom: 1px solid #e2e8f0; text-align: right; font-family: monospace;">${coef >= 0 ? '+' : ''}${coef.toFixed(4)}</td>
            <td style="padding: 0.75rem; border-bottom: 1px solid #e2e8f0; text-align: right; font-family: monospace;">${se.toFixed(4)}</td>
            <td style="padding: 0.75rem; border-bottom: 1px solid #e2e8f0; text-align: right; font-family: monospace;">${t.toFixed(3)}</td>
            <td style="padding: 0.75rem; border-bottom: 1px solid #e2e8f0; text-align: right; font-family: monospace;">${p < 0.0001 ? '<0.0001' : p.toFixed(4)}</td>
            <td style="padding: 0.75rem; border-bottom: 1px solid #e2e8f0; text-align: center; font-weight: 700; color: ${sigColor};">${sig || '-'}</td>
          </tr>
        `;
      }).join('');

      // Collinearity warning
      const highVIF = Object.entries(vifs).filter(([k, v]) => v > 5);
      const collinearDiv = document.getElementById('multiCollinearityWarning');
      if (highVIF.length > 0) {
        collinearDiv.style.display = 'block';
        document.getElementById('collinearityDetails').innerHTML =
          '<strong>High VIF values (>5):</strong><br>' +
          highVIF.map(([k, v]) => `‚Ä¢ ${CONFIG.NUTRIENT_NAMES[k] || k}: VIF = ${v.toFixed(2)}`).join('<br>') +
          '<br><br>Consider removing one of the correlated variables for more reliable estimates.';
      } else {
        collinearDiv.style.display = 'none';
      }

      // Setup predictor inputs
      const predictorDiv = document.getElementById('predictorInputs');
      predictorDiv.innerHTML = model.vars.filter(v => v !== 'Intercept').map(v => {
        const name = CONFIG.NUTRIENT_NAMES[v] || v;
        return `
          <div>
            <label style="font-size: 0.7rem; color: #64748b; display: block;">${name}</label>
            <input type="number" id="predict_${v}" placeholder="${v}" style="width: 100%; padding: 0.375rem; border: 1px solid #d8b4fe; border-radius: 0.25rem; font-size: 0.85rem;">
          </div>
        `;
      }).join('');

      showStatus('Regression complete', true);
    }

    // Predict yield from entered values
    function predictYield() {
      if (!lastMultiModel) {
        showStatus('Run regression first', false);
        return;
      }

      const values = [1]; // Intercept
      let missing = [];

      lastMultiModel.vars.forEach((v, i) => {
        if (v === 'Intercept') return;
        const input = document.getElementById(`predict_${v}`);
        const val = parseFloat(input?.value);
        if (isNaN(val)) {
          missing.push(CONFIG.NUTRIENT_NAMES[v] || v);
          values.push(0);
        } else {
          values.push(val);
        }
      });

      if (missing.length > 0) {
        showStatus(`Enter values for: ${missing.join(', ')}`, false);
        return;
      }

      // Calculate prediction
      let prediction = 0;
      for (let i = 0; i < lastMultiModel.beta.length; i++) {
        prediction += lastMultiModel.beta[i] * values[i];
      }

      // Simple confidence interval (rough approximation)
      const se = lastMultiModel.RMSE;
      const ci95 = 1.96 * se;

      const resultDiv = document.getElementById('predictionResult');
      resultDiv.style.display = 'block';
      resultDiv.innerHTML = `
        <div style="text-align: center;">
          <div style="font-size: 1.5rem; font-weight: 700; color: #7c3aed;">${prediction.toFixed(1)} bu/ac</div>
          <div style="font-size: 0.8rem; color: #64748b;">Predicted Yield</div>
          <div style="font-size: 0.75rem; color: #a855f7; margin-top: 0.5rem;">95% CI: ${(prediction - ci95).toFixed(1)} ‚Äì ${(prediction + ci95).toFixed(1)} bu/ac</div>
        </div>
      `;
    }

    // Toggle yield debug panel
    function toggleYieldDebug() {
      const panel = document.getElementById('yieldDebugPanel');
      const content = document.getElementById('yieldDebugContent');

      if (panel.style.display === 'none') {
        content.textContent = generateDebugReport();
        panel.style.display = 'block';
      } else {
        panel.style.display = 'none';
      }
    }

    // Generate comprehensive debug report for yield correlation verification
    function generateDebugReport() {
      const cropFilter = document.getElementById('yieldCropSelect').value;
      const yearFilter = document.getElementById('yieldYearSelect').value;
      const soilYearFilter = document.getElementById('soilYearSelect').value;
      const fieldFilter = document.getElementById('yieldFieldSelect').value;

      let report = [];
      report.push('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
      report.push('‚ïë               YIELD CORRELATION VERIFICATION REPORT                ‚ïë');
      report.push('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
      report.push('');

      // Get samples with yield correlations
      let samplesWithYield = sampleData.filter(s => s.yieldCorrelations && Object.keys(s.yieldCorrelations).length > 0);

      report.push(`FILTERS APPLIED:`);
      report.push(`  Crop: ${cropFilter}`);
      report.push(`  Yield Year: ${yearFilter}`);
      report.push(`  Soil Sample Year: ${soilYearFilter}`);
      report.push(`  Field: ${fieldFilter}`);
      report.push('');

      // Filter by field
      if (fieldFilter !== 'all') {
        samplesWithYield = samplesWithYield.filter(s => s.field === fieldFilter);
      }

      // Filter by soil sample year
      let soilYearDescription = '';
      if (soilYearFilter === 'recent') {
        // Use only most recent soil sample at each location
        const locationMap = new Map();
        samplesWithYield.forEach(sample => {
          const locKey = `${sample.lat.toFixed(5)},${sample.lon.toFixed(5)}`;
          const existing = locationMap.get(locKey);
          if (!existing || (sample.year && sample.year > existing.year)) {
            locationMap.set(locKey, sample);
          }
        });
        samplesWithYield = Array.from(locationMap.values());
        soilYearDescription = 'Most recent at each location';
      } else if (soilYearFilter === 'all') {
        soilYearDescription = 'All years (may include duplicates)';
      } else {
        const selectedYear = parseInt(soilYearFilter);
        samplesWithYield = samplesWithYield.filter(s => s.year === selectedYear);
        soilYearDescription = `${selectedYear} only`;
      }

      report.push(`STEP 1: DATA SELECTION`);
      report.push(`  Total samples in database: ${sampleData.length}`);
      report.push(`  Samples with yield data: ${samplesWithYield.length}`);
      report.push(`  Soil year filter: ${soilYearDescription}`);
      report.push('');

      // Build data points based on yearFilter mode
      const dataPoints = [];

      if (yearFilter === 'avg') {
        samplesWithYield.forEach(sample => {
          const validYields = [];
          Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
            if (cropFilter === 'all' || yieldInfo.crop === cropFilter) {
              validYields.push({ yield: yieldInfo.avgYield, year: year });
            }
          });
          if (validYields.length > 0) {
            const avgYield = validYields.reduce((sum, v) => sum + v.yield, 0) / validYields.length;
            dataPoints.push({ ...sample, avgYield: avgYield, yearsUsed: validYields.map(v => v.year).join(',') });
          }
        });
        report.push(`STEP 2: MULTI-YEAR AVERAGING`);
        report.push(`  Mode: All Years (Average) - averaging yield across years at each location`);
        report.push(`  Resulting data points: ${dataPoints.length}`);
      } else if (yearFilter === 'combined') {
        samplesWithYield.forEach(sample => {
          Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
            if (cropFilter === 'all' || yieldInfo.crop === cropFilter) {
              dataPoints.push({ ...sample, avgYield: yieldInfo.avgYield, yieldYear: year });
            }
          });
        });
        report.push(`STEP 2: MULTI-YEAR COMBINED`);
        report.push(`  Mode: All Years (Combined) - each year is a separate data point`);
        report.push(`  Resulting data points: ${dataPoints.length}`);
      } else {
        samplesWithYield.forEach(sample => {
          const yieldInfo = sample.yieldCorrelations[yearFilter];
          if (yieldInfo && (cropFilter === 'all' || yieldInfo.crop === cropFilter)) {
            dataPoints.push({ ...sample, avgYield: yieldInfo.avgYield });
          }
        });
        report.push(`STEP 2: SINGLE YEAR FILTER`);
        report.push(`  Selected year: ${yearFilter}`);
        report.push(`  Matching data points: ${dataPoints.length}`);
      }
      report.push('');

      // Show radius information for selected crop
      report.push(`STEP 3: YIELD SEARCH RADIUS (${cropFilter})`);
      const radiusValues = new Set();
      samplesWithYield.forEach(sample => {
        Object.values(sample.yieldCorrelations).forEach(yieldInfo => {
          if (yieldInfo.radiusFt && yieldInfo.crop === cropFilter) {
            radiusValues.add(yieldInfo.radiusFt);
          }
        });
      });
      if (radiusValues.size > 0) {
        report.push(`  Radius values for ${cropFilter}: ${[...radiusValues].sort((a,b) => a-b).join(', ')} ft`);
      } else {
        report.push(`  No radius information stored for ${cropFilter} (older import or no data)`);
      }
      report.push('');

      // Show crop breakdown
      report.push(`STEP 3.5: CROP DATA BREAKDOWN`);
      const cropCounts = {};
      const cropsByYear = {};
      samplesWithYield.forEach(sample => {
        Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
          const crop = yieldInfo.crop || 'unknown';
          cropCounts[crop] = (cropCounts[crop] || 0) + 1;
          if (!cropsByYear[year]) cropsByYear[year] = {};
          cropsByYear[year][crop] = (cropsByYear[year][crop] || 0) + 1;
        });
      });
      report.push(`  Crops stored in database:`);
      Object.entries(cropCounts).sort((a,b) => b[1] - a[1]).forEach(([crop, count]) => {
        const marker = (cropFilter === 'all' || crop === cropFilter) ? '‚úì' : '‚úó';
        report.push(`    ${marker} ${crop}: ${count} yield entries ${cropFilter !== 'all' && crop !== cropFilter ? '(filtered out)' : '(included)'}`);
      });
      report.push(`  Crops by year:`);
      Object.keys(cropsByYear).sort().forEach(year => {
        const crops = Object.entries(cropsByYear[year]).map(([c, n]) => `${c}:${n}`).join(', ');
        report.push(`    ${year}: ${crops}`);
      });
      report.push(`  Current crop filter: "${cropFilter}"`);
      if (cropFilter !== 'all') {
        const filteredCount = cropCounts[cropFilter] || 0;
        report.push(`  ‚Üí Only using ${filteredCount} entries matching "${cropFilter}"`);
      }
      report.push('');

      // Get yield statistics
      const yields = dataPoints.map(d => d.avgYield);
      const avgYield = yields.reduce((a, b) => a + b, 0) / yields.length;
      const minYield = Math.min(...yields);
      const maxYield = Math.max(...yields);

      report.push(`STEP 4: YIELD DATA QUALITY`);
      report.push(`  Data points: ${dataPoints.length}`);
      report.push(`  Yield range: ${minYield.toFixed(1)} - ${maxYield.toFixed(1)} bu/ac`);
      report.push(`  Average yield: ${avgYield.toFixed(1)} bu/ac`);
      report.push('');

      // Pick a sample nutrient for detailed verification
      const testNutrient = 'P';
      const pairsP = dataPoints.filter(d => d[testNutrient] !== undefined && d[testNutrient] !== null && d[testNutrient] !== '');
      const xValues = pairsP.map(d => parseFloat(d[testNutrient]));
      const yValues = pairsP.map(d => d.avgYield);

      if (pairsP.length >= 5) {
        const n = xValues.length;
        const sumX = xValues.reduce((a, b) => a + b, 0);
        const sumY = yValues.reduce((a, b) => a + b, 0);
        const meanX = sumX / n;
        const meanY = sumY / n;
        const sumXY = xValues.reduce((sum, x, i) => sum + x * yValues[i], 0);
        const sumX2 = xValues.reduce((sum, x) => sum + x * x, 0);
        const sumY2 = yValues.reduce((sum, y) => sum + y * y, 0);

        const numerator = n * sumXY - sumX * sumY;
        const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
        const r = denominator !== 0 ? numerator / denominator : 0;

        report.push(`STEP 5: CORRELATION CALCULATION (Example: ${testNutrient})`);
        report.push(`  Valid pairs (n): ${n}`);
        report.push(`  Mean ${testNutrient}: ${meanX.toFixed(2)}`);
        report.push(`  Mean Yield: ${meanY.toFixed(2)}`);
        report.push(`  Sum(X): ${sumX.toFixed(2)}`);
        report.push(`  Sum(Y): ${sumY.toFixed(2)}`);
        report.push(`  Sum(XY): ${sumXY.toFixed(2)}`);
        report.push(`  Sum(X¬≤): ${sumX2.toFixed(2)}`);
        report.push(`  Sum(Y¬≤): ${sumY2.toFixed(2)}`);
        report.push('');
        report.push(`  Formula: r = (n√óŒ£XY - Œ£X√óŒ£Y) / ‚àö[(n√óŒ£X¬≤ - (Œ£X)¬≤)(n√óŒ£Y¬≤ - (Œ£Y)¬≤)]`);
        report.push(`  Numerator: ${n} √ó ${sumXY.toFixed(2)} - ${sumX.toFixed(2)} √ó ${sumY.toFixed(2)} = ${numerator.toFixed(2)}`);
        report.push(`  Denominator: ${denominator.toFixed(2)}`);
        report.push(`  r = ${numerator.toFixed(2)} / ${denominator.toFixed(2)} = ${r.toFixed(4)}`);
        report.push(`  R¬≤ = ${(r * r * 100).toFixed(2)}%`);
        report.push('');

        // Show sample data points
        report.push(`SAMPLE DATA POINTS (first 10):`);
        report.push(`  ${'Sample ID'.padEnd(20)} ${'Field'.padEnd(15)} ${testNutrient.padStart(8)} ${'Yield'.padStart(10)}`);
        report.push(`  ${'-'.repeat(20)} ${'-'.repeat(15)} ${'-'.repeat(8)} ${'-'.repeat(10)}`);
        pairsP.slice(0, 10).forEach(d => {
          const id = (d.sampleId || 'N/A').toString().substring(0, 18).padEnd(20);
          const field = (d.field || 'N/A').substring(0, 13).padEnd(15);
          const pVal = parseFloat(d[testNutrient]).toFixed(1).padStart(8);
          const yVal = d.avgYield.toFixed(1).padStart(10);
          report.push(`  ${id} ${field} ${pVal} ${yVal}`);
        });
      } else {
        report.push(`STEP 5: INSUFFICIENT DATA`);
        report.push(`  Only ${pairsP.length} valid ${testNutrient} values (need 5+)`);
      }

      report.push('');
      report.push('');
      report.push('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
      report.push('‚ïë                    UNDERSTANDING CORRELATIONS                       ‚ïë');
      report.push('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
      report.push('');
      report.push('WHY MIGHT CORRELATIONS BE NEGATIVE?');
      report.push('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
      report.push('A negative correlation means higher nutrient levels are associated');
      report.push('with LOWER yields. This can happen for several legitimate reasons:');
      report.push('');
      report.push('1. NUTRIENT TOXICITY OR IMBALANCE');
      report.push('   ‚Ä¢ Too much of some nutrients can harm crops (e.g., high Na, Fe)');
      report.push('   ‚Ä¢ Nutrient imbalances affect uptake of other nutrients');
      report.push('   ‚Ä¢ Example: High Mg can block Ca uptake');
      report.push('');
      report.push('2. SOIL QUALITY INDICATORS');
      report.push('   ‚Ä¢ Some nutrients accumulate in poor-draining soils');
      report.push('   ‚Ä¢ High H_Sat indicates acidic conditions limiting yield');
      report.push('   ‚Ä¢ High Na_Sat indicates salinity problems');
      report.push('');
      report.push('3. MANAGEMENT PRACTICES');
      report.push('   ‚Ä¢ High-yielding areas may have depleted nutrients');
      report.push('   ‚Ä¢ Low-yielding areas may have accumulated unused fertilizer');
      report.push('   ‚Ä¢ Manure application patterns vs. yield patterns');
      report.push('');
      report.push('4. SPATIAL CONFOUNDING');
      report.push('   ‚Ä¢ Nutrient levels may correlate with other limiting factors');
      report.push('   ‚Ä¢ Example: Low spots have high nutrients but poor drainage');
      report.push('   ‚Ä¢ Hilltops may have low nutrients but better conditions');
      report.push('');
      report.push('5. SAMPLE SIZE & NOISE');
      report.push('   ‚Ä¢ Small sample sizes can show spurious correlations');
      report.push('   ‚Ä¢ Look for |r| > 0.3 and n > 20 for meaningful relationships');
      report.push('   ‚Ä¢ R¬≤ < 10% means the nutrient explains very little yield variation');
      report.push('');
      report.push('INTERPRETING THE RESULTS');
      report.push('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
      report.push('‚Ä¢ r = +1.0: Perfect positive (higher nutrient = higher yield)');
      report.push('‚Ä¢ r = +0.5: Moderate positive correlation');
      report.push('‚Ä¢ r =  0.0: No linear relationship');
      report.push('‚Ä¢ r = -0.5: Moderate negative correlation');
      report.push('‚Ä¢ r = -1.0: Perfect negative (higher nutrient = lower yield)');
      report.push('');
      report.push('‚Ä¢ R¬≤ (R-squared): % of yield variation explained by this nutrient');
      report.push('  - R¬≤ = 25% means 25% of yield differences relate to this nutrient');
      report.push('  - R¬≤ < 5% = very weak, likely not meaningful');
      report.push('  - R¬≤ > 20% = moderate, worth investigating');
      report.push('');
      report.push('NUTRIENTS EXPECTED TO BE NEGATIVE (Lower is Better):');
      report.push('  ‚Ä¢ H_Sat (Hydrogen Saturation) - indicates acidity');
      report.push('  ‚Ä¢ Na_Sat (Sodium Saturation) - indicates salinity');
      report.push('  ‚Ä¢ Mg_sat (when excessive) - can block calcium');
      report.push('  ‚Ä¢ Soluble_Salts - indicates salt stress');
      report.push('');
      report.push('‚ïê'.repeat(70));
      report.push(`Report generated: ${new Date().toLocaleString()}`);

      return report.join('\n');
    }

    // ========== EXPORT FUNCTIONS ==========
    function getReportStyles() {
      return `
        * { box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif; padding: 20px; font-size: 12px; color: #1e293b; line-height: 1.5; }
        h1 { color: #1e293b; border-bottom: 3px solid #3b82f6; padding-bottom: 12px; margin-bottom: 20px; font-size: 24px; }
        h2 { color: #334155; margin-top: 24px; margin-bottom: 16px; font-size: 18px; }
        h3 { color: #475569; margin: 0 0 8px 0; font-size: 16px; }
        p { color: #64748b; margin: 0 0 16px 0; }
        .summary { display: flex; gap: 20px; margin: 20px 0; flex-wrap: wrap; }
        .summary-box { background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%); padding: 16px 24px; border-radius: 10px; text-align: center; min-width: 120px; border: 1px solid #cbd5e1; }
        .summary-box .number { font-size: 28px; font-weight: bold; color: #3b82f6; }
        .summary-box .label { color: #64748b; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; margin-top: 4px; }
        table { width: 100%; border-collapse: collapse; margin: 16px 0; font-size: 11px; }
        th { background: #1e293b; color: white; padding: 10px 8px; text-align: left; font-weight: 600; }
        td { padding: 8px; border-bottom: 1px solid #e2e8f0; }
        tr:nth-child(even) { background: #f8fafc; }
        .positive { color: #16a34a; } .negative { color: #dc2626; }
        .card { background: #f8fafc; border-left: 4px solid #3b82f6; padding: 12px 16px; margin: 12px 0; border-radius: 6px; }
        .card.positive { border-left-color: #22c55e; background: #f0fdf4; }
        .card.negative { border-left-color: #ef4444; background: #fef2f2; }

        /* Trend Cards for Field Trends Report - PDF optimized */
        .trend-card { background: #fff; border: 2px solid #e2e8f0; border-radius: 10px; padding: 20px; margin-bottom: 20px; page-break-inside: avoid; box-shadow: 0 1px 4px rgba(0,0,0,0.08); }
        .trend-card.positive { background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%); border-color: #22c55e; }
        .trend-card.negative { background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%); border-color: #ef4444; }
        .trend-card.neutral { background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%); border-color: #94a3b8; }
        .trend-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid rgba(0,0,0,0.1); }
        .trend-title { font-size: 18px; font-weight: 700; color: #1e293b; margin: 0; }
        .trend-pct { font-size: 22px; font-weight: 700; text-align: right; }
        .trend-sub { font-size: 11px; color: #64748b; font-weight: 500; }

        /* Stacked layout for PDF - data table on top, full-width graph below */
        .trend-content { display: flex; flex-direction: column; gap: 16px; }
        .trend-values { background: rgba(255,255,255,0.8); border-radius: 6px; padding: 10px; width: 100%; border: 1px solid rgba(0,0,0,0.08); }
        .trend-values-row { display: flex; flex-wrap: wrap; gap: 8px; }
        .trend-row { display: flex; justify-content: space-between; align-items: center; padding: 6px 12px; font-size: 11px; border-radius: 4px; width: 100%; box-sizing: border-box; }
        .trend-row.alt { background: rgba(0,0,0,0.04); }
        .trend-year { font-weight: 600; color: #475569; flex: 0 0 60px; }
        .trend-value { font-weight: 700; color: #1e293b; flex: 0 0 70px; text-align: center; }
        .trend-graph { width: 100%; padding: 10px; background: rgba(255,255,255,0.5); border-radius: 8px; }
        .trend-graph svg { width: 100%; height: auto; min-height: 200px; display: block; }
        .trend-graph.large svg { min-height: 240px; }
        .trend-graph.xlarge svg { min-height: 300px; }

        /* Nutrient cards for Year Comparison */
        .nutrient-card { background: #fff; border: 2px solid #e2e8f0; border-radius: 8px; padding: 12px; margin-bottom: 12px; }
        .nutrient-card.positive { background: #f0fdf4; border-color: #22c55e; }
        .nutrient-card.negative { background: #fef2f2; border-color: #ef4444; }
        .nutrient-header { display: flex; justify-content: space-between; margin-bottom: 8px; }
        .nutrient-name { font-weight: 700; font-size: 14px; }
        .nutrient-pct { font-weight: 700; font-size: 14px; }
        .nutrient-stats { display: flex; gap: 12px; margin-bottom: 8px; }
        .stat-box { text-align: center; padding: 6px 10px; background: rgba(0,0,0,0.03); border-radius: 4px; }
        .stat-box .label { font-size: 9px; color: #64748b; text-transform: uppercase; }
        .stat-box .value { font-size: 16px; font-weight: 700; color: #1e293b; }

        .footer { margin-top: 40px; padding-top: 16px; border-top: 1px solid #e2e8f0; color: #94a3b8; font-size: 10px; text-align: center; }

        /* Page break hints for PDF - use on section wrappers */
        .page-break-before { page-break-before: always; break-before: page; }
        .page-break-after { page-break-after: always; break-after: page; }
        .no-break { page-break-inside: avoid; break-inside: avoid; }

        @media print {
          @page {
            size: letter portrait;
            margin: 0.5in;
          }

          body {
            padding: 0;
            -webkit-print-color-adjust: exact !important;
            print-color-adjust: exact !important;
          }

          /* ===== TREND CARDS - FIELD TRENDS REPORT ===== */

          /* Card container - keep card + all insights together */
          .trend-card {
            page-break-inside: avoid !important;
            break-inside: avoid !important;
            max-height: 680px !important;
            overflow: hidden !important;
            margin-bottom: 15px !important;
            padding: 15px !important;
            border: 2px solid #e2e8f0 !important;
            border-radius: 8px !important;
            position: relative !important;
          }
          .trend-card.positive {
            border-color: #22c55e !important;
            background: #f0fdf4 !important;
          }
          .trend-card.negative {
            border-color: #ef4444 !important;
            background: #fef2f2 !important;
          }
          .trend-card.neutral {
            border-color: #94a3b8 !important;
            background: #f8fafc !important;
          }

          /* Remove any pseudo-elements that might create stray lines */
          .trend-card::before,
          .trend-card::after {
            display: none !important;
          }

          /* Compact the graph for print */
          .trend-graph {
            padding: 5px !important;
          }
          .trend-graph svg {
            min-height: 120px !important;
            max-height: 150px !important;
            width: 100% !important;
          }
          .trend-graph.large svg,
          .trend-graph.xlarge svg {
            min-height: 140px !important;
            max-height: 170px !important;
          }

          /* Compact header */
          .trend-header {
            margin-bottom: 10px !important;
            padding-bottom: 8px !important;
          }
          .trend-title {
            font-size: 14px !important;
          }
          .trend-pct {
            font-size: 16px !important;
          }
          .trend-sub {
            font-size: 9px !important;
          }

          /* ===== DATA TABLE (trend-values) FIXES ===== */

          /* Container for data table */
          .trend-values {
            width: 100% !important;
            padding: 8px !important;
            background: rgba(255,255,255,0.9) !important;
            border: 1px solid #e2e8f0 !important;
            border-radius: 6px !important;
          }

          /* Header row - the div with Avg/Median labels */
          .trend-values > div:first-child {
            display: flex !important;
            justify-content: flex-end !important;
            padding: 4px 8px !important;
            margin-bottom: 4px !important;
            border-bottom: 1px solid #e2e8f0 !important;
            font-size: 9px !important;
          }

          /* Data rows */
          .trend-row {
            display: flex !important;
            justify-content: space-between !important;
            align-items: center !important;
            padding: 4px 8px !important;
            font-size: 10px !important;
            width: 100% !important;
            box-sizing: border-box !important;
          }

          .trend-row.alt {
            background: rgba(0,0,0,0.03) !important;
          }

          /* Year label */
          .trend-year {
            flex: 0 0 60px !important;
            font-weight: 600 !important;
          }

          /* Value columns - ensure consistent widths */
          .trend-value {
            flex: 0 0 65px !important;
            text-align: center !important;
          }

          /* Fix the Change row with border-top */
          .trend-row[style*="border-top"] {
            margin-top: 6px !important;
            padding-top: 6px !important;
            border-top-width: 2px !important;
            border-top-style: solid !important;
          }

          /* Insight boxes inside cards - keep together, compact */
          .trend-card > div[style*="background: #f8fafc"],
          .trend-card > div[style*="background: #fef3c7"],
          .trend-card > div[style*="background: #dcfce7"],
          .trend-card > div[style*="background: #fef2f2"],
          .trend-card > div[style*="background: #fffbeb"],
          .trend-card > div[style*="background: linear-gradient"] {
            page-break-inside: avoid !important;
            break-inside: avoid !important;
            margin: 8px 0 !important;
            padding: 8px !important;
            font-size: 10px !important;
            line-height: 1.3 !important;
          }

          /* Recommendation lists compact */
          .trend-card ul {
            margin: 5px 0 !important;
            padding-left: 15px !important;
          }
          .trend-card li {
            font-size: 9px !important;
            margin-bottom: 3px !important;
            line-height: 1.2 !important;
          }

          /* ===== NUTRIENT CARDS - YEAR COMPARISON ===== */
          .nutrient-card {
            page-break-inside: avoid !important;
            break-inside: avoid !important;
            padding: 10px !important;
            margin-bottom: 10px !important;
          }

          /* ===== GENERAL PRINT RULES ===== */

          /* Prevent breaking inside content containers */
          .card, table, .summary,
          .model-summary, .key-findings, .data-table, .zone-summary,
          .chart-container, .interpretation-section, .findings-grid,
          .coef-table, .scatter-container, .threshold-box {
            page-break-inside: avoid !important;
            break-inside: avoid !important;
          }

          /* Keep headers with their following content */
          h1, h2, h3, h4 {
            page-break-after: avoid !important;
            break-after: avoid !important;
          }

          /* Force page breaks BEFORE major sections */
          .new-section, .report-section {
            page-break-before: always;
            break-before: page;
          }
          .new-section:first-of-type, .report-section:first-of-type {
            page-break-before: avoid;
            break-before: avoid;
          }

          /* Prevent orphaned/widowed lines */
          p, li, td {
            orphans: 3;
            widows: 3;
          }

          /* Tables - keep rows together */
          tr {
            page-break-inside: avoid !important;
            break-inside: avoid !important;
          }
          thead {
            display: table-header-group;
          }

          /* Charts and visualizations */
          svg, canvas, .chart, .bar-chart {
            page-break-inside: avoid !important;
            break-inside: avoid !important;
            max-height: 300px !important;
          }
          canvas {
            max-width: 100% !important;
          }

          /* MVR and Spatial specific */
          .significance-chart, .mvr-coefficients,
          .zone-card, .change-grid {
            page-break-inside: avoid !important;
            break-inside: avoid !important;
          }

          /* Operation summary header - don't break */
          div[style*="background: linear-gradient(135deg, #eff6ff"] {
            page-break-inside: avoid !important;
            break-inside: avoid !important;
            page-break-after: avoid !important;
          }
        }
      `;
    }

    function exportYearComparison() {
      const y1 = document.getElementById('year1Select').value;
      const y2 = document.getElementById('year2Select').value;
      if (!y1 || !y2) { showStatus('Select both years first', false); return; }

      const operationName = localStorage.getItem('operationName') || 'Soil Analysis';
      const comparisonData = document.getElementById('comparisonGrid').innerHTML;

      const printWindow = window.open('', '_blank');
      printWindow.document.write(`<!DOCTYPE html><html><head><title>${operationName} - Year Comparison</title><style>${getReportStyles()}
        /* Print-optimized grid for Year Comparison */
        .comparison-grid {
          display: grid;
          grid-template-columns: repeat(3, 1fr);
          gap: 10px;
        }
        @media print {
          .comparison-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
          }
          .comparison-grid > .nutrient-card {
            page-break-inside: avoid !important;
            break-inside: avoid !important;
          }
        }
      </style></head><body>
        <h1>${operationName} - Year-Over-Year Comparison</h1>
        <p>Generated: ${new Date().toLocaleString()}</p>
        <div class="summary">
          <div class="summary-box"><div class="number">${y1}</div><div class="label">From Year</div></div>
          <div class="summary-box"><div class="number">${y2}</div><div class="label">To Year</div></div>
          <div class="summary-box"><div class="number">${selectedComparisonFields.size}</div><div class="label">Fields Compared</div></div>
        </div>
        <h2>Nutrient Changes</h2>
        <div class="comparison-grid">${comparisonData}</div>
        <div class="footer">Soil Sample Analysis App</div>
      </body></html>`);
      printWindow.document.close();
      printWindow.print();
    }

    function exportFieldTrends() {
      const field = document.getElementById('historyFieldSelect').value;
      if (!field) { showStatus('Select a field first', false); return; }

      const operationName = localStorage.getItem('operationName') || 'Soil Analysis';
      const trendData = document.getElementById('historyContent').innerHTML;
      const fieldLabel = field === '__all__' ? 'All Fields' : field;

      const printWindow = window.open('', '_blank');
      printWindow.document.write(`<!DOCTYPE html><html><head><title>${operationName} - Field Trends</title><style>${getReportStyles()}
        /* Print-optimized layout for Field Trends */
        .trends-container {
          display: flex;
          flex-direction: column;
          gap: 15px;
        }
        @media print {
          .trends-container {
            display: block;
          }
          .trends-container > .trend-card {
            width: 100% !important;
            margin-bottom: 15px !important;
          }
        }
      </style></head><body>
        <h1>${operationName} - Field Trends: ${fieldLabel}</h1>
        <p>Generated: ${new Date().toLocaleString()}</p>
        <h2>Historical Nutrient Trends</h2>
        <div class="trends-container">${trendData}</div>
        <div class="footer">Soil Sample Analysis App</div>
      </body></html>`);
      printWindow.document.close();
      printWindow.print();
    }

    function exportFieldRankings() {
      const nutrient = document.getElementById('rankingAttrSelect').value;
      const year = document.getElementById('rankingYearSelect').value;
      const operationName = localStorage.getItem('operationName') || 'Soil Analysis';
      const rankingData = document.getElementById('rankingsContent').innerHTML;

      const printWindow = window.open('', '_blank');
      printWindow.document.write(`<!DOCTYPE html><html><head><title>${operationName} - Field Rankings</title><style>${getReportStyles()}</style></head><body>
        <h1>${operationName} - Field Rankings</h1>
        <p>Generated: ${new Date().toLocaleString()}</p>
        <div class="summary">
          <div class="summary-box"><div class="number">${CONFIG.NUTRIENT_NAMES[nutrient] || nutrient}</div><div class="label">Nutrient</div></div>
          <div class="summary-box"><div class="number">${year === 'most_recent' ? 'Most Recent' : year}</div><div class="label">Year</div></div>
        </div>
        <h2>Rankings</h2>
        ${rankingData}
        <div class="footer">Soil Sample Analysis App</div>
      </body></html>`);
      printWindow.document.close();
      printWindow.print();
    }

    function exportYieldCorrelation() {
      const crop = document.getElementById('yieldCropSelect').value;
      const year = document.getElementById('yieldYearSelect').value;
      const field = document.getElementById('yieldFieldSelect').value;
      const operationName = localStorage.getItem('operationName') || 'Soil Analysis';

      // Format year label
      let yearLabel = year;
      if (year === 'avg') yearLabel = 'All (Averaged)';
      else if (year === 'combined') yearLabel = 'All (Combined)';

      // Detect which tab is active
      const isMultiTab = document.getElementById('yieldMultiTab').style.display !== 'none';
      const isBucketsTab = document.getElementById('yieldBucketsTab').style.display !== 'none';

      let reportContent = '';
      let reportTitle = '';

      if (isBucketsTab) {
        // Export Yield by Nutrient Level results
        reportTitle = 'Yield by Nutrient Level';
        reportContent = document.getElementById('yieldBucketsContent').innerHTML;
      } else if (isMultiTab) {
        // Export MVR results
        reportTitle = 'Multivariate Regression Analysis';

        // Check if model has been run
        if (!lastMultiModel) {
          alert('Please run the regression analysis first before exporting.');
          return;
        }

        // Get selected variables
        const selectedVars = Array.from(document.querySelectorAll('.multi-var-checkbox:checked'))
          .map(cb => CONFIG.NUTRIENT_NAMES[cb.value] || cb.value);

        // Model Summary
        reportContent = `
          <div style="background: #f0fdf4; border: 2px solid #22c55e; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem;">
            <h3 style="margin: 0 0 0.75rem 0; color: #166534;">Model Summary</h3>
            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; text-align: center;">
              <div><div style="font-size: 1.5rem; font-weight: 700; color: #166534;">${(lastMultiModel.R2 * 100).toFixed(1)}%</div><div style="font-size: 0.8rem; color: #64748b;">R¬≤ (Variance Explained)</div></div>
              <div><div style="font-size: 1.5rem; font-weight: 700; color: #1e40af;">${(lastMultiModel.adjR2 * 100).toFixed(1)}%</div><div style="font-size: 0.8rem; color: #64748b;">Adjusted R¬≤</div></div>
              <div><div style="font-size: 1.5rem; font-weight: 700; color: #7c3aed;">${lastMultiModel.Fstat.toFixed(2)}</div><div style="font-size: 0.8rem; color: #64748b;">F-statistic</div></div>
              <div><div style="font-size: 1.5rem; font-weight: 700; color: #475569;">${lastMultiModel.n}</div><div style="font-size: 0.8rem; color: #64748b;">Observations</div></div>
            </div>
          </div>

          <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem;">
            <h3 style="margin: 0 0 0.5rem 0; color: #1e293b;">Variables Included</h3>
            <p style="margin: 0; color: #475569;">${selectedVars.join(', ')}</p>
          </div>

          ${document.getElementById('multiInterpretation').innerHTML}

          <div style="margin-top: 1rem;">
            <h3 style="margin: 0 0 0.75rem 0; color: #1e293b;">Regression Coefficients</h3>
            <table style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
              <thead>
                <tr style="background: #f1f5f9;">
                  <th style="padding: 0.75rem; text-align: left; border: 1px solid #e2e8f0;">Variable</th>
                  <th style="padding: 0.75rem; text-align: right; border: 1px solid #e2e8f0;">Coefficient</th>
                  <th style="padding: 0.75rem; text-align: right; border: 1px solid #e2e8f0;">Std Error</th>
                  <th style="padding: 0.75rem; text-align: right; border: 1px solid #e2e8f0;">t-value</th>
                  <th style="padding: 0.75rem; text-align: right; border: 1px solid #e2e8f0;">p-value</th>
                  <th style="padding: 0.75rem; text-align: center; border: 1px solid #e2e8f0;">Sig.</th>
                </tr>
              </thead>
              <tbody>
                ${lastMultiModel.vars.map((v, i) => {
                  const coef = lastMultiModel.beta[i];
                  const se = lastMultiModel.seBeta[i];
                  const t = lastMultiModel.tStats[i];
                  const p = lastMultiModel.pValues[i];
                  const sig = p < 0.001 ? '***' : p < 0.01 ? '**' : p < 0.05 ? '*' : p < 0.1 ? '.' : '-';
                  const bgColor = p < 0.05 ? '#f0fdf4' : '';
                  return `<tr style="background: ${bgColor};">
                    <td style="padding: 0.5rem; border: 1px solid #e2e8f0;">${v === 'Intercept' ? '(Intercept)' : CONFIG.NUTRIENT_NAMES[v] || v}</td>
                    <td style="padding: 0.5rem; border: 1px solid #e2e8f0; text-align: right; font-family: monospace;">${coef >= 0 ? '+' : ''}${coef.toFixed(4)}</td>
                    <td style="padding: 0.5rem; border: 1px solid #e2e8f0; text-align: right; font-family: monospace;">${se.toFixed(4)}</td>
                    <td style="padding: 0.5rem; border: 1px solid #e2e8f0; text-align: right; font-family: monospace;">${t.toFixed(3)}</td>
                    <td style="padding: 0.5rem; border: 1px solid #e2e8f0; text-align: right; font-family: monospace;">${p < 0.0001 ? '<0.0001' : p.toFixed(4)}</td>
                    <td style="padding: 0.5rem; border: 1px solid #e2e8f0; text-align: center; font-weight: 700;">${sig}</td>
                  </tr>`;
                }).join('')}
              </tbody>
            </table>
            <p style="font-size: 0.75rem; color: #64748b; margin-top: 0.5rem;">Significance: *** p < 0.001, ** p < 0.01, * p < 0.05, . p < 0.1</p>
          </div>
        `;
      } else {
        // Export Individual Correlations
        reportTitle = 'Individual Correlations';
        reportContent = document.getElementById('yieldContent').innerHTML;
      }

      const printWindow = window.open('', '_blank');
      printWindow.document.write(`<!DOCTYPE html><html><head><title>${operationName} - Yield Correlation</title><style>${getReportStyles()}</style></head><body>
        <h1>${operationName} - Yield Correlation: ${reportTitle}</h1>
        <p>Generated: ${new Date().toLocaleString()}</p>
        <div class="summary">
          <div class="summary-box"><div class="number">${crop === 'all' ? 'All' : crop}</div><div class="label">Crop</div></div>
          <div class="summary-box"><div class="number">${yearLabel}</div><div class="label">Yield Year</div></div>
          <div class="summary-box"><div class="number">${field === 'all' ? 'All' : field}</div><div class="label">Field</div></div>
        </div>
        ${reportContent}
        <div class="footer">Soil Sample Analysis App</div>
      </body></html>`);
      printWindow.document.close();
      printWindow.print();
    }

    // ========== TAB 5: Spatial Change Analysis ==========
    function updateSpatialAnalysis() {
      const container = document.getElementById('spatialContent');
      const field = document.getElementById('spatialFieldSelect').value;
      const nutrient = document.getElementById('spatialNutrientSelect').value;
      const baseYearSelection = document.getElementById('spatialBaseYearSelect').value;
      const compareYear = document.getElementById('spatialCompareYearSelect').value;
      const radiusFt = parseInt(document.getElementById('spatialRadiusSelect').value);
      const useEarliestPerField = baseYearSelection === 'earliest';

      if (!field) {
        container.innerHTML = '<div class="no-data">Select a field to analyze spatial changes over time.</div>';
        return;
      }

      // Filter by active client/farm first
      const activeFieldsList = getActiveFields();
      const filteredSamples = sampleData.filter(s => activeFieldsList.includes(s.field));

      // Get all samples for this field (or all fields if __all__)
      const isAllFields = field === '__all__';
      const fieldDisplayName = isAllFields ? 'All Fields' : field;
      const fieldSamples = filteredSamples.filter(s => isAllFields || s.field === field);
      const years = [...new Set(fieldSamples.map(s => s.year).filter(y => y))].sort();

      if (years.length < 2) {
        container.innerHTML = '<div class="no-data">Need at least 2 years of data to analyze changes. ' + (isAllFields ? 'Operation' : 'This field') + ' only has data from: ' + years.join(', ') + '</div>';
        return;
      }

      // Calculate earliest year per field (for "Earliest Available" option)
      const earliestYearByField = {};
      if (useEarliestPerField) {
        const allFields = [...new Set(fieldSamples.map(s => s.field).filter(f => f))];
        allFields.forEach(f => {
          const fieldYears = fieldSamples
            .filter(s => s.field === f && s.year)
            .map(s => s.year)
            .sort((a, b) => a - b);
          if (fieldYears.length > 0) {
            earliestYearByField[f] = fieldYears[0];
          }
        });
      }

      // Get base year samples - either specific year or earliest per field
      let baseSamples;
      let baseYearDisplay;
      if (useEarliestPerField) {
        // Get samples from each field's earliest year
        baseSamples = fieldSamples.filter(s => s.field && earliestYearByField[s.field] === s.year);
        const uniqueBaseYears = [...new Set(Object.values(earliestYearByField))].sort();
        baseYearDisplay = uniqueBaseYears.length === 1 ? uniqueBaseYears[0] : `${Math.min(...uniqueBaseYears)}-${Math.max(...uniqueBaseYears)}`;
      } else {
        const baseYear = parseInt(baseYearSelection);
        baseSamples = fieldSamples.filter(s => s.year === baseYear);
        baseYearDisplay = baseYear;
      }

      if (baseSamples.length === 0) {
        container.innerHTML = `<div class="no-data">No samples found for ${fieldDisplayName} in baseline year(s)</div>`;
        return;
      }

      // Get valid nutrient values for base year
      const baseWithValues = baseSamples.filter(s => {
        const val = s[nutrient];
        return val !== undefined && val !== null && val !== '' && !isNaN(parseFloat(val));
      });

      if (baseWithValues.length < 4) {
        container.innerHTML = `<div class="no-data">Need at least 4 samples with ${nutrient} data in base year. Found: ${baseWithValues.length}</div>`;
        return;
      }

      // Calculate zone thresholds based on base year (quartiles)
      const baseValues = baseWithValues.map(s => parseFloat(s[nutrient])).sort((a, b) => a - b);
      const q1Index = Math.floor(baseValues.length * 0.25);
      const q3Index = Math.floor(baseValues.length * 0.75);
      const lowThreshold = baseValues[q1Index];
      const highThreshold = baseValues[q3Index];

      // Classify base year samples into zones
      const zonedSamples = baseWithValues.map(s => ({
        ...s,
        baseYear: useEarliestPerField ? earliestYearByField[s.field] : parseInt(baseYearSelection),
        baseValue: parseFloat(s[nutrient]),
        zone: parseFloat(s[nutrient]) <= lowThreshold ? 'low' :
              parseFloat(s[nutrient]) >= highThreshold ? 'high' : 'medium'
      }));

      // Determine which years to compare
      let compareYears;
      if (compareYear === 'all') {
        if (useEarliestPerField) {
          // Compare to all years after each field's baseline
          compareYears = years; // Will filter per-sample below
        } else {
          compareYears = years.filter(y => y !== parseInt(baseYearSelection));
        }
      } else {
        compareYears = [parseInt(compareYear)];
      }

      // For each zoned sample, find matching samples in compare years
      const radiusMeters = radiusFt * 0.3048;
      const matchedData = [];

      zonedSamples.forEach(baseSample => {
        const matches = { base: baseSample, years: {} };
        const sampleBaseYear = baseSample.baseYear;
        matches.years[sampleBaseYear] = baseSample.baseValue;

        // Get comparison years for this sample (only years after its baseline)
        const sampleCompareYears = compareYear === 'all'
          ? years.filter(y => y > sampleBaseYear)
          : compareYears.filter(y => y > sampleBaseYear);

        sampleCompareYears.forEach(year => {
          // Only look at samples from the same field for matching
          const yearSamples = fieldSamples.filter(s => s.year === year && (!isAllFields || s.field === baseSample.field));
          // Find closest sample within radius
          let closest = null;
          let closestDist = Infinity;

          yearSamples.forEach(s => {
            const dist = getDistanceMeters(baseSample.lat, baseSample.lon, s.lat, s.lon);
            if (dist <= radiusMeters && dist < closestDist) {
              const val = s[nutrient];
              if (val !== undefined && val !== null && val !== '' && !isNaN(parseFloat(val))) {
                closest = s;
                closestDist = dist;
              }
            }
          });

          if (closest) {
            matches.years[year] = parseFloat(closest[nutrient]);
          }
        });

        matchedData.push(matches);
      });

      // Calculate zone statistics for each year
      // Collect all unique years from matched data (handles per-field baselines)
      const allYearsSet = new Set();
      matchedData.forEach(m => {
        Object.keys(m.years).forEach(y => allYearsSet.add(parseInt(y)));
      });
      const allYears = [...allYearsSet].sort((a, b) => a - b);
      const zoneStats = { low: {}, medium: {}, high: {}, all: {} };

      allYears.forEach(year => {
        ['low', 'medium', 'high'].forEach(zone => {
          const zoneMatches = matchedData.filter(m => m.base.zone === zone && m.years[year] !== undefined);
          if (zoneMatches.length > 0) {
            const values = zoneMatches.map(m => m.years[year]);
            zoneStats[zone][year] = {
              avg: values.reduce((a, b) => a + b, 0) / values.length,
              count: values.length,
              min: Math.min(...values),
              max: Math.max(...values)
            };
          }
        });

        // Field average
        const allMatches = matchedData.filter(m => m.years[year] !== undefined);
        if (allMatches.length > 0) {
          const values = allMatches.map(m => m.years[year]);
          zoneStats.all[year] = {
            avg: values.reduce((a, b) => a + b, 0) / values.length,
            count: values.length
          };
        }
      });

      // Calculate match rates
      const lowCount = matchedData.filter(m => m.base.zone === 'low').length;
      const medCount = matchedData.filter(m => m.base.zone === 'medium').length;
      const highCount = matchedData.filter(m => m.base.zone === 'high').length;

      // Build the results HTML
      const nutrientName = CONFIG.NUTRIENT_NAMES[nutrient] || nutrient;
      const unit = CONFIG.NUTRIENT_UNITS[nutrient] || '';
      const decimals = getDecimals(nutrient);

      let html = `
        <div style="background: #f0f9ff; border: 1px solid #0ea5e9; border-radius: 0.5rem; padding: 0.75rem; margin-bottom: 1rem; font-size: 0.8rem; color: #0369a1;">
          <strong>Spatial Change Analysis: ${fieldDisplayName} - ${nutrientName}</strong><br>
          <strong>Base Year:</strong> ${baseYearDisplay} (zones defined by this year's values)<br>
          <strong>Comparing:</strong> ${compareYears.join(', ')}<br>
          <strong>Match Radius:</strong> ${radiusFt} ft | <strong>Matched Samples:</strong> ${matchedData.length} of ${baseSamples.length}
        </div>

        <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem; font-size: 0.8rem; color: #475569;">
          <strong style="color: #1e293b;">How Zones Are Defined:</strong><br>
          Samples from ${baseYearDisplay} are divided into three zones based on their ${nutrientName} values:
          <ul style="margin: 0.5rem 0 0.5rem 1.5rem; padding: 0;">
            <li><strong style="color: #dc2626;">Low Zone</strong> = Bottom 25% of samples (lowest quartile)</li>
            <li><strong style="color: #d97706;">Medium Zone</strong> = Middle 50% of samples (between 25th and 75th percentile)</li>
            <li><strong style="color: #16a34a;">High Zone</strong> = Top 25% of samples (highest quartile)</li>
          </ul>
          <strong style="color: #1e293b;">What This Analysis Shows:</strong><br>
          Once zones are defined by ${baseYearDisplay}, we track those <em>same GPS locations</em> across other years to see how values change over time. This answers: "Are my historically low-testing areas improving or staying low?"
        </div>

        <h3 style="margin: 0 0 0.5rem 0; color: #1e293b;">Zone Summary (${baseYearDisplay} Baseline)</h3>
        <p style="color: #64748b; font-size: 0.8rem; margin-bottom: 0.75rem;">Number of sample locations in each zone, based on ${baseYearDisplay} ${nutrientName} values:</p>

        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 0.75rem; margin-bottom: 1.5rem;">
          <div style="background: #fee2e2; border: 2px solid #ef4444; border-radius: 0.5rem; padding: 0.75rem; text-align: center;">
            <div style="font-size: 1.5rem; font-weight: 700; color: #991b1b;">${lowCount}</div>
            <div style="color: #991b1b; font-size: 0.75rem;">Low Zone Samples</div>
            <div style="color: #b91c1c; font-size: 0.7rem;">‚â§ ${lowThreshold.toFixed(decimals)} ${unit}</div>
          </div>
          <div style="background: #fef3c7; border: 2px solid #f59e0b; border-radius: 0.5rem; padding: 0.75rem; text-align: center;">
            <div style="font-size: 1.5rem; font-weight: 700; color: #92400e;">${medCount}</div>
            <div style="color: #92400e; font-size: 0.75rem;">Medium Zone Samples</div>
            <div style="color: #b45309; font-size: 0.7rem;">${lowThreshold.toFixed(decimals)} - ${highThreshold.toFixed(decimals)} ${unit}</div>
          </div>
          <div style="background: #dcfce7; border: 2px solid #22c55e; border-radius: 0.5rem; padding: 0.75rem; text-align: center;">
            <div style="font-size: 1.5rem; font-weight: 700; color: #166534;">${highCount}</div>
            <div style="color: #166534; font-size: 0.75rem;">High Zone Samples</div>
            <div style="color: #15803d; font-size: 0.7rem;">‚â• ${highThreshold.toFixed(decimals)} ${unit}</div>
          </div>
        </div>

        <h3 style="margin: 0 0 0.5rem 0; color: #1e293b;">Zone Tracking Over Time</h3>
        <p style="color: #64748b; font-size: 0.8rem; margin-bottom: 0.5rem;">
          <strong>How to read this table:</strong> Each row shows the <em>average ${nutrientName} value</em> for samples in that zone across years.
          The <strong>(n=X)</strong> shows how many samples had data for that year.
          The <strong>Change</strong> column shows the difference between the first and last year (+ is increase, - is decrease).
        </p>

        <table class="rankings-table" style="margin-bottom: 1.5rem;">
          <thead>
            <tr>
              <th>Zone (${baseYearDisplay} baseline)</th>
              ${allYears.map(y => `<th>${y} Avg</th>`).join('')}
              <th>Change</th>
            </tr>
          </thead>
          <tbody>`;

      // Add rows for each zone
      const firstYear = allYears[0];
      const lastYear = allYears[allYears.length - 1];

      ['low', 'medium', 'high'].forEach(zone => {
        const zoneName = zone === 'low' ? `Low (‚â§${lowThreshold.toFixed(decimals)})` :
                        zone === 'medium' ? `Medium (${lowThreshold.toFixed(decimals)}-${highThreshold.toFixed(decimals)})` :
                        `High (‚â•${highThreshold.toFixed(decimals)})`;
        const zoneColor = zone === 'low' ? '#dc2626' : zone === 'medium' ? '#d97706' : '#16a34a';

        html += `<tr>
          <td style="font-weight: 600; color: ${zoneColor};">${zoneName}</td>`;

        allYears.forEach(year => {
          const stat = zoneStats[zone][year];
          if (stat) {
            html += `<td>${stat.avg.toFixed(decimals)} <span style="color: #94a3b8; font-size: 0.7rem;">(n=${stat.count})</span></td>`;
          } else {
            html += `<td style="color: #94a3b8;">-</td>`;
          }
        });

        // Change column (compare first year to last year)
        const baseAvg = zoneStats[zone][firstYear]?.avg;
        const lastAvg = zoneStats[zone][lastYear]?.avg;
        if (baseAvg !== undefined && lastAvg !== undefined) {
          const change = lastAvg - baseAvg;
          const pctChange = baseAvg !== 0 ? ((change / baseAvg) * 100).toFixed(0) : 'N/A';
          const changeColor = change > 0 ? '#16a34a' : change < 0 ? '#dc2626' : '#64748b';
          const arrow = change > 0 ? '‚Üë' : change < 0 ? '‚Üì' : '‚Üí';
          html += `<td style="font-weight: 600; color: ${changeColor};">${change >= 0 ? '+' : ''}${change.toFixed(decimals)} ${arrow} <span style="font-size: 0.75rem;">(${pctChange}%)</span></td>`;
        } else {
          html += `<td style="color: #94a3b8;">-</td>`;
        }

        html += `</tr>`;
      });

      // Field average row
      html += `<tr style="background: #f1f5f9; font-weight: 600;">
        <td>Field Average</td>`;
      allYears.forEach(year => {
        const stat = zoneStats.all[year];
        if (stat) {
          html += `<td>${stat.avg.toFixed(decimals)}</td>`;
        } else {
          html += `<td style="color: #94a3b8;">-</td>`;
        }
      });

      const baseFieldAvg = zoneStats.all[firstYear]?.avg;
      const lastFieldAvg = zoneStats.all[lastYear]?.avg;
      if (baseFieldAvg !== undefined && lastFieldAvg !== undefined) {
        const change = lastFieldAvg - baseFieldAvg;
        const changeColor = change > 0 ? '#16a34a' : change < 0 ? '#dc2626' : '#64748b';
        const arrow = change > 0 ? '‚Üë' : change < 0 ? '‚Üì' : '‚Üí';
        html += `<td style="color: ${changeColor};">${change >= 0 ? '+' : ''}${change.toFixed(decimals)} ${arrow}</td>`;
      } else {
        html += `<td>-</td>`;
      }
      html += `</tr></tbody></table>`;

      // Generate insights
      html += generateSpatialInsights(zoneStats, firstYear, lastYear, nutrientName, decimals, unit);

      container.innerHTML = html;
    }

    function generateSpatialInsights(zoneStats, baseYear, lastYear, nutrientName, decimals, unit) {
      const insights = [];

      // Low zone insight
      const lowBase = zoneStats.low[baseYear]?.avg;
      const lowLast = zoneStats.low[lastYear]?.avg;
      if (lowBase !== undefined && lowLast !== undefined) {
        const lowChange = lowLast - lowBase;
        const lowPct = lowBase !== 0 ? Math.abs((lowChange / lowBase) * 100).toFixed(0) : 0;
        if (lowChange > 0) {
          insights.push({
            type: 'positive',
            icon: 'üìà',
            text: `Low ${nutrientName} areas improved ${lowPct}% (+${lowChange.toFixed(decimals)} ${unit} avg)`
          });
        } else if (lowChange < 0) {
          insights.push({
            type: 'negative',
            icon: 'üìâ',
            text: `Low ${nutrientName} areas declined ${lowPct}% (${lowChange.toFixed(decimals)} ${unit} avg)`
          });
        }
      }

      // High zone insight
      const highBase = zoneStats.high[baseYear]?.avg;
      const highLast = zoneStats.high[lastYear]?.avg;
      if (highBase !== undefined && highLast !== undefined) {
        const highChange = highLast - highBase;
        const highPct = highBase !== 0 ? Math.abs((highChange / highBase) * 100).toFixed(0) : 0;
        if (highChange < 0) {
          insights.push({
            type: 'neutral',
            icon: '‚öñÔ∏è',
            text: `High ${nutrientName} areas decreased ${highPct}% (${highChange.toFixed(decimals)} ${unit} avg)`
          });
        } else if (highChange > 0) {
          insights.push({
            type: 'warning',
            icon: '‚¨ÜÔ∏è',
            text: `High ${nutrientName} areas increased ${highPct}% (+${highChange.toFixed(decimals)} ${unit} avg)`
          });
        }
      }

      // Overall strategy insight
      if (lowBase !== undefined && lowLast !== undefined && highBase !== undefined && highLast !== undefined) {
        const lowChange = lowLast - lowBase;
        const highChange = highLast - highBase;

        if (lowChange > 0 && highChange <= 0) {
          insights.push({
            type: 'positive',
            icon: 'üéØ',
            text: `Your fertility strategy is successfully bringing up the low spots while maintaining high areas!`
          });
        } else if (lowChange > 0 && highChange > 0) {
          insights.push({
            type: 'neutral',
            icon: 'üìä',
            text: `All areas are increasing - consider variable rate application to target low spots more`
          });
        } else if (lowChange <= 0 && highChange > 0) {
          insights.push({
            type: 'warning',
            icon: '‚ö†Ô∏è',
            text: `High areas getting higher while low areas stagnate - review application targeting`
          });
        }
      }

      if (insights.length === 0) {
        return '';
      }

      let html = `
        <h3 style="margin: 1rem 0 0.75rem 0; color: #1e293b;">üí° Insights</h3>
        <div style="display: flex; flex-direction: column; gap: 0.5rem;">`;

      insights.forEach(insight => {
        const bgColor = insight.type === 'positive' ? '#f0fdf4' :
                       insight.type === 'negative' ? '#fef2f2' :
                       insight.type === 'warning' ? '#fffbeb' : '#f8fafc';
        const borderColor = insight.type === 'positive' ? '#22c55e' :
                           insight.type === 'negative' ? '#ef4444' :
                           insight.type === 'warning' ? '#f59e0b' : '#cbd5e1';

        html += `
          <div style="background: ${bgColor}; border-left: 4px solid ${borderColor}; padding: 0.75rem 1rem; border-radius: 0.375rem;">
            <span style="font-size: 1.1rem; margin-right: 0.5rem;">${insight.icon}</span>
            <span style="color: #1e293b;">${insight.text}</span>
          </div>`;
      });

      html += `</div>`;
      return html;
    }

    function getDistanceMeters(lat1, lon1, lat2, lon2) {
      // Haversine formula for distance between two GPS coordinates
      const R = 6371000; // Earth radius in meters
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }

    function exportSpatialAnalysis() {
      const field = document.getElementById('spatialFieldSelect').value;
      const fieldDisplayName = field === '__all__' ? 'All Fields' : field;
      const nutrient = document.getElementById('spatialNutrientSelect').value;
      const nutrientName = CONFIG.NUTRIENT_NAMES[nutrient] || nutrient;
      const operationName = localStorage.getItem('operationName') || 'Soil Analysis';
      const spatialData = document.getElementById('spatialContent').innerHTML;

      const printWindow = window.open('', '_blank');
      printWindow.document.write(`<!DOCTYPE html><html><head><title>${operationName} - Spatial Change Analysis</title><style>${getReportStyles()}</style></head><body>
        <h1>${operationName} - Spatial Change Analysis</h1>
        <p>Generated: ${new Date().toLocaleString()}</p>
        <div class="summary">
          <div class="summary-box"><div class="number">${fieldDisplayName}</div><div class="label">Field</div></div>
          <div class="summary-box"><div class="number">${nutrientName}</div><div class="label">Nutrient</div></div>
        </div>
        ${spatialData}
        <div class="footer">Soil Sample Analysis App</div>
      </body></html>`);
      printWindow.document.close();
      printWindow.print();
    }

    function showStatus(msg, ok) {
      const el = document.getElementById('statusMessage');
      el.textContent = msg;
      el.style.display = 'block';
      el.style.background = ok ? '#dcfce7' : '#fee2e2';
      el.style.color = ok ? '#166534' : '#991b1b';
      setTimeout(() => el.style.display = 'none', 4000);
    }

    function updateBackupFooter() {
      const backupTime = localStorage.getItem('soilDataBackupTime');
      const footer = document.getElementById('backupFooter');
      const buildDate = new Date(BUILD_DATE);
      const buildStr = buildDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) + ', ' +
                       buildDate.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
      const versionInfo = `App ${APP_VERSION} ‚Ä¢ Built: ${buildStr}`;
      const legalLinks = `<span style="margin: 0 0.5rem; color: #cbd5e1;">|</span> <a href="methodology.html" style="color: #94a3b8; text-decoration: none;">How We Calculate</a> <span style="color: #cbd5e1;">¬∑</span> <a href="privacy-policy.html" style="color: #94a3b8; text-decoration: none;">Privacy</a> <span style="color: #cbd5e1;">¬∑</span> <a href="terms-of-service.html" style="color: #94a3b8; text-decoration: none;">Terms</a>`;

      const sampleData = JSON.parse(localStorage.getItem('soilSamples') || '[]');

      if (backupTime) {
        const date = new Date(parseInt(backupTime));
        const backupStr = date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
        footer.innerHTML = `${versionInfo} <span style="margin: 0 0.5rem; color: #cbd5e1;">|</span> <span style="color: #22c55e;">Data backup: ${backupStr}</span>${legalLinks}`;
      } else if (sampleData.length === 0) {
        // No data yet - don't show backup warning
        footer.innerHTML = versionInfo + legalLinks;
      } else {
        // Has data but no backup - show warning
        footer.innerHTML = `${versionInfo} <span style="margin: 0 0.5rem; color: #cbd5e1;">|</span> <span style="color: #f59e0b;">No backup yet</span>${legalLinks}`;
      }
    }
  </script>
  <div class="backup-footer" id="backupFooter"></div>
</body>
</html>
