<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Soil Sample Analysis - Analysis</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f8fafc; color: #1e293b; min-height: 100vh; }
    .top-bar { background: linear-gradient(135deg, #1e293b 0%, #334155 100%); color: white; padding: 1rem 1.5rem; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem; }
    .top-bar h1 { font-size: 1.5rem; font-weight: 700; }
    .top-bar p { font-size: 0.875rem; opacity: 0.8; margin-top: 0.25rem; }
    .nav-links { display: flex; gap: 0.5rem; flex-wrap: wrap; }
    .nav-link { padding: 0.5rem 1rem; background: rgba(255,255,255,0.1); color: white; text-decoration: none; border-radius: 0.375rem; font-size: 0.875rem; font-weight: 500; }
    .nav-link:hover { background: rgba(255,255,255,0.2); }
    .nav-link.active { background: #3b82f6; }
    .auth-section { display: flex; align-items: center; gap: 1rem; }
    .user-info { font-size: 0.875rem; color: rgba(255,255,255,0.9); }
    .sign-in-btn { padding: 0.5rem 1rem; background: #4285f4; color: white; border: none; border-radius: 0.375rem; font-size: 0.875rem; cursor: pointer; }
    .sign-in-btn.signed-in { background: #22c55e; }
    
    .analysis-container { max-width: 1400px; margin: 0 auto; padding: 1.5rem; }
    
    /* Tabs */
    .tabs { display: flex; gap: 0.5rem; margin-bottom: 1.5rem; flex-wrap: wrap; }
    .tab { padding: 0.75rem 1.25rem; background: white; border: 1px solid #cbd5e1; border-radius: 0.5rem; cursor: pointer; font-weight: 500; font-size: 0.875rem; }
    .tab:hover { background: #f1f5f9; }
    .tab.active { background: #3b82f6; color: white; border-color: #3b82f6; }
    
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    
    /* Controls */
    .controls-bar { background: white; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1.5rem; box-shadow: 0 1px 3px rgba(0,0,0,0.1); display: flex; gap: 1.5rem; flex-wrap: wrap; align-items: flex-end; }
    .control-group { display: flex; flex-direction: column; gap: 0.25rem; }
    .control-group label { font-size: 0.75rem; font-weight: 600; color: #64748b; text-transform: uppercase; }
    .control-group select { padding: 0.5rem 0.75rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 0.375rem; min-width: 160px; }
    .export-btn { padding: 0.5rem 1rem; background: #8b5cf6; color: white; border: none; border-radius: 0.375rem; font-size: 0.875rem; font-weight: 500; cursor: pointer; margin-left: auto; }
    .export-btn:hover { background: #7c3aed; }

    /* Nutrient Grid for Year Comparison */
    .nutrient-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1rem; }
    
    .nutrient-card { background: white; border-radius: 0.5rem; padding: 1rem; box-shadow: 0 1px 3px rgba(0,0,0,0.1); border-left: 4px solid #94a3b8; }
    .nutrient-card.positive { border-left-color: #22c55e; background: linear-gradient(to right, #f0fdf4, white); }
    .nutrient-card.negative { border-left-color: #ef4444; background: linear-gradient(to right, #fef2f2, white); }
    .nutrient-card.no-comparison { border-left-color: #f59e0b; background: linear-gradient(to right, #fffbeb, white); }
    
    .nutrient-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem; }
    .nutrient-name { font-size: 1rem; font-weight: 700; color: #1e293b; }
    .nutrient-pct { font-size: 1.125rem; font-weight: 700; }
    .nutrient-pct.positive { color: #22c55e; }
    .nutrient-pct.negative { color: #ef4444; }
    .nutrient-pct.neutral { color: #64748b; }
    
    .nutrient-stats { display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem; margin-bottom: 0.75rem; }
    .stat-box { background: #f8fafc; border-radius: 0.375rem; padding: 0.5rem; text-align: center; }
    .stat-box .label { font-size: 0.625rem; font-weight: 600; color: #64748b; text-transform: uppercase; }
    .stat-box .value { font-size: 0.9375rem; font-weight: 700; color: #1e293b; }
    
    .year-comparison { display: flex; justify-content: space-between; align-items: center; background: #f1f5f9; border-radius: 0.375rem; padding: 0.5rem 0.75rem; margin-bottom: 0.5rem; }
    .year-val { text-align: center; }
    .year-val .yr { font-size: 0.625rem; font-weight: 600; color: #64748b; }
    .year-val .num { font-size: 1.125rem; font-weight: 700; color: #1e293b; }
    .year-arrow { font-size: 1.25rem; color: #94a3b8; }
    
    .change-row { display: flex; justify-content: center; gap: 1.5rem; font-size: 0.75rem; color: #64748b; }
    .change-row .val { font-weight: 600; }
    .change-row .val.positive { color: #22c55e; }
    .change-row .val.negative { color: #ef4444; }
    
    /* Historical Trends */
    .trend-card { background: white; border: 2px solid; border-radius: 0.75rem; padding: 1.25rem; margin-bottom: 1.25rem; box-shadow: 0 2px 8px rgba(0,0,0,0.06); }
    .trend-card.positive { background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%); border-color: #22c55e; }
    .trend-card.negative { background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%); border-color: #ef4444; }
    .trend-card.neutral { background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%); border-color: #94a3b8; }
    .trend-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 1rem; padding-bottom: 0.75rem; border-bottom: 1px solid rgba(0,0,0,0.08); }
    .trend-title { font-size: 1.25rem; font-weight: 700; color: #1e293b; }
    .trend-pct { font-size: 1.5rem; font-weight: 700; text-align: right; }
    .trend-sub { font-size: 0.75rem; color: #64748b; font-weight: 500; }
    .trend-content { display: flex; flex-wrap: nowrap; gap: 1rem; align-items: stretch; }
    .trend-values { background: rgba(255,255,255,0.7); border-radius: 0.5rem; padding: 0.5rem; min-width: 200px; flex: 0 0 auto; max-height: 400px; overflow-y: auto; }
    .trend-row { display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0.75rem; font-size: 0.875rem; border-radius: 0.25rem; }
    .trend-row.alt { background: rgba(0,0,0,0.03); }
    .trend-year { font-weight: 600; color: #475569; min-width: 50px; }
    .trend-value { font-weight: 700; color: #1e293b; }
    .trend-graph { flex: 1 1 auto; background: rgba(255,255,255,0.5); border-radius: 0.5rem; padding: 0.75rem; min-width: 400px; }
    .trend-graph svg { display: block; width: 100%; height: auto; min-height: 180px; }
    .trend-graph.large svg { min-height: 220px; }
    .trend-graph.xlarge svg { min-height: 280px; }
    @media (max-width: 900px) {
      .trend-content { flex-direction: column; }
      .trend-graph { min-width: 100%; width: 100%; }
      .trend-graph svg { min-height: 200px; }
    }
    
    /* Field Rankings */
    .rankings-table { width: 100%; border-collapse: collapse; background: white; border-radius: 0.5rem; overflow: hidden; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
    .rankings-table th, .rankings-table td { padding: 0.75rem 1rem; text-align: left; border-bottom: 1px solid #e2e8f0; }
    .rankings-table th { background: #f8fafc; font-weight: 600; color: #475569; font-size: 0.75rem; text-transform: uppercase; }
    .rankings-table th.sortable-header:hover { background: #e2e8f0; }
    .rankings-table tr:hover { background: #f8fafc; }
    .rankings-table .rank { font-weight: 700; color: #64748b; width: 60px; }
    .rankings-table .field { font-weight: 500; }
    .rankings-table .value { font-weight: 700; }
    .rankings-table .high { color: #22c55e; }
    .rankings-table .low { color: #ef4444; }
    
    .no-data { background: #fef3c7; border: 2px solid #f59e0b; border-radius: 0.5rem; padding: 2rem; text-align: center; color: #92400e; }
    #statusMessage { display: none; position: fixed; top: 1rem; left: 50%; transform: translateX(-50%); z-index: 9999; padding: 0.75rem 1rem; border-radius: 0.375rem; box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
    
    @media (max-width: 639px) {
      .nutrient-grid { grid-template-columns: 1fr; }
      .controls-bar { flex-direction: column; align-items: stretch; }
      .tabs { flex-direction: column; }
      .tab { text-align: center; }
    }
    .backup-footer { position: fixed; bottom: 0; left: 0; right: 0; background: #f8fafc; border-top: 1px solid #e2e8f0; padding: 0.25rem 1rem; font-size: 0.7rem; color: #64748b; text-align: center; z-index: 900; }
  </style>
</head>
<body>
  <div class="top-bar">
    <div>
      <h1>üìä Soil Analysis</h1>
      <p>Trends, Comparisons & Rankings</p>
    </div>
    <nav class="nav-links">
      <a href="index.html" class="nav-link">üìç Map</a>
      <a href="analysis.html" class="nav-link active">üìä Analysis</a>
      <a href="import.html" class="nav-link">üìÅ Import</a>
      <a href="settings.html" class="nav-link">‚öôÔ∏è Settings</a>
    </nav>
    <div class="auth-section">
      <span class="user-info" id="userInfo"></span>
      <button class="sign-in-btn" id="authBtn" onclick="handleAuth()">Sign In to Edit</button>
    </div>
  </div>
  
  <div class="analysis-container">
    <div class="tabs">
      <div class="tab active" data-tab="history">üìà Field Trends</div>
      <div class="tab" data-tab="comparison">üìä Year-Over-Year</div>
      <div class="tab" data-tab="rankings">üèÜ Field Rankings</div>
      <div class="tab" data-tab="yield">üåæ Yield Correlation</div>
    </div>
    
    <!-- Tab: Year Comparison (Operation-wide) -->
    <div id="comparison" class="tab-content">
      <div class="controls-bar">
        <div class="control-group">
          <label>From Year</label>
          <select id="year1Select"></select>
        </div>
        <div class="control-group">
          <label>To Year</label>
          <select id="year2Select"></select>
        </div>
        <button onclick="exportYearComparison()" class="export-btn">üìÑ Export Report</button>
      </div>
      
      <!-- Year Stats Section -->
      <div id="yearStats" style="display: flex; gap: 1rem; margin-bottom: 1rem; flex-wrap: wrap;">
        <div id="fromYearStats" style="flex: 1; min-width: 250px; background: #f8fafc; border: 2px solid #cbd5e1; border-radius: 0.5rem; padding: 1rem;">
          <h4 style="margin: 0 0 0.5rem 0; color: #64748b; font-size: 0.875rem;">From Year Stats</h4>
          <div id="fromYearInfo"></div>
        </div>
        <div id="toYearStats" style="flex: 1; min-width: 250px; background: #f0fdf4; border: 2px solid #22c55e; border-radius: 0.5rem; padding: 1rem;">
          <h4 style="margin: 0 0 0.5rem 0; color: #166534; font-size: 0.875rem;">To Year Stats</h4>
          <div id="toYearInfo"></div>
        </div>
      </div>
      
      <!-- Field Selection & Mismatch Warning -->
      <div id="fieldSelectionSection" style="background: white; border: 2px solid #e2e8f0; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1.5rem;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
          <h4 style="margin: 0; color: #475569; font-size: 0.875rem;">üìã Fields Included in Comparison</h4>
          <div>
            <button onclick="selectMatchingComparisonFields()" style="padding: 0.25rem 0.5rem; font-size: 0.75rem; border: 1px solid #cbd5e1; border-radius: 0.25rem; background: white; cursor: pointer; margin-right: 0.25rem;">Select Matching</button>
            <button onclick="selectAllComparisonFields()" style="padding: 0.25rem 0.5rem; font-size: 0.75rem; border: 1px solid #cbd5e1; border-radius: 0.25rem; background: white; cursor: pointer;">Select All</button>
          </div>
        </div>
        <div id="fieldCheckboxes" style="display: flex; flex-wrap: wrap; gap: 0.5rem;"></div>
        <div id="fieldMismatchWarning" style="margin-top: 0.75rem;"></div>
      </div>
      
      <div id="comparisonGrid" class="nutrient-grid"></div>
    </div>
    
    <!-- Tab: Historical Field Trends -->
    <div id="history" class="tab-content active">
      <div class="controls-bar">
        <div class="control-group">
          <label>Select Field</label>
          <select id="historyFieldSelect"><option value="">Select a field...</option></select>
        </div>
        <button onclick="exportFieldTrends()" class="export-btn">üìÑ Export Report</button>
      </div>
      <div id="historyContent"></div>
    </div>

    <!-- Tab 3: Field Rankings -->
    <div id="rankings" class="tab-content">
      <div class="controls-bar">
        <div class="control-group">
          <label>Nutrient</label>
          <select id="rankingAttrSelect"></select>
        </div>
        <div class="control-group">
          <label>Year</label>
          <select id="rankingYearSelect"></select>
        </div>
        <button onclick="exportFieldRankings()" class="export-btn">üìÑ Export Report</button>
      </div>
      <div id="rankingsContent"></div>
    </div>

    <!-- Tab 4: Yield Correlation -->
    <div id="yield" class="tab-content">
      <div class="controls-bar">
        <div class="control-group">
          <label>Crop</label>
          <select id="yieldCropSelect">
            <option value="all">All Crops</option>
            <option value="corn">üåΩ Corn</option>
            <option value="soybeans">ü´ò Soybeans</option>
          </select>
        </div>
        <div class="control-group">
          <label>Yield Year</label>
          <select id="yieldYearSelect"></select>
        </div>
        <div class="control-group">
          <label>Field</label>
          <select id="yieldFieldSelect">
            <option value="all">All Fields</option>
          </select>
        </div>
        <button onclick="exportYieldCorrelation()" class="export-btn">üìÑ Export Report</button>
        <button onclick="toggleYieldDebug()" class="export-btn" style="background: #f59e0b;">üîç Debug Data</button>
      </div>
      <div id="yieldContent">
        <div class="no-data">No yield data available. Import yield maps on the Import page to see correlations.</div>
      </div>

      <!-- Scatter Plot Section -->
      <div id="scatterSection" style="display: none; margin-top: 1.5rem; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 0.5rem; padding: 1rem;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
          <h3 style="margin: 0; color: #1e293b;">Scatter Plot: Nutrient vs Yield</h3>
          <div>
            <label style="margin-right: 0.5rem;">Nutrient:</label>
            <select id="scatterNutrientSelect" onchange="drawScatterPlot()" style="padding: 0.375rem 0.75rem; border-radius: 0.375rem; border: 1px solid #cbd5e1;"></select>
          </div>
        </div>
        <canvas id="scatterCanvas" width="800" height="400" style="background: white; border: 1px solid #e2e8f0; border-radius: 0.375rem; max-width: 100%;"></canvas>
        <div id="scatterStats" style="margin-top: 0.75rem; font-size: 0.875rem; color: #64748b;"></div>
      </div>

      <!-- Debug Panel -->
      <div id="yieldDebugPanel" style="display: none; margin-top: 1.5rem; background: #fffbeb; border: 2px solid #f59e0b; border-radius: 0.5rem; padding: 1rem;">
        <h3 style="margin: 0 0 1rem 0; color: #92400e;">üîç Data Verification Panel</h3>
        <div id="debugContent" style="font-family: monospace; font-size: 0.8rem; white-space: pre-wrap; overflow-x: auto;"></div>
      </div>
    </div>
  </div>
  
  <div id="statusMessage"></div>

  <script src="https://apis.google.com/js/api.js"></script>
  <script src="https://accounts.google.com/gsi/client"></script>
  <script>
    const CONFIG = {
      CLIENT_ID: '714780458094-9rde31taeottmavhl5t0uo8b9kfpergc.apps.googleusercontent.com',
      API_KEY: 'AIzaSyCOSDbrAlc3ct2-lRvJv1y7V0nV7haWc9E',
      get SHEET_ID() { return localStorage.getItem('googleSheetId') || '1buu-8KXoM1kRJSOAWtHaAk40seQT5kqGFY9RICYwdRY'; },
      
      NUTRIENTS: ['pH', 'P', 'P2', 'K', 'OM', 'CEC', 'Ca_sat', 'Mg_sat', 'K_Sat', 'H_Sat', 'Na_Sat', 'Zn', 'Cu', 'Mn', 'Fe', 'Boron', 'S', 'Buffer_pH', 'Na', 'Ca', 'Mg', 'NO3', 'NH4', 'Soluble_Salts', 'EC'],
      
      NUTRIENT_NAMES: {
        pH: 'pH', P: 'Phosphorus (P)', P2: 'Phosphorus P2', K: 'Potassium (K)', OM: 'Organic Matter',
        CEC: 'CEC', Ca_sat: 'Calcium Sat %', Mg_sat: 'Magnesium Sat %',
        K_Sat: 'K Base Sat %', H_Sat: 'H Base Sat %', Na_Sat: 'Na Base Sat %', Zn: 'Zinc', Cu: 'Copper',
        Mn: 'Manganese', Fe: 'Iron', Boron: 'Boron', S: 'Sulfur', Buffer_pH: 'Buffer pH',
        Na: 'Sodium', Ca: 'Calcium', Mg: 'Magnesium', NO3: 'Nitrate', NH4: 'Ammonium', Soluble_Salts: 'Soluble Salts', EC: 'EC'
      },
      
      NUTRIENT_UNITS: {
        pH: '', P: 'ppm', P2: 'ppm', K: 'ppm', OM: '%', CEC: 'meq/100g',
        Ca_sat: '%', Mg_sat: '%', K_Sat: '%', H_Sat: '%', Na_Sat: '%',
        Zn: 'ppm', Cu: 'ppm', Mn: 'ppm', Fe: 'ppm', Boron: 'ppm', S: 'ppm', Buffer_pH: '',
        Na: 'ppm', Ca: 'ppm', Mg: 'ppm', NO3: 'ppm', NH4: 'ppm', Soluble_Salts: 'mmhos/cm', EC: 'dS/m'
      },
      
      LOWER_IS_BETTER: ['Mg_sat', 'H_Sat', 'Na_Sat', 'Soluble_Salts'],

      // Default visibility for nutrients (used if no settings saved)
      DEFAULT_VISIBLE: ['pH', 'P', 'K', 'OM', 'CEC', 'Ca_sat', 'Mg_sat', 'K_Sat', 'H_Sat', 'Zn', 'Cu', 'Mn', 'Fe', 'Boron', 'S', 'Buffer_pH'],

      // Default decimal places for each attribute
      DECIMAL_PLACES: {
        pH: 2, Buffer_pH: 2, OM: 2, P: 0, P2: 0, K: 0, CEC: 1,
        Ca_sat: 1, Mg_sat: 1, K_Sat: 1, H_Sat: 1, Na_Sat: 1,
        Zn: 2, Cu: 2, Mn: 1, Fe: 1, Boron: 2, S: 1,
        Ca: 0, Mg: 0, Na: 0, NO3: 1, NH4: 1, Soluble_Salts: 2, EC: 2
      }
    };

    // Get decimal places for an attribute (checks user settings, then CONFIG defaults)
    function getDecimals(attr) {
      const customDecimals = JSON.parse(localStorage.getItem('decimalPlaces') || '{}');
      if (customDecimals[attr] !== undefined) return customDecimals[attr];
      if (CONFIG.DECIMAL_PLACES[attr] !== undefined) return CONFIG.DECIMAL_PLACES[attr];
      return 1;
    }

    // Format a value using the configured decimal places for an attribute
    function formatValue(value, attr) {
      if (value === null || value === undefined || isNaN(value)) return '-';
      return Number(value).toFixed(getDecimals(attr));
    }

    // Get visible nutrients based on settings
    function getVisibleNutrients() {
      const saved = JSON.parse(localStorage.getItem('nutrientVisibility') || '{}');
      return CONFIG.NUTRIENTS.filter(n => {
        if (saved[n] !== undefined) return saved[n];
        return CONFIG.DEFAULT_VISIBLE.includes(n);
      });
    }

    let tokenClient, accessToken = null, tokenExpiry = null;
    let sampleData = [];
    let year1 = null, year2 = null;
    let selectedComparisonFields = new Set(); // Track which fields are included in comparison

    // Yield correlation table state
    let yieldCorrelationsData = [];
    let yieldSortColumn = 'r'; // Default sort by correlation
    let yieldSortDirection = 'desc'; // desc = highest first
    
    const SheetsAPI = {
      isSignedIn: false,
      async init() {
        return new Promise((resolve, reject) => {
          gapi.load('client', async () => {
            try {
              await gapi.client.init({ apiKey: CONFIG.API_KEY, discoveryDocs: ['https://sheets.googleapis.com/$discovery/rest?version=v4'] });
              tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: CONFIG.CLIENT_ID,
                scope: 'https://www.googleapis.com/auth/spreadsheets',
                callback: (response) => {
                  if (response.error) return;
                  accessToken = response.access_token;
                  tokenExpiry = Date.now() + (response.expires_in * 1000) - 60000;
                  localStorage.setItem('googleAccessToken', accessToken);
                  localStorage.setItem('googleTokenExpiry', tokenExpiry.toString());
                  gapi.client.setToken({ access_token: accessToken });
                  this.isSignedIn = true;
                  this.onSignInChange(true);
                },
              });
              const savedToken = localStorage.getItem('googleAccessToken');
              const savedExpiry = localStorage.getItem('googleTokenExpiry');
              if (savedToken && savedExpiry && Date.now() < parseInt(savedExpiry)) {
                accessToken = savedToken;
                tokenExpiry = parseInt(savedExpiry);
                gapi.client.setToken({ access_token: accessToken });
                this.isSignedIn = true;
                this.onSignInChange(true);
              }
              resolve(true);
            } catch (e) { reject(e); }
          });
        });
      },
      async signIn() { tokenClient.requestAccessToken({ prompt: 'consent' }); },
      async signOut() {
        if (accessToken) google.accounts.oauth2.revoke(accessToken);
        accessToken = null;
        tokenExpiry = null;
        localStorage.removeItem('googleAccessToken');
        localStorage.removeItem('googleTokenExpiry');
        this.isSignedIn = false;
        this.onSignInChange(false);
      },
      onSignInChange(s) {}
    };

    document.addEventListener('DOMContentLoaded', async () => {
      try { await SheetsAPI.init(); SheetsAPI.onSignInChange = handleSignInChange; handleSignInChange(SheetsAPI.isSignedIn); } catch (e) {}
      loadLocalData();
      setupTabs();
      setupEventListeners();
      updateBackupFooter();
    });

    async function handleAuth() { if (SheetsAPI.isSignedIn) await SheetsAPI.signOut(); else await SheetsAPI.signIn(); }
    
    function handleSignInChange(isSignedIn) {
      const authBtn = document.getElementById('authBtn'), userInfo = document.getElementById('userInfo');
      if (isSignedIn) { userInfo.textContent = 'Connected'; authBtn.textContent = '‚úì Signed In'; authBtn.classList.add('signed-in'); }
      else { userInfo.textContent = ''; authBtn.textContent = 'Sign In to Edit'; authBtn.classList.remove('signed-in'); }
    }

    // IndexedDB for large datasets
    const DB_NAME = 'SoilAppDB';
    const DB_VERSION = 1;

    function openDB() {
      return new Promise((resolve, reject) => {
        if (!window.indexedDB) { reject(new Error('IndexedDB not supported')); return; }
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);
        request.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains('samples')) db.createObjectStore('samples', { keyPath: 'id' });
          if (!db.objectStoreNames.contains('boundaries')) db.createObjectStore('boundaries', { keyPath: 'id' });
        };
      });
    }

    async function loadFromIndexedDB() {
      try {
        const db = await openDB();
        const tx = db.transaction(['samples'], 'readonly');
        const samplesData = await new Promise((resolve, reject) => {
          const req = tx.objectStore('samples').get('all');
          req.onsuccess = () => resolve(req.result?.data || []);
          req.onerror = reject;
        });
        db.close();
        return samplesData;
      } catch (e) { return null; }
    }

    async function loadLocalData() {
      try {
        // Check IndexedDB first if flagged
        if (localStorage.getItem('usingIndexedDB') === 'true') {
          const idbSamples = await loadFromIndexedDB();
          if (idbSamples && idbSamples.length > 0) {
            sampleData = idbSamples;
            console.log('Loaded from IndexedDB:', sampleData.length, 'samples');
          }
        } else {
          const saved = localStorage.getItem('soilSamples');
          if (saved) sampleData = JSON.parse(saved);
        }
      } catch (e) { console.error(e); }
      populateSelectors();
      updateComparison();
      updateHistory('__all__');  // Default to All Fields view
      updateRankings();
      updateYieldAnalysis();
    }

    function populateSelectors() {
      const years = [...new Set(sampleData.map(s => s.year).filter(y => y))].sort((a, b) => b - a);
      const fields = [...new Set(sampleData.map(s => s.field).filter(f => f && f !== 'Unknown'))].sort();
      
      // Year comparison selectors - year1 is earlier (FROM), year2 is later (TO)
      const year1Sel = document.getElementById('year1Select');
      const year2Sel = document.getElementById('year2Select');
      year1Sel.innerHTML = ''; year2Sel.innerHTML = '';
      years.forEach((y, i) => {
        year1Sel.innerHTML += `<option value="${y}" ${i === 1 ? 'selected' : ''}>${y}</option>`;
        year2Sel.innerHTML += `<option value="${y}" ${i === 0 ? 'selected' : ''}>${y}</option>`;
      });
      year1 = years[1] || years[0] || null;  // Earlier year (second most recent)
      year2 = years[0] || null;               // Later year (most recent)
      
      // History field selector - default to All Fields (Operation Average)
      const historyFieldSel = document.getElementById('historyFieldSelect');
      historyFieldSel.innerHTML = '<option value="__all__" style="font-weight: bold;">üìä All Fields (Operation Average)</option>';
      fields.forEach(f => { historyFieldSel.innerHTML += `<option value="${f}">${f}</option>`; });
      historyFieldSel.value = '__all__';
      
      // Rankings selectors
      const rankAttrSel = document.getElementById('rankingAttrSelect');
      rankAttrSel.innerHTML = '';
      const visibleNutrients = getVisibleNutrients();
      visibleNutrients.forEach(n => { rankAttrSel.innerHTML += `<option value="${n}">${CONFIG.NUTRIENT_NAMES[n] || n}</option>`; });
      
      const rankYearSel = document.getElementById('rankingYearSelect');
      rankYearSel.innerHTML = '<option value="most_recent" selected>Most Recent</option>';
      years.forEach(y => { rankYearSel.innerHTML += `<option value="${y}">${y}</option>`; });
      
      // Yield selectors
      const yieldYearSel = document.getElementById('yieldYearSelect');
      const yieldYears = getYieldYears();
      yieldYearSel.innerHTML = '<option value="avg">All Years (Average)</option><option value="combined">All Years (Combined)</option>';
      yieldYears.forEach(y => { yieldYearSel.innerHTML += `<option value="${y}">${y}</option>`; });
      
      const yieldFieldSel = document.getElementById('yieldFieldSelect');
      yieldFieldSel.innerHTML = '<option value="all">All Fields</option>';
      // Only show fields that have yield data
      const fieldsWithYield = [...new Set(sampleData.filter(s => s.yieldCorrelations && Object.keys(s.yieldCorrelations).length > 0).map(s => s.field).filter(f => f && f !== 'Unknown'))].sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));
      fieldsWithYield.forEach(f => { yieldFieldSel.innerHTML += `<option value="${f}">${f}</option>`; });
    }
    
    function getYieldYears() {
      const years = new Set();
      sampleData.forEach(s => {
        if (s.yieldCorrelations) {
          Object.keys(s.yieldCorrelations).forEach(y => years.add(parseInt(y)));
        }
      });
      return [...years].sort((a, b) => b - a);
    }

    function setupTabs() {
      document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', () => {
          document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
          tab.classList.add('active');
          document.getElementById(tab.dataset.tab).classList.add('active');
        });
      });
    }

    function setupEventListeners() {
      document.getElementById('year1Select').addEventListener('change', (e) => { year1 = e.target.value; selectedComparisonFields.clear(); updateComparison(); });
      document.getElementById('year2Select').addEventListener('change', (e) => { year2 = e.target.value; selectedComparisonFields.clear(); updateComparison(); });
      document.getElementById('historyFieldSelect').addEventListener('change', (e) => { updateHistory(e.target.value); });
      document.getElementById('rankingAttrSelect').addEventListener('change', updateRankings);
      document.getElementById('rankingYearSelect').addEventListener('change', updateRankings);
      document.getElementById('yieldCropSelect').addEventListener('change', updateYieldAnalysis);
      document.getElementById('yieldYearSelect').addEventListener('change', updateYieldAnalysis);
      document.getElementById('yieldFieldSelect').addEventListener('change', updateYieldAnalysis);
    }

    function getStats(samples, attr) {
      // Filter to only valid numeric values - exclude undefined, null, empty strings, and NaN
      const values = samples.map(s => s[attr])
        .filter(v => v !== undefined && v !== null && v !== '' && !isNaN(parseFloat(v)))
        .map(v => parseFloat(v));
      if (values.length === 0) return null;
      const sorted = [...values].sort((a, b) => a - b);
      const mid = Math.floor(sorted.length / 2);
      const median = sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
      return {
        avg: values.reduce((a, b) => a + b, 0) / values.length,
        median: median,
        high: Math.max(...values),
        low: Math.min(...values),
        count: values.length
      };
    }
    
    function updateYearStatsBox(container, year, samples) {
      if (!year || samples.length === 0) {
        container.innerHTML = '<p style="color: #94a3b8; font-style: italic;">No data</p>';
        return;
      }

      // Get unique fields
      const fields = [...new Set(samples.map(s => s.field).filter(f => f && f !== 'Unknown'))].sort();

      let html = `
        <div style="display: flex; gap: 1.5rem; flex-wrap: wrap; align-items: center;">
          <div>
            <div style="font-size: 1.5rem; font-weight: 700; color: #1e293b;">${year}</div>
            <div style="font-size: 0.875rem; color: #64748b;">${samples.length} samples across ${fields.length} fields</div>
          </div>
        </div>
      `;

      container.innerHTML = html;
    }
    
    window.toggleComparisonField = function(field) {
      if (selectedComparisonFields.has(field)) {
        selectedComparisonFields.delete(field);
      } else {
        selectedComparisonFields.add(field);
      }
      updateComparison();
    };
    
    window.selectMatchingComparisonFields = function() {
      const allSamplesFrom = year1 ? sampleData.filter(s => String(s.year) === String(year1)) : [];
      const allSamplesTo = sampleData.filter(s => String(s.year) === String(year2));
      const excludeFields = ['Unknown', 'Unassigned', 'unknown', 'unassigned', null, undefined, ''];
      const fieldsFrom = new Set(allSamplesFrom.map(s => s.field).filter(f => f && !excludeFields.includes(f)));
      const fieldsTo = new Set(allSamplesTo.map(s => s.field).filter(f => f && !excludeFields.includes(f)));
      const allFields = [...new Set([...fieldsFrom, ...fieldsTo])];
      // Clear first, then only select fields that have data in both years (matching fields)
      selectedComparisonFields.clear();
      allFields.forEach(f => {
        if (fieldsFrom.has(f) && fieldsTo.has(f)) {
          selectedComparisonFields.add(f);
        }
      });
      updateComparison();
    };

    window.selectAllComparisonFields = function() {
      const allSamplesFrom = year1 ? sampleData.filter(s => String(s.year) === String(year1)) : [];
      const allSamplesTo = sampleData.filter(s => String(s.year) === String(year2));
      const excludeFields = ['Unknown', 'Unassigned', 'unknown', 'unassigned', null, undefined, ''];
      const fieldsFrom = new Set(allSamplesFrom.map(s => s.field).filter(f => f && !excludeFields.includes(f)));
      const fieldsTo = new Set(allSamplesTo.map(s => s.field).filter(f => f && !excludeFields.includes(f)));
      const allFields = [...new Set([...fieldsFrom, ...fieldsTo])];
      // Select all fields from both years
      selectedComparisonFields.clear();
      allFields.forEach(f => selectedComparisonFields.add(f));
      updateComparison();
    };

    // ========== TAB 1: Year Comparison ==========
    // year1 = FROM (earlier year), year2 = TO (later year)
    // Stats shown are for year2, change = year2 - year1
    function updateComparison() {
      const grid = document.getElementById('comparisonGrid');
      const fromYearInfo = document.getElementById('fromYearInfo');
      const toYearInfo = document.getElementById('toYearInfo');
      const fieldCheckboxes = document.getElementById('fieldCheckboxes');
      const mismatchWarning = document.getElementById('fieldMismatchWarning');
      
      if (!year2 || sampleData.length === 0) {
        grid.innerHTML = '<div class="no-data">No data available. Import soil samples to see analysis.</div>';
        fromYearInfo.innerHTML = '';
        toYearInfo.innerHTML = '';
        fieldCheckboxes.innerHTML = '';
        mismatchWarning.innerHTML = '';
        return;
      }
      
      const allSamplesFrom = year1 ? sampleData.filter(s => String(s.year) === String(year1)) : [];
      const allSamplesTo = sampleData.filter(s => String(s.year) === String(year2));
      
      // Get all fields from both years (exclude Unknown and Unassigned)
      const excludeFields = ['Unknown', 'Unassigned', 'unknown', 'unassigned', null, undefined, ''];
      const fieldsFrom = new Set(allSamplesFrom.map(s => s.field).filter(f => f && !excludeFields.includes(f)));
      const fieldsTo = new Set(allSamplesTo.map(s => s.field).filter(f => f && !excludeFields.includes(f)));
      const allFields = [...new Set([...fieldsFrom, ...fieldsTo])].sort();
      
      // Initialize selectedComparisonFields if empty - only select fields in BOTH years by default
      if (selectedComparisonFields.size === 0) {
        allFields.forEach(f => {
          // Only check fields that have data in both years
          if (fieldsFrom.has(f) && fieldsTo.has(f)) {
            selectedComparisonFields.add(f);
          }
        });
      }
      
      // Update field checkboxes
      fieldCheckboxes.innerHTML = allFields.map(field => {
        const inFrom = fieldsFrom.has(field);
        const inTo = fieldsTo.has(field);
        const checked = selectedComparisonFields.has(field);
        const mismatch = (inFrom && !inTo) || (!inFrom && inTo);
        const bgColor = mismatch ? '#fef3c7' : (checked ? '#dcfce7' : '#f8fafc');
        const borderColor = mismatch ? '#f59e0b' : (checked ? '#22c55e' : '#cbd5e1');
        
        return `
          <label style="display: flex; align-items: center; gap: 0.375rem; padding: 0.375rem 0.625rem; background: ${bgColor}; border: 1px solid ${borderColor}; border-radius: 0.375rem; cursor: pointer; font-size: 0.8125rem;">
            <input type="checkbox" ${checked ? 'checked' : ''} onchange="toggleComparisonField('${field}')" style="cursor: pointer;">
            <span>${field}</span>
            ${mismatch ? '<span style="color: #f59e0b;" title="Not in both years">‚ö†Ô∏è</span>' : ''}
          </label>
        `;
      }).join('');
      
      // Check for mismatches
      const onlyInFrom = [...fieldsFrom].filter(f => !fieldsTo.has(f));
      const onlyInTo = [...fieldsTo].filter(f => !fieldsFrom.has(f));
      
      if (onlyInFrom.length > 0 || onlyInTo.length > 0) {
        let warningHtml = '<div style="background: #fef3c7; border: 1px solid #f59e0b; border-radius: 0.375rem; padding: 0.75rem; font-size: 0.8125rem;">';
        warningHtml += '<strong style="color: #92400e;">‚ö†Ô∏è Field Mismatch Detected</strong><br>';
        if (onlyInFrom.length > 0) {
          warningHtml += `<span style="color: #92400e;">Only in ${year1}: ${onlyInFrom.join(', ')}</span><br>`;
        }
        if (onlyInTo.length > 0) {
          warningHtml += `<span style="color: #92400e;">Only in ${year2}: ${onlyInTo.join(', ')}</span>`;
        }
        warningHtml += '</div>';
        mismatchWarning.innerHTML = warningHtml;
      } else {
        mismatchWarning.innerHTML = '';
      }
      
      // Filter samples by selected fields
      const samplesFrom = allSamplesFrom.filter(s => selectedComparisonFields.has(s.field));
      const samplesTo = allSamplesTo.filter(s => selectedComparisonFields.has(s.field));
      
      // Update year stats boxes
      updateYearStatsBox(fromYearInfo, year1, samplesFrom);
      updateYearStatsBox(toYearInfo, year2, samplesTo);
      
      if (samplesTo.length === 0) {
        // Check if the issue is no matching fields
        const matchingFields = allFields.filter(f => fieldsFrom.has(f) && fieldsTo.has(f));
        if (matchingFields.length === 0 && allFields.length > 0) {
          grid.innerHTML = `<div class="no-data">No matching fields between ${year1} and ${year2}.<br><small style="color: #64748b;">Fields may have different names. Try "Reassign samples to boundaries" on the Import page, or select fields manually above.</small></div>`;
        } else {
          grid.innerHTML = `<div class="no-data">No samples found for ${year2} with selected fields.<br><small style="color: #64748b;">Select fields above to include in comparison.</small></div>`;
        }
        return;
      }
      
      let html = '';
      
      const visibleNutrients = getVisibleNutrients();
      visibleNutrients.forEach(attr => {
        const statsTo = getStats(samplesTo, attr);
        const statsFrom = year1 ? getStats(samplesFrom, attr) : null;
        
        if (!statsTo) return;
        
        const name = CONFIG.NUTRIENT_NAMES[attr] || attr;
        const unit = CONFIG.NUTRIENT_UNITS[attr] || '';
        const decimals = getDecimals(attr);
        const isLowerBetter = CONFIG.LOWER_IS_BETTER.includes(attr);
        
        let pointChange = 0, pctChange = 0, cardClass = '', pctClass = 'neutral';
        
        if (statsFrom && statsFrom.avg !== undefined) {
          pointChange = statsTo.avg - statsFrom.avg;
          pctChange = statsFrom.avg !== 0 ? (pointChange / statsFrom.avg) * 100 : 0;
          const isPositive = isLowerBetter ? pointChange < 0 : pointChange > 0;
          const isSignificant = Math.abs(pctChange) > 2;
          if (isSignificant) {
            cardClass = isPositive ? 'positive' : 'negative';
            pctClass = isPositive ? 'positive' : 'negative';
          }
        } else if (year1 && samplesFrom.length === 0) {
          // No data from year1 for selected fields - show warning style
          cardClass = 'no-comparison';
        }
        
        html += `
          <div class="nutrient-card ${cardClass}">
            <div class="nutrient-header">
              <span class="nutrient-name">${name}</span>
              ${statsFrom ? `<span class="nutrient-pct ${pctClass}">${pctChange >= 0 ? '+' : ''}${pctChange.toFixed(1)}%</span>` : ''}
            </div>
            <div class="nutrient-stats">
              <div class="stat-box"><div class="label">Average</div><div class="value">${statsTo.avg.toFixed(decimals)}</div></div>
              <div class="stat-box"><div class="label">High</div><div class="value">${statsTo.high.toFixed(decimals)}</div></div>
              <div class="stat-box"><div class="label">Low</div><div class="value">${statsTo.low.toFixed(decimals)}</div></div>
            </div>
            ${statsFrom ? `
              <div class="year-comparison">
                <div class="year-val"><div class="yr">${year1}</div><div class="num">${statsFrom.avg.toFixed(decimals)}</div></div>
                <div class="year-arrow">‚Üí</div>
                <div class="year-val"><div class="yr">${year2}</div><div class="num">${statsTo.avg.toFixed(decimals)}</div></div>
              </div>
              <div class="change-row">
                <span>Point: <span class="val ${pctClass}">${pointChange >= 0 ? '+' : ''}${pointChange.toFixed(decimals)}</span></span>
                <span>%: <span class="val ${pctClass}">${pctChange >= 0 ? '+' : ''}${pctChange.toFixed(1)}%</span></span>
              </div>
            ` : `<div class="year-comparison" style="justify-content:center; flex-direction:column; align-items:center;">
              <div class="year-val"><div class="yr">${year2}</div><div class="num">${statsTo.avg.toFixed(decimals)} ${unit}</div></div>
              ${year1 && samplesFrom.length === 0 ? `<div style="font-size:0.75rem;color:#92400e;margin-top:0.5rem;">‚ö†Ô∏è No ${year1} data for selected fields</div>` : ''}
            </div>`}
          </div>
        `;
      });
      
      grid.innerHTML = html || '<div class="no-data">No nutrient data available</div>';
    }

    // ========== TAB 2: Historical Field Trends ==========
    function updateHistory(fieldName) {
      const container = document.getElementById('historyContent');

      if (!fieldName) {
        container.innerHTML = '<div class="no-data">Select a field to view nutrient trends over time</div>';
        return;
      }

      // Handle "All Fields" operation-wide trends
      if (fieldName === '__all__') {
        renderOperationTrends(container);
        return;
      }

      console.log('=== Field Trends Debug ===');
      console.log('Selected field:', JSON.stringify(fieldName), 'length:', fieldName.length);

      const fieldSamples = sampleData.filter(s => s.field === fieldName);
      console.log('Samples found:', fieldSamples.length);

      const years = [...new Set(fieldSamples.map(s => s.year).filter(y => y))].sort();
      console.log('Years found:', years);

      if (fieldSamples.length > 0) {
        console.log('First sample:', JSON.stringify(fieldSamples[0]));
        console.log('Sample years breakdown:', years.map(y => ({ year: y, count: fieldSamples.filter(s => String(s.year) === String(y)).length })));
      }

      if (years.length < 1) {
        container.innerHTML = '<div class="no-data">No data available for this field</div>';
        return;
      }

      let html = `<div style="background:#f8fafc;border:2px solid #cbd5e1;border-radius:0.5rem;padding:1rem;margin-bottom:1rem;"><h3 style="margin:0 0 0.25rem 0;">${fieldName}</h3><p style="margin:0;color:#64748b;">Years: ${years.join(', ')} (${fieldSamples.length} samples)</p></div>`;

      try {
        const visibleNutrients = getVisibleNutrients();
        console.log('Visible nutrients:', visibleNutrients.length);

        visibleNutrients.forEach(attr => {
          try {
            const yearData = [];
            let hasData = false;

            years.forEach(year => {
              const yearSamples = fieldSamples.filter(s => String(s.year) === String(year));
              const stats = getStats(yearSamples, attr);
              if (stats) { yearData.push({ year, avg: stats.avg, median: stats.median, count: stats.count }); hasData = true; }
            });

            if (!hasData || yearData.length < 1) return;

            const first = yearData[0], last = yearData[yearData.length - 1];
            const avgChange = last.avg - first.avg;
            const medianChange = last.median - first.median;
            const pctChange = first.avg !== 0 ? (avgChange / first.avg) * 100 : 0;
            const isLowerBetter = CONFIG.LOWER_IS_BETTER.includes(attr);
            const isPositive = isLowerBetter ? avgChange < 0 : avgChange > 0;
            const decimals = getDecimals(attr);
            const unit = CONFIG.NUTRIENT_UNITS[attr] || '';
            const name = CONFIG.NUTRIENT_NAMES[attr] || attr;

            let cardClass = 'neutral', color = '#64748b';
            if (yearData.length > 1) {
              cardClass = isPositive ? 'positive' : 'negative';
              color = isPositive ? '#22c55e' : '#ef4444';
            }

            const graph = createDualLineGraph(yearData, color, attr);

            html += `
              <div class="trend-card ${cardClass}">
                <div class="trend-header">
                  <h4 class="trend-title">${name}</h4>
                  ${yearData.length > 1 ? `<div class="trend-pct" style="color:${color};">${pctChange >= 0 ? '+' : ''}${pctChange.toFixed(1)}%<div class="trend-sub">${first.year} ‚Üí ${last.year}</div></div>` : ''}
                </div>
                <div class="trend-content">
                  <div class="trend-values">
                    <div style="font-size:0.7rem;color:#64748b;margin-bottom:0.25rem;display:flex;justify-content:space-between;padding:0 0.75rem;"><span></span><span style="width:70px;text-align:center;">Avg</span><span style="width:70px;text-align:center;">Median</span></div>
                    ${yearData.map((d, i) => `<div class="trend-row ${i % 2 === 0 ? 'alt' : ''}"><span class="trend-year">${d.year}:</span><span class="trend-value" style="width:70px;text-align:center;">${d.avg.toFixed(decimals)}</span><span class="trend-value" style="width:70px;text-align:center;color:#8b5cf6;">${d.median.toFixed(decimals)}</span></div>`).join('')}
                    ${yearData.length > 1 ? `<div class="trend-row" style="margin-top:0.5rem;border-top:2px solid ${color};padding-top:0.5rem;"><span>Change:</span><span style="width:70px;text-align:center;color:${color};font-weight:700;">${avgChange >= 0 ? '+' : ''}${avgChange.toFixed(decimals)}</span><span style="width:70px;text-align:center;color:#8b5cf6;font-weight:700;">${medianChange >= 0 ? '+' : ''}${medianChange.toFixed(decimals)}</span></div>` : ''}
                  </div>
                  <div class="trend-graph ${yearData.length > 10 ? 'xlarge' : (yearData.length > 5 ? 'large' : '')}">
                    <div style="display:flex;gap:1rem;font-size:0.7rem;margin-bottom:0.25rem;justify-content:center;">
                      <span><span style="color:${color};">‚óè</span> Average</span>
                      <span><span style="color:#8b5cf6;">‚óè</span> Median</span>
                    </div>
                    ${graph}
                  </div>
                </div>
              </div>
            `;
          } catch (attrError) {
            console.error('Error processing attribute', attr, ':', attrError);
          }
        });

        console.log('Generated HTML length:', html.length);
        container.innerHTML = html || '<div class="no-data">No nutrient data available</div>';
      } catch (error) {
        console.error('Error in updateHistory:', error);
        container.innerHTML = `<div class="no-data" style="color: red;">Error loading data: ${error.message}</div>`;
      }
    }

    // Operation-wide trends (All Fields)
    function renderOperationTrends(container) {
      const years = [...new Set(sampleData.map(s => s.year).filter(y => y))].sort();
      const allFields = [...new Set(sampleData.map(s => s.field).filter(f => f && f !== 'Unknown' && f !== 'Unassigned'))];

      if (years.length < 1) {
        container.innerHTML = '<div class="no-data">No data available</div>';
        return;
      }

      // Calculate per-year statistics
      const yearStats = years.map(year => {
        const yearSamples = sampleData.filter(s => String(s.year) === String(year));
        const fieldsInYear = [...new Set(yearSamples.map(s => s.field).filter(f => f && f !== 'Unknown' && f !== 'Unassigned'))];
        return {
          year,
          sampleCount: yearSamples.length,
          fieldCount: fieldsInYear.length,
          fields: fieldsInYear
        };
      });

      const totalSamples = sampleData.length;
      const operationName = localStorage.getItem('operationName') || 'Operation';

      let html = `
        <div style="background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%); border: 2px solid #3b82f6; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem;">
          <h3 style="margin: 0 0 0.5rem 0; color: #1e40af;">üìä ${operationName} - All Fields Average</h3>
          <p style="margin: 0 0 0.5rem 0; color: #64748b; font-size: 0.875rem;">
            Operation-wide nutrient trends across <strong>${allFields.length} fields</strong> and <strong>${totalSamples.toLocaleString()} total samples</strong>
          </p>
          <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; font-size: 0.75rem;">
            ${yearStats.map(ys => `
              <span style="background: white; padding: 0.25rem 0.5rem; border-radius: 0.25rem; border: 1px solid #93c5fd;">
                <strong>${ys.year}:</strong> ${ys.sampleCount} samples, ${ys.fieldCount} fields
              </span>
            `).join('')}
          </div>
        </div>
      `;

      try {
        const visibleNutrients = getVisibleNutrients();

        visibleNutrients.forEach(attr => {
          try {
            const yearData = [];
            let hasData = false;

            years.forEach(year => {
              const yearSamples = sampleData.filter(s => String(s.year) === String(year));
              const stats = getStats(yearSamples, attr);

              // Calculate per-field averages for range band
              const fieldsInYear = [...new Set(yearSamples.map(s => s.field).filter(f => f && f !== 'Unknown' && f !== 'Unassigned'))];
              const fieldAvgs = fieldsInYear.map(field => {
                const fieldSamples = yearSamples.filter(s => s.field === field);
                const fieldStats = getStats(fieldSamples, attr);
                return fieldStats ? fieldStats.avg : null;
              }).filter(v => v !== null);

              if (stats) {
                yearData.push({
                  year,
                  avg: stats.avg,
                  median: stats.median,
                  count: stats.count,
                  fieldCount: fieldsInYear.length,
                  minFieldAvg: fieldAvgs.length > 0 ? Math.min(...fieldAvgs) : stats.avg,
                  maxFieldAvg: fieldAvgs.length > 0 ? Math.max(...fieldAvgs) : stats.avg
                });
                hasData = true;
              }
            });

            if (!hasData || yearData.length < 1) return;

            const first = yearData[0], last = yearData[yearData.length - 1];
            const avgChange = last.avg - first.avg;
            const medianChange = last.median - first.median;
            const pctChange = first.avg !== 0 ? (avgChange / first.avg) * 100 : 0;
            const isLowerBetter = CONFIG.LOWER_IS_BETTER.includes(attr);
            const isPositive = isLowerBetter ? avgChange < 0 : avgChange > 0;
            const decimals = getDecimals(attr);
            const name = CONFIG.NUTRIENT_NAMES[attr] || attr;

            let cardClass = 'neutral', color = '#64748b';
            if (yearData.length > 1) {
              cardClass = isPositive ? 'positive' : 'negative';
              color = isPositive ? '#22c55e' : '#ef4444';
            }

            const graph = createOperationTrendGraph(yearData, color);

            html += `
              <div class="trend-card ${cardClass}">
                <div class="trend-header">
                  <h4 class="trend-title">${name}</h4>
                  ${yearData.length > 1 ? `<div class="trend-pct" style="color:${color};">${pctChange >= 0 ? '+' : ''}${pctChange.toFixed(1)}%<div class="trend-sub">${first.year} ‚Üí ${last.year}</div></div>` : ''}
                </div>
                <div class="trend-content">
                  <div class="trend-values">
                    <div style="font-size:0.65rem;color:#64748b;margin-bottom:0.25rem;display:flex;justify-content:space-between;padding:0 0.5rem;">
                      <span></span>
                      <span style="width:50px;text-align:center;">Avg</span>
                      <span style="width:50px;text-align:center;">Med</span>
                      <span style="width:70px;text-align:center;font-size:0.6rem;">Range</span>
                    </div>
                    ${yearData.map((d, i) => `
                      <div class="trend-row ${i % 2 === 0 ? 'alt' : ''}" style="font-size:0.8rem;">
                        <span class="trend-year">${d.year}:</span>
                        <span style="width:50px;text-align:center;">${d.avg.toFixed(decimals)}</span>
                        <span style="width:50px;text-align:center;color:#8b5cf6;">${d.median.toFixed(decimals)}</span>
                        <span style="width:70px;text-align:center;font-size:0.65rem;color:#94a3b8;">${d.minFieldAvg.toFixed(decimals)}-${d.maxFieldAvg.toFixed(decimals)}</span>
                      </div>
                    `).join('')}
                    ${yearData.length > 1 ? `
                      <div class="trend-row" style="margin-top:0.5rem;border-top:2px solid ${color};padding-top:0.5rem;">
                        <span>Change:</span>
                        <span style="width:50px;text-align:center;color:${color};font-weight:700;">${avgChange >= 0 ? '+' : ''}${avgChange.toFixed(decimals)}</span>
                        <span style="width:50px;text-align:center;color:#8b5cf6;font-weight:700;">${medianChange >= 0 ? '+' : ''}${medianChange.toFixed(decimals)}</span>
                        <span style="width:70px;"></span>
                      </div>
                    ` : ''}
                  </div>
                  <div class="trend-graph ${yearData.length > 10 ? 'xlarge' : (yearData.length > 5 ? 'large' : '')}">
                    <div style="display:flex;gap:0.75rem;font-size:0.65rem;margin-bottom:0.25rem;justify-content:center;">
                      <span><span style="color:${color};">‚óè</span> Avg</span>
                      <span><span style="color:#8b5cf6;">‚óè</span> Median</span>
                      <span style="color:#cbd5e1;">‚ñà Field Range</span>
                    </div>
                    ${graph}
                  </div>
                </div>
              </div>
            `;
          } catch (attrError) {
            console.error('Error processing attribute', attr, ':', attrError);
          }
        });

        container.innerHTML = html || '<div class="no-data">No nutrient data available</div>';
      } catch (error) {
        console.error('Error in renderOperationTrends:', error);
        container.innerHTML = `<div class="no-data" style="color: red;">Error loading data: ${error.message}</div>`;
      }
    }

    // Graph with range band for operation trends
    function createOperationTrendGraph(yearData, avgColor) {
      if (yearData.length < 1) return '';
      const medianColor = '#8b5cf6';
      const numYears = yearData.length;

      // Get all values including range to determine scale
      const allValues = [
        ...yearData.map(d => d.avg),
        ...yearData.map(d => d.median),
        ...yearData.map(d => d.minFieldAvg),
        ...yearData.map(d => d.maxFieldAvg)
      ];
      const minVal = Math.min(...allValues) * 0.9, maxVal = Math.max(...allValues) * 1.1;
      const range = maxVal - minVal || 1;

      // Dynamic dimensions based on year count - larger for PDF readability
      const baseWidth = 450;
      const width = numYears <= 5 ? baseWidth : Math.max(baseWidth, numYears * 60);
      const height = numYears <= 5 ? 190 : (numYears <= 10 ? 230 : 290);
      const padLeft = 35, padRight = 35, padTop = 30, padBottom = 40;
      const gw = width - padLeft - padRight;
      const gh = height - padTop - padBottom;

      // Determine label skip interval - only skip for very many years
      const labelSkip = numYears > 15 ? 2 : (numYears > 10 ? 1 : 0);

      // Calculate points
      const avgPts = yearData.map((d, i) => {
        const x = padLeft + (yearData.length > 1 ? (i / (yearData.length - 1)) * gw : gw / 2);
        const y = padTop + gh - ((d.avg - minVal) / range) * gh;
        return { x, y, year: d.year, val: d.avg };
      });

      const medianPts = yearData.map((d, i) => {
        const x = padLeft + (yearData.length > 1 ? (i / (yearData.length - 1)) * gw : gw / 2);
        const y = padTop + gh - ((d.median - minVal) / range) * gh;
        return { x, y, year: d.year, val: d.median };
      });

      // Range band (min/max field averages)
      const rangePts = yearData.map((d, i) => {
        const x = padLeft + (yearData.length > 1 ? (i / (yearData.length - 1)) * gw : gw / 2);
        const yMin = padTop + gh - ((d.minFieldAvg - minVal) / range) * gh;
        const yMax = padTop + gh - ((d.maxFieldAvg - minVal) / range) * gh;
        return { x, yMin, yMax };
      });

      // Create range band path (polygon)
      let rangePath = '';
      if (yearData.length > 1) {
        const topPoints = rangePts.map(p => `${p.x},${p.yMax}`).join(' L');
        const bottomPoints = [...rangePts].reverse().map(p => `${p.x},${p.yMin}`).join(' L');
        rangePath = `<path d="M${topPoints} L${bottomPoints} Z" fill="#e2e8f0" opacity="0.5"/>`;
      } else {
        // Single point - draw a vertical line
        const p = rangePts[0];
        rangePath = `<line x1="${p.x}" y1="${p.yMin}" x2="${p.x}" y2="${p.yMax}" stroke="#cbd5e1" stroke-width="8" opacity="0.5"/>`;
      }

      // Create lines
      const avgLine = avgPts.map((p, i) => `${i === 0 ? 'M' : 'L'}${p.x},${p.y}`).join(' ');
      const medianLine = medianPts.map((p, i) => `${i === 0 ? 'M' : 'L'}${p.x},${p.y}`).join(' ');

      // Create dots
      const dotRadius = numYears > 10 ? 4 : 5;
      const avgDots = avgPts.map(p => `<circle cx="${p.x}" cy="${p.y}" r="${dotRadius}" fill="${avgColor}" stroke="white" stroke-width="2"/>`).join('');
      const medianDots = medianPts.map(p => `<circle cx="${p.x}" cy="${p.y}" r="${dotRadius}" fill="${medianColor}" stroke="white" stroke-width="2"/>`).join('');

      // Year labels - always show all for small datasets
      const yearLabels = avgPts.map((p, i) => {
        const showLabel = i === 0 || i === avgPts.length - 1 || (labelSkip === 0) || (labelSkip === 1 && i % 2 === 0) || (labelSkip === 2 && i % 3 === 0);
        if (!showLabel) return '';
        const fontSize = numYears > 12 ? 10 : 11;
        return `<text x="${p.x}" y="${height - 12}" text-anchor="middle" font-size="${fontSize}" font-weight="600" fill="#475569">${p.year}</text>`;
      }).join('');

      const sizeClass = numYears > 10 ? 'xlarge' : (numYears > 5 ? 'large' : '');

      return `<svg width="100%" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet" style="width:100%;height:auto;min-height:${height}px;" data-size="${sizeClass}">
        ${rangePath}
        <path d="${avgLine}" fill="none" stroke="${avgColor}" stroke-width="3" stroke-linecap="round"/>
        <path d="${medianLine}" fill="none" stroke="${medianColor}" stroke-width="2.5" stroke-linecap="round" stroke-dasharray="4,2"/>
        ${avgDots}
        ${medianDots}
        ${yearLabels}
      </svg>`;
    }

    function createLineGraph(yearData, color, attr = 'P') {
      if (yearData.length < 1) return '';
      const decimals = getDecimals(attr);
      const values = yearData.map(d => d.avg);
      const minVal = Math.min(...values) * 0.9, maxVal = Math.max(...values) * 1.1;
      const range = maxVal - minVal || 1;
      const width = 400, height = 140, pad = 20;
      const gw = width - pad * 2, gh = height - pad * 2 - 20;

      const pts = yearData.map((d, i) => {
        const x = pad + (yearData.length > 1 ? (i / (yearData.length - 1)) * gw : gw / 2);
        const y = pad + gh - ((d.avg - minVal) / range) * gh;
        return { x, y, year: d.year, val: d.avg };
      });

      const line = pts.map((p, i) => `${i === 0 ? 'M' : 'L'}${p.x},${p.y}`).join(' ');
      const dots = pts.map(p => `<circle cx="${p.x}" cy="${p.y}" r="6" fill="${color}" stroke="white" stroke-width="2"/><text x="${p.x}" y="${height - 5}" text-anchor="middle" font-size="11" fill="#64748b">${p.year}</text><text x="${p.x}" y="${p.y - 12}" text-anchor="middle" font-size="12" font-weight="700" fill="#1e293b">${p.val.toFixed(decimals)}</text>`).join('');

      return `<svg width="100%" height="${height}" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet"><path d="${line}" fill="none" stroke="${color}" stroke-width="3" stroke-linecap="round"/>${dots}</svg>`;
    }

    function createDualLineGraph(yearData, avgColor, attr = 'P') {
      if (yearData.length < 1) return '';
      const medianColor = '#8b5cf6'; // Purple for median
      const numYears = yearData.length;
      const decimals = getDecimals(attr);

      // Get all values to determine scale
      const allValues = [...yearData.map(d => d.avg), ...yearData.map(d => d.median)];
      const minVal = Math.min(...allValues) * 0.85, maxVal = Math.max(...allValues) * 1.15;
      const range = maxVal - minVal || 1;

      // Dynamic dimensions based on year count - larger for PDF readability
      const baseWidth = 450;  // Wider base for better label spacing
      const width = numYears <= 5 ? baseWidth : Math.max(baseWidth, numYears * 60);
      const height = numYears <= 5 ? 180 : (numYears <= 10 ? 220 : 280);
      const padLeft = 35, padRight = 35, padTop = 30, padBottom = 40; // More padding for labels
      const gw = width - padLeft - padRight;
      const gh = height - padTop - padBottom;

      // Determine label skip interval - only skip for very many years
      const labelSkip = numYears > 15 ? 2 : (numYears > 10 ? 1 : 0);

      // Calculate points for both lines
      const avgPts = yearData.map((d, i) => {
        const x = padLeft + (yearData.length > 1 ? (i / (yearData.length - 1)) * gw : gw / 2);
        const y = padTop + gh - ((d.avg - minVal) / range) * gh;
        return { x, y, year: d.year, val: d.avg, idx: i };
      });

      const medianPts = yearData.map((d, i) => {
        const x = padLeft + (yearData.length > 1 ? (i / (yearData.length - 1)) * gw : gw / 2);
        const y = padTop + gh - ((d.median - minVal) / range) * gh;
        return { x, y, year: d.year, val: d.median, idx: i };
      });

      // Create path lines
      const avgLine = avgPts.map((p, i) => `${i === 0 ? 'M' : 'L'}${p.x},${p.y}`).join(' ');
      const medianLine = medianPts.map((p, i) => `${i === 0 ? 'M' : 'L'}${p.x},${p.y}`).join(' ');

      // Create dots - smaller for many years
      const dotRadius = numYears > 10 ? 4 : 5;
      const avgDots = avgPts.map(p => `<circle cx="${p.x}" cy="${p.y}" r="${dotRadius}" fill="${avgColor}" stroke="white" stroke-width="2"/>`).join('');
      const medianDots = medianPts.map(p => `<circle cx="${p.x}" cy="${p.y}" r="${dotRadius}" fill="${medianColor}" stroke="white" stroke-width="2"/>`).join('');

      // Year labels at bottom - always show all for small datasets
      const yearLabels = avgPts.map((p, i) => {
        // Always show first and last, skip middle ones only for very many years
        const showLabel = i === 0 || i === avgPts.length - 1 || (labelSkip === 0) || (labelSkip === 1 && i % 2 === 0) || (labelSkip === 2 && i % 3 === 0);
        if (!showLabel) return '';
        const fontSize = numYears > 12 ? 10 : 11;
        return `<text x="${p.x}" y="${height - 12}" text-anchor="middle" font-size="${fontSize}" font-weight="600" fill="#475569">${p.year}</text>`;
      }).join('');

      // Value labels - show for up to 10 years
      let avgLabels = '', medianLabels = '';
      if (numYears <= 10) {
        avgLabels = avgPts.map((p, i) => {
          const medianY = medianPts[i].y;
          const gap = Math.abs(p.y - medianY);
          let offset = gap < 20 ? (p.y < medianY ? -12 : 16) : -12;
          const fontSize = numYears > 6 ? 9 : 10;
          return `<text x="${p.x}" y="${p.y + offset}" text-anchor="middle" font-size="${fontSize}" font-weight="700" fill="${avgColor}">${p.val.toFixed(decimals)}</text>`;
        }).join('');

        medianLabels = medianPts.map((p, i) => {
          const avgY = avgPts[i].y;
          const gap = Math.abs(p.y - avgY);
          let offset = gap < 20 ? (p.y <= avgY ? -12 : 16) : 16;
          const fontSize = numYears > 6 ? 9 : 10;
          return `<text x="${p.x}" y="${p.y + offset}" text-anchor="middle" font-size="${fontSize}" font-weight="700" fill="${medianColor}">${p.val.toFixed(decimals)}</text>`;
        }).join('');
      }

      // Add size class hint via data attribute
      const sizeClass = numYears > 10 ? 'xlarge' : (numYears > 5 ? 'large' : '');

      return `<svg viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet" style="width:100%;height:auto;min-height:${height}px;" data-size="${sizeClass}">
        <path d="${avgLine}" fill="none" stroke="${avgColor}" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
        <path d="${medianLine}" fill="none" stroke="${medianColor}" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" stroke-dasharray="6,3"/>
        ${avgDots}${medianDots}
        ${yearLabels}
        ${avgLabels}${medianLabels}
      </svg>`;
    }

    // ========== TAB 3: Field Rankings ==========
    function updateRankings() {
      const container = document.getElementById('rankingsContent');
      const attr = document.getElementById('rankingAttrSelect').value;
      const yearOption = document.getElementById('rankingYearSelect').value;
      
      if (!attr) {
        container.innerHTML = '<div class="no-data">Select nutrient</div>';
        return;
      }
      
      // Get all unique fields
      const allFields = [...new Set(sampleData.map(s => s.field).filter(f => f && f !== 'Unknown'))];
      
      const fieldStats = allFields.map(field => {
        // Get samples for this field
        let fieldSamples = sampleData.filter(s => s.field === field);
        
        if (yearOption === 'most_recent') {
          // Find most recent year for this field
          const fieldYears = [...new Set(fieldSamples.map(s => s.year).filter(y => y))].sort((a, b) => b - a);
          if (fieldYears.length === 0) return null;
          const mostRecentYear = fieldYears[0];
          fieldSamples = fieldSamples.filter(s => String(s.year) === String(mostRecentYear));
          const stats = getStats(fieldSamples, attr);
          return stats ? { field, avg: stats.avg, high: stats.high, low: stats.low, count: stats.count, year: mostRecentYear } : null;
        } else {
          // Filter by selected year
          fieldSamples = fieldSamples.filter(s => String(s.year) === String(yearOption));
          const stats = getStats(fieldSamples, attr);
          return stats ? { field, avg: stats.avg, high: stats.high, low: stats.low, count: stats.count, year: yearOption } : null;
        }
      }).filter(f => f);
      
      const isLowerBetter = CONFIG.LOWER_IS_BETTER.includes(attr);
      fieldStats.sort((a, b) => isLowerBetter ? a.avg - b.avg : b.avg - a.avg);
      
      const name = CONFIG.NUTRIENT_NAMES[attr] || attr;
      const unit = CONFIG.NUTRIENT_UNITS[attr] || '';
      const decimals = getDecimals(attr);
      const maxAvg = Math.max(...fieldStats.map(f => f.avg));
      const minAvg = Math.min(...fieldStats.map(f => f.avg));
      
      // Add Year column if using Most Recent
      const showYearCol = yearOption === 'most_recent';
      
      let html = `<table class="rankings-table"><thead><tr><th>Rank</th><th>Field</th>${showYearCol ? '<th>Year</th>' : ''}<th>Average</th><th>High</th><th>Low</th><th>Samples</th></tr></thead><tbody>`;
      
      fieldStats.forEach((f, i) => {
        const isTop = f.avg === (isLowerBetter ? minAvg : maxAvg);
        const isBottom = f.avg === (isLowerBetter ? maxAvg : minAvg);
        html += `<tr><td class="rank">#${i + 1}</td><td class="field">${f.field}</td>${showYearCol ? `<td>${f.year}</td>` : ''}<td class="value ${isTop ? 'high' : isBottom ? 'low' : ''}">${f.avg.toFixed(decimals)} ${unit}</td><td>${f.high.toFixed(decimals)}</td><td>${f.low.toFixed(decimals)}</td><td>${f.count}</td></tr>`;
      });
      
      html += '</tbody></table>';
      container.innerHTML = fieldStats.length > 0 ? html : '<div class="no-data">No data available</div>';
    }
    
    // ========== TAB 4: Yield Correlation ==========
    function updateYieldAnalysis() {
      const container = document.getElementById('yieldContent');
      const cropFilter = document.getElementById('yieldCropSelect').value;
      const yearFilter = document.getElementById('yieldYearSelect').value;
      const fieldFilter = document.getElementById('yieldFieldSelect').value;

      // Get samples with yield correlations
      let samplesWithYield = sampleData.filter(s => s.yieldCorrelations && Object.keys(s.yieldCorrelations).length > 0);

      if (samplesWithYield.length === 0) {
        container.innerHTML = '<div class="no-data">No yield data available. Import yield maps on the Import page to see correlations.</div>';
        return;
      }

      // Filter by field
      if (fieldFilter !== 'all') {
        samplesWithYield = samplesWithYield.filter(s => s.field === fieldFilter);
      }

      // Use only the most recent soil sample at each location
      // Group by approximate location (rounded to 5 decimal places ~1m precision)
      const locationMap = new Map();
      samplesWithYield.forEach(sample => {
        const locKey = `${sample.lat.toFixed(5)},${sample.lon.toFixed(5)}`;
        const existing = locationMap.get(locKey);
        if (!existing || (sample.year && sample.year > existing.year)) {
          locationMap.set(locKey, sample);
        }
      });
      samplesWithYield = Array.from(locationMap.values());

      // Get soil sample year range
      const soilYears = [...new Set(samplesWithYield.map(s => s.year).filter(y => y))].sort();
      const soilYearRange = soilYears.length > 0 ? `${Math.min(...soilYears)}-${Math.max(...soilYears)}` : 'N/A';

      // Get all available yield years (before filtering)
      const allYieldYears = new Set();
      samplesWithYield.forEach(sample => {
        Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
          if (cropFilter === 'all' || yieldInfo.crop === cropFilter) {
            allYieldYears.add(parseInt(year));
          }
        });
      });
      const sortedYieldYears = [...allYieldYears].sort();

      // Build correlation data points based on yearFilter mode
      const dataPoints = [];
      const uniqueLocations = samplesWithYield.length;

      if (yearFilter === 'avg') {
        // ALL YEARS (AVERAGE): Average yield across all years at each location
        samplesWithYield.forEach(sample => {
          const validYields = [];
          Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
            if (cropFilter === 'all' || yieldInfo.crop === cropFilter) {
              validYields.push({
                yield: yieldInfo.avgYield,
                crop: yieldInfo.crop,
                pointCount: yieldInfo.pointCount
              });
            }
          });

          if (validYields.length > 0) {
            const avgYield = validYields.reduce((sum, v) => sum + v.yield, 0) / validYields.length;
            dataPoints.push({
              ...sample,
              yieldYear: 'avg',
              avgYield: avgYield,
              crop: validYields[0].crop,
              yieldPointCount: validYields.reduce((sum, v) => sum + v.pointCount, 0),
              yearsAveraged: validYields.length
            });
          }
        });
      } else if (yearFilter === 'combined') {
        // ALL YEARS (COMBINED): Each year is a separate data point
        samplesWithYield.forEach(sample => {
          Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
            if (cropFilter === 'all' || yieldInfo.crop === cropFilter) {
              dataPoints.push({
                ...sample,
                yieldYear: parseInt(year),
                avgYield: yieldInfo.avgYield,
                crop: yieldInfo.crop,
                yieldPointCount: yieldInfo.pointCount
              });
            }
          });
        });
      } else {
        // SPECIFIC YEAR: Only use yield from that year
        samplesWithYield.forEach(sample => {
          const yieldInfo = sample.yieldCorrelations[yearFilter];
          if (yieldInfo && (cropFilter === 'all' || yieldInfo.crop === cropFilter)) {
            dataPoints.push({
              ...sample,
              yieldYear: parseInt(yearFilter),
              avgYield: yieldInfo.avgYield,
              crop: yieldInfo.crop,
              yieldPointCount: yieldInfo.pointCount
            });
          }
        });
      }

      if (dataPoints.length === 0) {
        container.innerHTML = '<div class="no-data">No matching yield data for selected filters.</div>';
        return;
      }

      // Calculate correlations for each nutrient
      const visibleNutrients = getVisibleNutrients();
      const correlations = [];

      console.log('=== YIELD CORRELATION DEBUG ===');
      console.log('Year filter:', yearFilter);
      console.log('Data points:', dataPoints.length);
      console.log('Unique locations:', uniqueLocations);

      visibleNutrients.forEach(nutrient => {
        // Filter for valid numeric values - must handle strings, empty values, etc.
        const pairs = dataPoints.filter(d => {
          const val = d[nutrient];
          if (val === undefined || val === null || val === '') return false;
          const num = parseFloat(val);
          return isFinite(num);
        });
        console.log(`  ${nutrient}: ${pairs.length} valid pairs (need 5+)`);
        if (pairs.length < 5) return; // Need at least 5 points

        const correlation = calculateCorrelation(
          pairs.map(p => parseFloat(p[nutrient])),
          pairs.map(p => p.avgYield)
        );

        if (correlation !== null && !isNaN(correlation.r)) {
          correlations.push({
            nutrient,
            name: CONFIG.NUTRIENT_NAMES[nutrient] || nutrient,
            r: correlation.r,
            r2: correlation.r2,
            n: pairs.length,
            significance: getSignificance(correlation.r, pairs.length)
          });
        }
      });

      // Store correlations globally for re-sorting
      yieldCorrelationsData = correlations;

      // Apply current sort
      sortYieldCorrelations();

      // Get summary stats
      const avgYield = dataPoints.reduce((sum, d) => sum + d.avgYield, 0) / dataPoints.length;
      const crops = [...new Set(dataPoints.map(d => d.crop))];
      const usedYieldYears = yearFilter === 'avg' || yearFilter === 'combined'
        ? sortedYieldYears
        : [parseInt(yearFilter)];

      const getSortIcon = (col) => {
        if (yieldSortColumn !== col) return '<span style="opacity: 0.3; font-size: 0.75rem;">&#9650;&#9660;</span>';
        return yieldSortDirection === 'asc' ? '<span style="color: #3b82f6;">&#9650;</span>' : '<span style="color: #3b82f6;">&#9660;</span>';
      };

      // Build description based on mode
      let modeDescription = '';
      if (yearFilter === 'avg') {
        modeDescription = `<div style="font-size: 0.8rem; color: #64748b;">${uniqueLocations} locations √ó avg of ${sortedYieldYears.length} yield years</div>`;
      } else if (yearFilter === 'combined') {
        modeDescription = `<div style="font-size: 0.8rem; color: #64748b;">${uniqueLocations} locations √ó ${sortedYieldYears.length} yield years</div>`;
      } else {
        modeDescription = `<div style="font-size: 0.8rem; color: #64748b;">${dataPoints.length} locations with ${yearFilter} yield</div>`;
      }

      let html = `
        <div style="background: #f0f9ff; border: 1px solid #0ea5e9; border-radius: 0.5rem; padding: 0.75rem; margin-bottom: 1rem; font-size: 0.8rem; color: #0369a1;">
          <strong>Data Selection:</strong><br>
          <strong>Soil Samples:</strong> Most recent sample at each location (${soilYearRange})<br>
          <strong>Yield Years:</strong> ${usedYieldYears.join(', ')}
          ${yearFilter === 'avg' ? ' <em>(averaged at each location)</em>' : yearFilter === 'combined' ? ' <em>(each year = separate data point)</em>' : ''}
        </div>

        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1.5rem;">
          <div style="background: #fef3c7; border: 2px solid #f59e0b; border-radius: 0.5rem; padding: 1rem; text-align: center;">
            <div style="font-size: 2rem; font-weight: 700; color: #92400e;">${dataPoints.length}</div>
            <div style="color: #92400e; font-size: 0.875rem;">Data Points</div>
            ${modeDescription}
          </div>
          <div style="background: #f0fdf4; border: 2px solid #22c55e; border-radius: 0.5rem; padding: 1rem; text-align: center;">
            <div style="font-size: 2rem; font-weight: 700; color: #166534;">${avgYield.toFixed(1)}</div>
            <div style="color: #166534; font-size: 0.875rem;">Avg Yield (bu/ac)</div>
          </div>
          <div style="background: #eff6ff; border: 2px solid #3b82f6; border-radius: 0.5rem; padding: 1rem; text-align: center;">
            <div style="font-size: 1.25rem; font-weight: 600; color: #1e40af;">${crops.map(c => c === 'corn' ? 'üåΩ' : 'ü´ò').join(' ')}</div>
            <div style="color: #1e40af; font-size: 0.875rem;">Yield Years: ${usedYieldYears.join(', ')}</div>
          </div>
        </div>

        <h3 style="margin: 0 0 1rem 0; color: #1e293b;">Nutrient-Yield Correlations</h3>
        <p style="color: #64748b; font-size: 0.875rem; margin-bottom: 0.5rem;">Shows how each soil nutrient correlates with crop yield at matched sample locations. Click column headers to sort.</p>
        <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 0.375rem; padding: 0.75rem; margin-bottom: 1rem; font-size: 0.8rem; color: #475569;">
          <strong>How to read this table:</strong><br>
          <strong>r (Correlation)</strong> ranges from -1 to +1. Positive = higher nutrient, higher yield. Negative = higher nutrient, lower yield. Values closer to +/-1 indicate stronger relationships.<br>
          <strong>R¬≤ (R-squared)</strong> shows what % of yield variation is explained by this nutrient. Example: R¬≤=25% means 25% of yield differences can be attributed to this nutrient.<br>
          <strong>Significance:</strong> *** = strong (|r| > 0.7), ** = moderate (|r| > 0.4), * = weak (|r| > 0.2), - = no meaningful correlation
        </div>

        <table class="rankings-table" id="yieldCorrelationTable">
          <thead>
            <tr>
              <th class="sortable-header" onclick="sortYieldTable('name')" style="cursor: pointer;">Nutrient ${getSortIcon('name')}</th>
              <th class="sortable-header" onclick="sortYieldTable('r')" style="cursor: pointer;">Correlation (r) ${getSortIcon('r')}</th>
              <th class="sortable-header" onclick="sortYieldTable('r2')" style="cursor: pointer;">R¬≤ ${getSortIcon('r2')}</th>
              <th class="sortable-header" onclick="sortYieldTable('significance')" style="cursor: pointer;">Significance ${getSortIcon('significance')}</th>
              <th class="sortable-header" onclick="sortYieldTable('n')" style="cursor: pointer;">Samples ${getSortIcon('n')}</th>
            </tr>
          </thead>
          <tbody id="yieldCorrelationBody">
      `;

      html += renderYieldCorrelationRows();

      html += '</tbody></table>';

      if (yieldCorrelationsData.length === 0) {
        html = '<div class="no-data">Not enough data points to calculate correlations. Need at least 5 samples with yield data.</div>';
      }

      container.innerHTML = html;
    }
    
    function calculateCorrelation(x, y) {
      const n = x.length;
      if (n < 3) return null;
      
      const sumX = x.reduce((a, b) => a + b, 0);
      const sumY = y.reduce((a, b) => a + b, 0);
      const sumXY = x.reduce((total, xi, i) => total + xi * y[i], 0);
      const sumX2 = x.reduce((total, xi) => total + xi * xi, 0);
      const sumY2 = y.reduce((total, yi) => total + yi * yi, 0);
      
      const numerator = n * sumXY - sumX * sumY;
      const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
      
      if (denominator === 0) return null;
      
      const r = numerator / denominator;
      return { r, r2: r * r };
    }
    
    function getSignificance(r, n) {
      // Simplified significance based on r value and sample size
      const absR = Math.abs(r);
      if (n < 10) return 'insufficient';
      if (absR > 0.7) return 'high';
      if (absR > 0.4) return 'medium';
      if (absR > 0.2) return 'low';
      return 'none';
    }

    // Sort the yield correlations data array
    function sortYieldCorrelations() {
      const sigOrder = { 'high': 3, 'medium': 2, 'low': 1, 'none': 0, 'insufficient': -1 };

      yieldCorrelationsData.sort((a, b) => {
        let aVal, bVal;

        switch (yieldSortColumn) {
          case 'name':
            aVal = a.name.toLowerCase();
            bVal = b.name.toLowerCase();
            return yieldSortDirection === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
          case 'r':
            // Sort by absolute value for correlation
            aVal = Math.abs(a.r);
            bVal = Math.abs(b.r);
            break;
          case 'r2':
            aVal = a.r2;
            bVal = b.r2;
            break;
          case 'significance':
            aVal = sigOrder[a.significance] || 0;
            bVal = sigOrder[b.significance] || 0;
            break;
          case 'n':
            aVal = a.n;
            bVal = b.n;
            break;
          default:
            aVal = Math.abs(a.r);
            bVal = Math.abs(b.r);
        }

        if (yieldSortDirection === 'asc') {
          return aVal - bVal;
        } else {
          return bVal - aVal;
        }
      });
    }

    // Render just the table rows (for re-sorting without rebuilding header)
    function renderYieldCorrelationRows() {
      let rows = '';
      yieldCorrelationsData.forEach(c => {
        const color = c.r > 0 ? '#22c55e' : '#ef4444';
        const barWidth = Math.abs(c.r) * 100;
        const significance = c.significance === 'high' ? '***' : c.significance === 'medium' ? '**' : c.significance === 'low' ? '*' : '-';
        const sigColor = c.significance === 'high' ? '#22c55e' : c.significance === 'medium' ? '#f59e0b' : '#94a3b8';

        rows += `
          <tr>
            <td class="field">${c.name}</td>
            <td>
              <div style="display: flex; align-items: center; gap: 0.5rem;">
                <div style="width: 80px; height: 12px; background: #e2e8f0; border-radius: 6px; overflow: hidden;">
                  <div style="width: ${barWidth}%; height: 100%; background: ${color}; ${c.r < 0 ? 'margin-left: auto;' : ''}"></div>
                </div>
                <span style="font-weight: 600; color: ${color};">${c.r > 0 ? '+' : ''}${c.r.toFixed(3)}</span>
              </div>
            </td>
            <td>${(c.r2 * 100).toFixed(1)}%</td>
            <td style="color: ${sigColor};">${significance}</td>
            <td>${c.n}</td>
          </tr>
        `;
      });
      return rows;
    }

    // Handle column header click to sort (attached to window for inline onclick)
    window.sortYieldTable = function(column) {
      if (yieldSortColumn === column) {
        // Toggle direction if same column
        yieldSortDirection = yieldSortDirection === 'asc' ? 'desc' : 'asc';
      } else {
        // New column, default to desc (highest first)
        yieldSortColumn = column;
        yieldSortDirection = 'desc';
      }

      // Re-run the full update to rebuild with new sort
      updateYieldAnalysis();
    };

    // ========== SCATTER PLOT & DEBUG ==========
    let currentYieldDataPoints = []; // Store for scatter plot

    function toggleYieldDebug() {
      const debugPanel = document.getElementById('yieldDebugPanel');
      const scatterSection = document.getElementById('scatterSection');
      const isHidden = debugPanel.style.display === 'none';

      debugPanel.style.display = isHidden ? 'block' : 'none';
      scatterSection.style.display = isHidden ? 'block' : 'none';

      if (isHidden) {
        generateDebugReport();
        populateScatterSelect();
        drawScatterPlot();
      }
    }

    function populateScatterSelect() {
      const select = document.getElementById('scatterNutrientSelect');
      const visibleNutrients = getVisibleNutrients();
      select.innerHTML = visibleNutrients.map(n =>
        `<option value="${n}"${n === 'P' ? ' selected' : ''}>${CONFIG.NUTRIENT_NAMES[n] || n}</option>`
      ).join('');
    }

    function getYieldDataPoints() {
      const cropFilter = document.getElementById('yieldCropSelect').value;
      const yearFilter = document.getElementById('yieldYearSelect').value;
      const fieldFilter = document.getElementById('yieldFieldSelect').value;

      let samplesWithYield = sampleData.filter(s => s.yieldCorrelations && Object.keys(s.yieldCorrelations).length > 0);
      if (fieldFilter !== 'all') samplesWithYield = samplesWithYield.filter(s => s.field === fieldFilter);

      const locationMap = new Map();
      samplesWithYield.forEach(sample => {
        const locKey = `${sample.lat.toFixed(5)},${sample.lon.toFixed(5)}`;
        const existing = locationMap.get(locKey);
        if (!existing || (sample.year && sample.year > existing.year)) {
          locationMap.set(locKey, sample);
        }
      });
      samplesWithYield = Array.from(locationMap.values());

      const dataPoints = [];

      if (yearFilter === 'avg') {
        // ALL YEARS (AVERAGE): Average yield across all years at each location
        samplesWithYield.forEach(sample => {
          const validYields = [];
          Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
            if (cropFilter === 'all' || yieldInfo.crop === cropFilter) {
              validYields.push({
                yield: yieldInfo.avgYield,
                crop: yieldInfo.crop,
                pointCount: yieldInfo.pointCount
              });
            }
          });
          if (validYields.length > 0) {
            const avgYield = validYields.reduce((sum, v) => sum + v.yield, 0) / validYields.length;
            dataPoints.push({
              ...sample,
              yieldYear: 'avg',
              avgYield: avgYield,
              crop: validYields[0].crop,
              yieldPointCount: validYields.reduce((sum, v) => sum + v.pointCount, 0),
              yearsAveraged: validYields.length
            });
          }
        });
      } else if (yearFilter === 'combined') {
        // ALL YEARS (COMBINED): Each year is a separate data point
        samplesWithYield.forEach(sample => {
          Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
            if (cropFilter === 'all' || yieldInfo.crop === cropFilter) {
              dataPoints.push({
                ...sample,
                yieldYear: parseInt(year),
                avgYield: yieldInfo.avgYield,
                crop: yieldInfo.crop,
                yieldPointCount: yieldInfo.pointCount
              });
            }
          });
        });
      } else {
        // SPECIFIC YEAR: Only use yield from that year
        samplesWithYield.forEach(sample => {
          const yieldInfo = sample.yieldCorrelations[yearFilter];
          if (yieldInfo && (cropFilter === 'all' || yieldInfo.crop === cropFilter)) {
            dataPoints.push({
              ...sample,
              yieldYear: parseInt(yearFilter),
              avgYield: yieldInfo.avgYield,
              crop: yieldInfo.crop,
              yieldPointCount: yieldInfo.pointCount
            });
          }
        });
      }
      return dataPoints;
    }

    function drawScatterPlot() {
      const canvas = document.getElementById('scatterCanvas');
      const ctx = canvas.getContext('2d');
      const nutrient = document.getElementById('scatterNutrientSelect').value;
      const dataPoints = getYieldDataPoints();

      // Filter for valid data
      const validPoints = dataPoints.filter(d => {
        const val = d[nutrient];
        if (val === undefined || val === null || val === '') return false;
        return isFinite(parseFloat(val));
      });

      // Clear canvas
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      if (validPoints.length < 3) {
        ctx.fillStyle = '#64748b';
        ctx.font = '14px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('Not enough data points', canvas.width / 2, canvas.height / 2);
        return;
      }

      // Get data ranges
      const xValues = validPoints.map(p => parseFloat(p[nutrient]));
      const yValues = validPoints.map(p => p.avgYield);
      const xMin = Math.min(...xValues);
      const xMax = Math.max(...xValues);
      const yMin = Math.min(...yValues);
      const yMax = Math.max(...yValues);

      // Padding for axes
      const padding = { left: 60, right: 30, top: 30, bottom: 50 };
      const plotWidth = canvas.width - padding.left - padding.right;
      const plotHeight = canvas.height - padding.top - padding.bottom;

      // Scale functions
      const xScale = (val) => padding.left + ((val - xMin) / (xMax - xMin || 1)) * plotWidth;
      const yScale = (val) => canvas.height - padding.bottom - ((val - yMin) / (yMax - yMin || 1)) * plotHeight;

      // Draw axes
      ctx.strokeStyle = '#cbd5e1';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding.left, padding.top);
      ctx.lineTo(padding.left, canvas.height - padding.bottom);
      ctx.lineTo(canvas.width - padding.right, canvas.height - padding.bottom);
      ctx.stroke();

      // Draw grid lines
      ctx.strokeStyle = '#f1f5f9';
      for (let i = 0; i <= 5; i++) {
        const y = padding.top + (i * plotHeight / 5);
        ctx.beginPath();
        ctx.moveTo(padding.left, y);
        ctx.lineTo(canvas.width - padding.right, y);
        ctx.stroke();
      }

      // Draw axis labels
      ctx.fillStyle = '#64748b';
      ctx.font = '11px system-ui';
      ctx.textAlign = 'center';

      // X-axis labels
      for (let i = 0; i <= 5; i++) {
        const val = xMin + (i * (xMax - xMin) / 5);
        const x = xScale(val);
        ctx.fillText(val.toFixed(1), x, canvas.height - padding.bottom + 20);
      }
      ctx.fillText(`${CONFIG.NUTRIENT_NAMES[nutrient] || nutrient}`, canvas.width / 2, canvas.height - 10);

      // Y-axis labels
      ctx.textAlign = 'right';
      for (let i = 0; i <= 5; i++) {
        const val = yMin + (i * (yMax - yMin) / 5);
        const y = yScale(val);
        ctx.fillText(val.toFixed(0), padding.left - 10, y + 4);
      }
      ctx.save();
      ctx.translate(15, canvas.height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.textAlign = 'center';
      ctx.fillText('Yield (bu/ac)', 0, 0);
      ctx.restore();

      // Calculate correlation for color
      const correlation = calculateCorrelation(xValues, yValues);
      const r = correlation ? correlation.r : 0;

      // Draw points
      validPoints.forEach(p => {
        const x = xScale(parseFloat(p[nutrient]));
        const y = yScale(p.avgYield);

        ctx.beginPath();
        ctx.arc(x, y, 5, 0, Math.PI * 2);
        ctx.fillStyle = r >= 0 ? 'rgba(34, 197, 94, 0.6)' : 'rgba(239, 68, 68, 0.6)';
        ctx.fill();
        ctx.strokeStyle = r >= 0 ? '#16a34a' : '#dc2626';
        ctx.lineWidth = 1;
        ctx.stroke();
      });

      // Draw trend line if significant correlation
      if (correlation && Math.abs(r) > 0.1) {
        const meanX = xValues.reduce((a, b) => a + b, 0) / xValues.length;
        const meanY = yValues.reduce((a, b) => a + b, 0) / yValues.length;
        const slope = xValues.reduce((sum, xi, i) => sum + (xi - meanX) * (yValues[i] - meanY), 0) /
                      xValues.reduce((sum, xi) => sum + (xi - meanX) ** 2, 0);
        const intercept = meanY - slope * meanX;

        const x1 = xMin;
        const x2 = xMax;
        const y1 = slope * x1 + intercept;
        const y2 = slope * x2 + intercept;

        ctx.strokeStyle = r >= 0 ? '#22c55e' : '#ef4444';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(xScale(x1), yScale(y1));
        ctx.lineTo(xScale(x2), yScale(y2));
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // Update stats
      const statsDiv = document.getElementById('scatterStats');
      statsDiv.innerHTML = `
        <strong>${CONFIG.NUTRIENT_NAMES[nutrient] || nutrient}:</strong>
        n=${validPoints.length} |
        r=${r.toFixed(3)} |
        R¬≤=${(r * r * 100).toFixed(1)}% |
        Range: ${xMin.toFixed(1)} - ${xMax.toFixed(1)} |
        Yield Range: ${yMin.toFixed(0)} - ${yMax.toFixed(0)} bu/ac
        ${r >= 0 ? '<span style="color: #16a34a;">‚Üó Positive correlation</span>' : '<span style="color: #dc2626;">‚Üò Negative correlation</span>'}
      `;
    }

    function generateDebugReport() {
      const debugDiv = document.getElementById('debugContent');
      const dataPoints = getYieldDataPoints();
      let report = '';

      // 1. HIGH vs LOW P SAMPLES
      report += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n';
      report += '1. RAW DATA: HIGH P vs LOW P SAMPLES\n';
      report += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n';

      const samplesWithP = dataPoints.filter(d => d.P !== undefined && d.P !== null && d.P !== '' && isFinite(parseFloat(d.P)));
      if (samplesWithP.length > 0) {
        const sortedByP = [...samplesWithP].sort((a, b) => parseFloat(b.P) - parseFloat(a.P));

        report += 'üìà TOP 5 HIGH PHOSPHORUS SAMPLES:\n';
        report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
        sortedByP.slice(0, 5).forEach((s, i) => {
          report += `  ${i + 1}. P = ${parseFloat(s.P).toFixed(1)} ppm ‚Üí Yield = ${s.avgYield.toFixed(1)} bu/ac\n`;
          report += `     Field: ${s.field || 'Unknown'} | GPS: (${s.lat.toFixed(5)}, ${s.lon.toFixed(5)})\n`;
          report += `     Crop: ${s.crop} | Year: ${s.yieldYear} | Yield Points: ${s.yieldPointCount}\n\n`;
        });

        report += '\nüìâ BOTTOM 5 LOW PHOSPHORUS SAMPLES:\n';
        report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
        sortedByP.slice(-5).reverse().forEach((s, i) => {
          report += `  ${i + 1}. P = ${parseFloat(s.P).toFixed(1)} ppm ‚Üí Yield = ${s.avgYield.toFixed(1)} bu/ac\n`;
          report += `     Field: ${s.field || 'Unknown'} | GPS: (${s.lat.toFixed(5)}, ${s.lon.toFixed(5)})\n`;
          report += `     Crop: ${s.crop} | Year: ${s.yieldYear} | Yield Points: ${s.yieldPointCount}\n\n`;
        });

        // Calculate average yield for high vs low P
        const highPAvg = sortedByP.slice(0, Math.ceil(sortedByP.length / 4))
          .reduce((sum, s) => sum + s.avgYield, 0) / Math.ceil(sortedByP.length / 4);
        const lowPAvg = sortedByP.slice(-Math.ceil(sortedByP.length / 4))
          .reduce((sum, s) => sum + s.avgYield, 0) / Math.ceil(sortedByP.length / 4);

        report += '\nüìä QUARTILE COMPARISON:\n';
        report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
        report += `  Top 25% P samples (n=${Math.ceil(sortedByP.length / 4)}): Avg Yield = ${highPAvg.toFixed(1)} bu/ac\n`;
        report += `  Bottom 25% P samples (n=${Math.ceil(sortedByP.length / 4)}): Avg Yield = ${lowPAvg.toFixed(1)} bu/ac\n`;
        report += `  Difference: ${(highPAvg - lowPAvg).toFixed(1)} bu/ac\n`;
        report += `  ${highPAvg > lowPAvg ? '‚úì HIGH P ‚Üí HIGHER YIELD (expected)' : '‚ö† HIGH P ‚Üí LOWER YIELD (unusual!)'}\n`;
      } else {
        report += '  ‚ö† No samples with phosphorus data found\n';
      }

      // 2. CORRELATION FORMULA VERIFICATION
      report += '\n\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n';
      report += '2. CORRELATION FORMULA VERIFICATION (Pearson r)\n';
      report += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n';

      if (samplesWithP.length >= 5) {
        const x = samplesWithP.map(s => parseFloat(s.P));
        const y = samplesWithP.map(s => s.avgYield);
        const n = x.length;

        const sumX = x.reduce((a, b) => a + b, 0);
        const sumY = y.reduce((a, b) => a + b, 0);
        const sumXY = x.reduce((total, xi, i) => total + xi * y[i], 0);
        const sumX2 = x.reduce((total, xi) => total + xi * xi, 0);
        const sumY2 = y.reduce((total, yi) => total + yi * yi, 0);

        const numerator = n * sumXY - sumX * sumY;
        const denomX = n * sumX2 - sumX * sumX;
        const denomY = n * sumY2 - sumY * sumY;
        const denominator = Math.sqrt(denomX * denomY);
        const r = numerator / denominator;

        report += 'Formula: r = Œ£((x - xÃÑ)(y - »≥)) / ‚àö(Œ£(x - xÃÑ)¬≤ √ó Œ£(y - »≥)¬≤)\n';
        report += 'Equivalent: r = (n√óŒ£xy - Œ£x√óŒ£y) / ‚àö((n√óŒ£x¬≤ - (Œ£x)¬≤) √ó (n√óŒ£y¬≤ - (Œ£y)¬≤))\n\n';
        report += 'Step-by-step for PHOSPHORUS:\n';
        report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
        report += `  n (sample count) = ${n}\n`;
        report += `  Œ£x (sum of P values) = ${sumX.toFixed(2)}\n`;
        report += `  Œ£y (sum of yields) = ${sumY.toFixed(2)}\n`;
        report += `  Œ£xy (sum of P√óyield) = ${sumXY.toFixed(2)}\n`;
        report += `  Œ£x¬≤ (sum of P¬≤) = ${sumX2.toFixed(2)}\n`;
        report += `  Œ£y¬≤ (sum of yield¬≤) = ${sumY2.toFixed(2)}\n\n`;
        report += `  Mean P (xÃÑ) = ${(sumX / n).toFixed(2)}\n`;
        report += `  Mean Yield (»≥) = ${(sumY / n).toFixed(2)}\n\n`;
        report += `  Numerator = n√óŒ£xy - Œ£x√óŒ£y = ${n}√ó${sumXY.toFixed(2)} - ${sumX.toFixed(2)}√ó${sumY.toFixed(2)} = ${numerator.toFixed(2)}\n`;
        report += `  Denom Part 1 = n√óŒ£x¬≤ - (Œ£x)¬≤ = ${n}√ó${sumX2.toFixed(2)} - ${sumX.toFixed(2)}¬≤ = ${denomX.toFixed(2)}\n`;
        report += `  Denom Part 2 = n√óŒ£y¬≤ - (Œ£y)¬≤ = ${n}√ó${sumY2.toFixed(2)} - ${sumY.toFixed(2)}¬≤ = ${denomY.toFixed(2)}\n`;
        report += `  Denominator = ‚àö(${denomX.toFixed(2)} √ó ${denomY.toFixed(2)}) = ${denominator.toFixed(2)}\n\n`;
        report += `  r = ${numerator.toFixed(2)} / ${denominator.toFixed(2)} = ${r.toFixed(4)}\n`;
        report += `  R¬≤ = ${(r * r * 100).toFixed(2)}%\n\n`;
        report += `  ‚úì FORMULA CHECK: ${Math.abs(r - calculateCorrelation(x, y).r) < 0.0001 ? 'PASSED - matches internal calculation' : 'MISMATCH - possible bug!'}\n`;
      }

      // 3. DATA ALIGNMENT VERIFICATION
      report += '\n\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n';
      report += '3. DATA ALIGNMENT: SAMPLE-YIELD GPS MATCHING\n';
      report += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n';

      report += 'Sample 5 random sample-yield pairs with GPS coordinates:\n';
      report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
      const randomSamples = [...dataPoints].sort(() => Math.random() - 0.5).slice(0, 5);
      randomSamples.forEach((s, i) => {
        report += `\n${i + 1}. SOIL SAMPLE:\n`;
        report += `   GPS: (${s.lat.toFixed(6)}, ${s.lon.toFixed(6)})\n`;
        report += `   Field: ${s.field} | Sample Year: ${s.year || 'N/A'}\n`;
        report += `   P: ${s.P || 'N/A'} | K: ${s.K || 'N/A'} | pH: ${s.pH || 'N/A'} | OM: ${s.OM || 'N/A'}\n`;
        report += `   ‚Üí MATCHED YIELD: ${s.avgYield.toFixed(1)} bu/ac (${s.crop}, ${s.yieldYear})\n`;
        report += `   ‚Üí Based on ${s.yieldPointCount} yield points within search radius\n`;
      });

      // 4. DATA QUALITY CHECKS
      report += '\n\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n';
      report += '4. DATA QUALITY CHECKS\n';
      report += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n';

      // Check each nutrient for issues
      const visibleNutrients = getVisibleNutrients();
      report += 'NUTRIENT DATA RANGES AND ISSUES:\n';
      report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';

      visibleNutrients.forEach(nutrient => {
        const validData = dataPoints.filter(d => {
          const val = d[nutrient];
          return val !== undefined && val !== null && val !== '' && isFinite(parseFloat(val));
        });

        if (validData.length === 0) {
          report += `  ${nutrient}: No valid data\n`;
          return;
        }

        const values = validData.map(d => parseFloat(d[nutrient]));
        const min = Math.min(...values);
        const max = Math.max(...values);
        const mean = values.reduce((a, b) => a + b, 0) / values.length;
        const sorted = [...values].sort((a, b) => a - b);
        const median = sorted[Math.floor(sorted.length / 2)];

        // Check for zeros
        const zeroCount = values.filter(v => v === 0).length;
        const zeroPct = (zeroCount / values.length * 100).toFixed(1);

        // Check for outliers (> 3 std dev)
        const stdDev = Math.sqrt(values.reduce((sum, v) => sum + (v - mean) ** 2, 0) / values.length);
        const outliers = values.filter(v => Math.abs(v - mean) > 3 * stdDev).length;

        report += `\n  ${CONFIG.NUTRIENT_NAMES[nutrient] || nutrient}:\n`;
        report += `    Range: ${min.toFixed(2)} - ${max.toFixed(2)} (spread: ${(max - min).toFixed(2)})\n`;
        report += `    Mean: ${mean.toFixed(2)} | Median: ${median.toFixed(2)}\n`;
        report += `    Valid samples: ${validData.length} / ${dataPoints.length}\n`;
        if (zeroCount > 0) {
          report += `    ‚ö† ZEROS: ${zeroCount} samples (${zeroPct}%) have value = 0\n`;
        }
        if (outliers > 0) {
          report += `    ‚ö† OUTLIERS: ${outliers} samples > 3 std devs from mean\n`;
        }
      });

      // Yield distribution
      report += '\n\nYIELD DISTRIBUTION:\n';
      report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
      const yields = dataPoints.map(d => d.avgYield);
      const yMin = Math.min(...yields);
      const yMax = Math.max(...yields);
      const yMean = yields.reduce((a, b) => a + b, 0) / yields.length;
      const ySorted = [...yields].sort((a, b) => a - b);
      const yMedian = ySorted[Math.floor(ySorted.length / 2)];
      const yStdDev = Math.sqrt(yields.reduce((sum, v) => sum + (v - yMean) ** 2, 0) / yields.length);

      report += `  Range: ${yMin.toFixed(1)} - ${yMax.toFixed(1)} bu/ac\n`;
      report += `  Mean: ${yMean.toFixed(1)} bu/ac | Median: ${yMedian.toFixed(1)} bu/ac\n`;
      report += `  Std Dev: ${yStdDev.toFixed(1)} bu/ac\n`;
      report += `  Total samples: ${dataPoints.length}\n`;

      // Check for suspiciously uniform yield
      const yieldVariation = yStdDev / yMean * 100;
      if (yieldVariation < 5) {
        report += `  ‚ö† LOW VARIATION: Yield varies only ${yieldVariation.toFixed(1)}% - might indicate data issue\n`;
      }

      // 5. INTERPRETATION
      report += '\n\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n';
      report += '5. INTERPRETATION NOTES\n';
      report += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n';

      report += 'Reasons correlations might appear negative when they "shouldn\'t be":\n';
      report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
      report += '  1. Luxury consumption: Crop yields plateau but soil nutrient keeps increasing\n';
      report += '  2. Confounding factors: High P fields may have other limiting factors\n';
      report += '  3. Soil type variation: Lighter soils may show high P but lower yields\n';
      report += '  4. Management zones: High-input areas may have drainage/compaction issues\n';
      report += '  5. Timing: Soil samples from different year than yield data\n';
      report += '  6. Spatial mismatch: Check that yield points are actually within sample zones\n';
      report += '  7. Data errors: Zero values, outliers, or import issues\n\n';

      report += 'What to verify:\n';
      report += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
      report += '  ‚úì Look at scatter plot - does the trend visually match the correlation sign?\n';
      report += '  ‚úì Check high vs low quartile yields above - do they make sense?\n';
      report += '  ‚úì Verify GPS coordinates are in the right locations\n';
      report += '  ‚úì Check for zeros or outliers pulling the correlation\n';
      report += '  ‚úì Filter by single field to reduce confounding factors\n';

      debugDiv.textContent = report;
    }

    // ========== EXPORT FUNCTIONS ==========
    function getReportStyles() {
      return `
        * { box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif; padding: 20px; font-size: 12px; color: #1e293b; line-height: 1.5; }
        h1 { color: #1e293b; border-bottom: 3px solid #3b82f6; padding-bottom: 12px; margin-bottom: 20px; font-size: 24px; }
        h2 { color: #334155; margin-top: 24px; margin-bottom: 16px; font-size: 18px; }
        h3 { color: #475569; margin: 0 0 8px 0; font-size: 16px; }
        p { color: #64748b; margin: 0 0 16px 0; }
        .summary { display: flex; gap: 20px; margin: 20px 0; flex-wrap: wrap; }
        .summary-box { background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%); padding: 16px 24px; border-radius: 10px; text-align: center; min-width: 120px; border: 1px solid #cbd5e1; }
        .summary-box .number { font-size: 28px; font-weight: bold; color: #3b82f6; }
        .summary-box .label { color: #64748b; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; margin-top: 4px; }
        table { width: 100%; border-collapse: collapse; margin: 16px 0; font-size: 11px; }
        th { background: #1e293b; color: white; padding: 10px 8px; text-align: left; font-weight: 600; }
        td { padding: 8px; border-bottom: 1px solid #e2e8f0; }
        tr:nth-child(even) { background: #f8fafc; }
        .positive { color: #16a34a; } .negative { color: #dc2626; }
        .card { background: #f8fafc; border-left: 4px solid #3b82f6; padding: 12px 16px; margin: 12px 0; border-radius: 6px; }
        .card.positive { border-left-color: #22c55e; background: #f0fdf4; }
        .card.negative { border-left-color: #ef4444; background: #fef2f2; }

        /* Trend Cards for Field Trends Report - PDF optimized */
        .trend-card { background: #fff; border: 2px solid #e2e8f0; border-radius: 10px; padding: 20px; margin-bottom: 20px; page-break-inside: avoid; box-shadow: 0 1px 4px rgba(0,0,0,0.08); }
        .trend-card.positive { background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%); border-color: #22c55e; }
        .trend-card.negative { background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%); border-color: #ef4444; }
        .trend-card.neutral { background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%); border-color: #94a3b8; }
        .trend-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid rgba(0,0,0,0.1); }
        .trend-title { font-size: 18px; font-weight: 700; color: #1e293b; margin: 0; }
        .trend-pct { font-size: 22px; font-weight: 700; text-align: right; }
        .trend-sub { font-size: 11px; color: #64748b; font-weight: 500; }

        /* Stacked layout for PDF - data table on top, full-width graph below */
        .trend-content { display: flex; flex-direction: column; gap: 16px; }
        .trend-values { background: rgba(255,255,255,0.8); border-radius: 6px; padding: 10px; width: 100%; }
        .trend-values-row { display: flex; flex-wrap: wrap; gap: 8px; }
        .trend-row { display: inline-flex; justify-content: space-between; gap: 8px; padding: 6px 12px; font-size: 11px; border-radius: 4px; min-width: 120px; }
        .trend-row.alt { background: rgba(0,0,0,0.04); }
        .trend-year { font-weight: 600; color: #475569; }
        .trend-value { font-weight: 700; color: #1e293b; }
        .trend-graph { width: 100%; padding: 10px; background: rgba(255,255,255,0.5); border-radius: 8px; }
        .trend-graph svg { width: 100%; height: auto; min-height: 200px; display: block; }
        .trend-graph.large svg { min-height: 240px; }
        .trend-graph.xlarge svg { min-height: 300px; }

        /* Nutrient cards for Year Comparison */
        .nutrient-card { background: #fff; border: 2px solid #e2e8f0; border-radius: 8px; padding: 12px; margin-bottom: 12px; }
        .nutrient-card.positive { background: #f0fdf4; border-color: #22c55e; }
        .nutrient-card.negative { background: #fef2f2; border-color: #ef4444; }
        .nutrient-header { display: flex; justify-content: space-between; margin-bottom: 8px; }
        .nutrient-name { font-weight: 700; font-size: 14px; }
        .nutrient-pct { font-weight: 700; font-size: 14px; }
        .nutrient-stats { display: flex; gap: 12px; margin-bottom: 8px; }
        .stat-box { text-align: center; padding: 6px 10px; background: rgba(0,0,0,0.03); border-radius: 4px; }
        .stat-box .label { font-size: 9px; color: #64748b; text-transform: uppercase; }
        .stat-box .value { font-size: 16px; font-weight: 700; color: #1e293b; }

        .footer { margin-top: 40px; padding-top: 16px; border-top: 1px solid #e2e8f0; color: #94a3b8; font-size: 10px; text-align: center; }
        @media print {
          body { padding: 10px; }
          .trend-card, .nutrient-card { page-break-inside: avoid; }
          h1 { page-break-after: avoid; }
          .trend-graph { width: 100%; }
          .trend-graph svg { min-height: 220px; width: 100%; }
        }
      `;
    }

    function exportYearComparison() {
      const y1 = document.getElementById('year1Select').value;
      const y2 = document.getElementById('year2Select').value;
      if (!y1 || !y2) { showStatus('Select both years first', false); return; }

      const operationName = localStorage.getItem('operationName') || 'Soil Analysis';
      const comparisonData = document.getElementById('comparisonGrid').innerHTML;

      const printWindow = window.open('', '_blank');
      printWindow.document.write(`<!DOCTYPE html><html><head><title>${operationName} - Year Comparison</title><style>${getReportStyles()}</style></head><body>
        <h1>${operationName} - Year-Over-Year Comparison</h1>
        <p>Generated: ${new Date().toLocaleString()}</p>
        <div class="summary">
          <div class="summary-box"><div class="number">${y1}</div><div class="label">From Year</div></div>
          <div class="summary-box"><div class="number">${y2}</div><div class="label">To Year</div></div>
          <div class="summary-box"><div class="number">${selectedComparisonFields.size}</div><div class="label">Fields Compared</div></div>
        </div>
        <h2>Nutrient Changes</h2>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 10px;">${comparisonData}</div>
        <div class="footer">Soil Sample Analysis App</div>
      </body></html>`);
      printWindow.document.close();
      printWindow.print();
    }

    function exportFieldTrends() {
      const field = document.getElementById('historyFieldSelect').value;
      if (!field) { showStatus('Select a field first', false); return; }

      const operationName = localStorage.getItem('operationName') || 'Soil Analysis';
      const trendData = document.getElementById('historyContent').innerHTML;

      const printWindow = window.open('', '_blank');
      printWindow.document.write(`<!DOCTYPE html><html><head><title>${operationName} - Field Trends</title><style>${getReportStyles()}</style></head><body>
        <h1>${operationName} - Field Trends: ${field}</h1>
        <p>Generated: ${new Date().toLocaleString()}</p>
        <h2>Historical Nutrient Trends</h2>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 10px;">${trendData}</div>
        <div class="footer">Soil Sample Analysis App</div>
      </body></html>`);
      printWindow.document.close();
      printWindow.print();
    }

    function exportFieldRankings() {
      const nutrient = document.getElementById('rankingAttrSelect').value;
      const year = document.getElementById('rankingYearSelect').value;
      const operationName = localStorage.getItem('operationName') || 'Soil Analysis';
      const rankingData = document.getElementById('rankingsContent').innerHTML;

      const printWindow = window.open('', '_blank');
      printWindow.document.write(`<!DOCTYPE html><html><head><title>${operationName} - Field Rankings</title><style>${getReportStyles()}</style></head><body>
        <h1>${operationName} - Field Rankings</h1>
        <p>Generated: ${new Date().toLocaleString()}</p>
        <div class="summary">
          <div class="summary-box"><div class="number">${CONFIG.NUTRIENT_NAMES[nutrient] || nutrient}</div><div class="label">Nutrient</div></div>
          <div class="summary-box"><div class="number">${year === 'most_recent' ? 'Most Recent' : year}</div><div class="label">Year</div></div>
        </div>
        <h2>Rankings</h2>
        ${rankingData}
        <div class="footer">Soil Sample Analysis App</div>
      </body></html>`);
      printWindow.document.close();
      printWindow.print();
    }

    function exportYieldCorrelation() {
      const crop = document.getElementById('yieldCropSelect').value;
      const year = document.getElementById('yieldYearSelect').value;
      const field = document.getElementById('yieldFieldSelect').value;
      const operationName = localStorage.getItem('operationName') || 'Soil Analysis';
      const yieldData = document.getElementById('yieldContent').innerHTML;

      // Format year label
      let yearLabel = year;
      if (year === 'avg') yearLabel = 'All (Averaged)';
      else if (year === 'combined') yearLabel = 'All (Combined)';

      const printWindow = window.open('', '_blank');
      printWindow.document.write(`<!DOCTYPE html><html><head><title>${operationName} - Yield Correlation</title><style>${getReportStyles()}</style></head><body>
        <h1>${operationName} - Yield Correlation Analysis</h1>
        <p>Generated: ${new Date().toLocaleString()}</p>
        <div class="summary">
          <div class="summary-box"><div class="number">${crop === 'all' ? 'All' : crop}</div><div class="label">Crop</div></div>
          <div class="summary-box"><div class="number">${yearLabel}</div><div class="label">Yield Year</div></div>
          <div class="summary-box"><div class="number">${field === 'all' ? 'All' : field}</div><div class="label">Field</div></div>
        </div>
        ${yieldData}
        <div class="footer">Soil Sample Analysis App</div>
      </body></html>`);
      printWindow.document.close();
      printWindow.print();
    }

    function showStatus(msg, ok) {
      const el = document.getElementById('statusMessage');
      el.textContent = msg;
      el.style.display = 'block';
      el.style.background = ok ? '#dcfce7' : '#fee2e2';
      el.style.color = ok ? '#166534' : '#991b1b';
      setTimeout(() => el.style.display = 'none', 4000);
    }

    function updateBackupFooter() {
      const backupTime = localStorage.getItem('soilDataBackupTime');
      const footer = document.getElementById('backupFooter');
      if (backupTime) {
        const date = new Date(parseInt(backupTime));
        footer.textContent = 'Last backup: ' + date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      } else {
        footer.textContent = 'No backup yet';
      }
    }
  </script>
  <div class="backup-footer" id="backupFooter">No backup yet</div>
</body>
</html>
