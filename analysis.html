<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Soil Sample Analysis - Analysis</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f8fafc; color: #1e293b; min-height: 100vh; }
    .top-bar { background: linear-gradient(135deg, #1e293b 0%, #334155 100%); color: white; padding: 1rem 1.5rem; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem; }
    .top-bar h1 { font-size: 1.5rem; font-weight: 700; }
    .top-bar p { font-size: 0.875rem; opacity: 0.8; margin-top: 0.25rem; }
    .nav-links { display: flex; gap: 0.5rem; flex-wrap: wrap; }
    .nav-link { padding: 0.5rem 1rem; background: rgba(255,255,255,0.1); color: white; text-decoration: none; border-radius: 0.375rem; font-size: 0.875rem; font-weight: 500; }
    .nav-link:hover { background: rgba(255,255,255,0.2); }
    .nav-link.active { background: #3b82f6; }
    .auth-section { display: flex; align-items: center; gap: 1rem; }
    .user-info { font-size: 0.875rem; color: rgba(255,255,255,0.9); }
    .sign-in-btn { padding: 0.5rem 1rem; background: #4285f4; color: white; border: none; border-radius: 0.375rem; font-size: 0.875rem; cursor: pointer; }
    .sign-in-btn.signed-in { background: #22c55e; }
    
    .analysis-container { max-width: 1400px; margin: 0 auto; padding: 1.5rem; }
    
    /* Tabs */
    .tabs { display: flex; gap: 0.5rem; margin-bottom: 1.5rem; flex-wrap: wrap; }
    .tab { padding: 0.75rem 1.25rem; background: white; border: 1px solid #cbd5e1; border-radius: 0.5rem; cursor: pointer; font-weight: 500; font-size: 0.875rem; }
    .tab:hover { background: #f1f5f9; }
    .tab.active { background: #3b82f6; color: white; border-color: #3b82f6; }
    
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    
    /* Controls */
    .controls-bar { background: white; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1.5rem; box-shadow: 0 1px 3px rgba(0,0,0,0.1); display: flex; gap: 1.5rem; flex-wrap: wrap; align-items: flex-end; }
    .control-group { display: flex; flex-direction: column; gap: 0.25rem; }
    .control-group label { font-size: 0.75rem; font-weight: 600; color: #64748b; text-transform: uppercase; }
    .control-group select { padding: 0.5rem 0.75rem; font-size: 0.875rem; border: 1px solid #cbd5e1; border-radius: 0.375rem; min-width: 160px; }
    .export-btn { padding: 0.5rem 1rem; background: #8b5cf6; color: white; border: none; border-radius: 0.375rem; font-size: 0.875rem; font-weight: 500; cursor: pointer; margin-left: auto; }
    .export-btn:hover { background: #7c3aed; }

    /* Nutrient Grid for Year Comparison */
    .nutrient-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1rem; }
    
    .nutrient-card { background: white; border-radius: 0.5rem; padding: 1rem; box-shadow: 0 1px 3px rgba(0,0,0,0.1); border-left: 4px solid #94a3b8; }
    .nutrient-card.positive { border-left-color: #22c55e; background: linear-gradient(to right, #f0fdf4, white); }
    .nutrient-card.negative { border-left-color: #ef4444; background: linear-gradient(to right, #fef2f2, white); }
    .nutrient-card.no-comparison { border-left-color: #f59e0b; background: linear-gradient(to right, #fffbeb, white); }
    
    .nutrient-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem; }
    .nutrient-name { font-size: 1rem; font-weight: 700; color: #1e293b; }
    .nutrient-pct { font-size: 1.125rem; font-weight: 700; }
    .nutrient-pct.positive { color: #22c55e; }
    .nutrient-pct.negative { color: #ef4444; }
    .nutrient-pct.neutral { color: #64748b; }
    
    .nutrient-stats { display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem; margin-bottom: 0.75rem; }
    .stat-box { background: #f8fafc; border-radius: 0.375rem; padding: 0.5rem; text-align: center; }
    .stat-box .label { font-size: 0.625rem; font-weight: 600; color: #64748b; text-transform: uppercase; }
    .stat-box .value { font-size: 0.9375rem; font-weight: 700; color: #1e293b; }
    
    .year-comparison { display: flex; justify-content: space-between; align-items: center; background: #f1f5f9; border-radius: 0.375rem; padding: 0.5rem 0.75rem; margin-bottom: 0.5rem; }
    .year-val { text-align: center; }
    .year-val .yr { font-size: 0.625rem; font-weight: 600; color: #64748b; }
    .year-val .num { font-size: 1.125rem; font-weight: 700; color: #1e293b; }
    .year-arrow { font-size: 1.25rem; color: #94a3b8; }
    
    .change-row { display: flex; justify-content: center; gap: 1.5rem; font-size: 0.75rem; color: #64748b; }
    .change-row .val { font-weight: 600; }
    .change-row .val.positive { color: #22c55e; }
    .change-row .val.negative { color: #ef4444; }
    
    /* Historical Trends */
    .trend-card { background: white; border: 2px solid; border-radius: 0.75rem; padding: 1.25rem; margin-bottom: 1.25rem; box-shadow: 0 2px 8px rgba(0,0,0,0.06); }
    .trend-card.positive { background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%); border-color: #22c55e; }
    .trend-card.negative { background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%); border-color: #ef4444; }
    .trend-card.neutral { background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%); border-color: #94a3b8; }
    .trend-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 1rem; padding-bottom: 0.75rem; border-bottom: 1px solid rgba(0,0,0,0.08); }
    .trend-title { font-size: 1.25rem; font-weight: 700; color: #1e293b; }
    .trend-pct { font-size: 1.5rem; font-weight: 700; text-align: right; }
    .trend-sub { font-size: 0.75rem; color: #64748b; font-weight: 500; }
    .trend-content { display: flex; flex-wrap: nowrap; gap: 1rem; align-items: stretch; }
    .trend-values { background: rgba(255,255,255,0.7); border-radius: 0.5rem; padding: 0.5rem; min-width: 200px; flex: 0 0 auto; max-height: 400px; overflow-y: auto; }
    .trend-row { display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0.75rem; font-size: 0.875rem; border-radius: 0.25rem; }
    .trend-row.alt { background: rgba(0,0,0,0.03); }
    .trend-year { font-weight: 600; color: #475569; min-width: 50px; }
    .trend-value { font-weight: 700; color: #1e293b; }
    .trend-graph { flex: 1 1 auto; background: rgba(255,255,255,0.5); border-radius: 0.5rem; padding: 0.75rem; min-width: 400px; }
    .trend-graph svg { display: block; width: 100%; height: auto; min-height: 180px; }
    .trend-graph.large svg { min-height: 220px; }
    .trend-graph.xlarge svg { min-height: 280px; }
    @media (max-width: 900px) {
      .trend-content { flex-direction: column; }
      .trend-graph { min-width: 100%; width: 100%; }
      .trend-graph svg { min-height: 200px; }
    }
    
    /* Field Rankings */
    .rankings-table { width: 100%; border-collapse: collapse; background: white; border-radius: 0.5rem; overflow: hidden; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
    .rankings-table th, .rankings-table td { padding: 0.75rem 1rem; text-align: left; border-bottom: 1px solid #e2e8f0; }
    .rankings-table th { background: #f8fafc; font-weight: 600; color: #475569; font-size: 0.75rem; text-transform: uppercase; }
    .rankings-table th.sortable-header:hover { background: #e2e8f0; }
    .rankings-table tr:hover { background: #f8fafc; }
    .rankings-table .rank { font-weight: 700; color: #64748b; width: 60px; }
    .rankings-table .field { font-weight: 500; }
    .rankings-table .value { font-weight: 700; }
    .rankings-table .high { color: #22c55e; }
    .rankings-table .low { color: #ef4444; }
    
    .no-data { background: #fef3c7; border: 2px solid #f59e0b; border-radius: 0.5rem; padding: 2rem; text-align: center; color: #92400e; }
    #statusMessage { display: none; position: fixed; top: 1rem; left: 50%; transform: translateX(-50%); z-index: 9999; padding: 0.75rem 1rem; border-radius: 0.375rem; box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
    
    @media (max-width: 639px) {
      .nutrient-grid { grid-template-columns: 1fr; }
      .controls-bar { flex-direction: column; align-items: stretch; }
      .tabs { flex-direction: column; }
      .tab { text-align: center; }
    }
    .backup-footer { position: fixed; bottom: 0; left: 0; right: 0; background: #f8fafc; border-top: 1px solid #e2e8f0; padding: 0.25rem 1rem; font-size: 0.7rem; color: #64748b; text-align: center; z-index: 900; }
  </style>
</head>
<body>
  <div class="top-bar">
    <div>
      <h1>üìä Soil Analysis</h1>
      <p>Trends, Comparisons & Rankings</p>
    </div>
    <nav class="nav-links">
      <a href="index.html" class="nav-link">üìç Map</a>
      <a href="analysis.html" class="nav-link active">üìä Analysis</a>
      <a href="import.html" class="nav-link">üìÅ Import</a>
      <a href="settings.html" class="nav-link">‚öôÔ∏è Settings</a>
    </nav>
    <div class="auth-section">
      <span class="user-info" id="userInfo"></span>
      <button class="sign-in-btn" id="authBtn" onclick="handleAuth()">Sign In to Edit</button>
    </div>
  </div>
  
  <div class="analysis-container">
    <div class="tabs">
      <div class="tab active" data-tab="history">üìà Field Trends</div>
      <div class="tab" data-tab="comparison">üìä Year-Over-Year</div>
      <div class="tab" data-tab="rankings">üèÜ Field Rankings</div>
      <div class="tab" data-tab="yield">üåæ Yield Correlation</div>
      <div class="tab" data-tab="spatial">üó∫Ô∏è Spatial Change</div>
    </div>
    
    <!-- Tab: Year Comparison (Operation-wide) -->
    <div id="comparison" class="tab-content">
      <div class="controls-bar">
        <div class="control-group">
          <label>From Year</label>
          <select id="year1Select"></select>
        </div>
        <div class="control-group">
          <label>To Year</label>
          <select id="year2Select"></select>
        </div>
        <button onclick="exportYearComparison()" class="export-btn">üìÑ Export Report</button>
      </div>
      
      <!-- Year Stats Section -->
      <div id="yearStats" style="display: flex; gap: 1rem; margin-bottom: 1rem; flex-wrap: wrap;">
        <div id="fromYearStats" style="flex: 1; min-width: 250px; background: #f8fafc; border: 2px solid #cbd5e1; border-radius: 0.5rem; padding: 1rem;">
          <h4 style="margin: 0 0 0.5rem 0; color: #64748b; font-size: 0.875rem;">From Year Stats</h4>
          <div id="fromYearInfo"></div>
        </div>
        <div id="toYearStats" style="flex: 1; min-width: 250px; background: #f0fdf4; border: 2px solid #22c55e; border-radius: 0.5rem; padding: 1rem;">
          <h4 style="margin: 0 0 0.5rem 0; color: #166534; font-size: 0.875rem;">To Year Stats</h4>
          <div id="toYearInfo"></div>
        </div>
      </div>
      
      <!-- Field Selection & Mismatch Warning -->
      <div id="fieldSelectionSection" style="background: white; border: 2px solid #e2e8f0; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1.5rem;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
          <h4 style="margin: 0; color: #475569; font-size: 0.875rem;">üìã Fields Included in Comparison</h4>
          <div>
            <button onclick="selectMatchingComparisonFields()" style="padding: 0.25rem 0.5rem; font-size: 0.75rem; border: 1px solid #cbd5e1; border-radius: 0.25rem; background: white; cursor: pointer; margin-right: 0.25rem;">Select Matching</button>
            <button onclick="selectAllComparisonFields()" style="padding: 0.25rem 0.5rem; font-size: 0.75rem; border: 1px solid #cbd5e1; border-radius: 0.25rem; background: white; cursor: pointer;">Select All</button>
          </div>
        </div>
        <div id="fieldCheckboxes" style="display: flex; flex-wrap: wrap; gap: 0.5rem;"></div>
        <div id="fieldMismatchWarning" style="margin-top: 0.75rem;"></div>
      </div>
      
      <div id="comparisonGrid" class="nutrient-grid"></div>
    </div>
    
    <!-- Tab: Historical Field Trends -->
    <div id="history" class="tab-content active">
      <div class="controls-bar">
        <div class="control-group">
          <label>Select Field</label>
          <select id="historyFieldSelect"><option value="">Select a field...</option></select>
        </div>
        <button onclick="exportFieldTrends()" class="export-btn">üìÑ Export Report</button>
      </div>
      <div id="historyContent"></div>
    </div>

    <!-- Tab 3: Field Rankings -->
    <div id="rankings" class="tab-content">
      <div class="controls-bar">
        <div class="control-group">
          <label>Nutrient</label>
          <select id="rankingAttrSelect"></select>
        </div>
        <div class="control-group">
          <label>Year</label>
          <select id="rankingYearSelect"></select>
        </div>
        <button onclick="exportFieldRankings()" class="export-btn">üìÑ Export Report</button>
      </div>
      <div id="rankingsContent"></div>
    </div>

    <!-- Tab 4: Yield Correlation -->
    <div id="yield" class="tab-content">
      <div class="controls-bar">
        <div class="control-group">
          <label>Crop</label>
          <select id="yieldCropSelect">
            <option value="corn">üåΩ Corn</option>
            <option value="amylose">üçö Amylose</option>
          </select>
        </div>
        <div class="control-group">
          <label>Yield Year</label>
          <select id="yieldYearSelect"></select>
        </div>
        <div class="control-group">
          <label>Soil Sample Year</label>
          <select id="soilYearSelect">
            <option value="recent">Most Recent</option>
          </select>
        </div>
        <div class="control-group">
          <label>Field</label>
          <select id="yieldFieldSelect">
            <option value="all">All Fields</option>
          </select>
        </div>
        <button onclick="exportYieldCorrelation()" class="export-btn">üìÑ Export Report</button>
      </div>
      <div id="yieldContent">
        <div class="no-data">No yield data available. Import yield maps on the Import page to see correlations.</div>
      </div>

      <!-- Scatter Plot Section -->
      <div id="scatterSection" style="margin-top: 1.5rem; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 0.5rem; padding: 1rem;">
        <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem; margin-bottom: 1rem;">
          <div style="display: flex; align-items: center; gap: 1rem;">
            <h3 id="scatterTitle" style="margin: 0; color: #1e293b;">Scatter Plot: Nutrient vs Yield</h3>
            <button onclick="toggleScatterAxes()" id="swapAxesBtn" style="padding: 0.375rem 0.75rem; border-radius: 0.375rem; border: 1px solid #3b82f6; background: #eff6ff; color: #1d4ed8; font-size: 0.8rem; cursor: pointer; display: flex; align-items: center; gap: 0.25rem;">
              <span style="font-size: 1rem;">‚áÑ</span> Swap Axes
            </button>
          </div>
          <div style="display: flex; gap: 1rem; align-items: center; flex-wrap: wrap;">
            <div>
              <label style="margin-right: 0.5rem;">Nutrient:</label>
              <select id="scatterNutrientSelect" onchange="drawScatterPlot()" style="padding: 0.375rem 0.75rem; border-radius: 0.375rem; border: 1px solid #cbd5e1;"></select>
            </div>
            <div style="display: flex; align-items: center; gap: 0.5rem;">
              <label>Yield Threshold:</label>
              <input type="range" id="yieldThresholdSlider" min="100" max="400" value="200" step="10" onchange="updateThresholdDisplay(); drawScatterPlot();" style="width: 120px;">
              <input type="number" id="yieldThresholdInput" value="200" min="50" max="500" step="5" onchange="syncThresholdSlider(); drawScatterPlot();" style="width: 70px; padding: 0.25rem; border-radius: 0.25rem; border: 1px solid #cbd5e1;">
              <span style="color: #64748b;">bu/ac</span>
            </div>
          </div>
        </div>
        <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
          <div style="flex: 1; min-width: 600px;">
            <canvas id="scatterCanvas" width="900" height="500" style="background: white; border: 1px solid #e2e8f0; border-radius: 0.375rem; width: 100%; height: auto;"></canvas>
          </div>
          <div id="thresholdAnalysis" style="min-width: 280px; background: white; border: 1px solid #e2e8f0; border-radius: 0.375rem; padding: 1rem;">
            <h4 style="margin: 0 0 0.75rem 0; color: #1e293b; font-size: 0.95rem;">Threshold Analysis</h4>
            <div id="thresholdContent" style="font-size: 0.85rem; color: #475569;"></div>
          </div>
        </div>
        <div id="scatterStats" style="margin-top: 0.75rem; font-size: 0.875rem; color: #64748b;"></div>

        <!-- Data Verification Button -->
        <div style="margin-top: 1rem; text-align: center;">
          <button onclick="toggleYieldDebug()" class="export-btn" style="background: #f1f5f9; color: #475569; border: 1px solid #cbd5e1;">üîç Data Verification Check</button>
        </div>
      </div>

      <!-- Debug Panel (hidden by default) -->
      <div id="yieldDebugPanel" style="display: none; margin-top: 1rem; background: #fffbeb; border: 2px solid #f59e0b; border-radius: 0.5rem; padding: 1rem;">
        <h4 style="margin: 0 0 1rem 0; color: #92400e;">Data Verification Report</h4>
        <div id="yieldDebugContent" style="font-family: monospace; font-size: 0.75rem; white-space: pre-wrap; color: #78350f; max-height: 500px; overflow-y: auto;"></div>
      </div>
    </div>

    <!-- Tab: Spatial Change Analysis -->
    <div id="spatial" class="tab-content">
      <div class="controls-bar">
        <div class="control-group">
          <label>Field</label>
          <select id="spatialFieldSelect"></select>
        </div>
        <div class="control-group">
          <label>Nutrient</label>
          <select id="spatialNutrientSelect"></select>
        </div>
        <div class="control-group">
          <label>Base Year</label>
          <select id="spatialBaseYearSelect"></select>
        </div>
        <div class="control-group">
          <label>Compare To</label>
          <select id="spatialCompareYearSelect"></select>
        </div>
        <div class="control-group">
          <label>Match Radius</label>
          <select id="spatialRadiusSelect">
            <option value="50">50 ft</option>
            <option value="100" selected>100 ft (default)</option>
            <option value="150">150 ft</option>
            <option value="200">200 ft</option>
          </select>
        </div>
        <button onclick="exportSpatialAnalysis()" class="export-btn">üìÑ Export Report</button>
      </div>
      <div id="spatialContent">
        <div class="no-data">Select a field and nutrient to analyze spatial changes over time.</div>
      </div>
    </div>
  </div>

  <div id="statusMessage"></div>

  <script src="https://apis.google.com/js/api.js"></script>
  <script src="https://accounts.google.com/gsi/client"></script>
  <script>
    // ========== APP VERSION ==========
    const APP_VERSION = "v1.0.6";
    const BUILD_DATE = "2026-01-14T16:16:43";

    const CONFIG = {
      CLIENT_ID: '714780458094-9rde31taeottmavhl5t0uo8b9kfpergc.apps.googleusercontent.com',
      API_KEY: 'AIzaSyCOSDbrAlc3ct2-lRvJv1y7V0nV7haWc9E',
      get SHEET_ID() { return localStorage.getItem('googleSheetId') || '1buu-8KXoM1kRJSOAWtHaAk40seQT5kqGFY9RICYwdRY'; },
      
      NUTRIENTS: ['pH', 'P', 'P2', 'K', 'OM', 'CEC', 'Ca_sat', 'Mg_sat', 'K_Sat', 'H_Sat', 'Na_Sat', 'Zn', 'Cu', 'Mn', 'Fe', 'Boron', 'S', 'Buffer_pH', 'Na', 'Ca', 'Mg', 'NO3', 'NH4', 'Soluble_Salts', 'EC'],
      
      NUTRIENT_NAMES: {
        pH: 'pH', P: 'Phosphorus (P)', P2: 'Phosphorus P2', K: 'Potassium (K)', OM: 'Organic Matter',
        CEC: 'CEC', Ca_sat: 'Calcium Sat %', Mg_sat: 'Magnesium Sat %',
        K_Sat: 'K Base Sat %', H_Sat: 'H Base Sat %', Na_Sat: 'Na Base Sat %', Zn: 'Zinc', Cu: 'Copper',
        Mn: 'Manganese', Fe: 'Iron', Boron: 'Boron', S: 'Sulfur', Buffer_pH: 'Buffer pH',
        Na: 'Sodium', Ca: 'Calcium', Mg: 'Magnesium', NO3: 'Nitrate', NH4: 'Ammonium', Soluble_Salts: 'Soluble Salts', EC: 'EC'
      },
      
      NUTRIENT_UNITS: {
        pH: '', P: 'ppm', P2: 'ppm', K: 'ppm', OM: '%', CEC: 'meq/100g',
        Ca_sat: '%', Mg_sat: '%', K_Sat: '%', H_Sat: '%', Na_Sat: '%',
        Zn: 'ppm', Cu: 'ppm', Mn: 'ppm', Fe: 'ppm', Boron: 'ppm', S: 'ppm', Buffer_pH: '',
        Na: 'ppm', Ca: 'ppm', Mg: 'ppm', NO3: 'ppm', NH4: 'ppm', Soluble_Salts: 'mmhos/cm', EC: 'dS/m'
      },
      
      LOWER_IS_BETTER: ['Mg_sat', 'H_Sat', 'Na_Sat', 'Soluble_Salts'],

      // Default visibility for nutrients (used if no settings saved)
      DEFAULT_VISIBLE: ['pH', 'P', 'K', 'OM', 'CEC', 'Ca_sat', 'Mg_sat', 'K_Sat', 'H_Sat', 'Zn', 'Cu', 'Mn', 'Fe', 'Boron', 'S', 'Buffer_pH'],

      // Default decimal places for each attribute
      DECIMAL_PLACES: {
        pH: 2, Buffer_pH: 2, OM: 2, P: 0, P2: 0, K: 0, CEC: 1,
        Ca_sat: 1, Mg_sat: 1, K_Sat: 1, H_Sat: 1, Na_Sat: 1,
        Zn: 2, Cu: 2, Mn: 1, Fe: 1, Boron: 2, S: 1,
        Ca: 0, Mg: 0, Na: 0, NO3: 1, NH4: 1, Soluble_Salts: 2, EC: 2
      }
    };

    // Get decimal places for an attribute (checks user settings, then CONFIG defaults)
    function getDecimals(attr) {
      const customDecimals = JSON.parse(localStorage.getItem('decimalPlaces') || '{}');
      if (customDecimals[attr] !== undefined) return customDecimals[attr];
      if (CONFIG.DECIMAL_PLACES[attr] !== undefined) return CONFIG.DECIMAL_PLACES[attr];
      return 1;
    }

    // Format a value using the configured decimal places for an attribute
    function formatValue(value, attr) {
      if (value === null || value === undefined || isNaN(value)) return '-';
      return Number(value).toFixed(getDecimals(attr));
    }

    // Get visible nutrients based on settings
    function getVisibleNutrients() {
      const saved = JSON.parse(localStorage.getItem('nutrientVisibility') || '{}');
      return CONFIG.NUTRIENTS.filter(n => {
        if (saved[n] !== undefined) return saved[n];
        return CONFIG.DEFAULT_VISIBLE.includes(n);
      });
    }

    let tokenClient, accessToken = null, tokenExpiry = null;
    let sampleData = [];
    let year1 = null, year2 = null;
    let selectedComparisonFields = new Set(); // Track which fields are included in comparison

    // Yield correlation table state
    let yieldCorrelationsData = [];
    let yieldSortColumn = 'r'; // Default sort by correlation
    let yieldSortDirection = 'desc'; // desc = highest first
    
    const SheetsAPI = {
      isSignedIn: false,
      async init() {
        return new Promise((resolve, reject) => {
          gapi.load('client', async () => {
            try {
              await gapi.client.init({ apiKey: CONFIG.API_KEY, discoveryDocs: ['https://sheets.googleapis.com/$discovery/rest?version=v4'] });
              tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: CONFIG.CLIENT_ID,
                scope: 'https://www.googleapis.com/auth/spreadsheets',
                callback: (response) => {
                  if (response.error) return;
                  accessToken = response.access_token;
                  tokenExpiry = Date.now() + (response.expires_in * 1000) - 60000;
                  localStorage.setItem('googleAccessToken', accessToken);
                  localStorage.setItem('googleTokenExpiry', tokenExpiry.toString());
                  gapi.client.setToken({ access_token: accessToken });
                  this.isSignedIn = true;
                  this.onSignInChange(true);
                },
              });
              const savedToken = localStorage.getItem('googleAccessToken');
              const savedExpiry = localStorage.getItem('googleTokenExpiry');
              if (savedToken && savedExpiry && Date.now() < parseInt(savedExpiry)) {
                accessToken = savedToken;
                tokenExpiry = parseInt(savedExpiry);
                gapi.client.setToken({ access_token: accessToken });
                this.isSignedIn = true;
                this.onSignInChange(true);
              }
              resolve(true);
            } catch (e) { reject(e); }
          });
        });
      },
      async signIn() { tokenClient.requestAccessToken({ prompt: 'consent' }); },
      async signOut() {
        if (accessToken) google.accounts.oauth2.revoke(accessToken);
        accessToken = null;
        tokenExpiry = null;
        localStorage.removeItem('googleAccessToken');
        localStorage.removeItem('googleTokenExpiry');
        this.isSignedIn = false;
        this.onSignInChange(false);
      },
      onSignInChange(s) {}
    };

    document.addEventListener('DOMContentLoaded', async () => {
      try { await SheetsAPI.init(); SheetsAPI.onSignInChange = handleSignInChange; handleSignInChange(SheetsAPI.isSignedIn); } catch (e) {}
      loadLocalData();
      setupTabs();
      setupEventListeners();
      updateBackupFooter();
    });

    async function handleAuth() { if (SheetsAPI.isSignedIn) await SheetsAPI.signOut(); else await SheetsAPI.signIn(); }
    
    function handleSignInChange(isSignedIn) {
      const authBtn = document.getElementById('authBtn'), userInfo = document.getElementById('userInfo');
      if (isSignedIn) { userInfo.textContent = 'Connected'; authBtn.textContent = '‚úì Signed In'; authBtn.classList.add('signed-in'); }
      else { userInfo.textContent = ''; authBtn.textContent = 'Sign In to Edit'; authBtn.classList.remove('signed-in'); }
    }

    // IndexedDB for large datasets
    const DB_NAME = 'SoilAppDB';
    const DB_VERSION = 1;

    function openDB() {
      return new Promise((resolve, reject) => {
        if (!window.indexedDB) { reject(new Error('IndexedDB not supported')); return; }
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);
        request.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains('samples')) db.createObjectStore('samples', { keyPath: 'id' });
          if (!db.objectStoreNames.contains('boundaries')) db.createObjectStore('boundaries', { keyPath: 'id' });
        };
      });
    }

    async function loadFromIndexedDB() {
      try {
        const db = await openDB();
        const tx = db.transaction(['samples'], 'readonly');
        const samplesData = await new Promise((resolve, reject) => {
          const req = tx.objectStore('samples').get('all');
          req.onsuccess = () => resolve(req.result?.data || []);
          req.onerror = reject;
        });
        db.close();
        return samplesData;
      } catch (e) { return null; }
    }

    async function loadLocalData() {
      try {
        // Check IndexedDB first if flagged
        if (localStorage.getItem('usingIndexedDB') === 'true') {
          const idbSamples = await loadFromIndexedDB();
          if (idbSamples && idbSamples.length > 0) {
            sampleData = idbSamples;
            console.log('Loaded from IndexedDB:', sampleData.length, 'samples');
          }
        } else {
          const saved = localStorage.getItem('soilSamples');
          if (saved) sampleData = JSON.parse(saved);
        }
      } catch (e) { console.error(e); }
      populateSelectors();
      updateComparison();
      updateHistory('__all__');  // Default to All Fields view
      updateRankings();
      updateYieldAnalysis();
    }

    function populateSelectors() {
      const years = [...new Set(sampleData.map(s => s.year).filter(y => y))].sort((a, b) => b - a);
      const fields = [...new Set(sampleData.map(s => s.field).filter(f => f && f !== 'Unknown'))].sort();
      
      // Year comparison selectors - year1 is earlier (FROM), year2 is later (TO)
      const year1Sel = document.getElementById('year1Select');
      const year2Sel = document.getElementById('year2Select');
      year1Sel.innerHTML = ''; year2Sel.innerHTML = '';
      years.forEach((y, i) => {
        year1Sel.innerHTML += `<option value="${y}" ${i === 1 ? 'selected' : ''}>${y}</option>`;
        year2Sel.innerHTML += `<option value="${y}" ${i === 0 ? 'selected' : ''}>${y}</option>`;
      });
      year1 = years[1] || years[0] || null;  // Earlier year (second most recent)
      year2 = years[0] || null;               // Later year (most recent)
      
      // History field selector - default to All Fields (Operation Average)
      const historyFieldSel = document.getElementById('historyFieldSelect');
      historyFieldSel.innerHTML = '<option value="__all__" style="font-weight: bold;">üìä All Fields (Operation Average)</option>';
      fields.forEach(f => { historyFieldSel.innerHTML += `<option value="${f}">${f}</option>`; });
      historyFieldSel.value = '__all__';
      
      // Rankings selectors
      const rankAttrSel = document.getElementById('rankingAttrSelect');
      rankAttrSel.innerHTML = '';
      const visibleNutrients = getVisibleNutrients();
      visibleNutrients.forEach(n => { rankAttrSel.innerHTML += `<option value="${n}">${CONFIG.NUTRIENT_NAMES[n] || n}</option>`; });
      
      const rankYearSel = document.getElementById('rankingYearSelect');
      rankYearSel.innerHTML = '<option value="most_recent" selected>Most Recent</option>';
      years.forEach(y => { rankYearSel.innerHTML += `<option value="${y}">${y}</option>`; });
      
      // Yield selectors
      const yieldYearSel = document.getElementById('yieldYearSelect');
      const yieldYears = getYieldYears();
      yieldYearSel.innerHTML = '<option value="avg">All Years (Average)</option><option value="combined">All Years (Combined)</option>';
      yieldYears.forEach(y => { yieldYearSel.innerHTML += `<option value="${y}">${y}</option>`; });

      // Soil sample year selector
      const soilYearSel = document.getElementById('soilYearSelect');
      const soilYears = getSoilYearsWithYield();
      soilYearSel.innerHTML = '<option value="recent">Most Recent (default)</option><option value="all">All Years</option>';
      soilYears.forEach(y => { soilYearSel.innerHTML += `<option value="${y}">${y}</option>`; });

      const yieldFieldSel = document.getElementById('yieldFieldSelect');
      yieldFieldSel.innerHTML = '<option value="all">All Fields</option>';
      // Only show fields that have yield data
      const fieldsWithYield = [...new Set(sampleData.filter(s => s.yieldCorrelations && Object.keys(s.yieldCorrelations).length > 0).map(s => s.field).filter(f => f && f !== 'Unknown'))].sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));
      fieldsWithYield.forEach(f => { yieldFieldSel.innerHTML += `<option value="${f}">${f}</option>`; });

      // Spatial Change Analysis selectors
      const spatialFieldSel = document.getElementById('spatialFieldSelect');
      spatialFieldSel.innerHTML = '<option value="">-- Select Field --</option>';
      fields.forEach(f => { spatialFieldSel.innerHTML += `<option value="${f}">${f}</option>`; });

      const spatialNutrientSel = document.getElementById('spatialNutrientSelect');
      spatialNutrientSel.innerHTML = '';
      visibleNutrients.forEach(n => { spatialNutrientSel.innerHTML += `<option value="${n}">${CONFIG.NUTRIENT_NAMES[n] || n}</option>`; });

      // Spatial year selectors start empty - will populate when field is selected
      document.getElementById('spatialBaseYearSelect').innerHTML = '<option value="">Select field first</option>';
      document.getElementById('spatialCompareYearSelect').innerHTML = '<option value="">Select field first</option>';
    }

    function updateSpatialYearSelectors(field) {
      // Get years that have data for the selected field
      const fieldYears = [...new Set(
        sampleData
          .filter(s => s.field === field && s.year)
          .map(s => s.year)
      )].sort((a, b) => a - b); // Sort ascending (oldest first for base year)

      const spatialBaseYearSel = document.getElementById('spatialBaseYearSelect');
      const spatialCompareYearSel = document.getElementById('spatialCompareYearSelect');

      if (fieldYears.length === 0) {
        spatialBaseYearSel.innerHTML = '<option value="">No data for field</option>';
        spatialCompareYearSel.innerHTML = '<option value="">No data for field</option>';
        return;
      }

      // Base year dropdown - oldest first (ascending)
      spatialBaseYearSel.innerHTML = '';
      fieldYears.forEach(y => { spatialBaseYearSel.innerHTML += `<option value="${y}">${y}</option>`; });

      // Compare year dropdown - includes "All Years" option, newest first (descending)
      const descendingYears = [...fieldYears].sort((a, b) => b - a);
      spatialCompareYearSel.innerHTML = '<option value="all">All Years</option>';
      descendingYears.forEach(y => { spatialCompareYearSel.innerHTML += `<option value="${y}">${y}</option>`; });
    }

    function getSoilYearsWithYield() {
      // Get soil sample years that have yield correlations
      const years = new Set();
      sampleData.forEach(s => {
        if (s.yieldCorrelations && Object.keys(s.yieldCorrelations).length > 0 && s.year) {
          years.add(s.year);
        }
      });
      return [...years].sort((a, b) => b - a);
    }
    
    function getYieldYears() {
      const years = new Set();
      sampleData.forEach(s => {
        if (s.yieldCorrelations) {
          Object.keys(s.yieldCorrelations).forEach(y => years.add(parseInt(y)));
        }
      });
      return [...years].sort((a, b) => b - a);
    }

    function setupTabs() {
      document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', () => {
          document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
          tab.classList.add('active');
          document.getElementById(tab.dataset.tab).classList.add('active');
        });
      });
    }

    function setupEventListeners() {
      document.getElementById('year1Select').addEventListener('change', (e) => { year1 = e.target.value; selectedComparisonFields.clear(); updateComparison(); });
      document.getElementById('year2Select').addEventListener('change', (e) => { year2 = e.target.value; selectedComparisonFields.clear(); updateComparison(); });
      document.getElementById('historyFieldSelect').addEventListener('change', (e) => { updateHistory(e.target.value); });
      document.getElementById('rankingAttrSelect').addEventListener('change', updateRankings);
      document.getElementById('rankingYearSelect').addEventListener('change', updateRankings);
      document.getElementById('yieldCropSelect').addEventListener('change', updateYieldAnalysis);
      document.getElementById('yieldYearSelect').addEventListener('change', updateYieldAnalysis);
      document.getElementById('soilYearSelect').addEventListener('change', updateYieldAnalysis);
      document.getElementById('yieldFieldSelect').addEventListener('change', updateYieldAnalysis);
      // Spatial Change Analysis listeners
      document.getElementById('spatialFieldSelect').addEventListener('change', (e) => {
        updateSpatialYearSelectors(e.target.value);
        updateSpatialAnalysis();
      });
      document.getElementById('spatialNutrientSelect').addEventListener('change', updateSpatialAnalysis);
      document.getElementById('spatialBaseYearSelect').addEventListener('change', updateSpatialAnalysis);
      document.getElementById('spatialCompareYearSelect').addEventListener('change', updateSpatialAnalysis);
      document.getElementById('spatialRadiusSelect').addEventListener('change', updateSpatialAnalysis);
    }

    function getStats(samples, attr) {
      // Filter to only valid numeric values - exclude undefined, null, empty strings, and NaN
      const values = samples.map(s => s[attr])
        .filter(v => v !== undefined && v !== null && v !== '' && !isNaN(parseFloat(v)))
        .map(v => parseFloat(v));
      if (values.length === 0) return null;
      const sorted = [...values].sort((a, b) => a - b);
      const mid = Math.floor(sorted.length / 2);
      const median = sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
      return {
        avg: values.reduce((a, b) => a + b, 0) / values.length,
        median: median,
        high: Math.max(...values),
        low: Math.min(...values),
        count: values.length
      };
    }
    
    function updateYearStatsBox(container, year, samples) {
      if (!year || samples.length === 0) {
        container.innerHTML = '<p style="color: #94a3b8; font-style: italic;">No data</p>';
        return;
      }

      // Get unique fields
      const fields = [...new Set(samples.map(s => s.field).filter(f => f && f !== 'Unknown'))].sort();

      let html = `
        <div style="display: flex; gap: 1.5rem; flex-wrap: wrap; align-items: center;">
          <div>
            <div style="font-size: 1.5rem; font-weight: 700; color: #1e293b;">${year}</div>
            <div style="font-size: 0.875rem; color: #64748b;">${samples.length} samples across ${fields.length} fields</div>
          </div>
        </div>
      `;

      container.innerHTML = html;
    }
    
    window.toggleComparisonField = function(field) {
      if (selectedComparisonFields.has(field)) {
        selectedComparisonFields.delete(field);
      } else {
        selectedComparisonFields.add(field);
      }
      updateComparison();
    };
    
    window.selectMatchingComparisonFields = function() {
      const allSamplesFrom = year1 ? sampleData.filter(s => String(s.year) === String(year1)) : [];
      const allSamplesTo = sampleData.filter(s => String(s.year) === String(year2));
      const excludeFields = ['Unknown', 'Unassigned', 'unknown', 'unassigned', null, undefined, ''];
      const fieldsFrom = new Set(allSamplesFrom.map(s => s.field).filter(f => f && !excludeFields.includes(f)));
      const fieldsTo = new Set(allSamplesTo.map(s => s.field).filter(f => f && !excludeFields.includes(f)));
      const allFields = [...new Set([...fieldsFrom, ...fieldsTo])];
      // Clear first, then only select fields that have data in both years (matching fields)
      selectedComparisonFields.clear();
      allFields.forEach(f => {
        if (fieldsFrom.has(f) && fieldsTo.has(f)) {
          selectedComparisonFields.add(f);
        }
      });
      updateComparison();
    };

    window.selectAllComparisonFields = function() {
      const allSamplesFrom = year1 ? sampleData.filter(s => String(s.year) === String(year1)) : [];
      const allSamplesTo = sampleData.filter(s => String(s.year) === String(year2));
      const excludeFields = ['Unknown', 'Unassigned', 'unknown', 'unassigned', null, undefined, ''];
      const fieldsFrom = new Set(allSamplesFrom.map(s => s.field).filter(f => f && !excludeFields.includes(f)));
      const fieldsTo = new Set(allSamplesTo.map(s => s.field).filter(f => f && !excludeFields.includes(f)));
      const allFields = [...new Set([...fieldsFrom, ...fieldsTo])];
      // Select all fields from both years
      selectedComparisonFields.clear();
      allFields.forEach(f => selectedComparisonFields.add(f));
      updateComparison();
    };

    // ========== TAB 1: Year Comparison ==========
    // year1 = FROM (earlier year), year2 = TO (later year)
    // Stats shown are for year2, change = year2 - year1
    function updateComparison() {
      const grid = document.getElementById('comparisonGrid');
      const fromYearInfo = document.getElementById('fromYearInfo');
      const toYearInfo = document.getElementById('toYearInfo');
      const fieldCheckboxes = document.getElementById('fieldCheckboxes');
      const mismatchWarning = document.getElementById('fieldMismatchWarning');
      
      if (!year2 || sampleData.length === 0) {
        grid.innerHTML = '<div class="no-data">No data available. Import soil samples to see analysis.</div>';
        fromYearInfo.innerHTML = '';
        toYearInfo.innerHTML = '';
        fieldCheckboxes.innerHTML = '';
        mismatchWarning.innerHTML = '';
        return;
      }
      
      const allSamplesFrom = year1 ? sampleData.filter(s => String(s.year) === String(year1)) : [];
      const allSamplesTo = sampleData.filter(s => String(s.year) === String(year2));
      
      // Get all fields from both years (exclude Unknown and Unassigned)
      const excludeFields = ['Unknown', 'Unassigned', 'unknown', 'unassigned', null, undefined, ''];
      const fieldsFrom = new Set(allSamplesFrom.map(s => s.field).filter(f => f && !excludeFields.includes(f)));
      const fieldsTo = new Set(allSamplesTo.map(s => s.field).filter(f => f && !excludeFields.includes(f)));
      const allFields = [...new Set([...fieldsFrom, ...fieldsTo])].sort();
      
      // Initialize selectedComparisonFields if empty - only select fields in BOTH years by default
      if (selectedComparisonFields.size === 0) {
        allFields.forEach(f => {
          // Only check fields that have data in both years
          if (fieldsFrom.has(f) && fieldsTo.has(f)) {
            selectedComparisonFields.add(f);
          }
        });
      }
      
      // Update field checkboxes
      fieldCheckboxes.innerHTML = allFields.map(field => {
        const inFrom = fieldsFrom.has(field);
        const inTo = fieldsTo.has(field);
        const checked = selectedComparisonFields.has(field);
        const mismatch = (inFrom && !inTo) || (!inFrom && inTo);
        const bgColor = mismatch ? '#fef3c7' : (checked ? '#dcfce7' : '#f8fafc');
        const borderColor = mismatch ? '#f59e0b' : (checked ? '#22c55e' : '#cbd5e1');
        
        return `
          <label style="display: flex; align-items: center; gap: 0.375rem; padding: 0.375rem 0.625rem; background: ${bgColor}; border: 1px solid ${borderColor}; border-radius: 0.375rem; cursor: pointer; font-size: 0.8125rem;">
            <input type="checkbox" ${checked ? 'checked' : ''} onchange="toggleComparisonField('${field}')" style="cursor: pointer;">
            <span>${field}</span>
            ${mismatch ? '<span style="color: #f59e0b;" title="Not in both years">‚ö†Ô∏è</span>' : ''}
          </label>
        `;
      }).join('');
      
      // Check for mismatches
      const onlyInFrom = [...fieldsFrom].filter(f => !fieldsTo.has(f));
      const onlyInTo = [...fieldsTo].filter(f => !fieldsFrom.has(f));
      
      if (onlyInFrom.length > 0 || onlyInTo.length > 0) {
        let warningHtml = '<div style="background: #fef3c7; border: 1px solid #f59e0b; border-radius: 0.375rem; padding: 0.75rem; font-size: 0.8125rem;">';
        warningHtml += '<strong style="color: #92400e;">‚ö†Ô∏è Field Mismatch Detected</strong><br>';
        if (onlyInFrom.length > 0) {
          warningHtml += `<span style="color: #92400e;">Only in ${year1}: ${onlyInFrom.join(', ')}</span><br>`;
        }
        if (onlyInTo.length > 0) {
          warningHtml += `<span style="color: #92400e;">Only in ${year2}: ${onlyInTo.join(', ')}</span>`;
        }
        warningHtml += '</div>';
        mismatchWarning.innerHTML = warningHtml;
      } else {
        mismatchWarning.innerHTML = '';
      }
      
      // Filter samples by selected fields
      const samplesFrom = allSamplesFrom.filter(s => selectedComparisonFields.has(s.field));
      const samplesTo = allSamplesTo.filter(s => selectedComparisonFields.has(s.field));
      
      // Update year stats boxes
      updateYearStatsBox(fromYearInfo, year1, samplesFrom);
      updateYearStatsBox(toYearInfo, year2, samplesTo);
      
      if (samplesTo.length === 0) {
        // Check if the issue is no matching fields
        const matchingFields = allFields.filter(f => fieldsFrom.has(f) && fieldsTo.has(f));
        if (matchingFields.length === 0 && allFields.length > 0) {
          grid.innerHTML = `<div class="no-data">No matching fields between ${year1} and ${year2}.<br><small style="color: #64748b;">Fields may have different names. Try "Reassign samples to boundaries" on the Import page, or select fields manually above.</small></div>`;
        } else {
          grid.innerHTML = `<div class="no-data">No samples found for ${year2} with selected fields.<br><small style="color: #64748b;">Select fields above to include in comparison.</small></div>`;
        }
        return;
      }
      
      let html = '';
      
      const visibleNutrients = getVisibleNutrients();
      visibleNutrients.forEach(attr => {
        const statsTo = getStats(samplesTo, attr);
        const statsFrom = year1 ? getStats(samplesFrom, attr) : null;
        
        if (!statsTo) return;
        
        const name = CONFIG.NUTRIENT_NAMES[attr] || attr;
        const unit = CONFIG.NUTRIENT_UNITS[attr] || '';
        const decimals = getDecimals(attr);
        const isLowerBetter = CONFIG.LOWER_IS_BETTER.includes(attr);
        
        let pointChange = 0, pctChange = 0, cardClass = '', pctClass = 'neutral';
        
        if (statsFrom && statsFrom.avg !== undefined) {
          pointChange = statsTo.avg - statsFrom.avg;
          pctChange = statsFrom.avg !== 0 ? (pointChange / statsFrom.avg) * 100 : 0;
          const isPositive = isLowerBetter ? pointChange < 0 : pointChange > 0;
          const isSignificant = Math.abs(pctChange) > 2;
          if (isSignificant) {
            cardClass = isPositive ? 'positive' : 'negative';
            pctClass = isPositive ? 'positive' : 'negative';
          }
        } else if (year1 && samplesFrom.length === 0) {
          // No data from year1 for selected fields - show warning style
          cardClass = 'no-comparison';
        }
        
        html += `
          <div class="nutrient-card ${cardClass}">
            <div class="nutrient-header">
              <span class="nutrient-name">${name}</span>
              ${statsFrom ? `<span class="nutrient-pct ${pctClass}">${pctChange >= 0 ? '+' : ''}${pctChange.toFixed(1)}%</span>` : ''}
            </div>
            <div class="nutrient-stats">
              <div class="stat-box"><div class="label">Average</div><div class="value">${statsTo.avg.toFixed(decimals)}</div></div>
              <div class="stat-box"><div class="label">High</div><div class="value">${statsTo.high.toFixed(decimals)}</div></div>
              <div class="stat-box"><div class="label">Low</div><div class="value">${statsTo.low.toFixed(decimals)}</div></div>
            </div>
            ${statsFrom ? `
              <div class="year-comparison">
                <div class="year-val"><div class="yr">${year1}</div><div class="num">${statsFrom.avg.toFixed(decimals)}</div></div>
                <div class="year-arrow">‚Üí</div>
                <div class="year-val"><div class="yr">${year2}</div><div class="num">${statsTo.avg.toFixed(decimals)}</div></div>
              </div>
              <div class="change-row">
                <span>Point: <span class="val ${pctClass}">${pointChange >= 0 ? '+' : ''}${pointChange.toFixed(decimals)}</span></span>
                <span>%: <span class="val ${pctClass}">${pctChange >= 0 ? '+' : ''}${pctChange.toFixed(1)}%</span></span>
              </div>
            ` : `<div class="year-comparison" style="justify-content:center; flex-direction:column; align-items:center;">
              <div class="year-val"><div class="yr">${year2}</div><div class="num">${statsTo.avg.toFixed(decimals)} ${unit}</div></div>
              ${year1 && samplesFrom.length === 0 ? `<div style="font-size:0.75rem;color:#92400e;margin-top:0.5rem;">‚ö†Ô∏è No ${year1} data for selected fields</div>` : ''}
            </div>`}
          </div>
        `;
      });
      
      grid.innerHTML = html || '<div class="no-data">No nutrient data available</div>';
    }

    // ========== TAB 2: Historical Field Trends ==========
    function updateHistory(fieldName) {
      const container = document.getElementById('historyContent');

      if (!fieldName) {
        container.innerHTML = '<div class="no-data">Select a field to view nutrient trends over time</div>';
        return;
      }

      // Handle "All Fields" operation-wide trends
      if (fieldName === '__all__') {
        renderOperationTrends(container);
        return;
      }

      console.log('=== Field Trends Debug ===');
      console.log('Selected field:', JSON.stringify(fieldName), 'length:', fieldName.length);

      const fieldSamples = sampleData.filter(s => s.field === fieldName);
      console.log('Samples found:', fieldSamples.length);

      const years = [...new Set(fieldSamples.map(s => s.year).filter(y => y))].sort();
      console.log('Years found:', years);

      if (fieldSamples.length > 0) {
        console.log('First sample:', JSON.stringify(fieldSamples[0]));
        console.log('Sample years breakdown:', years.map(y => ({ year: y, count: fieldSamples.filter(s => String(s.year) === String(y)).length })));
      }

      if (years.length < 1) {
        container.innerHTML = '<div class="no-data">No data available for this field</div>';
        return;
      }

      let html = `<div style="background:#f8fafc;border:2px solid #cbd5e1;border-radius:0.5rem;padding:1rem;margin-bottom:1rem;"><h3 style="margin:0 0 0.25rem 0;">${fieldName}</h3><p style="margin:0;color:#64748b;">Years: ${years.join(', ')} (${fieldSamples.length} samples)</p></div>`;

      try {
        const visibleNutrients = getVisibleNutrients();
        console.log('Visible nutrients:', visibleNutrients.length);

        visibleNutrients.forEach(attr => {
          try {
            const yearData = [];
            let hasData = false;

            years.forEach(year => {
              const yearSamples = fieldSamples.filter(s => String(s.year) === String(year));
              const stats = getStats(yearSamples, attr);
              if (stats) { yearData.push({ year, avg: stats.avg, median: stats.median, count: stats.count }); hasData = true; }
            });

            if (!hasData || yearData.length < 1) return;

            const first = yearData[0], last = yearData[yearData.length - 1];
            const avgChange = last.avg - first.avg;
            const medianChange = last.median - first.median;
            const pctChange = first.avg !== 0 ? (avgChange / first.avg) * 100 : 0;
            const isLowerBetter = CONFIG.LOWER_IS_BETTER.includes(attr);
            const isPositive = isLowerBetter ? avgChange < 0 : avgChange > 0;
            const decimals = getDecimals(attr);
            const unit = CONFIG.NUTRIENT_UNITS[attr] || '';
            const name = CONFIG.NUTRIENT_NAMES[attr] || attr;

            let cardClass = 'neutral', color = '#64748b';
            if (yearData.length > 1) {
              cardClass = isPositive ? 'positive' : 'negative';
              color = isPositive ? '#22c55e' : '#ef4444';
            }

            const graph = createDualLineGraph(yearData, color, attr);

            html += `
              <div class="trend-card ${cardClass}">
                <div class="trend-header">
                  <h4 class="trend-title">${name}</h4>
                  ${yearData.length > 1 ? `<div class="trend-pct" style="color:${color};">${pctChange >= 0 ? '+' : ''}${pctChange.toFixed(1)}%<div class="trend-sub">${first.year} ‚Üí ${last.year}</div></div>` : ''}
                </div>
                <div class="trend-content">
                  <div class="trend-values">
                    <div style="font-size:0.7rem;color:#64748b;margin-bottom:0.25rem;display:flex;justify-content:space-between;padding:0 0.75rem;"><span></span><span style="width:70px;text-align:center;">Avg</span><span style="width:70px;text-align:center;">Median</span></div>
                    ${yearData.map((d, i) => `<div class="trend-row ${i % 2 === 0 ? 'alt' : ''}"><span class="trend-year">${d.year}:</span><span class="trend-value" style="width:70px;text-align:center;">${d.avg.toFixed(decimals)}</span><span class="trend-value" style="width:70px;text-align:center;color:#8b5cf6;">${d.median.toFixed(decimals)}</span></div>`).join('')}
                    ${yearData.length > 1 ? `<div class="trend-row" style="margin-top:0.5rem;border-top:2px solid ${color};padding-top:0.5rem;"><span>Change:</span><span style="width:70px;text-align:center;color:${color};font-weight:700;">${avgChange >= 0 ? '+' : ''}${avgChange.toFixed(decimals)}</span><span style="width:70px;text-align:center;color:#8b5cf6;font-weight:700;">${medianChange >= 0 ? '+' : ''}${medianChange.toFixed(decimals)}</span></div>` : ''}
                  </div>
                  <div class="trend-graph ${yearData.length > 10 ? 'xlarge' : (yearData.length > 5 ? 'large' : '')}">
                    <div style="display:flex;gap:1rem;font-size:0.7rem;margin-bottom:0.25rem;justify-content:center;">
                      <span><span style="color:${color};">‚óè</span> Average</span>
                      <span><span style="color:#8b5cf6;">‚óè</span> Median</span>
                    </div>
                    ${graph}
                  </div>
                </div>
              </div>
            `;
          } catch (attrError) {
            console.error('Error processing attribute', attr, ':', attrError);
          }
        });

        console.log('Generated HTML length:', html.length);
        container.innerHTML = html || '<div class="no-data">No nutrient data available</div>';
      } catch (error) {
        console.error('Error in updateHistory:', error);
        container.innerHTML = `<div class="no-data" style="color: red;">Error loading data: ${error.message}</div>`;
      }
    }

    // Operation-wide trends (All Fields)
    function renderOperationTrends(container) {
      const years = [...new Set(sampleData.map(s => s.year).filter(y => y))].sort();
      const allFields = [...new Set(sampleData.map(s => s.field).filter(f => f && f !== 'Unknown' && f !== 'Unassigned'))];

      if (years.length < 1) {
        container.innerHTML = '<div class="no-data">No data available</div>';
        return;
      }

      // Calculate per-year statistics
      const yearStats = years.map(year => {
        const yearSamples = sampleData.filter(s => String(s.year) === String(year));
        const fieldsInYear = [...new Set(yearSamples.map(s => s.field).filter(f => f && f !== 'Unknown' && f !== 'Unassigned'))];
        return {
          year,
          sampleCount: yearSamples.length,
          fieldCount: fieldsInYear.length,
          fields: fieldsInYear
        };
      });

      const totalSamples = sampleData.length;
      const operationName = localStorage.getItem('operationName') || 'Operation';

      let html = `
        <div style="background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%); border: 2px solid #3b82f6; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem;">
          <h3 style="margin: 0 0 0.5rem 0; color: #1e40af;">üìä ${operationName} - All Fields Average</h3>
          <p style="margin: 0 0 0.5rem 0; color: #64748b; font-size: 0.875rem;">
            Operation-wide nutrient trends across <strong>${allFields.length} fields</strong> and <strong>${totalSamples.toLocaleString()} total samples</strong>
          </p>
          <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; font-size: 0.75rem;">
            ${yearStats.map(ys => `
              <span style="background: white; padding: 0.25rem 0.5rem; border-radius: 0.25rem; border: 1px solid #93c5fd;">
                <strong>${ys.year}:</strong> ${ys.sampleCount} samples, ${ys.fieldCount} fields
              </span>
            `).join('')}
          </div>
        </div>
      `;

      try {
        const visibleNutrients = getVisibleNutrients();

        visibleNutrients.forEach(attr => {
          try {
            const yearData = [];
            let hasData = false;

            years.forEach(year => {
              const yearSamples = sampleData.filter(s => String(s.year) === String(year));
              const stats = getStats(yearSamples, attr);

              // Calculate per-field averages for range band
              const fieldsInYear = [...new Set(yearSamples.map(s => s.field).filter(f => f && f !== 'Unknown' && f !== 'Unassigned'))];
              const fieldAvgs = fieldsInYear.map(field => {
                const fieldSamples = yearSamples.filter(s => s.field === field);
                const fieldStats = getStats(fieldSamples, attr);
                return fieldStats ? fieldStats.avg : null;
              }).filter(v => v !== null);

              if (stats) {
                yearData.push({
                  year,
                  avg: stats.avg,
                  median: stats.median,
                  count: stats.count,
                  fieldCount: fieldsInYear.length,
                  minFieldAvg: fieldAvgs.length > 0 ? Math.min(...fieldAvgs) : stats.avg,
                  maxFieldAvg: fieldAvgs.length > 0 ? Math.max(...fieldAvgs) : stats.avg
                });
                hasData = true;
              }
            });

            if (!hasData || yearData.length < 1) return;

            const first = yearData[0], last = yearData[yearData.length - 1];
            const avgChange = last.avg - first.avg;
            const medianChange = last.median - first.median;
            const pctChange = first.avg !== 0 ? (avgChange / first.avg) * 100 : 0;
            const isLowerBetter = CONFIG.LOWER_IS_BETTER.includes(attr);
            const isPositive = isLowerBetter ? avgChange < 0 : avgChange > 0;
            const decimals = getDecimals(attr);
            const name = CONFIG.NUTRIENT_NAMES[attr] || attr;

            let cardClass = 'neutral', color = '#64748b';
            if (yearData.length > 1) {
              cardClass = isPositive ? 'positive' : 'negative';
              color = isPositive ? '#22c55e' : '#ef4444';
            }

            const graph = createOperationTrendGraph(yearData, color);

            html += `
              <div class="trend-card ${cardClass}">
                <div class="trend-header">
                  <h4 class="trend-title">${name}</h4>
                  ${yearData.length > 1 ? `<div class="trend-pct" style="color:${color};">${pctChange >= 0 ? '+' : ''}${pctChange.toFixed(1)}%<div class="trend-sub">${first.year} ‚Üí ${last.year}</div></div>` : ''}
                </div>
                <div class="trend-content">
                  <div class="trend-values">
                    <div style="font-size:0.65rem;color:#64748b;margin-bottom:0.25rem;display:flex;justify-content:space-between;padding:0 0.5rem;">
                      <span></span>
                      <span style="width:50px;text-align:center;">Avg</span>
                      <span style="width:50px;text-align:center;">Med</span>
                      <span style="width:70px;text-align:center;font-size:0.6rem;">Range</span>
                    </div>
                    ${yearData.map((d, i) => `
                      <div class="trend-row ${i % 2 === 0 ? 'alt' : ''}" style="font-size:0.8rem;">
                        <span class="trend-year">${d.year}:</span>
                        <span style="width:50px;text-align:center;">${d.avg.toFixed(decimals)}</span>
                        <span style="width:50px;text-align:center;color:#8b5cf6;">${d.median.toFixed(decimals)}</span>
                        <span style="width:70px;text-align:center;font-size:0.65rem;color:#94a3b8;">${d.minFieldAvg.toFixed(decimals)}-${d.maxFieldAvg.toFixed(decimals)}</span>
                      </div>
                    `).join('')}
                    ${yearData.length > 1 ? `
                      <div class="trend-row" style="margin-top:0.5rem;border-top:2px solid ${color};padding-top:0.5rem;">
                        <span>Change:</span>
                        <span style="width:50px;text-align:center;color:${color};font-weight:700;">${avgChange >= 0 ? '+' : ''}${avgChange.toFixed(decimals)}</span>
                        <span style="width:50px;text-align:center;color:#8b5cf6;font-weight:700;">${medianChange >= 0 ? '+' : ''}${medianChange.toFixed(decimals)}</span>
                        <span style="width:70px;"></span>
                      </div>
                    ` : ''}
                  </div>
                  <div class="trend-graph ${yearData.length > 10 ? 'xlarge' : (yearData.length > 5 ? 'large' : '')}">
                    <div style="display:flex;gap:0.75rem;font-size:0.65rem;margin-bottom:0.25rem;justify-content:center;">
                      <span><span style="color:${color};">‚óè</span> Avg</span>
                      <span><span style="color:#8b5cf6;">‚óè</span> Median</span>
                      <span style="color:#cbd5e1;">‚ñà Field Range</span>
                    </div>
                    ${graph}
                  </div>
                </div>
              </div>
            `;
          } catch (attrError) {
            console.error('Error processing attribute', attr, ':', attrError);
          }
        });

        container.innerHTML = html || '<div class="no-data">No nutrient data available</div>';
      } catch (error) {
        console.error('Error in renderOperationTrends:', error);
        container.innerHTML = `<div class="no-data" style="color: red;">Error loading data: ${error.message}</div>`;
      }
    }

    // Graph with range band for operation trends
    function createOperationTrendGraph(yearData, avgColor) {
      if (yearData.length < 1) return '';
      const medianColor = '#8b5cf6';
      const numYears = yearData.length;

      // Get all values including range to determine scale
      const allValues = [
        ...yearData.map(d => d.avg),
        ...yearData.map(d => d.median),
        ...yearData.map(d => d.minFieldAvg),
        ...yearData.map(d => d.maxFieldAvg)
      ];
      const minVal = Math.min(...allValues) * 0.9, maxVal = Math.max(...allValues) * 1.1;
      const range = maxVal - minVal || 1;

      // Dynamic dimensions based on year count - larger for PDF readability
      const baseWidth = 450;
      const width = numYears <= 5 ? baseWidth : Math.max(baseWidth, numYears * 60);
      const height = numYears <= 5 ? 190 : (numYears <= 10 ? 230 : 290);
      const padLeft = 35, padRight = 35, padTop = 30, padBottom = 40;
      const gw = width - padLeft - padRight;
      const gh = height - padTop - padBottom;

      // Determine label skip interval - only skip for very many years
      const labelSkip = numYears > 15 ? 2 : (numYears > 10 ? 1 : 0);

      // Calculate points
      const avgPts = yearData.map((d, i) => {
        const x = padLeft + (yearData.length > 1 ? (i / (yearData.length - 1)) * gw : gw / 2);
        const y = padTop + gh - ((d.avg - minVal) / range) * gh;
        return { x, y, year: d.year, val: d.avg };
      });

      const medianPts = yearData.map((d, i) => {
        const x = padLeft + (yearData.length > 1 ? (i / (yearData.length - 1)) * gw : gw / 2);
        const y = padTop + gh - ((d.median - minVal) / range) * gh;
        return { x, y, year: d.year, val: d.median };
      });

      // Range band (min/max field averages)
      const rangePts = yearData.map((d, i) => {
        const x = padLeft + (yearData.length > 1 ? (i / (yearData.length - 1)) * gw : gw / 2);
        const yMin = padTop + gh - ((d.minFieldAvg - minVal) / range) * gh;
        const yMax = padTop + gh - ((d.maxFieldAvg - minVal) / range) * gh;
        return { x, yMin, yMax };
      });

      // Create range band path (polygon)
      let rangePath = '';
      if (yearData.length > 1) {
        const topPoints = rangePts.map(p => `${p.x},${p.yMax}`).join(' L');
        const bottomPoints = [...rangePts].reverse().map(p => `${p.x},${p.yMin}`).join(' L');
        rangePath = `<path d="M${topPoints} L${bottomPoints} Z" fill="#e2e8f0" opacity="0.5"/>`;
      } else {
        // Single point - draw a vertical line
        const p = rangePts[0];
        rangePath = `<line x1="${p.x}" y1="${p.yMin}" x2="${p.x}" y2="${p.yMax}" stroke="#cbd5e1" stroke-width="8" opacity="0.5"/>`;
      }

      // Create lines
      const avgLine = avgPts.map((p, i) => `${i === 0 ? 'M' : 'L'}${p.x},${p.y}`).join(' ');
      const medianLine = medianPts.map((p, i) => `${i === 0 ? 'M' : 'L'}${p.x},${p.y}`).join(' ');

      // Create dots
      const dotRadius = numYears > 10 ? 4 : 5;
      const avgDots = avgPts.map(p => `<circle cx="${p.x}" cy="${p.y}" r="${dotRadius}" fill="${avgColor}" stroke="white" stroke-width="2"/>`).join('');
      const medianDots = medianPts.map(p => `<circle cx="${p.x}" cy="${p.y}" r="${dotRadius}" fill="${medianColor}" stroke="white" stroke-width="2"/>`).join('');

      // Year labels - always show all for small datasets
      const yearLabels = avgPts.map((p, i) => {
        const showLabel = i === 0 || i === avgPts.length - 1 || (labelSkip === 0) || (labelSkip === 1 && i % 2 === 0) || (labelSkip === 2 && i % 3 === 0);
        if (!showLabel) return '';
        const fontSize = numYears > 12 ? 10 : 11;
        return `<text x="${p.x}" y="${height - 12}" text-anchor="middle" font-size="${fontSize}" font-weight="600" fill="#475569">${p.year}</text>`;
      }).join('');

      const sizeClass = numYears > 10 ? 'xlarge' : (numYears > 5 ? 'large' : '');

      return `<svg width="100%" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet" style="width:100%;height:auto;min-height:${height}px;" data-size="${sizeClass}">
        ${rangePath}
        <path d="${avgLine}" fill="none" stroke="${avgColor}" stroke-width="3" stroke-linecap="round"/>
        <path d="${medianLine}" fill="none" stroke="${medianColor}" stroke-width="2.5" stroke-linecap="round" stroke-dasharray="4,2"/>
        ${avgDots}
        ${medianDots}
        ${yearLabels}
      </svg>`;
    }

    function createLineGraph(yearData, color, attr = 'P') {
      if (yearData.length < 1) return '';
      const decimals = getDecimals(attr);
      const values = yearData.map(d => d.avg);
      const minVal = Math.min(...values) * 0.9, maxVal = Math.max(...values) * 1.1;
      const range = maxVal - minVal || 1;
      const width = 400, height = 140, pad = 20;
      const gw = width - pad * 2, gh = height - pad * 2 - 20;

      const pts = yearData.map((d, i) => {
        const x = pad + (yearData.length > 1 ? (i / (yearData.length - 1)) * gw : gw / 2);
        const y = pad + gh - ((d.avg - minVal) / range) * gh;
        return { x, y, year: d.year, val: d.avg };
      });

      const line = pts.map((p, i) => `${i === 0 ? 'M' : 'L'}${p.x},${p.y}`).join(' ');
      const dots = pts.map(p => `<circle cx="${p.x}" cy="${p.y}" r="6" fill="${color}" stroke="white" stroke-width="2"/><text x="${p.x}" y="${height - 5}" text-anchor="middle" font-size="11" fill="#64748b">${p.year}</text><text x="${p.x}" y="${p.y - 12}" text-anchor="middle" font-size="12" font-weight="700" fill="#1e293b">${p.val.toFixed(decimals)}</text>`).join('');

      return `<svg width="100%" height="${height}" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet"><path d="${line}" fill="none" stroke="${color}" stroke-width="3" stroke-linecap="round"/>${dots}</svg>`;
    }

    function createDualLineGraph(yearData, avgColor, attr = 'P') {
      if (yearData.length < 1) return '';
      const medianColor = '#8b5cf6'; // Purple for median
      const numYears = yearData.length;
      const decimals = getDecimals(attr);

      // Get all values to determine scale
      const allValues = [...yearData.map(d => d.avg), ...yearData.map(d => d.median)];
      const minVal = Math.min(...allValues) * 0.85, maxVal = Math.max(...allValues) * 1.15;
      const range = maxVal - minVal || 1;

      // Dynamic dimensions based on year count - larger for PDF readability
      const baseWidth = 450;  // Wider base for better label spacing
      const width = numYears <= 5 ? baseWidth : Math.max(baseWidth, numYears * 60);
      const height = numYears <= 5 ? 180 : (numYears <= 10 ? 220 : 280);
      const padLeft = 35, padRight = 35, padTop = 30, padBottom = 40; // More padding for labels
      const gw = width - padLeft - padRight;
      const gh = height - padTop - padBottom;

      // Determine label skip interval - only skip for very many years
      const labelSkip = numYears > 15 ? 2 : (numYears > 10 ? 1 : 0);

      // Calculate points for both lines
      const avgPts = yearData.map((d, i) => {
        const x = padLeft + (yearData.length > 1 ? (i / (yearData.length - 1)) * gw : gw / 2);
        const y = padTop + gh - ((d.avg - minVal) / range) * gh;
        return { x, y, year: d.year, val: d.avg, idx: i };
      });

      const medianPts = yearData.map((d, i) => {
        const x = padLeft + (yearData.length > 1 ? (i / (yearData.length - 1)) * gw : gw / 2);
        const y = padTop + gh - ((d.median - minVal) / range) * gh;
        return { x, y, year: d.year, val: d.median, idx: i };
      });

      // Create path lines
      const avgLine = avgPts.map((p, i) => `${i === 0 ? 'M' : 'L'}${p.x},${p.y}`).join(' ');
      const medianLine = medianPts.map((p, i) => `${i === 0 ? 'M' : 'L'}${p.x},${p.y}`).join(' ');

      // Create dots - smaller for many years
      const dotRadius = numYears > 10 ? 4 : 5;
      const avgDots = avgPts.map(p => `<circle cx="${p.x}" cy="${p.y}" r="${dotRadius}" fill="${avgColor}" stroke="white" stroke-width="2"/>`).join('');
      const medianDots = medianPts.map(p => `<circle cx="${p.x}" cy="${p.y}" r="${dotRadius}" fill="${medianColor}" stroke="white" stroke-width="2"/>`).join('');

      // Year labels at bottom - always show all for small datasets
      const yearLabels = avgPts.map((p, i) => {
        // Always show first and last, skip middle ones only for very many years
        const showLabel = i === 0 || i === avgPts.length - 1 || (labelSkip === 0) || (labelSkip === 1 && i % 2 === 0) || (labelSkip === 2 && i % 3 === 0);
        if (!showLabel) return '';
        const fontSize = numYears > 12 ? 10 : 11;
        return `<text x="${p.x}" y="${height - 12}" text-anchor="middle" font-size="${fontSize}" font-weight="600" fill="#475569">${p.year}</text>`;
      }).join('');

      // Value labels - show for up to 10 years
      let avgLabels = '', medianLabels = '';
      if (numYears <= 10) {
        avgLabels = avgPts.map((p, i) => {
          const medianY = medianPts[i].y;
          const gap = Math.abs(p.y - medianY);
          let offset = gap < 20 ? (p.y < medianY ? -12 : 16) : -12;
          const fontSize = numYears > 6 ? 9 : 10;
          return `<text x="${p.x}" y="${p.y + offset}" text-anchor="middle" font-size="${fontSize}" font-weight="700" fill="${avgColor}">${p.val.toFixed(decimals)}</text>`;
        }).join('');

        medianLabels = medianPts.map((p, i) => {
          const avgY = avgPts[i].y;
          const gap = Math.abs(p.y - avgY);
          let offset = gap < 20 ? (p.y <= avgY ? -12 : 16) : 16;
          const fontSize = numYears > 6 ? 9 : 10;
          return `<text x="${p.x}" y="${p.y + offset}" text-anchor="middle" font-size="${fontSize}" font-weight="700" fill="${medianColor}">${p.val.toFixed(decimals)}</text>`;
        }).join('');
      }

      // Add size class hint via data attribute
      const sizeClass = numYears > 10 ? 'xlarge' : (numYears > 5 ? 'large' : '');

      return `<svg viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet" style="width:100%;height:auto;min-height:${height}px;" data-size="${sizeClass}">
        <path d="${avgLine}" fill="none" stroke="${avgColor}" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
        <path d="${medianLine}" fill="none" stroke="${medianColor}" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" stroke-dasharray="6,3"/>
        ${avgDots}${medianDots}
        ${yearLabels}
        ${avgLabels}${medianLabels}
      </svg>`;
    }

    // ========== TAB 3: Field Rankings ==========
    function updateRankings() {
      const container = document.getElementById('rankingsContent');
      const attr = document.getElementById('rankingAttrSelect').value;
      const yearOption = document.getElementById('rankingYearSelect').value;
      
      if (!attr) {
        container.innerHTML = '<div class="no-data">Select nutrient</div>';
        return;
      }
      
      // Get all unique fields
      const allFields = [...new Set(sampleData.map(s => s.field).filter(f => f && f !== 'Unknown'))];
      
      const fieldStats = allFields.map(field => {
        // Get samples for this field
        let fieldSamples = sampleData.filter(s => s.field === field);
        
        if (yearOption === 'most_recent') {
          // Find most recent year for this field
          const fieldYears = [...new Set(fieldSamples.map(s => s.year).filter(y => y))].sort((a, b) => b - a);
          if (fieldYears.length === 0) return null;
          const mostRecentYear = fieldYears[0];
          fieldSamples = fieldSamples.filter(s => String(s.year) === String(mostRecentYear));
          const stats = getStats(fieldSamples, attr);
          return stats ? { field, avg: stats.avg, high: stats.high, low: stats.low, count: stats.count, year: mostRecentYear } : null;
        } else {
          // Filter by selected year
          fieldSamples = fieldSamples.filter(s => String(s.year) === String(yearOption));
          const stats = getStats(fieldSamples, attr);
          return stats ? { field, avg: stats.avg, high: stats.high, low: stats.low, count: stats.count, year: yearOption } : null;
        }
      }).filter(f => f);
      
      const isLowerBetter = CONFIG.LOWER_IS_BETTER.includes(attr);
      fieldStats.sort((a, b) => isLowerBetter ? a.avg - b.avg : b.avg - a.avg);
      
      const name = CONFIG.NUTRIENT_NAMES[attr] || attr;
      const unit = CONFIG.NUTRIENT_UNITS[attr] || '';
      const decimals = getDecimals(attr);
      const maxAvg = Math.max(...fieldStats.map(f => f.avg));
      const minAvg = Math.min(...fieldStats.map(f => f.avg));
      
      // Add Year column if using Most Recent
      const showYearCol = yearOption === 'most_recent';
      
      let html = `<table class="rankings-table"><thead><tr><th>Rank</th><th>Field</th>${showYearCol ? '<th>Year</th>' : ''}<th>Average</th><th>High</th><th>Low</th><th>Samples</th></tr></thead><tbody>`;
      
      fieldStats.forEach((f, i) => {
        const isTop = f.avg === (isLowerBetter ? minAvg : maxAvg);
        const isBottom = f.avg === (isLowerBetter ? maxAvg : minAvg);
        html += `<tr><td class="rank">#${i + 1}</td><td class="field">${f.field}</td>${showYearCol ? `<td>${f.year}</td>` : ''}<td class="value ${isTop ? 'high' : isBottom ? 'low' : ''}">${f.avg.toFixed(decimals)} ${unit}</td><td>${f.high.toFixed(decimals)}</td><td>${f.low.toFixed(decimals)}</td><td>${f.count}</td></tr>`;
      });
      
      html += '</tbody></table>';
      container.innerHTML = fieldStats.length > 0 ? html : '<div class="no-data">No data available</div>';
    }
    
    // ========== TAB 4: Yield Correlation ==========
    function updateYieldAnalysis() {
      const container = document.getElementById('yieldContent');
      const cropFilter = document.getElementById('yieldCropSelect').value;
      const yearFilter = document.getElementById('yieldYearSelect').value;
      const soilYearFilter = document.getElementById('soilYearSelect').value;
      const fieldFilter = document.getElementById('yieldFieldSelect').value;

      // Get samples with yield correlations
      let samplesWithYield = sampleData.filter(s => s.yieldCorrelations && Object.keys(s.yieldCorrelations).length > 0);

      if (samplesWithYield.length === 0) {
        container.innerHTML = '<div class="no-data">No yield data available. Import yield maps on the Import page to see correlations.</div>';
        return;
      }

      // Filter by field
      if (fieldFilter !== 'all') {
        samplesWithYield = samplesWithYield.filter(s => s.field === fieldFilter);
      }

      // Filter by soil sample year
      let soilYearDescription = '';
      if (soilYearFilter === 'recent') {
        // Use only the most recent soil sample at each location
        // Group by approximate location (rounded to 5 decimal places ~1m precision)
        const locationMap = new Map();
        samplesWithYield.forEach(sample => {
          const locKey = `${sample.lat.toFixed(5)},${sample.lon.toFixed(5)}`;
          const existing = locationMap.get(locKey);
          if (!existing || (sample.year && sample.year > existing.year)) {
            locationMap.set(locKey, sample);
          }
        });
        samplesWithYield = Array.from(locationMap.values());
        soilYearDescription = 'Most recent at each location';
      } else if (soilYearFilter === 'all') {
        // Use all soil samples (may have multiple per location)
        soilYearDescription = 'All years (may include duplicates)';
      } else {
        // Filter to specific soil sample year
        const selectedYear = parseInt(soilYearFilter);
        samplesWithYield = samplesWithYield.filter(s => s.year === selectedYear);
        soilYearDescription = `${selectedYear} only`;
      }

      // Get soil sample year range (after filtering)
      const soilYears = [...new Set(samplesWithYield.map(s => s.year).filter(y => y))].sort();
      const soilYearRange = soilYears.length > 0
        ? (soilYears.length === 1 ? `${soilYears[0]}` : `${Math.min(...soilYears)}-${Math.max(...soilYears)}`)
        : 'N/A';

      // Get all available yield years (before filtering)
      const allYieldYears = new Set();
      samplesWithYield.forEach(sample => {
        Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
          if (cropFilter === 'all' || yieldInfo.crop === cropFilter) {
            allYieldYears.add(parseInt(year));
          }
        });
      });
      const sortedYieldYears = [...allYieldYears].sort();

      // Build correlation data points based on yearFilter mode
      const dataPoints = [];
      const uniqueLocations = samplesWithYield.length;

      if (yearFilter === 'avg') {
        // ALL YEARS (AVERAGE): Average yield across all years at each location
        samplesWithYield.forEach(sample => {
          const validYields = [];
          Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
            if (cropFilter === 'all' || yieldInfo.crop === cropFilter) {
              validYields.push({
                yield: yieldInfo.avgYield,
                crop: yieldInfo.crop,
                pointCount: yieldInfo.pointCount
              });
            }
          });

          if (validYields.length > 0) {
            const avgYield = validYields.reduce((sum, v) => sum + v.yield, 0) / validYields.length;
            dataPoints.push({
              ...sample,
              yieldYear: 'avg',
              avgYield: avgYield,
              crop: validYields[0].crop,
              yieldPointCount: validYields.reduce((sum, v) => sum + v.pointCount, 0),
              yearsAveraged: validYields.length
            });
          }
        });
      } else if (yearFilter === 'combined') {
        // ALL YEARS (COMBINED): Each year is a separate data point
        samplesWithYield.forEach(sample => {
          Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
            if (cropFilter === 'all' || yieldInfo.crop === cropFilter) {
              dataPoints.push({
                ...sample,
                yieldYear: parseInt(year),
                avgYield: yieldInfo.avgYield,
                crop: yieldInfo.crop,
                yieldPointCount: yieldInfo.pointCount
              });
            }
          });
        });
      } else {
        // SPECIFIC YEAR: Only use yield from that year
        samplesWithYield.forEach(sample => {
          const yieldInfo = sample.yieldCorrelations[yearFilter];
          if (yieldInfo && (cropFilter === 'all' || yieldInfo.crop === cropFilter)) {
            dataPoints.push({
              ...sample,
              yieldYear: parseInt(yearFilter),
              avgYield: yieldInfo.avgYield,
              crop: yieldInfo.crop,
              yieldPointCount: yieldInfo.pointCount
            });
          }
        });
      }

      if (dataPoints.length === 0) {
        container.innerHTML = '<div class="no-data">No matching yield data for selected filters.</div>';
        return;
      }

      // Calculate correlations for each nutrient
      const visibleNutrients = getVisibleNutrients();
      const correlations = [];

      console.log('=== YIELD CORRELATION DEBUG ===');
      console.log('Year filter:', yearFilter);
      console.log('Data points:', dataPoints.length);
      console.log('Unique locations:', uniqueLocations);

      visibleNutrients.forEach(nutrient => {
        // Filter for valid numeric values - must handle strings, empty values, etc.
        const pairs = dataPoints.filter(d => {
          const val = d[nutrient];
          if (val === undefined || val === null || val === '') return false;
          const num = parseFloat(val);
          return isFinite(num);
        });
        console.log(`  ${nutrient}: ${pairs.length} valid pairs (need 5+)`);
        if (pairs.length < 5) return; // Need at least 5 points

        const correlation = calculateCorrelation(
          pairs.map(p => parseFloat(p[nutrient])),
          pairs.map(p => p.avgYield)
        );

        if (correlation !== null && !isNaN(correlation.r)) {
          correlations.push({
            nutrient,
            name: CONFIG.NUTRIENT_NAMES[nutrient] || nutrient,
            r: correlation.r,
            r2: correlation.r2,
            n: pairs.length,
            significance: getSignificance(correlation.r, pairs.length)
          });
        }
      });

      // Store correlations globally for re-sorting
      yieldCorrelationsData = correlations;

      // Apply current sort
      sortYieldCorrelations();

      // Get summary stats
      const avgYield = dataPoints.reduce((sum, d) => sum + d.avgYield, 0) / dataPoints.length;
      const crops = [...new Set(dataPoints.map(d => d.crop))];
      const usedYieldYears = yearFilter === 'avg' || yearFilter === 'combined'
        ? sortedYieldYears
        : [parseInt(yearFilter)];

      // Get yield search radius values for selected crop only
      const radiusValues = new Set();
      samplesWithYield.forEach(sample => {
        Object.values(sample.yieldCorrelations).forEach(yieldInfo => {
          if (yieldInfo.radiusFt && yieldInfo.crop === cropFilter) {
            radiusValues.add(yieldInfo.radiusFt);
          }
        });
      });
      const radiusNote = radiusValues.size > 0
        ? `<br><strong>Yield Search Radius (${cropFilter}):</strong> ${[...radiusValues].sort((a,b) => a-b).join(', ')} ft`
        : '';

      const getSortIcon = (col) => {
        if (yieldSortColumn !== col) return '<span style="opacity: 0.3; font-size: 0.75rem;">&#9650;&#9660;</span>';
        return yieldSortDirection === 'asc' ? '<span style="color: #3b82f6;">&#9650;</span>' : '<span style="color: #3b82f6;">&#9660;</span>';
      };

      // Build description based on mode
      let modeDescription = '';
      if (yearFilter === 'avg') {
        modeDescription = `<div style="font-size: 0.8rem; color: #64748b;">${uniqueLocations} locations √ó avg of ${sortedYieldYears.length} yield years</div>`;
      } else if (yearFilter === 'combined') {
        modeDescription = `<div style="font-size: 0.8rem; color: #64748b;">${uniqueLocations} locations √ó ${sortedYieldYears.length} yield years</div>`;
      } else {
        modeDescription = `<div style="font-size: 0.8rem; color: #64748b;">${dataPoints.length} locations with ${yearFilter} yield</div>`;
      }

      let html = `
        <div style="background: #f0f9ff; border: 1px solid #0ea5e9; border-radius: 0.5rem; padding: 0.75rem; margin-bottom: 1rem; font-size: 0.8rem; color: #0369a1;">
          <strong>Data Selection:</strong><br>
          <strong>Soil Samples:</strong> ${soilYearDescription} (${soilYearRange})<br>
          <strong>Yield Years:</strong> ${usedYieldYears.join(', ')}
          ${yearFilter === 'avg' ? ' <em>(averaged at each location)</em>' : yearFilter === 'combined' ? ' <em>(each year = separate data point)</em>' : ''}${radiusNote}
        </div>

        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1.5rem;">
          <div style="background: #fef3c7; border: 2px solid #f59e0b; border-radius: 0.5rem; padding: 1rem; text-align: center;">
            <div style="font-size: 2rem; font-weight: 700; color: #92400e;">${dataPoints.length}</div>
            <div style="color: #92400e; font-size: 0.875rem;">Data Points</div>
            ${modeDescription}
          </div>
          <div style="background: #f0fdf4; border: 2px solid #22c55e; border-radius: 0.5rem; padding: 1rem; text-align: center;">
            <div style="font-size: 2rem; font-weight: 700; color: #166534;">${avgYield.toFixed(1)}</div>
            <div style="color: #166534; font-size: 0.875rem;">Avg Yield (bu/ac)</div>
          </div>
          <div style="background: #eff6ff; border: 2px solid #3b82f6; border-radius: 0.5rem; padding: 1rem; text-align: center;">
            <div style="font-size: 1.25rem; font-weight: 600; color: #1e40af;">${crops.map(c => c === 'corn' ? 'üåΩ' : 'ü´ò').join(' ')}</div>
            <div style="color: #1e40af; font-size: 0.875rem;">Yield Years: ${usedYieldYears.join(', ')}</div>
          </div>
        </div>

        <h3 style="margin: 0 0 1rem 0; color: #1e293b;">Nutrient-Yield Correlations</h3>
        <p style="color: #64748b; font-size: 0.875rem; margin-bottom: 0.5rem;">Shows how each soil nutrient correlates with crop yield at matched sample locations. Click column headers to sort.</p>
        <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 0.375rem; padding: 0.75rem; margin-bottom: 1rem; font-size: 0.8rem; color: #475569;">
          <strong>How to read this table:</strong><br>
          <strong>r (Correlation)</strong> ranges from -1 to +1. Positive = higher nutrient, higher yield. Negative = higher nutrient, lower yield. Values closer to +/-1 indicate stronger relationships.<br>
          <strong>R¬≤ (R-squared)</strong> shows what % of yield variation is explained by this nutrient. Example: R¬≤=25% means 25% of yield differences can be attributed to this nutrient.<br>
          <strong>Significance:</strong> *** = strong (|r| > 0.7), ** = moderate (|r| > 0.4), * = weak (|r| > 0.2), - = no meaningful correlation
        </div>

        <table class="rankings-table" id="yieldCorrelationTable">
          <thead>
            <tr>
              <th class="sortable-header" onclick="sortYieldTable('name')" style="cursor: pointer;">Nutrient ${getSortIcon('name')}</th>
              <th class="sortable-header" onclick="sortYieldTable('r')" style="cursor: pointer;">Correlation (r) ${getSortIcon('r')}</th>
              <th class="sortable-header" onclick="sortYieldTable('r2')" style="cursor: pointer;">R¬≤ ${getSortIcon('r2')}</th>
              <th class="sortable-header" onclick="sortYieldTable('significance')" style="cursor: pointer;">Significance ${getSortIcon('significance')}</th>
              <th class="sortable-header" onclick="sortYieldTable('n')" style="cursor: pointer;">Samples ${getSortIcon('n')}</th>
            </tr>
          </thead>
          <tbody id="yieldCorrelationBody">
      `;

      html += renderYieldCorrelationRows();

      html += '</tbody></table>';

      if (yieldCorrelationsData.length === 0) {
        html = '<div class="no-data">Not enough data points to calculate correlations. Need at least 5 samples with yield data.</div>';
      }

      container.innerHTML = html;

      // Initialize scatter plot
      populateScatterSelect();
      drawScatterPlot();
    }

    function calculateCorrelation(x, y) {
      const n = x.length;
      if (n < 3) return null;
      
      const sumX = x.reduce((a, b) => a + b, 0);
      const sumY = y.reduce((a, b) => a + b, 0);
      const sumXY = x.reduce((total, xi, i) => total + xi * y[i], 0);
      const sumX2 = x.reduce((total, xi) => total + xi * xi, 0);
      const sumY2 = y.reduce((total, yi) => total + yi * yi, 0);
      
      const numerator = n * sumXY - sumX * sumY;
      const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
      
      if (denominator === 0) return null;
      
      const r = numerator / denominator;
      return { r, r2: r * r };
    }
    
    function getSignificance(r, n) {
      // Simplified significance based on r value and sample size
      const absR = Math.abs(r);
      if (n < 10) return 'insufficient';
      if (absR > 0.7) return 'high';
      if (absR > 0.4) return 'medium';
      if (absR > 0.2) return 'low';
      return 'none';
    }

    // Sort the yield correlations data array
    function sortYieldCorrelations() {
      const sigOrder = { 'high': 3, 'medium': 2, 'low': 1, 'none': 0, 'insufficient': -1 };

      yieldCorrelationsData.sort((a, b) => {
        let aVal, bVal;

        switch (yieldSortColumn) {
          case 'name':
            aVal = a.name.toLowerCase();
            bVal = b.name.toLowerCase();
            return yieldSortDirection === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
          case 'r':
            // Sort by absolute value for correlation
            aVal = Math.abs(a.r);
            bVal = Math.abs(b.r);
            break;
          case 'r2':
            aVal = a.r2;
            bVal = b.r2;
            break;
          case 'significance':
            aVal = sigOrder[a.significance] || 0;
            bVal = sigOrder[b.significance] || 0;
            break;
          case 'n':
            aVal = a.n;
            bVal = b.n;
            break;
          default:
            aVal = Math.abs(a.r);
            bVal = Math.abs(b.r);
        }

        if (yieldSortDirection === 'asc') {
          return aVal - bVal;
        } else {
          return bVal - aVal;
        }
      });
    }

    // Render just the table rows (for re-sorting without rebuilding header)
    function renderYieldCorrelationRows() {
      let rows = '';
      yieldCorrelationsData.forEach(c => {
        const color = c.r > 0 ? '#22c55e' : '#ef4444';
        const barWidth = Math.abs(c.r) * 100;
        const significance = c.significance === 'high' ? '***' : c.significance === 'medium' ? '**' : c.significance === 'low' ? '*' : '-';
        const sigColor = c.significance === 'high' ? '#22c55e' : c.significance === 'medium' ? '#f59e0b' : '#94a3b8';

        rows += `
          <tr>
            <td class="field">${c.name}</td>
            <td>
              <div style="display: flex; align-items: center; gap: 0.5rem;">
                <div style="width: 80px; height: 12px; background: #e2e8f0; border-radius: 6px; overflow: hidden;">
                  <div style="width: ${barWidth}%; height: 100%; background: ${color}; ${c.r < 0 ? 'margin-left: auto;' : ''}"></div>
                </div>
                <span style="font-weight: 600; color: ${color};">${c.r > 0 ? '+' : ''}${c.r.toFixed(3)}</span>
              </div>
            </td>
            <td>${(c.r2 * 100).toFixed(1)}%</td>
            <td style="color: ${sigColor};">${significance}</td>
            <td>${c.n}</td>
          </tr>
        `;
      });
      return rows;
    }

    // Handle column header click to sort (attached to window for inline onclick)
    window.sortYieldTable = function(column) {
      if (yieldSortColumn === column) {
        // Toggle direction if same column
        yieldSortDirection = yieldSortDirection === 'asc' ? 'desc' : 'asc';
      } else {
        // New column, default to desc (highest first)
        yieldSortColumn = column;
        yieldSortDirection = 'desc';
      }

      // Re-run the full update to rebuild with new sort
      updateYieldAnalysis();
    };

    // ========== SCATTER PLOT & DEBUG ==========
    let currentYieldDataPoints = []; // Store for scatter plot

    function populateScatterSelect() {
      const select = document.getElementById('scatterNutrientSelect');
      const visibleNutrients = getVisibleNutrients();
      select.innerHTML = visibleNutrients.map(n =>
        `<option value="${n}"${n === 'P' ? ' selected' : ''}>${CONFIG.NUTRIENT_NAMES[n] || n}</option>`
      ).join('');
    }

    function getYieldDataPoints() {
      const cropFilter = document.getElementById('yieldCropSelect').value;
      const yearFilter = document.getElementById('yieldYearSelect').value;
      const fieldFilter = document.getElementById('yieldFieldSelect').value;

      let samplesWithYield = sampleData.filter(s => s.yieldCorrelations && Object.keys(s.yieldCorrelations).length > 0);
      if (fieldFilter !== 'all') samplesWithYield = samplesWithYield.filter(s => s.field === fieldFilter);

      const locationMap = new Map();
      samplesWithYield.forEach(sample => {
        const locKey = `${sample.lat.toFixed(5)},${sample.lon.toFixed(5)}`;
        const existing = locationMap.get(locKey);
        if (!existing || (sample.year && sample.year > existing.year)) {
          locationMap.set(locKey, sample);
        }
      });
      samplesWithYield = Array.from(locationMap.values());

      const dataPoints = [];

      if (yearFilter === 'avg') {
        // ALL YEARS (AVERAGE): Average yield across all years at each location
        samplesWithYield.forEach(sample => {
          const validYields = [];
          Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
            if (cropFilter === 'all' || yieldInfo.crop === cropFilter) {
              validYields.push({
                yield: yieldInfo.avgYield,
                crop: yieldInfo.crop,
                pointCount: yieldInfo.pointCount
              });
            }
          });
          if (validYields.length > 0) {
            const avgYield = validYields.reduce((sum, v) => sum + v.yield, 0) / validYields.length;
            dataPoints.push({
              ...sample,
              yieldYear: 'avg',
              avgYield: avgYield,
              crop: validYields[0].crop,
              yieldPointCount: validYields.reduce((sum, v) => sum + v.pointCount, 0),
              yearsAveraged: validYields.length
            });
          }
        });
      } else if (yearFilter === 'combined') {
        // ALL YEARS (COMBINED): Each year is a separate data point
        samplesWithYield.forEach(sample => {
          Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
            if (cropFilter === 'all' || yieldInfo.crop === cropFilter) {
              dataPoints.push({
                ...sample,
                yieldYear: parseInt(year),
                avgYield: yieldInfo.avgYield,
                crop: yieldInfo.crop,
                yieldPointCount: yieldInfo.pointCount
              });
            }
          });
        });
      } else {
        // SPECIFIC YEAR: Only use yield from that year
        samplesWithYield.forEach(sample => {
          const yieldInfo = sample.yieldCorrelations[yearFilter];
          if (yieldInfo && (cropFilter === 'all' || yieldInfo.crop === cropFilter)) {
            dataPoints.push({
              ...sample,
              yieldYear: parseInt(yearFilter),
              avgYield: yieldInfo.avgYield,
              crop: yieldInfo.crop,
              yieldPointCount: yieldInfo.pointCount
            });
          }
        });
      }
      return dataPoints;
    }

    // Scatter plot axis state
    let scatterAxesFlipped = false;

    function toggleScatterAxes() {
      scatterAxesFlipped = !scatterAxesFlipped;
      const btn = document.getElementById('swapAxesBtn');
      const title = document.getElementById('scatterTitle');
      const nutrient = document.getElementById('scatterNutrientSelect').value;
      const nutrientName = CONFIG.NUTRIENT_NAMES[nutrient] || nutrient;

      if (scatterAxesFlipped) {
        btn.style.background = '#3b82f6';
        btn.style.color = 'white';
        title.textContent = `Scatter Plot: Yield vs ${nutrientName}`;
      } else {
        btn.style.background = '#eff6ff';
        btn.style.color = '#1d4ed8';
        title.textContent = `Scatter Plot: ${nutrientName} vs Yield`;
      }
      drawScatterPlot();
    }

    // Threshold slider sync functions
    function updateThresholdDisplay() {
      const slider = document.getElementById('yieldThresholdSlider');
      const input = document.getElementById('yieldThresholdInput');
      input.value = slider.value;
    }

    function syncThresholdSlider() {
      const slider = document.getElementById('yieldThresholdSlider');
      const input = document.getElementById('yieldThresholdInput');
      slider.value = Math.max(100, Math.min(400, input.value));
    }

    function drawScatterPlot() {
      const canvas = document.getElementById('scatterCanvas');
      const ctx = canvas.getContext('2d');
      const nutrient = document.getElementById('scatterNutrientSelect').value;
      const yieldThreshold = parseFloat(document.getElementById('yieldThresholdInput').value) || 200;
      const dataPoints = getYieldDataPoints();

      // Filter for valid data
      const validPoints = dataPoints.filter(d => {
        const val = d[nutrient];
        if (val === undefined || val === null || val === '') return false;
        return isFinite(parseFloat(val));
      });

      // Clear canvas
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      if (validPoints.length < 3) {
        ctx.fillStyle = '#64748b';
        ctx.font = '14px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('Not enough data points', canvas.width / 2, canvas.height / 2);
        document.getElementById('thresholdContent').innerHTML = '<p style="color: #94a3b8;">Not enough data</p>';
        return;
      }

      // Get data ranges - swap if axes are flipped
      const nutrientValues = validPoints.map(p => parseFloat(p[nutrient]));
      const yieldValues = validPoints.map(p => p.avgYield);

      // When flipped: X = Yield, Y = Nutrient
      const xValues = scatterAxesFlipped ? yieldValues : nutrientValues;
      const yValues = scatterAxesFlipped ? nutrientValues : yieldValues;
      const xMin = Math.min(...xValues);
      const xMax = Math.max(...xValues);
      const yMin = Math.min(...yValues);
      const yMax = Math.max(...yValues);

      // Labels for axes
      const nutrientName = CONFIG.NUTRIENT_NAMES[nutrient] || nutrient;
      const xLabel = scatterAxesFlipped ? 'Yield (bu/ac)' : nutrientName;
      const yLabel = scatterAxesFlipped ? nutrientName : 'Yield (bu/ac)';

      // Padding for axes
      const padding = { left: 70, right: 40, top: 40, bottom: 60 };
      const plotWidth = canvas.width - padding.left - padding.right;
      const plotHeight = canvas.height - padding.top - padding.bottom;

      // Scale functions
      const xScale = (val) => padding.left + ((val - xMin) / (xMax - xMin || 1)) * plotWidth;
      const yScale = (val) => canvas.height - padding.bottom - ((val - yMin) / (yMax - yMin || 1)) * plotHeight;

      // Calculate regression
      const n = xValues.length;
      const meanX = xValues.reduce((a, b) => a + b, 0) / n;
      const meanY = yValues.reduce((a, b) => a + b, 0) / n;
      const ssX = xValues.reduce((sum, xi) => sum + (xi - meanX) ** 2, 0);
      const ssY = yValues.reduce((sum, yi) => sum + (yi - meanY) ** 2, 0);
      const ssXY = xValues.reduce((sum, xi, i) => sum + (xi - meanX) * (yValues[i] - meanY), 0);
      const slope = ssX > 0 ? ssXY / ssX : 0;
      const intercept = meanY - slope * meanX;
      const correlation = calculateCorrelation(xValues, yValues);
      const r = correlation ? correlation.r : 0;
      const r2 = r * r;

      // Calculate standard error for confidence bands
      const predictions = xValues.map(x => slope * x + intercept);
      const residuals = yValues.map((y, i) => y - predictions[i]);
      const sse = residuals.reduce((sum, r) => sum + r * r, 0);
      const mse = sse / (n - 2);
      const se = Math.sqrt(mse);

      // Draw axes
      ctx.strokeStyle = '#cbd5e1';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding.left, padding.top);
      ctx.lineTo(padding.left, canvas.height - padding.bottom);
      ctx.lineTo(canvas.width - padding.right, canvas.height - padding.bottom);
      ctx.stroke();

      // Draw grid lines
      ctx.strokeStyle = '#f1f5f9';
      ctx.lineWidth = 1;
      for (let i = 0; i <= 5; i++) {
        const y = padding.top + (i * plotHeight / 5);
        ctx.beginPath();
        ctx.moveTo(padding.left, y);
        ctx.lineTo(canvas.width - padding.right, y);
        ctx.stroke();
        const x = padding.left + (i * plotWidth / 5);
        ctx.beginPath();
        ctx.moveTo(x, padding.top);
        ctx.lineTo(x, canvas.height - padding.bottom);
        ctx.stroke();
      }

      // Draw confidence bands (95% CI)
      if (n > 5 && ssX > 0) {
        const tValue = 1.96; // ~95% CI
        ctx.fillStyle = 'rgba(59, 130, 246, 0.1)';
        ctx.beginPath();
        const bandPoints = 50;
        // Upper band
        for (let i = 0; i <= bandPoints; i++) {
          const x = xMin + (i / bandPoints) * (xMax - xMin);
          const yPred = slope * x + intercept;
          const seY = se * Math.sqrt(1 + 1/n + (x - meanX)**2 / ssX);
          const yUpper = yPred + tValue * seY;
          const px = xScale(x);
          const py = yScale(Math.min(yMax * 1.1, Math.max(yMin * 0.9, yUpper)));
          if (i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        // Lower band (reverse)
        for (let i = bandPoints; i >= 0; i--) {
          const x = xMin + (i / bandPoints) * (xMax - xMin);
          const yPred = slope * x + intercept;
          const seY = se * Math.sqrt(1 + 1/n + (x - meanX)**2 / ssX);
          const yLower = yPred - tValue * seY;
          const px = xScale(x);
          const py = yScale(Math.min(yMax * 1.1, Math.max(yMin * 0.9, yLower)));
          ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();
      }

      // Draw yield threshold line (vertical when flipped, horizontal when normal)
      if (scatterAxesFlipped) {
        // Flipped: X = Yield, so threshold is a vertical line
        if (yieldThreshold >= xMin && yieldThreshold <= xMax) {
          const thresholdX = xScale(yieldThreshold);
          ctx.strokeStyle = '#f59e0b';
          ctx.lineWidth = 2;
          ctx.setLineDash([8, 4]);
          ctx.beginPath();
          ctx.moveTo(thresholdX, padding.top);
          ctx.lineTo(thresholdX, canvas.height - padding.bottom);
          ctx.stroke();
          ctx.setLineDash([]);

          // Label the threshold line
          ctx.fillStyle = '#92400e';
          ctx.font = 'bold 12px system-ui';
          ctx.save();
          ctx.translate(thresholdX + 5, padding.top + 60);
          ctx.rotate(Math.PI / 2);
          ctx.textAlign = 'left';
          ctx.fillText(`${yieldThreshold} bu/ac threshold`, 0, 0);
          ctx.restore();
        }
      } else {
        // Normal: Y = Yield, so threshold is a horizontal line
        if (yieldThreshold >= yMin && yieldThreshold <= yMax) {
          const thresholdY = yScale(yieldThreshold);
          ctx.strokeStyle = '#f59e0b';
          ctx.lineWidth = 2;
          ctx.setLineDash([8, 4]);
          ctx.beginPath();
          ctx.moveTo(padding.left, thresholdY);
          ctx.lineTo(canvas.width - padding.right, thresholdY);
          ctx.stroke();
          ctx.setLineDash([]);

          // Label the threshold line
          ctx.fillStyle = '#92400e';
          ctx.font = 'bold 12px system-ui';
          ctx.textAlign = 'left';
          ctx.fillText(`${yieldThreshold} bu/ac threshold`, padding.left + 5, thresholdY - 5);
        }
      }

      // Separate points above/below threshold (always based on yield, not axis position)
      const aboveThreshold = validPoints.filter(p => p.avgYield >= yieldThreshold);
      const belowThreshold = validPoints.filter(p => p.avgYield < yieldThreshold);

      // Draw points below threshold (gray/muted)
      belowThreshold.forEach(p => {
        const px = scatterAxesFlipped ? xScale(p.avgYield) : xScale(parseFloat(p[nutrient]));
        const py = scatterAxesFlipped ? yScale(parseFloat(p[nutrient])) : yScale(p.avgYield);
        ctx.beginPath();
        ctx.arc(px, py, 4, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(148, 163, 184, 0.4)';
        ctx.fill();
        ctx.strokeStyle = '#94a3b8';
        ctx.lineWidth = 1;
        ctx.stroke();
      });

      // Draw points above threshold (highlighted)
      aboveThreshold.forEach(p => {
        const px = scatterAxesFlipped ? xScale(p.avgYield) : xScale(parseFloat(p[nutrient]));
        const py = scatterAxesFlipped ? yScale(parseFloat(p[nutrient])) : yScale(p.avgYield);
        ctx.beginPath();
        ctx.arc(px, py, 6, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(34, 197, 94, 0.7)';
        ctx.fill();
        ctx.strokeStyle = '#16a34a';
        ctx.lineWidth = 2;
        ctx.stroke();
      });

      // Draw trend line
      if (ssX > 0) {
        const y1 = slope * xMin + intercept;
        const y2 = slope * xMax + intercept;

        ctx.strokeStyle = '#3b82f6';
        ctx.lineWidth = 2.5;
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.moveTo(xScale(xMin), yScale(y1));
        ctx.lineTo(xScale(xMax), yScale(y2));
        ctx.stroke();
      }

      // Draw axis labels
      ctx.fillStyle = '#64748b';
      ctx.font = '12px system-ui';
      ctx.textAlign = 'center';

      // X-axis labels (format based on what's on X axis)
      for (let i = 0; i <= 5; i++) {
        const val = xMin + (i * (xMax - xMin) / 5);
        const x = xScale(val);
        ctx.fillText(scatterAxesFlipped ? val.toFixed(0) : val.toFixed(1), x, canvas.height - padding.bottom + 20);
      }
      ctx.font = 'bold 13px system-ui';
      ctx.fillText(xLabel, canvas.width / 2, canvas.height - 12);

      // Y-axis labels (format based on what's on Y axis)
      ctx.font = '12px system-ui';
      ctx.textAlign = 'right';
      for (let i = 0; i <= 5; i++) {
        const val = yMin + (i * (yMax - yMin) / 5);
        const y = yScale(val);
        ctx.fillText(scatterAxesFlipped ? val.toFixed(1) : val.toFixed(0), padding.left - 10, y + 4);
      }
      ctx.save();
      ctx.translate(18, canvas.height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.textAlign = 'center';
      ctx.font = 'bold 13px system-ui';
      ctx.fillText(yLabel, 0, 0);
      ctx.restore();

      // Draw equation and R¬≤ on chart
      ctx.fillStyle = '#1e293b';
      ctx.font = 'bold 13px system-ui';
      ctx.textAlign = 'left';
      const eqY = padding.top + 20;
      const slopeSign = slope >= 0 ? '+' : '';
      ctx.fillText(`y = ${slope.toFixed(2)}x ${slopeSign}${intercept.toFixed(1)}`, padding.left + 10, eqY);
      ctx.fillText(`R¬≤ = ${(r2 * 100).toFixed(1)}%`, padding.left + 10, eqY + 18);
      ctx.font = '12px system-ui';
      ctx.fillStyle = '#64748b';
      ctx.fillText(`n = ${n}`, padding.left + 10, eqY + 36);

      // Draw legend
      const legendX = canvas.width - padding.right - 180;
      const legendY = padding.top + 10;
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.fillRect(legendX - 10, legendY - 5, 190, 85);
      ctx.strokeStyle = '#e2e8f0';
      ctx.lineWidth = 1;
      ctx.strokeRect(legendX - 10, legendY - 5, 190, 85);

      ctx.font = '11px system-ui';
      ctx.textAlign = 'left';

      // Above threshold legend
      ctx.beginPath();
      ctx.arc(legendX + 6, legendY + 10, 5, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(34, 197, 94, 0.7)';
      ctx.fill();
      ctx.strokeStyle = '#16a34a';
      ctx.stroke();
      ctx.fillStyle = '#1e293b';
      ctx.fillText(`Above ${yieldThreshold} bu/ac (${aboveThreshold.length})`, legendX + 18, legendY + 14);

      // Below threshold legend
      ctx.beginPath();
      ctx.arc(legendX + 6, legendY + 30, 4, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(148, 163, 184, 0.4)';
      ctx.fill();
      ctx.strokeStyle = '#94a3b8';
      ctx.stroke();
      ctx.fillStyle = '#64748b';
      ctx.fillText(`Below ${yieldThreshold} bu/ac (${belowThreshold.length})`, legendX + 18, legendY + 34);

      // Trend line legend
      ctx.strokeStyle = '#3b82f6';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(legendX, legendY + 50);
      ctx.lineTo(legendX + 20, legendY + 50);
      ctx.stroke();
      ctx.fillStyle = '#1e293b';
      ctx.fillText('Trend line', legendX + 28, legendY + 54);

      // Confidence band legend
      ctx.fillStyle = 'rgba(59, 130, 246, 0.3)';
      ctx.fillRect(legendX, legendY + 63, 20, 10);
      ctx.fillStyle = '#64748b';
      ctx.fillText('95% prediction interval', legendX + 28, legendY + 72);

      // Update threshold analysis panel
      updateThresholdAnalysis(nutrient, validPoints, yieldThreshold, aboveThreshold, belowThreshold, scatterAxesFlipped);

      // Update stats bar
      const statsDiv = document.getElementById('scatterStats');
      const corrDirection = r >= 0 ? '‚Üó Positive' : '‚Üò Negative';
      const corrColor = r >= 0 ? '#16a34a' : '#dc2626';
      const nutrientMin = Math.min(...nutrientValues);
      const nutrientMax = Math.max(...nutrientValues);
      const yieldMin = Math.min(...yieldValues);
      const yieldMax = Math.max(...yieldValues);
      const axisNote = scatterAxesFlipped
        ? '<span style="color: #3b82f6; font-weight: 600;">[Axes Flipped: X=Yield, Y=Nutrient]</span>'
        : '';
      statsDiv.innerHTML = `
        <strong>${nutrientName}:</strong>
        n=${validPoints.length} |
        r=${r.toFixed(3)} |
        R¬≤=${(r2 * 100).toFixed(1)}% |
        ${nutrient} Range: ${nutrientMin.toFixed(1)} - ${nutrientMax.toFixed(1)} |
        Yield Range: ${yieldMin.toFixed(0)} - ${yieldMax.toFixed(0)} bu/ac |
        <span style="color: ${corrColor};">${corrDirection} correlation</span>
        ${axisNote}
      `;
    }

    function updateThresholdAnalysis(nutrient, validPoints, threshold, aboveThreshold, belowThreshold, isFlipped = false) {
      const content = document.getElementById('thresholdContent');
      const nutrientName = CONFIG.NUTRIENT_NAMES[nutrient] || nutrient;

      if (aboveThreshold.length === 0) {
        content.innerHTML = `
          <p style="color: #dc2626; font-weight: 600;">No samples above ${threshold} bu/ac</p>
          <p>Try lowering the yield threshold to analyze high-yielding samples.</p>
        `;
        return;
      }

      // Calculate stats for points above threshold
      const aboveNutrientValues = aboveThreshold.map(p => parseFloat(p[nutrient]));
      const minAbove = Math.min(...aboveNutrientValues);
      const maxAbove = Math.max(...aboveNutrientValues);
      const avgAbove = aboveNutrientValues.reduce((a, b) => a + b, 0) / aboveNutrientValues.length;
      const sortedAbove = [...aboveNutrientValues].sort((a, b) => a - b);
      const p10Above = sortedAbove[Math.floor(sortedAbove.length * 0.1)] || minAbove;

      // Calculate stats for points below threshold
      let belowStats = '';
      if (belowThreshold.length > 0) {
        const belowNutrientValues = belowThreshold.map(p => parseFloat(p[nutrient]));
        const avgBelow = belowNutrientValues.reduce((a, b) => a + b, 0) / belowNutrientValues.length;
        const diff = avgAbove - avgBelow;
        const diffPct = avgBelow > 0 ? ((diff / avgBelow) * 100).toFixed(0) : 'N/A';
        belowStats = `
          <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #e2e8f0;">
            <div style="font-weight: 600; color: #64748b; margin-bottom: 0.5rem;">Below ${threshold} bu/ac:</div>
            <div>Avg ${nutrient}: <strong>${avgBelow.toFixed(1)}</strong></div>
            <div style="margin-top: 0.5rem; color: ${diff >= 0 ? '#16a34a' : '#dc2626'};">
              Difference: ${diff >= 0 ? '+' : ''}${diff.toFixed(1)} (${diffPct}%)
            </div>
          </div>
        `;
      }

      // Different interpretation based on axis orientation
      const interpretationText = isFlipped
        ? `<strong>Key insight:</strong> At yields ‚â•${threshold} bu/ac, ${nutrient} levels ranged from <strong>${minAbove.toFixed(1)}</strong> to <strong>${maxAbove.toFixed(1)}</strong>. The minimum ${nutrient} observed at this yield level was <strong>${minAbove.toFixed(1)}</strong> - you never see ${nutrient} below this at high yields.`
        : `<strong>Interpretation:</strong> For high yields (‚â•${threshold} bu/ac), the minimum ${nutrientName} observed was <strong>${minAbove.toFixed(1)}</strong>. This suggests ${nutrient} levels below this may limit yield potential.`;

      content.innerHTML = `
        ${isFlipped ? '<div style="background: #eff6ff; border: 1px solid #3b82f6; border-radius: 0.375rem; padding: 0.5rem; margin-bottom: 0.75rem; font-size: 0.75rem; color: #1d4ed8;"><strong>Flipped View:</strong> X=Yield, Y=${nutrientName}. Look left of the threshold line to see nutrient levels at high yields.</div>' : ''}
        <div style="background: #f0fdf4; border: 1px solid #22c55e; border-radius: 0.375rem; padding: 0.75rem; margin-bottom: 0.75rem;">
          <div style="font-weight: 700; color: #166534; margin-bottom: 0.5rem;">
            üéØ For yields ‚â• ${threshold} bu/ac:
          </div>
          <div style="font-size: 0.8rem; color: #166534;">
            <strong>Minimum ${nutrient}:</strong> ${minAbove.toFixed(1)}<br>
            <strong>10th percentile:</strong> ${p10Above.toFixed(1)}<br>
            <strong>Average ${nutrient}:</strong> ${avgAbove.toFixed(1)}<br>
            <strong>Maximum ${nutrient}:</strong> ${maxAbove.toFixed(1)}
          </div>
        </div>

        <div style="font-size: 0.8rem; color: #475569;">
          <strong>${aboveThreshold.length}</strong> samples above threshold<br>
          <strong>${belowThreshold.length}</strong> samples below threshold
        </div>

        ${belowStats}

        <div style="margin-top: 0.75rem; padding: 0.5rem; background: #fef3c7; border-radius: 0.25rem; font-size: 0.75rem; color: #92400e;">
          ${interpretationText}
        </div>
      `;
    }

    // Toggle yield debug panel
    function toggleYieldDebug() {
      const panel = document.getElementById('yieldDebugPanel');
      const content = document.getElementById('yieldDebugContent');

      if (panel.style.display === 'none') {
        content.textContent = generateDebugReport();
        panel.style.display = 'block';
      } else {
        panel.style.display = 'none';
      }
    }

    // Generate comprehensive debug report for yield correlation verification
    function generateDebugReport() {
      const cropFilter = document.getElementById('yieldCropSelect').value;
      const yearFilter = document.getElementById('yieldYearSelect').value;
      const soilYearFilter = document.getElementById('soilYearSelect').value;
      const fieldFilter = document.getElementById('yieldFieldSelect').value;

      let report = [];
      report.push('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
      report.push('‚ïë               YIELD CORRELATION VERIFICATION REPORT                ‚ïë');
      report.push('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
      report.push('');

      // Get samples with yield correlations
      let samplesWithYield = sampleData.filter(s => s.yieldCorrelations && Object.keys(s.yieldCorrelations).length > 0);

      report.push(`FILTERS APPLIED:`);
      report.push(`  Crop: ${cropFilter}`);
      report.push(`  Yield Year: ${yearFilter}`);
      report.push(`  Soil Sample Year: ${soilYearFilter}`);
      report.push(`  Field: ${fieldFilter}`);
      report.push('');

      // Filter by field
      if (fieldFilter !== 'all') {
        samplesWithYield = samplesWithYield.filter(s => s.field === fieldFilter);
      }

      // Filter by soil sample year
      let soilYearDescription = '';
      if (soilYearFilter === 'recent') {
        // Use only most recent soil sample at each location
        const locationMap = new Map();
        samplesWithYield.forEach(sample => {
          const locKey = `${sample.lat.toFixed(5)},${sample.lon.toFixed(5)}`;
          const existing = locationMap.get(locKey);
          if (!existing || (sample.year && sample.year > existing.year)) {
            locationMap.set(locKey, sample);
          }
        });
        samplesWithYield = Array.from(locationMap.values());
        soilYearDescription = 'Most recent at each location';
      } else if (soilYearFilter === 'all') {
        soilYearDescription = 'All years (may include duplicates)';
      } else {
        const selectedYear = parseInt(soilYearFilter);
        samplesWithYield = samplesWithYield.filter(s => s.year === selectedYear);
        soilYearDescription = `${selectedYear} only`;
      }

      report.push(`STEP 1: DATA SELECTION`);
      report.push(`  Total samples in database: ${sampleData.length}`);
      report.push(`  Samples with yield data: ${samplesWithYield.length}`);
      report.push(`  Soil year filter: ${soilYearDescription}`);
      report.push('');

      // Build data points based on yearFilter mode
      const dataPoints = [];

      if (yearFilter === 'avg') {
        samplesWithYield.forEach(sample => {
          const validYields = [];
          Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
            if (cropFilter === 'all' || yieldInfo.crop === cropFilter) {
              validYields.push({ yield: yieldInfo.avgYield, year: year });
            }
          });
          if (validYields.length > 0) {
            const avgYield = validYields.reduce((sum, v) => sum + v.yield, 0) / validYields.length;
            dataPoints.push({ ...sample, avgYield: avgYield, yearsUsed: validYields.map(v => v.year).join(',') });
          }
        });
        report.push(`STEP 2: MULTI-YEAR AVERAGING`);
        report.push(`  Mode: All Years (Average) - averaging yield across years at each location`);
        report.push(`  Resulting data points: ${dataPoints.length}`);
      } else if (yearFilter === 'combined') {
        samplesWithYield.forEach(sample => {
          Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
            if (cropFilter === 'all' || yieldInfo.crop === cropFilter) {
              dataPoints.push({ ...sample, avgYield: yieldInfo.avgYield, yieldYear: year });
            }
          });
        });
        report.push(`STEP 2: MULTI-YEAR COMBINED`);
        report.push(`  Mode: All Years (Combined) - each year is a separate data point`);
        report.push(`  Resulting data points: ${dataPoints.length}`);
      } else {
        samplesWithYield.forEach(sample => {
          const yieldInfo = sample.yieldCorrelations[yearFilter];
          if (yieldInfo && (cropFilter === 'all' || yieldInfo.crop === cropFilter)) {
            dataPoints.push({ ...sample, avgYield: yieldInfo.avgYield });
          }
        });
        report.push(`STEP 2: SINGLE YEAR FILTER`);
        report.push(`  Selected year: ${yearFilter}`);
        report.push(`  Matching data points: ${dataPoints.length}`);
      }
      report.push('');

      // Show radius information for selected crop
      report.push(`STEP 3: YIELD SEARCH RADIUS (${cropFilter})`);
      const radiusValues = new Set();
      samplesWithYield.forEach(sample => {
        Object.values(sample.yieldCorrelations).forEach(yieldInfo => {
          if (yieldInfo.radiusFt && yieldInfo.crop === cropFilter) {
            radiusValues.add(yieldInfo.radiusFt);
          }
        });
      });
      if (radiusValues.size > 0) {
        report.push(`  Radius values for ${cropFilter}: ${[...radiusValues].sort((a,b) => a-b).join(', ')} ft`);
      } else {
        report.push(`  No radius information stored for ${cropFilter} (older import or no data)`);
      }
      report.push('');

      // Show crop breakdown
      report.push(`STEP 3.5: CROP DATA BREAKDOWN`);
      const cropCounts = {};
      const cropsByYear = {};
      samplesWithYield.forEach(sample => {
        Object.entries(sample.yieldCorrelations).forEach(([year, yieldInfo]) => {
          const crop = yieldInfo.crop || 'unknown';
          cropCounts[crop] = (cropCounts[crop] || 0) + 1;
          if (!cropsByYear[year]) cropsByYear[year] = {};
          cropsByYear[year][crop] = (cropsByYear[year][crop] || 0) + 1;
        });
      });
      report.push(`  Crops stored in database:`);
      Object.entries(cropCounts).sort((a,b) => b[1] - a[1]).forEach(([crop, count]) => {
        const marker = (cropFilter === 'all' || crop === cropFilter) ? '‚úì' : '‚úó';
        report.push(`    ${marker} ${crop}: ${count} yield entries ${cropFilter !== 'all' && crop !== cropFilter ? '(filtered out)' : '(included)'}`);
      });
      report.push(`  Crops by year:`);
      Object.keys(cropsByYear).sort().forEach(year => {
        const crops = Object.entries(cropsByYear[year]).map(([c, n]) => `${c}:${n}`).join(', ');
        report.push(`    ${year}: ${crops}`);
      });
      report.push(`  Current crop filter: "${cropFilter}"`);
      if (cropFilter !== 'all') {
        const filteredCount = cropCounts[cropFilter] || 0;
        report.push(`  ‚Üí Only using ${filteredCount} entries matching "${cropFilter}"`);
      }
      report.push('');

      // Get yield statistics
      const yields = dataPoints.map(d => d.avgYield);
      const avgYield = yields.reduce((a, b) => a + b, 0) / yields.length;
      const minYield = Math.min(...yields);
      const maxYield = Math.max(...yields);

      report.push(`STEP 4: YIELD DATA QUALITY`);
      report.push(`  Data points: ${dataPoints.length}`);
      report.push(`  Yield range: ${minYield.toFixed(1)} - ${maxYield.toFixed(1)} bu/ac`);
      report.push(`  Average yield: ${avgYield.toFixed(1)} bu/ac`);
      report.push('');

      // Pick a sample nutrient for detailed verification
      const testNutrient = 'P';
      const pairsP = dataPoints.filter(d => d[testNutrient] !== undefined && d[testNutrient] !== null && d[testNutrient] !== '');
      const xValues = pairsP.map(d => parseFloat(d[testNutrient]));
      const yValues = pairsP.map(d => d.avgYield);

      if (pairsP.length >= 5) {
        const n = xValues.length;
        const sumX = xValues.reduce((a, b) => a + b, 0);
        const sumY = yValues.reduce((a, b) => a + b, 0);
        const meanX = sumX / n;
        const meanY = sumY / n;
        const sumXY = xValues.reduce((sum, x, i) => sum + x * yValues[i], 0);
        const sumX2 = xValues.reduce((sum, x) => sum + x * x, 0);
        const sumY2 = yValues.reduce((sum, y) => sum + y * y, 0);

        const numerator = n * sumXY - sumX * sumY;
        const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
        const r = denominator !== 0 ? numerator / denominator : 0;

        report.push(`STEP 5: CORRELATION CALCULATION (Example: ${testNutrient})`);
        report.push(`  Valid pairs (n): ${n}`);
        report.push(`  Mean ${testNutrient}: ${meanX.toFixed(2)}`);
        report.push(`  Mean Yield: ${meanY.toFixed(2)}`);
        report.push(`  Sum(X): ${sumX.toFixed(2)}`);
        report.push(`  Sum(Y): ${sumY.toFixed(2)}`);
        report.push(`  Sum(XY): ${sumXY.toFixed(2)}`);
        report.push(`  Sum(X¬≤): ${sumX2.toFixed(2)}`);
        report.push(`  Sum(Y¬≤): ${sumY2.toFixed(2)}`);
        report.push('');
        report.push(`  Formula: r = (n√óŒ£XY - Œ£X√óŒ£Y) / ‚àö[(n√óŒ£X¬≤ - (Œ£X)¬≤)(n√óŒ£Y¬≤ - (Œ£Y)¬≤)]`);
        report.push(`  Numerator: ${n} √ó ${sumXY.toFixed(2)} - ${sumX.toFixed(2)} √ó ${sumY.toFixed(2)} = ${numerator.toFixed(2)}`);
        report.push(`  Denominator: ${denominator.toFixed(2)}`);
        report.push(`  r = ${numerator.toFixed(2)} / ${denominator.toFixed(2)} = ${r.toFixed(4)}`);
        report.push(`  R¬≤ = ${(r * r * 100).toFixed(2)}%`);
        report.push('');

        // Show sample data points
        report.push(`SAMPLE DATA POINTS (first 10):`);
        report.push(`  ${'Sample ID'.padEnd(20)} ${'Field'.padEnd(15)} ${testNutrient.padStart(8)} ${'Yield'.padStart(10)}`);
        report.push(`  ${'-'.repeat(20)} ${'-'.repeat(15)} ${'-'.repeat(8)} ${'-'.repeat(10)}`);
        pairsP.slice(0, 10).forEach(d => {
          const id = (d.sampleId || 'N/A').toString().substring(0, 18).padEnd(20);
          const field = (d.field || 'N/A').substring(0, 13).padEnd(15);
          const pVal = parseFloat(d[testNutrient]).toFixed(1).padStart(8);
          const yVal = d.avgYield.toFixed(1).padStart(10);
          report.push(`  ${id} ${field} ${pVal} ${yVal}`);
        });
      } else {
        report.push(`STEP 5: INSUFFICIENT DATA`);
        report.push(`  Only ${pairsP.length} valid ${testNutrient} values (need 5+)`);
      }

      report.push('');
      report.push('');
      report.push('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
      report.push('‚ïë                    UNDERSTANDING CORRELATIONS                       ‚ïë');
      report.push('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
      report.push('');
      report.push('WHY MIGHT CORRELATIONS BE NEGATIVE?');
      report.push('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
      report.push('A negative correlation means higher nutrient levels are associated');
      report.push('with LOWER yields. This can happen for several legitimate reasons:');
      report.push('');
      report.push('1. NUTRIENT TOXICITY OR IMBALANCE');
      report.push('   ‚Ä¢ Too much of some nutrients can harm crops (e.g., high Na, Fe)');
      report.push('   ‚Ä¢ Nutrient imbalances affect uptake of other nutrients');
      report.push('   ‚Ä¢ Example: High Mg can block Ca uptake');
      report.push('');
      report.push('2. SOIL QUALITY INDICATORS');
      report.push('   ‚Ä¢ Some nutrients accumulate in poor-draining soils');
      report.push('   ‚Ä¢ High H_Sat indicates acidic conditions limiting yield');
      report.push('   ‚Ä¢ High Na_Sat indicates salinity problems');
      report.push('');
      report.push('3. MANAGEMENT PRACTICES');
      report.push('   ‚Ä¢ High-yielding areas may have depleted nutrients');
      report.push('   ‚Ä¢ Low-yielding areas may have accumulated unused fertilizer');
      report.push('   ‚Ä¢ Manure application patterns vs. yield patterns');
      report.push('');
      report.push('4. SPATIAL CONFOUNDING');
      report.push('   ‚Ä¢ Nutrient levels may correlate with other limiting factors');
      report.push('   ‚Ä¢ Example: Low spots have high nutrients but poor drainage');
      report.push('   ‚Ä¢ Hilltops may have low nutrients but better conditions');
      report.push('');
      report.push('5. SAMPLE SIZE & NOISE');
      report.push('   ‚Ä¢ Small sample sizes can show spurious correlations');
      report.push('   ‚Ä¢ Look for |r| > 0.3 and n > 20 for meaningful relationships');
      report.push('   ‚Ä¢ R¬≤ < 10% means the nutrient explains very little yield variation');
      report.push('');
      report.push('INTERPRETING THE RESULTS');
      report.push('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
      report.push('‚Ä¢ r = +1.0: Perfect positive (higher nutrient = higher yield)');
      report.push('‚Ä¢ r = +0.5: Moderate positive correlation');
      report.push('‚Ä¢ r =  0.0: No linear relationship');
      report.push('‚Ä¢ r = -0.5: Moderate negative correlation');
      report.push('‚Ä¢ r = -1.0: Perfect negative (higher nutrient = lower yield)');
      report.push('');
      report.push('‚Ä¢ R¬≤ (R-squared): % of yield variation explained by this nutrient');
      report.push('  - R¬≤ = 25% means 25% of yield differences relate to this nutrient');
      report.push('  - R¬≤ < 5% = very weak, likely not meaningful');
      report.push('  - R¬≤ > 20% = moderate, worth investigating');
      report.push('');
      report.push('NUTRIENTS EXPECTED TO BE NEGATIVE (Lower is Better):');
      report.push('  ‚Ä¢ H_Sat (Hydrogen Saturation) - indicates acidity');
      report.push('  ‚Ä¢ Na_Sat (Sodium Saturation) - indicates salinity');
      report.push('  ‚Ä¢ Mg_sat (when excessive) - can block calcium');
      report.push('  ‚Ä¢ Soluble_Salts - indicates salt stress');
      report.push('');
      report.push('‚ïê'.repeat(70));
      report.push(`Report generated: ${new Date().toLocaleString()}`);

      return report.join('\n');
    }

    // ========== EXPORT FUNCTIONS ==========
    function getReportStyles() {
      return `
        * { box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif; padding: 20px; font-size: 12px; color: #1e293b; line-height: 1.5; }
        h1 { color: #1e293b; border-bottom: 3px solid #3b82f6; padding-bottom: 12px; margin-bottom: 20px; font-size: 24px; }
        h2 { color: #334155; margin-top: 24px; margin-bottom: 16px; font-size: 18px; }
        h3 { color: #475569; margin: 0 0 8px 0; font-size: 16px; }
        p { color: #64748b; margin: 0 0 16px 0; }
        .summary { display: flex; gap: 20px; margin: 20px 0; flex-wrap: wrap; }
        .summary-box { background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%); padding: 16px 24px; border-radius: 10px; text-align: center; min-width: 120px; border: 1px solid #cbd5e1; }
        .summary-box .number { font-size: 28px; font-weight: bold; color: #3b82f6; }
        .summary-box .label { color: #64748b; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; margin-top: 4px; }
        table { width: 100%; border-collapse: collapse; margin: 16px 0; font-size: 11px; }
        th { background: #1e293b; color: white; padding: 10px 8px; text-align: left; font-weight: 600; }
        td { padding: 8px; border-bottom: 1px solid #e2e8f0; }
        tr:nth-child(even) { background: #f8fafc; }
        .positive { color: #16a34a; } .negative { color: #dc2626; }
        .card { background: #f8fafc; border-left: 4px solid #3b82f6; padding: 12px 16px; margin: 12px 0; border-radius: 6px; }
        .card.positive { border-left-color: #22c55e; background: #f0fdf4; }
        .card.negative { border-left-color: #ef4444; background: #fef2f2; }

        /* Trend Cards for Field Trends Report - PDF optimized */
        .trend-card { background: #fff; border: 2px solid #e2e8f0; border-radius: 10px; padding: 20px; margin-bottom: 20px; page-break-inside: avoid; box-shadow: 0 1px 4px rgba(0,0,0,0.08); }
        .trend-card.positive { background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%); border-color: #22c55e; }
        .trend-card.negative { background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%); border-color: #ef4444; }
        .trend-card.neutral { background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%); border-color: #94a3b8; }
        .trend-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid rgba(0,0,0,0.1); }
        .trend-title { font-size: 18px; font-weight: 700; color: #1e293b; margin: 0; }
        .trend-pct { font-size: 22px; font-weight: 700; text-align: right; }
        .trend-sub { font-size: 11px; color: #64748b; font-weight: 500; }

        /* Stacked layout for PDF - data table on top, full-width graph below */
        .trend-content { display: flex; flex-direction: column; gap: 16px; }
        .trend-values { background: rgba(255,255,255,0.8); border-radius: 6px; padding: 10px; width: 100%; }
        .trend-values-row { display: flex; flex-wrap: wrap; gap: 8px; }
        .trend-row { display: inline-flex; justify-content: space-between; gap: 8px; padding: 6px 12px; font-size: 11px; border-radius: 4px; min-width: 120px; }
        .trend-row.alt { background: rgba(0,0,0,0.04); }
        .trend-year { font-weight: 600; color: #475569; }
        .trend-value { font-weight: 700; color: #1e293b; }
        .trend-graph { width: 100%; padding: 10px; background: rgba(255,255,255,0.5); border-radius: 8px; }
        .trend-graph svg { width: 100%; height: auto; min-height: 200px; display: block; }
        .trend-graph.large svg { min-height: 240px; }
        .trend-graph.xlarge svg { min-height: 300px; }

        /* Nutrient cards for Year Comparison */
        .nutrient-card { background: #fff; border: 2px solid #e2e8f0; border-radius: 8px; padding: 12px; margin-bottom: 12px; }
        .nutrient-card.positive { background: #f0fdf4; border-color: #22c55e; }
        .nutrient-card.negative { background: #fef2f2; border-color: #ef4444; }
        .nutrient-header { display: flex; justify-content: space-between; margin-bottom: 8px; }
        .nutrient-name { font-weight: 700; font-size: 14px; }
        .nutrient-pct { font-weight: 700; font-size: 14px; }
        .nutrient-stats { display: flex; gap: 12px; margin-bottom: 8px; }
        .stat-box { text-align: center; padding: 6px 10px; background: rgba(0,0,0,0.03); border-radius: 4px; }
        .stat-box .label { font-size: 9px; color: #64748b; text-transform: uppercase; }
        .stat-box .value { font-size: 16px; font-weight: 700; color: #1e293b; }

        .footer { margin-top: 40px; padding-top: 16px; border-top: 1px solid #e2e8f0; color: #94a3b8; font-size: 10px; text-align: center; }
        @media print {
          body { padding: 10px; }
          .trend-card, .nutrient-card { page-break-inside: avoid; }
          h1 { page-break-after: avoid; }
          .trend-graph { width: 100%; }
          .trend-graph svg { min-height: 220px; width: 100%; }
        }
      `;
    }

    function exportYearComparison() {
      const y1 = document.getElementById('year1Select').value;
      const y2 = document.getElementById('year2Select').value;
      if (!y1 || !y2) { showStatus('Select both years first', false); return; }

      const operationName = localStorage.getItem('operationName') || 'Soil Analysis';
      const comparisonData = document.getElementById('comparisonGrid').innerHTML;

      const printWindow = window.open('', '_blank');
      printWindow.document.write(`<!DOCTYPE html><html><head><title>${operationName} - Year Comparison</title><style>${getReportStyles()}</style></head><body>
        <h1>${operationName} - Year-Over-Year Comparison</h1>
        <p>Generated: ${new Date().toLocaleString()}</p>
        <div class="summary">
          <div class="summary-box"><div class="number">${y1}</div><div class="label">From Year</div></div>
          <div class="summary-box"><div class="number">${y2}</div><div class="label">To Year</div></div>
          <div class="summary-box"><div class="number">${selectedComparisonFields.size}</div><div class="label">Fields Compared</div></div>
        </div>
        <h2>Nutrient Changes</h2>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 10px;">${comparisonData}</div>
        <div class="footer">Soil Sample Analysis App</div>
      </body></html>`);
      printWindow.document.close();
      printWindow.print();
    }

    function exportFieldTrends() {
      const field = document.getElementById('historyFieldSelect').value;
      if (!field) { showStatus('Select a field first', false); return; }

      const operationName = localStorage.getItem('operationName') || 'Soil Analysis';
      const trendData = document.getElementById('historyContent').innerHTML;

      const printWindow = window.open('', '_blank');
      printWindow.document.write(`<!DOCTYPE html><html><head><title>${operationName} - Field Trends</title><style>${getReportStyles()}</style></head><body>
        <h1>${operationName} - Field Trends: ${field}</h1>
        <p>Generated: ${new Date().toLocaleString()}</p>
        <h2>Historical Nutrient Trends</h2>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 10px;">${trendData}</div>
        <div class="footer">Soil Sample Analysis App</div>
      </body></html>`);
      printWindow.document.close();
      printWindow.print();
    }

    function exportFieldRankings() {
      const nutrient = document.getElementById('rankingAttrSelect').value;
      const year = document.getElementById('rankingYearSelect').value;
      const operationName = localStorage.getItem('operationName') || 'Soil Analysis';
      const rankingData = document.getElementById('rankingsContent').innerHTML;

      const printWindow = window.open('', '_blank');
      printWindow.document.write(`<!DOCTYPE html><html><head><title>${operationName} - Field Rankings</title><style>${getReportStyles()}</style></head><body>
        <h1>${operationName} - Field Rankings</h1>
        <p>Generated: ${new Date().toLocaleString()}</p>
        <div class="summary">
          <div class="summary-box"><div class="number">${CONFIG.NUTRIENT_NAMES[nutrient] || nutrient}</div><div class="label">Nutrient</div></div>
          <div class="summary-box"><div class="number">${year === 'most_recent' ? 'Most Recent' : year}</div><div class="label">Year</div></div>
        </div>
        <h2>Rankings</h2>
        ${rankingData}
        <div class="footer">Soil Sample Analysis App</div>
      </body></html>`);
      printWindow.document.close();
      printWindow.print();
    }

    function exportYieldCorrelation() {
      const crop = document.getElementById('yieldCropSelect').value;
      const year = document.getElementById('yieldYearSelect').value;
      const field = document.getElementById('yieldFieldSelect').value;
      const operationName = localStorage.getItem('operationName') || 'Soil Analysis';
      const yieldData = document.getElementById('yieldContent').innerHTML;

      // Format year label
      let yearLabel = year;
      if (year === 'avg') yearLabel = 'All (Averaged)';
      else if (year === 'combined') yearLabel = 'All (Combined)';

      const printWindow = window.open('', '_blank');
      printWindow.document.write(`<!DOCTYPE html><html><head><title>${operationName} - Yield Correlation</title><style>${getReportStyles()}</style></head><body>
        <h1>${operationName} - Yield Correlation Analysis</h1>
        <p>Generated: ${new Date().toLocaleString()}</p>
        <div class="summary">
          <div class="summary-box"><div class="number">${crop === 'all' ? 'All' : crop}</div><div class="label">Crop</div></div>
          <div class="summary-box"><div class="number">${yearLabel}</div><div class="label">Yield Year</div></div>
          <div class="summary-box"><div class="number">${field === 'all' ? 'All' : field}</div><div class="label">Field</div></div>
        </div>
        ${yieldData}
        <div class="footer">Soil Sample Analysis App</div>
      </body></html>`);
      printWindow.document.close();
      printWindow.print();
    }

    // ========== TAB 5: Spatial Change Analysis ==========
    function updateSpatialAnalysis() {
      const container = document.getElementById('spatialContent');
      const field = document.getElementById('spatialFieldSelect').value;
      const nutrient = document.getElementById('spatialNutrientSelect').value;
      const baseYear = parseInt(document.getElementById('spatialBaseYearSelect').value);
      const compareYear = document.getElementById('spatialCompareYearSelect').value;
      const radiusFt = parseInt(document.getElementById('spatialRadiusSelect').value);

      if (!field) {
        container.innerHTML = '<div class="no-data">Select a field to analyze spatial changes over time.</div>';
        return;
      }

      // Get all samples for this field
      const fieldSamples = sampleData.filter(s => s.field === field);
      const years = [...new Set(fieldSamples.map(s => s.year).filter(y => y))].sort();

      if (years.length < 2) {
        container.innerHTML = '<div class="no-data">Need at least 2 years of data to analyze changes. This field only has data from: ' + years.join(', ') + '</div>';
        return;
      }

      // Get base year samples
      const baseSamples = fieldSamples.filter(s => s.year === baseYear);
      if (baseSamples.length === 0) {
        container.innerHTML = `<div class="no-data">No samples found for ${field} in ${baseYear}</div>`;
        return;
      }

      // Get valid nutrient values for base year
      const baseWithValues = baseSamples.filter(s => {
        const val = s[nutrient];
        return val !== undefined && val !== null && val !== '' && !isNaN(parseFloat(val));
      });

      if (baseWithValues.length < 4) {
        container.innerHTML = `<div class="no-data">Need at least 4 samples with ${nutrient} data in base year. Found: ${baseWithValues.length}</div>`;
        return;
      }

      // Calculate zone thresholds based on base year (quartiles)
      const baseValues = baseWithValues.map(s => parseFloat(s[nutrient])).sort((a, b) => a - b);
      const q1Index = Math.floor(baseValues.length * 0.25);
      const q3Index = Math.floor(baseValues.length * 0.75);
      const lowThreshold = baseValues[q1Index];
      const highThreshold = baseValues[q3Index];

      // Classify base year samples into zones
      const zonedSamples = baseWithValues.map(s => ({
        ...s,
        baseValue: parseFloat(s[nutrient]),
        zone: parseFloat(s[nutrient]) <= lowThreshold ? 'low' :
              parseFloat(s[nutrient]) >= highThreshold ? 'high' : 'medium'
      }));

      // Determine which years to compare
      const compareYears = compareYear === 'all'
        ? years.filter(y => y !== baseYear)
        : [parseInt(compareYear)];

      // For each zoned sample, find matching samples in compare years
      const radiusMeters = radiusFt * 0.3048;
      const matchedData = [];

      zonedSamples.forEach(baseSample => {
        const matches = { base: baseSample, years: {} };
        matches.years[baseYear] = baseSample.baseValue;

        compareYears.forEach(year => {
          const yearSamples = fieldSamples.filter(s => s.year === year);
          // Find closest sample within radius
          let closest = null;
          let closestDist = Infinity;

          yearSamples.forEach(s => {
            const dist = getDistanceMeters(baseSample.lat, baseSample.lon, s.lat, s.lon);
            if (dist <= radiusMeters && dist < closestDist) {
              const val = s[nutrient];
              if (val !== undefined && val !== null && val !== '' && !isNaN(parseFloat(val))) {
                closest = s;
                closestDist = dist;
              }
            }
          });

          if (closest) {
            matches.years[year] = parseFloat(closest[nutrient]);
          }
        });

        matchedData.push(matches);
      });

      // Calculate zone statistics for each year
      const allYears = [baseYear, ...compareYears].sort();
      const zoneStats = { low: {}, medium: {}, high: {}, all: {} };

      allYears.forEach(year => {
        ['low', 'medium', 'high'].forEach(zone => {
          const zoneMatches = matchedData.filter(m => m.base.zone === zone && m.years[year] !== undefined);
          if (zoneMatches.length > 0) {
            const values = zoneMatches.map(m => m.years[year]);
            zoneStats[zone][year] = {
              avg: values.reduce((a, b) => a + b, 0) / values.length,
              count: values.length,
              min: Math.min(...values),
              max: Math.max(...values)
            };
          }
        });

        // Field average
        const allMatches = matchedData.filter(m => m.years[year] !== undefined);
        if (allMatches.length > 0) {
          const values = allMatches.map(m => m.years[year]);
          zoneStats.all[year] = {
            avg: values.reduce((a, b) => a + b, 0) / values.length,
            count: values.length
          };
        }
      });

      // Calculate match rates
      const lowCount = matchedData.filter(m => m.base.zone === 'low').length;
      const medCount = matchedData.filter(m => m.base.zone === 'medium').length;
      const highCount = matchedData.filter(m => m.base.zone === 'high').length;

      // Build the results HTML
      const nutrientName = CONFIG.NUTRIENT_NAMES[nutrient] || nutrient;
      const unit = CONFIG.NUTRIENT_UNITS[nutrient] || '';
      const decimals = getDecimals(nutrient);

      let html = `
        <div style="background: #f0f9ff; border: 1px solid #0ea5e9; border-radius: 0.5rem; padding: 0.75rem; margin-bottom: 1rem; font-size: 0.8rem; color: #0369a1;">
          <strong>Spatial Change Analysis: ${field} - ${nutrientName}</strong><br>
          <strong>Base Year:</strong> ${baseYear} (zones defined by this year's values)<br>
          <strong>Comparing:</strong> ${compareYears.join(', ')}<br>
          <strong>Match Radius:</strong> ${radiusFt} ft | <strong>Matched Samples:</strong> ${matchedData.length} of ${baseSamples.length}
        </div>

        <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem; font-size: 0.8rem; color: #475569;">
          <strong style="color: #1e293b;">How Zones Are Defined:</strong><br>
          Samples from ${baseYear} are divided into three zones based on their ${nutrientName} values:
          <ul style="margin: 0.5rem 0 0.5rem 1.5rem; padding: 0;">
            <li><strong style="color: #dc2626;">Low Zone</strong> = Bottom 25% of samples (lowest quartile)</li>
            <li><strong style="color: #d97706;">Medium Zone</strong> = Middle 50% of samples (between 25th and 75th percentile)</li>
            <li><strong style="color: #16a34a;">High Zone</strong> = Top 25% of samples (highest quartile)</li>
          </ul>
          <strong style="color: #1e293b;">What This Analysis Shows:</strong><br>
          Once zones are defined by ${baseYear}, we track those <em>same GPS locations</em> across other years to see how values change over time. This answers: "Are my historically low-testing areas improving or staying low?"
        </div>

        <h3 style="margin: 0 0 0.5rem 0; color: #1e293b;">Zone Summary (${baseYear} Baseline)</h3>
        <p style="color: #64748b; font-size: 0.8rem; margin-bottom: 0.75rem;">Number of sample locations in each zone, based on ${baseYear} ${nutrientName} values:</p>

        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 0.75rem; margin-bottom: 1.5rem;">
          <div style="background: #fee2e2; border: 2px solid #ef4444; border-radius: 0.5rem; padding: 0.75rem; text-align: center;">
            <div style="font-size: 1.5rem; font-weight: 700; color: #991b1b;">${lowCount}</div>
            <div style="color: #991b1b; font-size: 0.75rem;">Low Zone Samples</div>
            <div style="color: #b91c1c; font-size: 0.7rem;">‚â§ ${lowThreshold.toFixed(decimals)} ${unit}</div>
          </div>
          <div style="background: #fef3c7; border: 2px solid #f59e0b; border-radius: 0.5rem; padding: 0.75rem; text-align: center;">
            <div style="font-size: 1.5rem; font-weight: 700; color: #92400e;">${medCount}</div>
            <div style="color: #92400e; font-size: 0.75rem;">Medium Zone Samples</div>
            <div style="color: #b45309; font-size: 0.7rem;">${lowThreshold.toFixed(decimals)} - ${highThreshold.toFixed(decimals)} ${unit}</div>
          </div>
          <div style="background: #dcfce7; border: 2px solid #22c55e; border-radius: 0.5rem; padding: 0.75rem; text-align: center;">
            <div style="font-size: 1.5rem; font-weight: 700; color: #166534;">${highCount}</div>
            <div style="color: #166534; font-size: 0.75rem;">High Zone Samples</div>
            <div style="color: #15803d; font-size: 0.7rem;">‚â• ${highThreshold.toFixed(decimals)} ${unit}</div>
          </div>
        </div>

        <h3 style="margin: 0 0 0.5rem 0; color: #1e293b;">Zone Tracking Over Time</h3>
        <p style="color: #64748b; font-size: 0.8rem; margin-bottom: 0.5rem;">
          <strong>How to read this table:</strong> Each row shows the <em>average ${nutrientName} value</em> for samples in that zone across years.
          The <strong>(n=X)</strong> shows how many samples had data for that year.
          The <strong>Change</strong> column shows the difference between the first and last year (+ is increase, - is decrease).
        </p>

        <table class="rankings-table" style="margin-bottom: 1.5rem;">
          <thead>
            <tr>
              <th>Zone (${baseYear} baseline)</th>
              ${allYears.map(y => `<th>${y} Avg</th>`).join('')}
              <th>Change</th>
            </tr>
          </thead>
          <tbody>`;

      // Add rows for each zone
      const lastYear = allYears[allYears.length - 1];

      ['low', 'medium', 'high'].forEach(zone => {
        const zoneName = zone === 'low' ? `Low (‚â§${lowThreshold.toFixed(decimals)})` :
                        zone === 'medium' ? `Medium (${lowThreshold.toFixed(decimals)}-${highThreshold.toFixed(decimals)})` :
                        `High (‚â•${highThreshold.toFixed(decimals)})`;
        const zoneColor = zone === 'low' ? '#dc2626' : zone === 'medium' ? '#d97706' : '#16a34a';

        html += `<tr>
          <td style="font-weight: 600; color: ${zoneColor};">${zoneName}</td>`;

        allYears.forEach(year => {
          const stat = zoneStats[zone][year];
          if (stat) {
            html += `<td>${stat.avg.toFixed(decimals)} <span style="color: #94a3b8; font-size: 0.7rem;">(n=${stat.count})</span></td>`;
          } else {
            html += `<td style="color: #94a3b8;">-</td>`;
          }
        });

        // Change column
        const baseAvg = zoneStats[zone][baseYear]?.avg;
        const lastAvg = zoneStats[zone][lastYear]?.avg;
        if (baseAvg !== undefined && lastAvg !== undefined) {
          const change = lastAvg - baseAvg;
          const pctChange = baseAvg !== 0 ? ((change / baseAvg) * 100).toFixed(0) : 'N/A';
          const changeColor = change > 0 ? '#16a34a' : change < 0 ? '#dc2626' : '#64748b';
          const arrow = change > 0 ? '‚Üë' : change < 0 ? '‚Üì' : '‚Üí';
          html += `<td style="font-weight: 600; color: ${changeColor};">${change >= 0 ? '+' : ''}${change.toFixed(decimals)} ${arrow} <span style="font-size: 0.75rem;">(${pctChange}%)</span></td>`;
        } else {
          html += `<td style="color: #94a3b8;">-</td>`;
        }

        html += `</tr>`;
      });

      // Field average row
      html += `<tr style="background: #f1f5f9; font-weight: 600;">
        <td>Field Average</td>`;
      allYears.forEach(year => {
        const stat = zoneStats.all[year];
        if (stat) {
          html += `<td>${stat.avg.toFixed(decimals)}</td>`;
        } else {
          html += `<td style="color: #94a3b8;">-</td>`;
        }
      });

      const baseFieldAvg = zoneStats.all[baseYear]?.avg;
      const lastFieldAvg = zoneStats.all[lastYear]?.avg;
      if (baseFieldAvg !== undefined && lastFieldAvg !== undefined) {
        const change = lastFieldAvg - baseFieldAvg;
        const changeColor = change > 0 ? '#16a34a' : change < 0 ? '#dc2626' : '#64748b';
        const arrow = change > 0 ? '‚Üë' : change < 0 ? '‚Üì' : '‚Üí';
        html += `<td style="color: ${changeColor};">${change >= 0 ? '+' : ''}${change.toFixed(decimals)} ${arrow}</td>`;
      } else {
        html += `<td>-</td>`;
      }
      html += `</tr></tbody></table>`;

      // Generate insights
      html += generateSpatialInsights(zoneStats, baseYear, lastYear, nutrientName, decimals, unit);

      container.innerHTML = html;
    }

    function generateSpatialInsights(zoneStats, baseYear, lastYear, nutrientName, decimals, unit) {
      const insights = [];

      // Low zone insight
      const lowBase = zoneStats.low[baseYear]?.avg;
      const lowLast = zoneStats.low[lastYear]?.avg;
      if (lowBase !== undefined && lowLast !== undefined) {
        const lowChange = lowLast - lowBase;
        const lowPct = lowBase !== 0 ? Math.abs((lowChange / lowBase) * 100).toFixed(0) : 0;
        if (lowChange > 0) {
          insights.push({
            type: 'positive',
            icon: 'üìà',
            text: `Low ${nutrientName} areas improved ${lowPct}% (+${lowChange.toFixed(decimals)} ${unit} avg)`
          });
        } else if (lowChange < 0) {
          insights.push({
            type: 'negative',
            icon: 'üìâ',
            text: `Low ${nutrientName} areas declined ${lowPct}% (${lowChange.toFixed(decimals)} ${unit} avg)`
          });
        }
      }

      // High zone insight
      const highBase = zoneStats.high[baseYear]?.avg;
      const highLast = zoneStats.high[lastYear]?.avg;
      if (highBase !== undefined && highLast !== undefined) {
        const highChange = highLast - highBase;
        const highPct = highBase !== 0 ? Math.abs((highChange / highBase) * 100).toFixed(0) : 0;
        if (highChange < 0) {
          insights.push({
            type: 'neutral',
            icon: '‚öñÔ∏è',
            text: `High ${nutrientName} areas decreased ${highPct}% (${highChange.toFixed(decimals)} ${unit} avg)`
          });
        } else if (highChange > 0) {
          insights.push({
            type: 'warning',
            icon: '‚¨ÜÔ∏è',
            text: `High ${nutrientName} areas increased ${highPct}% (+${highChange.toFixed(decimals)} ${unit} avg)`
          });
        }
      }

      // Overall strategy insight
      if (lowBase !== undefined && lowLast !== undefined && highBase !== undefined && highLast !== undefined) {
        const lowChange = lowLast - lowBase;
        const highChange = highLast - highBase;

        if (lowChange > 0 && highChange <= 0) {
          insights.push({
            type: 'positive',
            icon: 'üéØ',
            text: `Your fertility strategy is successfully bringing up the low spots while maintaining high areas!`
          });
        } else if (lowChange > 0 && highChange > 0) {
          insights.push({
            type: 'neutral',
            icon: 'üìä',
            text: `All areas are increasing - consider variable rate application to target low spots more`
          });
        } else if (lowChange <= 0 && highChange > 0) {
          insights.push({
            type: 'warning',
            icon: '‚ö†Ô∏è',
            text: `High areas getting higher while low areas stagnate - review application targeting`
          });
        }
      }

      if (insights.length === 0) {
        return '';
      }

      let html = `
        <h3 style="margin: 1rem 0 0.75rem 0; color: #1e293b;">üí° Insights</h3>
        <div style="display: flex; flex-direction: column; gap: 0.5rem;">`;

      insights.forEach(insight => {
        const bgColor = insight.type === 'positive' ? '#f0fdf4' :
                       insight.type === 'negative' ? '#fef2f2' :
                       insight.type === 'warning' ? '#fffbeb' : '#f8fafc';
        const borderColor = insight.type === 'positive' ? '#22c55e' :
                           insight.type === 'negative' ? '#ef4444' :
                           insight.type === 'warning' ? '#f59e0b' : '#cbd5e1';

        html += `
          <div style="background: ${bgColor}; border-left: 4px solid ${borderColor}; padding: 0.75rem 1rem; border-radius: 0.375rem;">
            <span style="font-size: 1.1rem; margin-right: 0.5rem;">${insight.icon}</span>
            <span style="color: #1e293b;">${insight.text}</span>
          </div>`;
      });

      html += `</div>`;
      return html;
    }

    function getDistanceMeters(lat1, lon1, lat2, lon2) {
      // Haversine formula for distance between two GPS coordinates
      const R = 6371000; // Earth radius in meters
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }

    function exportSpatialAnalysis() {
      const field = document.getElementById('spatialFieldSelect').value;
      const nutrient = document.getElementById('spatialNutrientSelect').value;
      const nutrientName = CONFIG.NUTRIENT_NAMES[nutrient] || nutrient;
      const operationName = localStorage.getItem('operationName') || 'Soil Analysis';
      const spatialData = document.getElementById('spatialContent').innerHTML;

      const printWindow = window.open('', '_blank');
      printWindow.document.write(`<!DOCTYPE html><html><head><title>${operationName} - Spatial Change Analysis</title><style>${getReportStyles()}</style></head><body>
        <h1>${operationName} - Spatial Change Analysis</h1>
        <p>Generated: ${new Date().toLocaleString()}</p>
        <div class="summary">
          <div class="summary-box"><div class="number">${field}</div><div class="label">Field</div></div>
          <div class="summary-box"><div class="number">${nutrientName}</div><div class="label">Nutrient</div></div>
        </div>
        ${spatialData}
        <div class="footer">Soil Sample Analysis App</div>
      </body></html>`);
      printWindow.document.close();
      printWindow.print();
    }

    function showStatus(msg, ok) {
      const el = document.getElementById('statusMessage');
      el.textContent = msg;
      el.style.display = 'block';
      el.style.background = ok ? '#dcfce7' : '#fee2e2';
      el.style.color = ok ? '#166534' : '#991b1b';
      setTimeout(() => el.style.display = 'none', 4000);
    }

    function updateBackupFooter() {
      const backupTime = localStorage.getItem('soilDataBackupTime');
      const footer = document.getElementById('backupFooter');
      const buildDate = new Date(BUILD_DATE);
      const buildStr = buildDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) + ', ' +
                       buildDate.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
      const versionInfo = `App ${APP_VERSION} ‚Ä¢ Built: ${buildStr}`;

      if (backupTime) {
        const date = new Date(parseInt(backupTime));
        const backupStr = date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
        footer.innerHTML = `${versionInfo} <span style="margin: 0 0.5rem; color: #cbd5e1;">|</span> Data backup: ${backupStr}`;
      } else {
        footer.innerHTML = `${versionInfo} <span style="margin: 0 0.5rem; color: #cbd5e1;">|</span> No backup yet`;
      }
    }
  </script>
  <div class="backup-footer" id="backupFooter">No backup yet</div>
</body>
</html>
