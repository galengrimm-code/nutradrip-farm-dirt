<!DOCTYPE html>
<!-- v18 - Smooth color gradients, year filtering by attribute -->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Soil Sample Analysis - Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f8fafc; color: #1e293b; }
    .app-container { display: flex; flex-direction: column; height: 100vh; }
    .top-bar { background: linear-gradient(135deg, #1e293b 0%, #334155 100%); color: white; padding: 1rem 1.5rem; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem; }
    .top-bar h1 { font-size: 1.5rem; font-weight: 700; }
    .top-bar p { font-size: 0.875rem; opacity: 0.8; margin-top: 0.25rem; }
    .nav-links { display: flex; gap: 0.5rem; flex-wrap: wrap; }
    .nav-link { padding: 0.5rem 1rem; background: rgba(255,255,255,0.1); color: white; text-decoration: none; border-radius: 0.375rem; font-size: 0.875rem; font-weight: 500; transition: background 0.2s; }
    .nav-link:hover { background: rgba(255,255,255,0.2); }
    .nav-link.active { background: #3b82f6; }
    .auth-section { display: flex; align-items: center; gap: 1rem; }
    .user-info { font-size: 0.875rem; color: rgba(255,255,255,0.9); }
    .sign-in-btn { padding: 0.5rem 1rem; background: #4285f4; color: white; border: none; border-radius: 0.375rem; font-size: 0.875rem; cursor: pointer; }
    .sign-in-btn:hover { background: #3367d6; }
    .sign-in-btn.signed-in { background: #22c55e; }
    .sign-in-btn.signed-in:hover { background: #16a34a; }
    .controls-bar { background: white; border-bottom: 1px solid #e2e8f0; padding: 0.75rem 1.5rem; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem; }
    .controls-left, .controls-right { display: flex; align-items: center; gap: 1rem; flex-wrap: wrap; }
    .control-group { display: flex; flex-direction: column; gap: 0.25rem; }
    .control-group label { font-size: 0.6875rem; font-weight: 600; color: #64748b; text-transform: uppercase; letter-spacing: 0.05em; }
    select, input[type="text"], input[type="number"] { padding: 0.5rem 0.75rem; border: 1px solid #cbd5e1; border-radius: 0.375rem; font-size: 0.875rem; background: white; min-width: 120px; }
    select:focus, input:focus { outline: none; border-color: #3b82f6; box-shadow: 0 0 0 3px rgba(59,130,246,0.1); }
    .button { padding: 0.5rem 1rem; border: 1px solid #cbd5e1; border-radius: 0.375rem; background: white; font-size: 0.875rem; font-weight: 500; cursor: pointer; transition: all 0.2s; display: inline-flex; align-items: center; gap: 0.5rem; }
    .button:hover { background: #f1f5f9; border-color: #94a3b8; }
    .button.active { background: #3b82f6; color: white; border-color: #3b82f6; }
    .toggle-group { display: flex; border: 1px solid #cbd5e1; border-radius: 0.375rem; overflow: hidden; }
    .toggle-btn { padding: 0.5rem 1rem; background: white; border: none; font-size: 0.875rem; cursor: pointer; transition: all 0.2s; }
    .toggle-btn:not(:last-child) { border-right: 1px solid #cbd5e1; }
    .toggle-btn:hover { background: #f1f5f9; }
    .toggle-btn.active { background: #3b82f6; color: white; }
    .legend { background: white; border-bottom: 1px solid #e2e8f0; padding: 0.5rem 1rem; display: flex; align-items: center; gap: 0.5rem; font-size: 0.75rem; }
    .legend-label { font-weight: 600; color: #64748b; }
    .main-content { display: flex; flex-direction: column; flex: 1; }
    #map { flex: 1; min-height: 500px; }
    .sample-marker { border-radius: 6px; border: none; box-shadow: 0 3px 8px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.25); display: flex; align-items: center; justify-content: center; font-weight: 600; color: white; text-shadow: 0 1px 2px rgba(0,0,0,0.5); letter-spacing: -0.5px; }
    .gps-marker { position: relative; }
    .gps-dot { width: 16px; height: 16px; background: #3b82f6; border: 3px solid white; border-radius: 50%; box-shadow: 0 2px 6px rgba(0,0,0,0.3); }
    .gps-pulse { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 16px; height: 16px; background: rgba(59,130,246,0.4); border-radius: 50%; animation: gpsPulse 2s ease-out infinite; }
    @keyframes gpsPulse { 0% { width: 16px; height: 16px; opacity: 1; } 100% { width: 50px; height: 50px; opacity: 0; } }
    #statusMessage { display: none; position: fixed; top: 5rem; left: 50%; transform: translateX(-50%); z-index: 9999; max-width: 90%; box-shadow: 0 4px 12px rgba(0,0,0,0.15); padding: 0.75rem 1rem; border-radius: 0.375rem; }
    .field-tooltip { background: white; border: 2px solid #1e293b; border-radius: 0.5rem; padding: 0.5rem 0.75rem; font-size: 0.875rem; font-weight: 500; box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
    .field-mode .sample-marker { min-width: 44px !important; min-height: 44px !important; font-size: 14px !important; }
    .field-mode .controls-left { display: none; }
    .field-mode .legend { display: none; }
    @media (max-width: 639px) {
      .top-bar { padding: 0.5rem 0.75rem; }
      .top-bar h1 { font-size: 1rem; }
      .top-bar > div:first-child { display: none; }
      .nav-links { width: 100%; justify-content: center; order: -1; }
      .nav-link { padding: 0.4rem 0.6rem; font-size: 0.75rem; }
      .auth-section { display: none; }
      
      /* Simplified mobile controls */
      .controls-bar { padding: 0.5rem; gap: 0.5rem; flex-direction: column; }
      .controls-left { display: flex; flex-wrap: wrap; gap: 0.5rem; width: 100%; }
      .control-group { flex: 1; min-width: calc(50% - 0.25rem); }
      .control-group label { font-size: 0.6rem; }
      .control-group.compare-mode { display: none; } /* Hide on mobile - use bottom bar */
      .controls-right { display: none; }
      select, input { font-size: 14px !important; padding: 0.5rem; min-width: 0; width: 100%; }
      .legend { display: none; } /* Hide legend on mobile */
      .mobile-toolbar { display: flex !important; }
      .stats-box { bottom: 60px !important; right: 0.5rem !important; font-size: 0.75rem !important; padding: 0 !important; min-width: 100px !important; }
      .stats-box h4 { font-size: 0.7rem !important; }
      .stats-box .stats-header { display: flex !important; cursor: pointer; padding: 0.4rem 0.5rem; }
      .stats-box .stats-content { padding: 0 0.5rem 0.5rem 0.5rem; }
      .stats-box.collapsed .stats-content { display: none !important; }
      .stats-box .stats-toggle { display: inline !important; }
      #compareYearStack { display: none !important; } /* Hide compare stack on mobile - use bottom bar */
    }
    .mobile-toolbar { display: none; position: fixed; bottom: 0; left: 0; right: 0; background: white; border-top: 1px solid #e2e8f0; padding: 0.5rem; z-index: 1000; justify-content: space-around; box-shadow: 0 -2px 10px rgba(0,0,0,0.1); }
    .mobile-toolbar button { flex: 1; margin: 0 0.25rem; padding: 0.6rem 0.5rem; border: 1px solid #cbd5e1; border-radius: 0.375rem; background: white; font-size: 0.7rem; cursor: pointer; font-weight: 500; }
    .mobile-toolbar button.active { background: #3b82f6; color: white; border-color: #3b82f6; }
    .backup-footer { position: fixed; bottom: 0; left: 0; right: 0; background: #f8fafc; border-top: 1px solid #e2e8f0; padding: 0.25rem 1rem; font-size: 0.7rem; color: #64748b; text-align: center; z-index: 900; }
    @media (max-width: 639px) { .backup-footer { bottom: 50px; } }
  </style>
</head>
<body>
  <div class="app-container">
    <div class="top-bar">
      <div>
        <h1>üå± Soil Sample Analysis</h1>
        <p id="operationSubtitle">Precision Farms Field Management</p>
      </div>
      <nav class="nav-links">
        <a href="index.html" class="nav-link active">üìç Map</a>
        <a href="analysis.html" class="nav-link">üìä Analysis</a>
        <a href="import.html" class="nav-link">üìÅ Import</a>
        <a href="settings.html" class="nav-link">‚öôÔ∏è Settings</a>
      </nav>
      <div class="auth-section">
        <span class="user-info" id="userInfo"></span>
        <button class="sign-in-btn" id="authBtn" onclick="handleAuth()">Sign In to Edit</button>
      </div>
    </div>
    
    <div class="controls-bar">
      <div class="controls-left">
        <div class="control-group">
          <label>FIELD</label>
          <select id="fieldSelect"><option value="all">All Fields</option></select>
        </div>
        <div class="control-group">
          <label>ATTRIBUTE</label>
          <select id="attributeSelect"></select>
        </div>
        <div class="control-group" id="viewYearGroup">
          <label>YEAR</label>
          <select id="yearSelect"><option value="all">All Years</option></select>
        </div>
        <div class="control-group">
          <label>MODE</label>
          <div class="toggle-group">
            <button class="toggle-btn active" id="singleYearBtn">View</button>
            <button class="toggle-btn" id="compareYearsBtn">Compare</button>
          </div>
        </div>
      </div>
      <!-- Compare Mode Year Stack -->
      <div id="compareYearStack" style="display: none; background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%); border: 2px solid #3b82f6; border-radius: 0.5rem; padding: 0.75rem 1rem; text-align: center;">
        <div style="display: flex; align-items: center; gap: 1rem;">
          <div style="text-align: center;">
            <label style="font-size: 0.6rem; font-weight: 600; color: #64748b; text-transform: uppercase; display: block; margin-bottom: 0.25rem;">BASELINE YEAR</label>
            <select id="compareYearSelect" style="padding: 0.4rem 0.6rem; border: 2px solid #93c5fd; border-radius: 0.375rem; font-size: 0.875rem; font-weight: 600; min-width: 90px;"><option value="">Select...</option></select>
          </div>
          <div style="display: flex; flex-direction: column; align-items: center; color: #3b82f6;">
            <span style="font-size: 1.25rem; font-weight: bold;">‚Üí</span>
          </div>
          <div style="text-align: center;">
            <label style="font-size: 0.6rem; font-weight: 600; color: #64748b; text-transform: uppercase; display: block; margin-bottom: 0.25rem;">COMPARE TO</label>
            <select id="compareToYearSelect" style="padding: 0.4rem 0.6rem; border: 2px solid #93c5fd; border-radius: 0.375rem; font-size: 0.875rem; font-weight: 600; min-width: 90px;"><option value="">Select...</option></select>
          </div>
        </div>
        <div id="compareSummaryText" style="margin-top: 0.5rem; font-size: 0.75rem; color: #1e40af; font-weight: 500;">Select years to compare</div>
      </div>
      <div class="controls-right">
        <button class="button" id="fieldModeBtn">üì± Field Mode</button>
        <button class="button" id="refreshBtn">üîÑ Refresh</button>
      </div>
    </div>
    
    <div class="legend" id="legendBar">
      <span class="legend-label">Legend:</span>
      <div style="width: 100px; height: 16px; background: linear-gradient(to right, #dc2626, #f97316, #eab308, #84cc16, #16a34a); border-radius: 8px; border: 1px solid #cbd5e1;"></div>
      <span id="legendText">Low ‚Üí High</span>
      <span style="margin-left: auto; color: #64748b; font-size: 0.75rem;" id="lastUpdated"></span>
    </div>

    <!-- Compare mode info bar -->
    <div id="compareInfoBar" style="display:none; background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%); border: 2px solid #3b82f6; border-radius: 0.5rem; padding: 0.75rem 1rem; margin: 0 1rem 0.5rem 1rem; font-size: 0.875rem;">
      <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 0.5rem;">
        <div style="display: flex; align-items: center; gap: 0.5rem;">
          <span style="font-weight: 700; color: #1d4ed8;">üìä Comparing:</span>
          <span id="compareFromYear" style="background: #fef3c7; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-weight: 600;">-</span>
          <span style="color: #64748b;">‚Üí</span>
          <span id="compareToYear" style="background: #dcfce7; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-weight: 600;">-</span>
        </div>
        <div id="compareSummary" style="color: #475569;"></div>
      </div>
      <div style="margin-top: 0.5rem; font-size: 0.75rem; color: #64748b;">
        <div style="margin-bottom: 0.25rem;">Each marker shows the change in value from baseline to current year. Samples are matched by location within each field.</div>
        <div style="display: flex; gap: 1rem; align-items: center; flex-wrap: wrap;">
          <span style="font-weight: 500;">Color scale:</span>
          <span><span style="color: #dc2626; font-weight: 700;">‚óè</span> Large decrease</span>
          <span><span style="color: #f87171; font-weight: 700;">‚óè</span> Small decrease</span>
          <span><span style="color: #94a3b8; font-weight: 700;">‚óè</span> No change</span>
          <span><span style="color: #86efac; font-weight: 700;">‚óè</span> Small increase</span>
          <span><span style="color: #16a34a; font-weight: 700;">‚óè</span> Large increase</span>
        </div>
      </div>
    </div>
    
    <!-- Mobile bottom toolbar -->
    <div class="mobile-toolbar">
      <button id="mobileFieldModeBtn">üì± Field</button>
      <button id="mobileCompareBtn">üìä Compare</button>
      <button id="mobileRefreshBtn">üîÑ Refresh</button>
    </div>
    
    <div class="main-content" style="position: relative;">
      <div id="map"></div>
      <div id="statsBox" class="stats-box" style="position: absolute; top: 80px; right: 10px; background: white; padding: 10px 15px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); z-index: 1000; font-size: 13px; min-width: 140px;">
        <div class="stats-header" onclick="toggleStatsBox()" style="font-weight: 600; margin-bottom: 6px; color: #374151; display: flex; justify-content: space-between; align-items: center;">
          <span id="statsTitle">Field Attribute Stats</span>
          <span class="stats-toggle" style="display: none; font-size: 10px; color: #94a3b8;">‚ñº</span>
        </div>
        <div class="stats-content">
          <div style="display: flex; justify-content: space-between; margin-bottom: 3px;"><span style="color: #64748b;">Avg:</span> <span id="statsAvg" style="font-weight: 600;">-</span></div>
          <div style="display: flex; justify-content: space-between; margin-bottom: 3px;"><span style="color: #64748b;">High:</span> <span id="statsHigh" style="font-weight: 600; color: #22c55e;">-</span></div>
          <div style="display: flex; justify-content: space-between;"><span style="color: #64748b;">Low:</span> <span id="statsLow" style="font-weight: 600; color: #ef4444;">-</span></div>
          <div id="statsNote" style="margin-top: 6px; font-size: 11px; color: #94a3b8; font-style: italic;"></div>
        </div>
      </div>
      <div id="zoomIndicator" style="position: absolute; bottom: 30px; left: 10px; background: white; padding: 6px 10px; border-radius: 6px; box-shadow: 0 2px 6px rgba(0,0,0,0.15); z-index: 1000; font-size: 11px; font-weight: 500;">
        <div style="display: flex; align-items: center; gap: 8px;">
          <span style="color: #64748b;">Zoom: <span id="zoomLevel">13</span></span>
          <span style="color: #94a3b8;">|</span>
          <span id="viewMode" style="color: #3b82f6;">Sample View</span>
        </div>
      </div>
    </div>
    
    <div id="statusMessage"></div>
  </div>

  <script src="https://apis.google.com/js/api.js"></script>
  <script src="https://accounts.google.com/gsi/client"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  
  <script>
    // ========== APP VERSION ==========
    const APP_VERSION = "v1.0.14";
    const BUILD_DATE = "2026-01-14T17:30:07";

    // ========== CONFIG ==========
    const CONFIG = {
      CLIENT_ID: '714780458094-9rde31taeottmavhl5t0uo8b9kfpergc.apps.googleusercontent.com',
      API_KEY: 'AIzaSyCOSDbrAlc3ct2-lRvJv1y7V0nV7haWc9E',
      get SHEET_ID() { return localStorage.getItem('googleSheetId') || '1buu-8KXoM1kRJSOAWtHaAk40seQT5kqGFY9RICYwdRY'; },
      DEFAULT_LAT: 39.8528,
      DEFAULT_LON: -95.5347,
      DEFAULT_ZOOM: 13,
      NUTRIENT_NAMES: {
        sampleId: 'Sample ID', pH: 'pH', OM: 'Organic Matter', P: 'Phosphorus (P)', P2: 'Phosphorus P2', K: 'Potassium (K)',
        CEC: 'CEC', Ca_sat: 'Calcium Base Sat', Mg_sat: 'Magnesium Base Sat', K_Sat: 'Potassium Base Sat', H_Sat: 'Hydrogen Base Sat', Na_Sat: 'Sodium Base Sat',
        Zn: 'Zinc', Cu: 'Copper', Mn: 'Manganese', Fe: 'Iron', Boron: 'Boron', S: 'Sulfur', Buffer_pH: 'Buffer pH',
        Na: 'Sodium', Ca: 'Calcium', Mg: 'Magnesium', NO3: 'Nitrate', NH4: 'Ammonium', Soluble_Salts: 'Soluble Salts', EC: 'EC'
      },
      NUTRIENT_UNITS: {
        sampleId: '', pH: '', OM: '%', P: 'ppm', P2: 'ppm', K: 'ppm', CEC: 'meq/100g',
        Ca_sat: '%', Mg_sat: '%', K_Sat: '%', H_Sat: '%', Na_Sat: '%',
        Zn: 'ppm', Cu: 'ppm', Mn: 'ppm', Fe: 'ppm', Boron: 'ppm', S: 'ppm', Buffer_pH: '',
        Na: 'ppm', Ca: 'ppm', Mg: 'ppm', NO3: 'ppm', NH4: 'ppm', Soluble_Salts: 'mmhos/cm', EC: 'dS/m'
      },
      LOWER_IS_BETTER: ['Mg_sat', 'H_Sat', 'Na_Sat', 'Soluble_Salts'],

      // Attributes where 0 typically means "no data" rather than actual zero
      // For these, we filter out 0 values from display and calculations
      ZERO_MEANS_NO_DATA: ['P', 'P2', 'K', 'OM', 'CEC', 'Zn', 'Cu', 'Mn', 'Fe', 'Boron', 'S', 'Ca', 'Mg', 'Na', 'NO3', 'NH4'],

      // Field-level shading thresholds (absolute values for 3-zone coloring)
      // { yellow: X, green: Y } means: red < X, yellow X-Y, green >= Y
      // For "lower is better" attributes, thresholds are inverted
      FIELD_SHADING_THRESHOLDS: {
        P: { yellow: 35, green: 70 },
        P2: { yellow: 35, green: 70 },
        K: { yellow: 125, green: 175 },
        OM: { yellow: 2.5, green: 4.0 },
        pH: { yellow: 6.0, green: 6.5, max: 7.2 },
        CEC: { yellow: 10, green: 20 },
        Ca_sat: { yellow: 60, green: 70 },
        Mg_sat: { green: 10, yellow: 15 }, // Lower is better - inverted
        K_Sat: { yellow: 2.5, green: 4.0 },
        Zn: { yellow: 1.0, green: 2.0 },
        S: { yellow: 8, green: 15 },
        Ca: { yellow: 1000, green: 2000 },
        Mg: { yellow: 150, green: 300 }
      },

      // Default decimal places for each attribute (can be overridden in settings)
      DECIMAL_PLACES: {
        pH: 2,
        Buffer_pH: 2,
        OM: 2,
        P: 0,
        P2: 0,
        K: 0,
        CEC: 1,
        Ca_sat: 1,
        Mg_sat: 1,
        K_Sat: 1,
        H_Sat: 1,
        Na_Sat: 1,
        Zn: 2,
        Cu: 2,
        Mn: 1,
        Fe: 1,
        Boron: 2,
        S: 1,
        Ca: 0,
        Mg: 0,
        Na: 0,
        NO3: 1,
        NH4: 1,
        Soluble_Salts: 2,
        EC: 2
      },

      // All nutrients in display order with default visibility
      ALL_NUTRIENTS: [
        { key: 'sampleId', name: 'Sample ID', defaultVisible: true },
        { key: 'pH', name: 'pH', defaultVisible: true },
        { key: 'P', name: 'Phosphorus (P)', defaultVisible: true },
        { key: 'K', name: 'Potassium (K)', defaultVisible: true },
        { key: 'OM', name: 'Organic Matter', defaultVisible: true },
        { key: 'CEC', name: 'CEC', defaultVisible: true },
        { key: 'Ca_sat', name: 'Calcium %', defaultVisible: true },
        { key: 'Mg_sat', name: 'Magnesium %', defaultVisible: true },
        { key: 'K_Sat', name: 'K Base Sat %', defaultVisible: true },
        { key: 'H_Sat', name: 'H Base Sat %', defaultVisible: true },
        { key: 'Zn', name: 'Zinc', defaultVisible: true },
        { key: 'Cu', name: 'Copper', defaultVisible: true },
        { key: 'Mn', name: 'Manganese', defaultVisible: true },
        { key: 'Fe', name: 'Iron', defaultVisible: true },
        { key: 'Boron', name: 'Boron', defaultVisible: true },
        { key: 'S', name: 'Sulfur', defaultVisible: true },
        { key: 'Buffer_pH', name: 'Buffer pH', defaultVisible: true },
        // Hidden by default
        { key: 'P2', name: 'Phosphorus P2', defaultVisible: false },
        { key: 'Na_Sat', name: 'Na Base Sat %', defaultVisible: false },
        { key: 'Na', name: 'Sodium', defaultVisible: false },
        { key: 'Ca', name: 'Calcium (ppm)', defaultVisible: false },
        { key: 'Mg', name: 'Magnesium (ppm)', defaultVisible: false },
        { key: 'NO3', name: 'Nitrate', defaultVisible: false },
        { key: 'NH4', name: 'Ammonium', defaultVisible: false },
        { key: 'Soluble_Salts', name: 'Soluble Salts', defaultVisible: false },
        { key: 'EC', name: 'EC', defaultVisible: false }
      ]
    };
    
    // Get visible nutrients based on settings
    function getVisibleNutrients() {
      const saved = JSON.parse(localStorage.getItem('nutrientVisibility') || '{}');
      return CONFIG.ALL_NUTRIENTS.filter(n => {
        return saved[n.key] !== undefined ? saved[n.key] : n.defaultVisible;
      });
    }
    
    // Populate attribute dropdown with visible nutrients
    function populateAttributeDropdown() {
      const select = document.getElementById('attributeSelect');
      const currentValue = select.value;
      const visible = getVisibleNutrients();
      
      select.innerHTML = visible.map(n => 
        `<option value="${n.key}">${n.name}</option>`
      ).join('');
      
      // Restore previous selection if still visible, otherwise default to P
      if (visible.some(n => n.key === currentValue)) {
        select.value = currentValue;
      } else if (visible.some(n => n.key === 'P')) {
        select.value = 'P';
        selectedAttribute = 'P';
      }
    }

    // ========== SHEETS API ==========
    let tokenClient;
    let accessToken = null;
    let tokenExpiry = null;

    const SheetsAPI = {
      isInitialized: false,
      isSignedIn: false,
      SHEETS: { FIELDS: 'Fields', SAMPLES: 'Samples', SETTINGS: 'Settings' },

      async init() {
        return new Promise((resolve, reject) => {
          // Load the Google API client library
          gapi.load('client', async () => {
            try {
              await gapi.client.init({
                apiKey: CONFIG.API_KEY,
                discoveryDocs: ['https://sheets.googleapis.com/$discovery/rest?version=v4'],
              });
              this.isInitialized = true;

              // Initialize the token client for Google Identity Services
              tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: CONFIG.CLIENT_ID,
                scope: 'https://www.googleapis.com/auth/spreadsheets',
                callback: (response) => {
                  if (response.error) {
                    console.error('Token error:', response);
                    return;
                  }
                  accessToken = response.access_token;
                  // Token expires in 1 hour, set expiry with buffer
                  tokenExpiry = Date.now() + (response.expires_in * 1000) - 60000;
                  // Save token to localStorage
                  localStorage.setItem('googleAccessToken', accessToken);
                  localStorage.setItem('googleTokenExpiry', tokenExpiry.toString());
                  gapi.client.setToken({ access_token: accessToken });
                  this.isSignedIn = true;
                  this.onSignInChange(true);
                },
              });

              // Check for saved token (but don't set it yet - we'll try public access first)
              const savedToken = localStorage.getItem('googleAccessToken');
              const savedExpiry = localStorage.getItem('googleTokenExpiry');
              if (savedToken && savedExpiry && Date.now() < parseInt(savedExpiry)) {
                accessToken = savedToken;
                tokenExpiry = parseInt(savedExpiry);
                // Don't set token or mark as signed in yet - we'll do this after trying public access
              }

              // Set up token refresh check every 5 minutes
              setInterval(() => this.checkTokenRefresh(), 300000);

              resolve(true);
            } catch (error) {
              console.error('Error initializing Google API:', error);
              reject(error);
            }
          });
        });
      },

      // Restore saved OAuth token after public load attempt
      restoreSavedToken() {
        if (accessToken && tokenExpiry && Date.now() < tokenExpiry) {
          gapi.client.setToken({ access_token: accessToken });
          this.isSignedIn = true;
          return true;
        }
        return false;
      },
      
      checkTokenRefresh() {
        // If token expires in less than 10 minutes, refresh it silently
        if (this.isSignedIn && tokenExpiry && Date.now() > tokenExpiry - 600000) {
          console.log('Token expiring soon, refreshing...');
          tokenClient.requestAccessToken({ prompt: '' }); // Silent refresh
        }
      },

      // Validate token by making a lightweight API call
      async validateToken() {
        try {
          // Try to get spreadsheet metadata (lightweight call)
          await gapi.client.sheets.spreadsheets.get({
            spreadsheetId: CONFIG.SHEET_ID,
            fields: 'spreadsheetId'  // Only request minimal data
          });
          return true;
        } catch (e) {
          console.log('Token validation failed:', e?.result?.error?.code || e.message);
          return false;
        }
      },

      // Attempt to refresh token and retry the operation
      async refreshTokenAndRetry(operation) {
        return new Promise((resolve, reject) => {
          console.log('Attempting token refresh...');
          const originalCallback = tokenClient.callback;
          tokenClient.callback = async (response) => {
            if (response.error) {
              console.error('Token refresh failed:', response);
              tokenClient.callback = originalCallback;
              reject(new Error('Token refresh failed'));
              return;
            }
            accessToken = response.access_token;
            tokenExpiry = Date.now() + (response.expires_in * 1000) - 60000;
            localStorage.setItem('googleAccessToken', accessToken);
            localStorage.setItem('googleTokenExpiry', tokenExpiry.toString());
            gapi.client.setToken({ access_token: accessToken });
            tokenClient.callback = originalCallback;

            try {
              const result = await operation();
              resolve(result);
            } catch (e) {
              reject(e);
            }
          };
          tokenClient.requestAccessToken({ prompt: '' });
        });
      },
      
      async signIn() { 
        tokenClient.requestAccessToken({ prompt: 'consent' }); 
      },
      async signOut() { 
        if (accessToken) {
          google.accounts.oauth2.revoke(accessToken);
          accessToken = null;
          tokenExpiry = null;
        }
        localStorage.removeItem('googleAccessToken');
        localStorage.removeItem('googleTokenExpiry');
        this.isSignedIn = false;
        this.onSignInChange(false);
      },
      onSignInChange(isSignedIn) { console.log('Sign-in state:', isSignedIn); },
      
      async getFields() {
        try {
          const sheetId = CONFIG.SHEET_ID;
          console.log('Loading fields from sheet:', sheetId);
          const response = await gapi.client.sheets.spreadsheets.values.get({
            spreadsheetId: sheetId,
            range: `${this.SHEETS.FIELDS}!A2:E1000`
          });
          const rows = response.result.values || [];
          return rows.map(row => ({
            id: row[0], name: row[1],
            boundary: row[2] ? JSON.parse(row[2]) : null,
            acres: parseFloat(row[3]) || 0
          }));
        } catch (e) { 
          console.error('getFields error:', e); 
          throw e; // Re-throw so loadFromSheets knows it failed
        }
      },
      
      async getSamples() {
        try {
          const sheetId = CONFIG.SHEET_ID;
          console.log('Loading samples from sheet:', sheetId);
          const response = await gapi.client.sheets.spreadsheets.values.get({
            spreadsheetId: sheetId,
            range: `${this.SHEETS.SAMPLES}!A1:ZZ10000`
          });
          const rows = response.result.values || [];
          if (rows.length < 2) return [];
          const headers = rows[0];
          const samples = [];
          for (let i = 1; i < rows.length; i++) {
            const row = rows[i];
            const sample = {};
            headers.forEach((header, idx) => {
              const value = row[idx];
              if (header === 'yieldCorrelations' && value) {
                // Parse JSON object for yield correlations
                try { sample[header] = JSON.parse(value); } catch (e) { sample[header] = null; }
              } else if (header !== 'sampleId' && header !== 'field' && value) {
                const num = parseFloat(value);
                sample[header] = isNaN(num) ? value : num;
              } else {
                sample[header] = value || '';
              }
            });
            samples.push(sample);
          }
          return samples;
        } catch (e) { 
          console.error('getSamples error:', e); 
          throw e; // Re-throw so loadFromSheets knows it failed
        }
      },
      
      async getSettings() {
        try {
          const sheetId = CONFIG.SHEET_ID;
          const response = await gapi.client.sheets.spreadsheets.values.get({
            spreadsheetId: sheetId,
            range: `${this.SHEETS.SETTINGS}!A2:D100`
          });
          const rows = response.result.values || [];
          const settings = {};
          rows.forEach(row => {
            settings[row[0]] = { min: parseFloat(row[1]) || null, target: parseFloat(row[2]) || null, max: parseFloat(row[3]) || null };
          });
          return settings;
        } catch (e) { 
          console.error('getSettings error:', e); 
          return {}; // Settings are optional, don't throw
        }
      }
    };

    // ========== UTILS ==========
    const Utils = {
      showStatus(message, isSuccess = true) {
        const el = document.getElementById('statusMessage');
        if (!el) return;
        el.textContent = message;
        el.style.display = 'block';
        el.style.background = isSuccess ? '#dcfce7' : '#fee2e2';
        el.style.color = isSuccess ? '#166534' : '#991b1b';
        setTimeout(() => el.style.display = 'none', 4000);
      },

      // Return the global settings object
      loadSettings() {
        return settings;
      },

      // Interpolate between two hex colors
      interpolateColor(color1, color2, factor) {
        const hex = c => parseInt(c, 16);
        const r1 = hex(color1.slice(1,3)), g1 = hex(color1.slice(3,5)), b1 = hex(color1.slice(5,7));
        const r2 = hex(color2.slice(1,3)), g2 = hex(color2.slice(3,5)), b2 = hex(color2.slice(5,7));
        const r = Math.round(r1 + (r2 - r1) * factor);
        const g = Math.round(g1 + (g2 - g1) * factor);
        const b = Math.round(b1 + (b2 - b1) * factor);
        return `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`;
      },

      // Get gradient color from red->yellow->green based on position (0-1)
      getGradientColor(position, isLowerBetter = false) {
        // Clamp position to 0-1
        const p = Math.max(0, Math.min(1, isLowerBetter ? 1 - position : position));
        // Color stops: red (#dc2626) -> orange (#f97316) -> yellow (#eab308) -> lime (#84cc16) -> green (#16a34a)
        const stops = [
          { pos: 0.0, color: '#dc2626' },  // red
          { pos: 0.25, color: '#f97316' }, // orange
          { pos: 0.5, color: '#eab308' },  // yellow
          { pos: 0.75, color: '#84cc16' }, // lime
          { pos: 1.0, color: '#16a34a' }   // green
        ];
        // Find the two stops to interpolate between
        for (let i = 0; i < stops.length - 1; i++) {
          if (p >= stops[i].pos && p <= stops[i+1].pos) {
            const range = stops[i+1].pos - stops[i].pos;
            const factor = (p - stops[i].pos) / range;
            return this.interpolateColor(stops[i].color, stops[i+1].color, factor);
          }
        }
        return stops[stops.length - 1].color;
      },

      // Get gradient color for change values (negative->neutral->positive)
      getChangeGradientColor(percentChange) {
        // Clamp to -30% to +30% range for color scaling
        const clampedPct = Math.max(-30, Math.min(30, percentChange));
        // Map to 0-1 where 0 = -30%, 0.5 = 0%, 1 = +30%
        const position = (clampedPct + 30) / 60;
        // Color stops: dark red -> light red -> gray -> light green -> dark green
        const stops = [
          { pos: 0.0, color: '#b91c1c' },  // dark red (-30%+)
          { pos: 0.25, color: '#f87171' }, // light red
          { pos: 0.45, color: '#d1d5db' }, // light gray
          { pos: 0.55, color: '#d1d5db' }, // light gray (neutral zone)
          { pos: 0.75, color: '#86efac' }, // light green
          { pos: 1.0, color: '#15803d' }   // dark green (+30%+)
        ];
        for (let i = 0; i < stops.length - 1; i++) {
          if (position >= stops[i].pos && position <= stops[i+1].pos) {
            const range = stops[i+1].pos - stops[i].pos;
            const factor = (position - stops[i].pos) / range;
            return this.interpolateColor(stops[i].color, stops[i+1].color, factor);
          }
        }
        return stops[stops.length - 1].color;
      },

      // Get median-based color using IQR to handle outliers
      // isLowerBetter: if true, lower values get green, higher get red (for Mg_sat, H_Sat, etc.)
      getMedianBasedColor(value, values, isLowerBetter = false) {
        if (!values || values.length === 0) return '#94a3b8';
        const sorted = [...values].sort((a, b) => a - b);
        const len = sorted.length;

        // Calculate quartiles
        const q1 = sorted[Math.floor(len * 0.25)];
        const q3 = sorted[Math.floor(len * 0.75)];
        const iqr = q3 - q1;

        // Use IQR-based bounds (ignore outliers beyond 1.5*IQR)
        const lowerBound = Math.max(sorted[0], q1 - 1.5 * iqr);
        const upperBound = Math.min(sorted[len - 1], q3 + 1.5 * iqr);
        const range = upperBound - lowerBound;

        if (range === 0) return '#eab308'; // All same value = yellow

        // Clamp value to bounds for color calculation
        const clampedValue = Math.max(lowerBound, Math.min(upperBound, value));
        const position = (clampedValue - lowerBound) / range; // 0 to 1

        // Use smooth gradient
        return this.getGradientColor(position, isLowerBetter);
      },
      
      // Get color for year-over-year change
      getChangeColor(change, percentChange) {
        // Use smooth gradient for change colors
        return this.getChangeGradientColor(percentChange);
      },
      
      getColor(value, attribute, settings = {}, bufferPercent = 25, allValues = null) {
        // Sample ID gets neutral blue color
        if (attribute === 'sampleId') return '#3b82f6';

        // CEC and micronutrients use median-based coloring if allValues provided
        const medianBasedAttrs = ['CEC', 'Zn', 'Cu', 'Mn', 'Fe', 'Boron', 'S'];
        if (medianBasedAttrs.includes(attribute) && allValues && allValues.length > 0) {
          return this.getMedianBasedColor(value, allValues);
        }

        // Default thresholds if none provided
        const defaultThresholds = {
          pH: { min: 6.3, max: 6.9 },
          P: { min: 20, max: null },
          K: { min: 150, max: null },
          OM: { min: 3.0, max: null },
          Ca_sat: { min: 65, max: 75 },
          Mg_sat: { min: null, max: 15 },
          K_Sat: { min: 3.0, max: null },
          H_Sat: { min: null, max: 5.0 }
        };

        const threshold = settings[attribute] || defaultThresholds[attribute];
        const isLowerBetter = CONFIG.LOWER_IS_BETTER.includes(attribute);

        if (!threshold) {
          return '#94a3b8';
        }

        // Calculate position for smooth gradient (0 = worst, 1 = best)
        if (threshold.min !== null && threshold.max !== null) {
          // Range threshold (pH, Ca_sat) - optimal is in the middle
          const buffer = (threshold.max - threshold.min) * (bufferPercent / 100);
          const lowerBound = threshold.min - buffer;
          const upperBound = threshold.max + buffer;

          if (value >= threshold.min && value <= threshold.max) {
            return '#16a34a'; // In optimal range = green
          } else if (value < threshold.min) {
            // Below optimal - calculate position from lowerBound to min
            const pos = Math.max(0, (value - lowerBound) / (threshold.min - lowerBound));
            return this.getGradientColor(pos * 0.5, false); // 0-0.5 range (red to yellow)
          } else {
            // Above optimal - calculate position from max to upperBound
            const pos = Math.max(0, 1 - (value - threshold.max) / (upperBound - threshold.max));
            return this.getGradientColor(pos * 0.5, false); // 0-0.5 range (red to yellow)
          }
        } else if (threshold.min !== null) {
          // Minimum threshold (P, K, OM, K_Sat) - higher is better
          const buffer = threshold.min * (bufferPercent / 100);
          const lowerBound = threshold.min - buffer;
          // Calculate position: 0 at lowerBound, 1 at min (optimal)
          if (value >= threshold.min) {
            // Above optimal - calculate gradient up to 2x min
            const pos = Math.min(1, 0.5 + (value - threshold.min) / (threshold.min * 2) * 0.5);
            return this.getGradientColor(pos, false);
          } else {
            // Below optimal
            const pos = Math.max(0, (value - lowerBound) / (threshold.min - lowerBound)) * 0.5;
            return this.getGradientColor(pos, false);
          }
        } else if (threshold.max !== null) {
          // Maximum threshold (Mg_sat, H_Sat) - lower is better
          const buffer = threshold.max * (bufferPercent / 100);
          const upperBound = threshold.max + buffer;
          if (value <= threshold.max) {
            // Below max (good) - calculate gradient
            const pos = 0.5 + (1 - value / threshold.max) * 0.5;
            return this.getGradientColor(Math.min(1, pos), false);
          } else {
            // Above max (bad)
            const pos = Math.max(0, 1 - (value - threshold.max) / (upperBound - threshold.max)) * 0.5;
            return this.getGradientColor(pos, false);
          }
        }
        return '#94a3b8';
      },
      
      formatNumber(value, decimals = 1) {
        if (value === null || value === undefined || isNaN(value)) return '-';
        return Number(value).toFixed(decimals);
      },

      // Get decimal places for an attribute (checks user settings, then CONFIG defaults)
      getDecimals(attr) {
        // Check for user-customized settings first
        const customDecimals = JSON.parse(localStorage.getItem('decimalPlaces') || '{}');
        if (customDecimals[attr] !== undefined) {
          return customDecimals[attr];
        }
        // Fall back to CONFIG defaults
        if (CONFIG.DECIMAL_PLACES[attr] !== undefined) {
          return CONFIG.DECIMAL_PLACES[attr];
        }
        // Default to 1 decimal for unknown attributes
        return 1;
      },

      // Format a value using the configured decimal places for an attribute
      formatValue(value, attr) {
        if (value === null || value === undefined || isNaN(value)) return '-';
        const decimals = Utils.getDecimals(attr);
        return Number(value).toFixed(decimals);
      },

      getUniqueYears(samples) {
        return [...new Set(samples.map(s => s.year).filter(y => y))].sort();
      },
      
      getUniqueFields(samples) {
        return [...new Set(samples.map(s => s.field).filter(f => f))].sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));
      },
      
      groupByField(samples) {
        const groups = {};
        samples.forEach(s => {
          const f = s.field || 'Unknown';
          if (!groups[f]) groups[f] = [];
          groups[f].push(s);
        });
        return groups;
      },
      
      calculateFieldAverage(samples, nutrient) {
        const values = samples.map(s => s[nutrient]).filter(v => this.isValidValue(v, nutrient));
        if (values.length === 0) return null;
        return values.reduce((a, b) => a + b, 0) / values.length;
      },

      // Check if a value represents actual data (not missing/placeholder)
      // For certain attributes, 0 typically means "not tested" rather than actual zero
      isValidValue(value, attribute) {
        if (value === undefined || value === null || value === '') return false;
        const num = parseFloat(value);
        if (isNaN(num) || !isFinite(num)) return false;
        // For attributes where 0 means "no data", filter out zeros
        if (num === 0 && CONFIG.ZERO_MEANS_NO_DATA.includes(attribute)) {
          return false;
        }
        return true;
      },

      // Get numeric value or null if invalid
      getNumericValue(value, attribute) {
        if (!this.isValidValue(value, attribute)) return null;
        return parseFloat(value);
      }
    };

    // ========== APP STATE ==========
    let map;
    let sampleData = [];
    let fieldBoundaries = {};
    let settings = {};
    let currentLayers = [];
    let selectedField = 'all';
    let selectedAttribute = 'P';
    let selectedYear = 'all';
    let compareYear = '';
    let compareMode = false;
    let fieldModeActive = false;
    let gpsMarker = null, gpsCircle = null, gpsWatchId = null;

    // ========== INIT ==========
    document.addEventListener('DOMContentLoaded', async () => {
      populateAttributeDropdown(); // Populate nutrients based on visibility settings
      initMap();
      setupEventListeners();
      updateZoomIndicator(); // Initialize zoom indicator

      // Load operation name
      const opName = localStorage.getItem('operationName');
      if (opName) {
        document.getElementById('operationSubtitle').textContent = opName;
      }

      // Load cached data first for instant display
      loadLocalData();
      updateLastUpdated();
      updateBackupFooter();

      // Check if cache is fresh (less than 5 minutes old)
      const cacheTime = localStorage.getItem('soilDataCacheTime');
      const cacheFresh = cacheTime && (Date.now() - parseInt(cacheTime)) < 300000; // 5 minutes

      try {
        await SheetsAPI.init();
        SheetsAPI.onSignInChange = handleSignInChange;

        // Try to load from Google Sheets (public access first)
        if (!cacheFresh) {
          const loaded = await loadFromSheetsPublic();
          // If Sheets failed and we have no data, try backup
          if (!loaded && sampleData.length === 0) {
            loadFromBackup();
          }
        } else {
          console.log('Using fresh cached data');
          // Still restore token state for UI
          if (SheetsAPI.restoreSavedToken()) {
            handleSignInChange(true);
          }
        }
      } catch (e) {
        console.warn('Google API init error:', e);
        // If we have no data, try loading from backup
        if (sampleData.length === 0) {
          loadFromBackup();
        }
      }

      // Listen for visibility changes from settings page
      window.addEventListener('storage', (e) => {
        if (e.key === 'nutrientVisibility') {
          populateAttributeDropdown();
        }
        if (e.key === 'operationName') {
          document.getElementById('operationSubtitle').textContent = e.newValue || 'Precision Farms Field Management';
        }
      });
    });

    function initMap() {
      map = L.map('map').setView([CONFIG.DEFAULT_LAT, CONFIG.DEFAULT_LON], CONFIG.DEFAULT_ZOOM);
      const street = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '¬© OpenStreetMap', maxZoom: 19 });
      const satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: '¬© Esri', maxZoom: 19 });
      satellite.addTo(map); // Default to satellite
      L.control.layers({ "Street": street, "Satellite": satellite }).addTo(map);
      
      // Listen for zoom changes to switch between field view and sample view
      map.on('zoomend', function() {
        updateZoomIndicator();
        updateMap();
      });

      // Also update on zoom start for smoother feel
      map.on('zoom', function() {
        updateZoomIndicator();
      });
      
      // Add "Center on Me" button for mobile
      const centerControl = L.control({ position: 'topleft' });
      centerControl.onAdd = function() {
        const div = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
        div.innerHTML = '<a href="#" title="Center on my location" style="display:flex;align-items:center;justify-content:center;width:34px;height:34px;background:white;font-size:18px;">‚äï</a>';
        div.onclick = function(e) {
          e.preventDefault();
          e.stopPropagation();
          centerOnMe();
          return false;
        };
        return div;
      };
      centerControl.addTo(map);
    }
    
    function centerOnMe() {
      if (!navigator.geolocation) {
        Utils.showStatus('Geolocation not supported', false);
        return;
      }
      Utils.showStatus('Getting your location...', true);
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          const { latitude, longitude, accuracy } = pos.coords;
          map.setView([latitude, longitude], 16);
          
          // Update or create GPS marker
          if (gpsMarker) {
            gpsMarker.setLatLng([latitude, longitude]);
            gpsCircle.setLatLng([latitude, longitude]).setRadius(accuracy);
          } else {
            const gpsIcon = L.divIcon({
              html: '<div class="gps-marker"><div class="gps-pulse"></div><div class="gps-dot"></div></div>',
              className: '',
              iconSize: [22, 22],
              iconAnchor: [11, 11]
            });
            gpsMarker = L.marker([latitude, longitude], { icon: gpsIcon }).addTo(map);
            gpsCircle = L.circle([latitude, longitude], {
              radius: accuracy, color: '#3b82f6', fillColor: '#3b82f6', fillOpacity: 0.1, weight: 2, dashArray: '4'
            }).addTo(map);
          }
          Utils.showStatus('Centered on your location', true);
        },
        (err) => {
          Utils.showStatus('Could not get location: ' + err.message, false);
        },
        { enableHighAccuracy: true, timeout: 10000 }
      );
    }

    function setupEventListeners() {
      document.getElementById('fieldSelect').addEventListener('change', (e) => { 
        selectedField = e.target.value; 
        updateYearSelector(); // Update years based on selected field
        updateMap(); 
        zoomToField(selectedField); 
      });
      document.getElementById('attributeSelect').addEventListener('change', (e) => { selectedAttribute = e.target.value; updateYearSelector(); updateCompareYearOptions(); updateMap(); updateLegend(); });
      document.getElementById('yearSelect').addEventListener('change', (e) => {
        selectedYear = e.target.value;
        console.log('Year changed to:', selectedYear);
        updateCompareYearOptions();
        updateMap();
      });
      document.getElementById('compareYearSelect').addEventListener('change', (e) => { compareYear = e.target.value; updateCompareSummary(); updateMap(); });
      document.getElementById('compareToYearSelect').addEventListener('change', (e) => { selectedYear = e.target.value; updateCompareSummary(); updateMap(); });
      document.getElementById('singleYearBtn').addEventListener('click', () => {
        compareMode = false;
        document.getElementById('singleYearBtn').classList.add('active');
        document.getElementById('compareYearsBtn').classList.remove('active');
        document.getElementById('compareYearStack').style.display = 'none';
        document.getElementById('viewYearGroup').style.display = 'block';
        document.getElementById('compareInfoBar').style.display = 'none';
        // Sync selectedYear with the View mode dropdown
        selectedYear = document.getElementById('yearSelect').value;
        updateLegend();
        updateMap();
      });
      document.getElementById('compareYearsBtn').addEventListener('click', () => {
        compareMode = true;
        document.getElementById('compareYearsBtn').classList.add('active');
        document.getElementById('singleYearBtn').classList.remove('active');
        document.getElementById('compareYearStack').style.display = 'block';
        document.getElementById('viewYearGroup').style.display = 'none';
        document.getElementById('compareInfoBar').style.display = 'block';
        updateCompareYearOptions();
        updateCompareSummary();
        updateLegend();
        updateMap();
      });
      document.getElementById('fieldModeBtn').addEventListener('click', toggleFieldMode);
      document.getElementById('refreshBtn').addEventListener('click', () => {
        // Reload data from localStorage (in case it was changed on another page)
        sampleData = [];
        fieldBoundaries = {};
        loadLocalData();
        Utils.showStatus('Data refreshed', true);
      });
      
      // Mobile toolbar buttons
      document.getElementById('mobileFieldModeBtn').addEventListener('click', toggleFieldMode);
      document.getElementById('mobileRefreshBtn').addEventListener('click', () => {
        sampleData = [];
        fieldBoundaries = {};
        loadLocalData();
        Utils.showStatus('Data refreshed', true);
      });
      document.getElementById('mobileCompareBtn').addEventListener('click', toggleMobileCompare);
    }
    
    function toggleMobileCompare() {
      const btn = document.getElementById('mobileCompareBtn');
      compareMode = !compareMode;

      if (compareMode) {
        btn.textContent = 'üìä Compare ON';
        btn.classList.add('active');
        document.getElementById('compareYearsBtn').classList.add('active');
        document.getElementById('singleYearBtn').classList.remove('active');
        document.getElementById('compareYearStack').style.display = 'block';
        document.getElementById('viewYearGroup').style.display = 'none';
        document.getElementById('compareInfoBar').style.display = 'block';
        updateCompareYearOptions();
        updateCompareSummary();
      } else {
        btn.textContent = 'üìä Compare';
        btn.classList.remove('active');
        document.getElementById('singleYearBtn').classList.add('active');
        document.getElementById('compareYearsBtn').classList.remove('active');
        document.getElementById('compareYearStack').style.display = 'none';
        document.getElementById('viewYearGroup').style.display = 'block';
        document.getElementById('compareInfoBar').style.display = 'none';
        compareYear = '';
      }
      updateLegend();
      updateMap();
    }

    function updateCompareSummary() {
      const baselineYear = document.getElementById('compareYearSelect').value;
      const compareToYear = document.getElementById('compareToYearSelect').value;
      const summaryEl = document.getElementById('compareSummaryText');

      if (baselineYear && compareToYear) {
        summaryEl.innerHTML = `Showing change from <strong>${baselineYear}</strong> ‚Üí <strong>${compareToYear}</strong>`;
        summaryEl.style.color = '#166534';
      } else if (baselineYear || compareToYear) {
        summaryEl.textContent = 'Select both years to compare';
        summaryEl.style.color = '#d97706';
      } else {
        summaryEl.textContent = 'Select years to compare';
        summaryEl.style.color = '#1e40af';
      }
    }

    function updateCompareYearOptions() {
      const baselineSel = document.getElementById('compareYearSelect');
      const compareToSel = document.getElementById('compareToYearSelect');

      // Filter samples by field and attribute
      let filteredSamples = selectedField === 'all'
        ? sampleData
        : sampleData.filter(s => s.field === selectedField);

      // Only include years that have data for the selected attribute
      filteredSamples = filteredSamples.filter(s => {
        const v = s[selectedAttribute];
        return v !== undefined && v !== null && (selectedAttribute === 'sampleId' || !isNaN(v));
      });

      const years = Utils.getUniqueYears(filteredSamples);

      // Populate baseline dropdown (older years first)
      baselineSel.innerHTML = '<option value="">Select...</option>';
      years.forEach(y => {
        const o = document.createElement('option');
        o.value = y; o.textContent = y;
        baselineSel.appendChild(o);
      });

      // Populate compare-to dropdown (newer years first, reversed)
      compareToSel.innerHTML = '<option value="">Select...</option>';
      [...years].reverse().forEach(y => {
        const o = document.createElement('option');
        o.value = y; o.textContent = y;
        compareToSel.appendChild(o);
      });

      // Auto-select: baseline = oldest year, compare-to = newest year
      // Only auto-set selectedYear when in Compare mode (not View mode)
      if (years.length >= 2) {
        baselineSel.value = years[0]; // Oldest
        compareYear = years[0];
        compareToSel.value = years[years.length - 1]; // Newest
        if (compareMode) {
          selectedYear = years[years.length - 1];
        }
      } else if (years.length === 1) {
        baselineSel.value = years[0];
        compareYear = years[0];
      }
    }
    
    function updateLegend() {
      const legendText = document.getElementById('legendText');
      if (compareMode) {
        legendText.textContent = 'Decrease ‚Üê ‚Üí Increase';
        document.querySelector('#legendBar div').style.background = 'linear-gradient(to right, #b91c1c, #f87171, #d1d5db, #86efac, #15803d)';
      } else {
        legendText.textContent = 'Low ‚Üí High';
        document.querySelector('#legendBar div').style.background = 'linear-gradient(to right, #dc2626, #f97316, #eab308, #84cc16, #16a34a)';
      }
    }
    
    function updateStats(values, mode = 'sample') {
      const statsTitle = document.getElementById('statsTitle');
      const statsAvg = document.getElementById('statsAvg');
      const statsHigh = document.getElementById('statsHigh');
      const statsLow = document.getElementById('statsLow');
      const statsNote = document.getElementById('statsNote');

      const attrName = CONFIG.NUTRIENT_NAMES[selectedAttribute] || selectedAttribute;
      const unit = CONFIG.NUTRIENT_UNITS[selectedAttribute] || '';
      statsTitle.textContent = attrName;

      // Update note based on mode
      if (mode === 'field') {
        statsNote.textContent = 'Based on field averages';
      } else {
        statsNote.textContent = 'Based on sample points';
      }

      if (!values || values.length === 0) {
        statsAvg.textContent = '-';
        statsHigh.textContent = '-';
        statsLow.textContent = '-';
        return;
      }

      const avg = values.reduce((a, b) => a + b, 0) / values.length;
      const high = Math.max(...values);
      const low = Math.min(...values);
      const decimals = Utils.getDecimals(selectedAttribute);

      statsAvg.textContent = avg.toFixed(decimals) + (unit ? ' ' + unit : '');
      statsHigh.textContent = high.toFixed(decimals) + (unit ? ' ' + unit : '');
      statsLow.textContent = low.toFixed(decimals) + (unit ? ' ' + unit : '');
    }

    async function handleAuth() {
      if (SheetsAPI.isSignedIn) await SheetsAPI.signOut();
      else await SheetsAPI.signIn();
    }

    function handleSignInChange(isSignedIn) {
      const authBtn = document.getElementById('authBtn');
      const userInfo = document.getElementById('userInfo');
      if (isSignedIn) {
        userInfo.textContent = 'Connected';
        authBtn.textContent = '‚úì Signed In';
        authBtn.classList.add('signed-in');
        // Only reload if user explicitly signed in (not on initial load with saved token)
        // The initial load already happened via loadFromSheetsPublic
      } else {
        userInfo.textContent = '';
        authBtn.textContent = 'Sign In to Edit';
        authBtn.classList.remove('signed-in');
      }
      updateMobileAuthBtn();
    }

    function updateMobileAuthBtn() {
      // Mobile toolbar doesn't have a dedicated auth button
      // The refresh button can be used to sync when signed in
    }

    // Load data using API key only (public access) - no OAuth required
    async function loadFromSheetsPublic() {
      Utils.showStatus('Loading data...', true);

      try {
        console.log('Attempting public load from sheet ID:', CONFIG.SHEET_ID);
        const fields = await SheetsAPI.getFields();
        fieldBoundaries = {};
        fields.forEach(f => { if (f.boundary) fieldBoundaries[f.name] = f.boundary; });
        sampleData = await SheetsAPI.getSamples();
        settings = await SheetsAPI.getSettings();
        updateFieldSelector();
        updateYearSelector();
        updateMap();
        saveLocalData();
        Utils.showStatus(`Loaded ${sampleData.length} samples, ${Object.keys(fieldBoundaries).length} fields`, true);

        // Restore saved OAuth token for edit capabilities (if available)
        if (SheetsAPI.restoreSavedToken()) {
          handleSignInChange(true);
        }
        return true;
      } catch (e) {
        console.log('Public access failed:', e?.result?.error?.code || e.message);
        const errorCode = e.result?.error?.code;

        // 403 = sheet is not public, need to sign in
        if (errorCode === 403) {
          console.log('Sheet is not public, checking for saved OAuth token...');
          // Try with saved OAuth token if available
          if (SheetsAPI.restoreSavedToken()) {
            handleSignInChange(true);
            return loadFromSheets();
          }
          Utils.showStatus('Sign in required to access this sheet', false);
          return false;
        }

        // 404 = sheet not found
        if (errorCode === 404) {
          Utils.showStatus('Google Sheet not found - check Sheet ID in Settings', false);
          return false;
        }

        // Other errors - use cached data
        Utils.showStatus('Could not connect to Google Sheets', false);
        return false;
      }
    }

    async function loadFromSheets(isRetry = false) {
      Utils.showStatus('Loading from Google Sheets...', true);

      const doLoad = async () => {
        console.log('Attempting to load from sheet ID:', CONFIG.SHEET_ID);
        const fields = await SheetsAPI.getFields();
        fieldBoundaries = {};
        fields.forEach(f => { if (f.boundary) fieldBoundaries[f.name] = f.boundary; });
        sampleData = await SheetsAPI.getSamples();
        settings = await SheetsAPI.getSettings();
        updateFieldSelector();
        updateYearSelector();
        updateMap();
        saveLocalData();
        Utils.showStatus(`‚úì Loaded ${sampleData.length} samples, ${Object.keys(fieldBoundaries).length} fields`, true);
      };

      try {
        await doLoad();
      } catch (e) {
        console.error('loadFromSheets error:', e);
        const errorCode = e.result?.error?.code;
        const errorMsg = e.result?.error?.message || e.message || 'Unknown error';

        // Handle 401 (unauthorized) - token may be expired/revoked
        if (errorCode === 401 && !isRetry) {
          console.log('Got 401, attempting token refresh and retry...');
          Utils.showStatus('Refreshing authentication...', true);
          try {
            await SheetsAPI.refreshTokenAndRetry(doLoad);
            Utils.showStatus(`‚úì Loaded ${sampleData.length} samples, ${Object.keys(fieldBoundaries).length} fields`, true);
            return;
          } catch (retryError) {
            console.error('Retry after refresh failed:', retryError);
            // Clear invalid token and fall through to error handling
            localStorage.removeItem('googleAccessToken');
            localStorage.removeItem('googleTokenExpiry');
            SheetsAPI.isSignedIn = false;
            handleSignInChange(false);
            Utils.showStatus('Session expired - please sign in again', false);
            loadLocalData();
            return;
          }
        }

        // Handle 403 (forbidden) - no access to sheet
        if (errorCode === 403) {
          Utils.showStatus('No access to this Google Sheet - check sharing settings', false);
          loadLocalData();
          return;
        }

        // Handle 404 (not found) - sheet doesn't exist
        if (errorCode === 404) {
          Utils.showStatus('Google Sheet not found - check Sheet ID in Settings', false);
          loadLocalData();
          return;
        }

        // Generic error
        Utils.showStatus(`Error loading from Sheets: ${errorMsg} - using local cache`, false);
        loadLocalData();
      }
    }

    async function loadData() {
      if (SheetsAPI.isSignedIn) {
        await loadFromSheets();
      } else {
        loadLocalData();
      }
    }

    // IndexedDB for large datasets
    const DB_NAME = 'SoilAppDB';
    const DB_VERSION = 1;

    function openDB() {
      return new Promise((resolve, reject) => {
        if (!window.indexedDB) { reject(new Error('IndexedDB not supported')); return; }
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);
        request.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains('samples')) db.createObjectStore('samples', { keyPath: 'id' });
          if (!db.objectStoreNames.contains('boundaries')) db.createObjectStore('boundaries', { keyPath: 'id' });
        };
      });
    }

    async function loadFromIndexedDB() {
      try {
        const db = await openDB();
        const tx = db.transaction(['samples', 'boundaries'], 'readonly');
        const samplesData = await new Promise((resolve, reject) => {
          const req = tx.objectStore('samples').get('all');
          req.onsuccess = () => resolve(req.result?.data || []);
          req.onerror = reject;
        });
        const boundariesData = await new Promise((resolve, reject) => {
          const req = tx.objectStore('boundaries').get('all');
          req.onsuccess = () => resolve(req.result?.data || {});
          req.onerror = reject;
        });
        db.close();
        return { samples: samplesData, boundaries: boundariesData };
      } catch (e) { return null; }
    }

    async function loadLocalData() {
      try {
        // Check IndexedDB first if flagged
        if (localStorage.getItem('usingIndexedDB') === 'true') {
          const idbData = await loadFromIndexedDB();
          if (idbData && idbData.samples.length > 0) {
            sampleData = idbData.samples;
            fieldBoundaries = idbData.boundaries;
            console.log('Loaded from IndexedDB:', sampleData.length, 'samples');
          }
        } else {
          // Fallback to localStorage
          const s = localStorage.getItem('soilSamples');
          const b = localStorage.getItem('fieldBoundaries');
          if (s) sampleData = JSON.parse(s);
          if (b) fieldBoundaries = JSON.parse(b);
        }

        // Load settings (always in localStorage)
        const st = localStorage.getItem('soilSettings');
        if (st) {
          const rawSettings = JSON.parse(st);
          settings = {
            pH: { min: rawSettings.pH_min || 6.3, max: rawSettings.pH_max || 6.9 },
            P: { min: rawSettings.P_min || 20, max: null },
            K: { min: rawSettings.K_min || 150, max: null },
            OM: { min: rawSettings.OM_min || 3.0, max: null },
            Ca_sat: { min: rawSettings.Ca_sat_min || 65, max: rawSettings.Ca_sat_max || 75 },
            Mg_sat: { min: rawSettings.Mg_sat_min || null, max: rawSettings.Mg_sat_max || 15 },
            K_Sat: { min: rawSettings.K_sat_min || 3.0, max: null },
            H_Sat: { min: null, max: rawSettings.H_sat_max || 5.0 },
            bufferPercent: rawSettings.bufferPercent || 25
          };
        }
        updateFieldSelector();
        updateYearSelector();
        updateMap();
        if (sampleData.length > 0) Utils.showStatus(`Loaded ${sampleData.length} samples`, true);
      } catch (e) { console.error(e); }
    }

    function saveLocalData() {
      try {
        localStorage.setItem('soilSamples', JSON.stringify(sampleData));
        localStorage.setItem('fieldBoundaries', JSON.stringify(fieldBoundaries));
        localStorage.setItem('soilSettings', JSON.stringify(settings));
        localStorage.setItem('soilDataCacheTime', Date.now().toString());
        updateLastUpdated();
      } catch (e) { console.error(e); }
    }

    function updateLastUpdated() {
      const cacheTime = localStorage.getItem('soilDataCacheTime');
      const el = document.getElementById('lastUpdated');
      if (cacheTime && el) {
        const date = new Date(parseInt(cacheTime));
        const now = new Date();
        const isToday = date.toDateString() === now.toDateString();
        if (isToday) {
          el.textContent = `Updated ${date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' })}`;
        } else {
          el.textContent = `Updated ${date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}`;
        }
      }
    }

    // Load from localStorage backup if primary data fails
    function loadFromBackup() {
      try {
        const backup = localStorage.getItem('soilDataBackup');
        if (!backup) return false;

        const data = JSON.parse(backup);
        if (data.sampleData) sampleData = data.sampleData;
        if (data.fieldBoundaries) fieldBoundaries = data.fieldBoundaries;
        if (data.settings) settings = data.settings;

        updateFieldSelector();
        updateYearSelector();
        updateMap();
        Utils.showStatus(`Loaded ${sampleData.length} samples from backup`, true);
        return true;
      } catch (e) {
        console.error('Failed to load from backup:', e);
        return false;
      }
    }

    function updateFieldSelector() {
      const sel = document.getElementById('fieldSelect');
      const val = sel.value;
      sel.innerHTML = '<option value="all">All Fields</option>';
      const fields = [...new Set([...Utils.getUniqueFields(sampleData), ...Object.keys(fieldBoundaries)])].sort((a,b) => a.localeCompare(b, undefined, {numeric:true}));
      fields.forEach(f => { const o = document.createElement('option'); o.value = f; o.textContent = f; sel.appendChild(o); });
      if (fields.includes(val)) sel.value = val;
    }

    function updateYearSelector() {
      const sel = document.getElementById('yearSelect');
      const val = sel.value;
      sel.innerHTML = '<option value="all">All Years</option>';

      // Filter samples by selected field if one is selected
      let filteredSamples = selectedField === 'all'
        ? sampleData
        : sampleData.filter(s => s.field === selectedField);

      // Only include years that have data for the selected attribute
      filteredSamples = filteredSamples.filter(s => {
        const v = s[selectedAttribute];
        return v !== undefined && v !== null && (selectedAttribute === 'sampleId' || !isNaN(v));
      });

      const years = Utils.getUniqueYears(filteredSamples);
      years.forEach(y => { const o = document.createElement('option'); o.value = y; o.textContent = y; sel.appendChild(o); });

      // Keep previous selection if still valid, otherwise reset to 'all'
      if (years.includes(parseInt(val))) {
        sel.value = val;
      } else {
        sel.value = 'all';
        selectedYear = 'all';
      }
    }

    const ZOOM_THRESHOLD = 15; // Zoom level threshold for switching views

    function updateZoomIndicator() {
      const zoomLevel = map.getZoom();
      const isZoomedOut = zoomLevel < ZOOM_THRESHOLD && selectedField === 'all';

      document.getElementById('zoomLevel').textContent = Math.round(zoomLevel);
      const viewModeEl = document.getElementById('viewMode');

      if (isZoomedOut && Object.keys(fieldBoundaries).length > 0 && selectedAttribute !== 'sampleId') {
        viewModeEl.textContent = 'Field View';
        viewModeEl.style.color = '#22c55e';
      } else {
        viewModeEl.textContent = 'Sample View';
        viewModeEl.style.color = '#3b82f6';
      }
    }

    function updateMap() {
      console.log('updateMap called - selectedYear:', selectedYear, 'selectedField:', selectedField, 'selectedAttribute:', selectedAttribute);

      currentLayers.forEach(l => map.removeLayer(l));
      currentLayers = [];

      const zoomLevel = map.getZoom();
      const isZoomedOut = zoomLevel < ZOOM_THRESHOLD && selectedField === 'all'; // Only use field view when "All Fields" selected

      // Compare mode - show year-over-year change (always show samples)
      if (compareMode && selectedYear !== 'all' && compareYear) {
        console.log('Rendering: Compare mode');
        drawBoundaries(false);
        renderCompareMode();
        return;
      }

      // Zoomed out with All Fields: show field-level shading
      if (isZoomedOut && Object.keys(fieldBoundaries).length > 0 && selectedAttribute !== 'sampleId') {
        console.log('Rendering: Field shading (zoomed out)');
        drawFieldShading();
        updateZoomIndicator();
        return;
      }

      // Zoomed in or specific field: show individual samples
      console.log('Rendering: Sample markers');
      drawBoundaries(false);
      drawSampleMarkers();
      updateZoomIndicator();
    }
    
    function drawBoundaries(withShading, fieldColors = {}) {
      Object.entries(fieldBoundaries).forEach(([name, polys]) => {
        if (selectedField !== 'all' && selectedField !== name) return;
        const arr = Array.isArray(polys[0]?.[0]) ? polys : [polys];
        arr.forEach((coords, idx) => {
          const color = fieldColors[name] || '#22c55e';
          const hasNoData = fieldColors[name + '_nodata'] === true;
          const fillOpacity = withShading ? (hasNoData ? 0.3 : 0.6) : 0.1;
          const poly = L.polygon(coords, {
            color: withShading ? color : '#22c55e',
            weight: withShading ? 2 : 3,
            fillOpacity: fillOpacity,
            fillColor: color
          }).addTo(map);

          if (withShading && fieldColors[name]) {
            const fieldStats = fieldColors[name + '_stats'];
            let tooltipContent;
            if (hasNoData) {
              tooltipContent = `<strong>${name}</strong><br><em style="color: #9ca3af;">No data for ${CONFIG.NUTRIENT_NAMES[selectedAttribute] || selectedAttribute}</em>`;
            } else if (fieldStats) {
              tooltipContent = `<strong>${name}</strong><br>Avg ${CONFIG.NUTRIENT_NAMES[selectedAttribute] || selectedAttribute}: ${Utils.formatValue(fieldStats.avg, selectedAttribute)} ${CONFIG.NUTRIENT_UNITS[selectedAttribute] || ''}`;
            } else {
              tooltipContent = name;
            }
            poly.bindTooltip(tooltipContent, { permanent: false, direction: 'center', className: 'field-tooltip' });

            // Add permanent field name label in center (only on first polygon of multi-polygon)
            // Hide labels when zoomed out past level 14 to avoid cluttering the map
            if (idx === 0 && map.getZoom() >= 14) {
              const center = poly.getBounds().getCenter();
              const label = L.marker(center, {
                icon: L.divIcon({
                  className: 'field-label',
                  html: `<div style="background: rgba(255,255,255,0.9); padding: 3px 8px; border-radius: 4px; font-size: 12px; font-weight: 600; color: #1e293b; white-space: nowrap; box-shadow: 0 1px 3px rgba(0,0,0,0.2); border: 1px solid ${color};">${name}</div>`,
                  iconSize: null,
                  iconAnchor: [0, 0]
                }),
                interactive: false
              }).addTo(map);
              currentLayers.push(label);
            }
          } else {
            poly.bindTooltip(name, { permanent: false, direction: 'center' });
          }
          currentLayers.push(poly);
        });
      });
    }
    
    function drawFieldShading() {
      const settings = Utils.loadSettings();
      const bufferPct = settings.bufferPercent || 25;

      // Calculate average for each field
      const fieldAverages = {};
      const fieldColors = {};
      const fieldsWithNoData = [];

      // Get all values for context (for relative coloring)
      let allFieldAvgs = [];

      Object.keys(fieldBoundaries).forEach(fieldName => {
        if (selectedField !== 'all' && selectedField !== fieldName) return;

        let fieldSamples = sampleData.filter(s => s.field === fieldName);
        if (selectedYear !== 'all') {
          fieldSamples = fieldSamples.filter(s => String(s.year) === String(selectedYear));
        }

        // Robust value extraction - handle strings, empty values, zeros for no-data attributes
        const values = fieldSamples
          .map(s => Utils.getNumericValue(s[selectedAttribute], selectedAttribute))
          .filter(v => v !== null);

        if (values.length > 0) {
          const sum = values.reduce((a, b) => a + b, 0);
          const avg = sum / values.length;

          // Debug: check for bad calculations
          if (!isFinite(avg)) {
            console.warn(`Field ${fieldName}: Bad avg calculation - sum=${sum}, count=${values.length}, values sample:`, values.slice(0, 5));
            fieldsWithNoData.push(fieldName);
          } else {
            fieldAverages[fieldName] = { avg, count: values.length };
            allFieldAvgs.push(avg);
          }
        } else {
          // Field has no valid data for this attribute/year
          fieldsWithNoData.push(fieldName);
        }
      });

      // Debug logging
      console.log('Field shading debug:', {
        attribute: selectedAttribute,
        year: selectedYear,
        fieldsWithData: Object.keys(fieldAverages).length,
        fieldsWithNoData: fieldsWithNoData.length,
        allFieldAvgs: allFieldAvgs.slice(0, 5),
        fieldAverages: Object.entries(fieldAverages).slice(0, 3).map(([k, v]) => `${k}: ${v.avg.toFixed(1)}`)
      });

      // Mark fields with no data as grey
      fieldsWithNoData.forEach(fieldName => {
        fieldColors[fieldName] = '#9ca3af'; // Grey for no data
        fieldColors[fieldName + '_stats'] = null; // No stats
        fieldColors[fieldName + '_nodata'] = true;
      });

      // Calculate colors based on field averages using relative coloring
      // This ensures fields are colored relative to each other, not just absolute thresholds
      const isLowerBetter = CONFIG.LOWER_IS_BETTER.includes(selectedAttribute);

      // Remove outliers using IQR method to prevent skewed color gradients
      const removeOutliers = (values) => {
        if (values.length < 4) return values;
        const sorted = [...values].sort((a, b) => a - b);
        const q1 = sorted[Math.floor(sorted.length * 0.25)];
        const q3 = sorted[Math.floor(sorted.length * 0.75)];
        const iqr = q3 - q1;
        const lowerBound = q1 - 1.5 * iqr;
        const upperBound = q3 + 1.5 * iqr;
        const filtered = values.filter(v => v >= lowerBound && v <= upperBound);
        // Log if we removed any outliers
        if (filtered.length < values.length) {
          const outliers = values.filter(v => v < lowerBound || v > upperBound);
          console.log(`Removed ${outliers.length} outlier(s) from color range:`, outliers);
        }
        return filtered.length > 0 ? filtered : values; // Fallback to original if all filtered
      };

      // Use absolute thresholds if defined for this attribute
      const thresholds = CONFIG.FIELD_SHADING_THRESHOLDS[selectedAttribute];

      // Debug: track color distribution
      const colorCounts = { green: 0, yellow: 0, red: 0 };

      if (thresholds && allFieldAvgs.length > 0) {
        // Use absolute threshold-based coloring
        console.log('Using absolute thresholds for', selectedAttribute, thresholds);

        Object.entries(fieldAverages).forEach(([fieldName, stats]) => {
          let color;
          const val = stats.avg;

          if (isLowerBetter) {
            // For "lower is better" (like Mg_sat): green if below green threshold, yellow in between, red above yellow
            // thresholds: { green: 10, yellow: 15 } means: val <= 10 = green, 10-15 = yellow, > 15 = red
            if (val <= thresholds.green) color = '#22c55e';      // Green (low/good)
            else if (val <= thresholds.yellow) color = '#eab308'; // Yellow (medium)
            else color = '#ef4444';                                // Red (high/bad)
          } else {
            // For "higher is better" (like P, K, OM): green if above green threshold, yellow in between, red below yellow
            // thresholds: { yellow: 35, green: 70 } means: val >= 70 = green, 35-70 = yellow, < 35 = red
            if (val >= thresholds.green) color = '#22c55e';      // Green (high/good)
            else if (val >= thresholds.yellow) color = '#eab308'; // Yellow (medium)
            else color = '#ef4444';                                // Red (low/bad)
          }

          fieldColors[fieldName] = color;
          fieldColors[fieldName + '_stats'] = stats;

          // Track color distribution
          if (color === '#22c55e') colorCounts.green++;
          else if (color === '#eab308') colorCounts.yellow++;
          else if (color === '#ef4444') colorCounts.red++;
        });

        console.log('Field color distribution:', colorCounts, 'Total fields colored:', Object.keys(fieldAverages).length);
      } else if (allFieldAvgs.length > 1) {
        // Fallback: relative coloring for attributes without defined thresholds
        const filteredAvgs = removeOutliers(allFieldAvgs);
        const sortedAvgs = [...filteredAvgs].sort((a, b) => a - b);
        const minAvg = sortedAvgs[0];
        const maxAvg = sortedAvgs[sortedAvgs.length - 1];
        const range = maxAvg - minAvg;

        console.log('Using relative color gradient:', { minAvg, maxAvg, range, isLowerBetter, originalCount: allFieldAvgs.length, filteredCount: filteredAvgs.length });

        Object.entries(fieldAverages).forEach(([fieldName, stats]) => {
          let color;
          if (range === 0) {
            color = '#eab308'; // All same value = yellow
          } else {
            // Calculate position from 0 to 1, clamping outliers to the range
            let position = (stats.avg - minAvg) / range;
            position = Math.max(0, Math.min(1, position)); // Clamp to 0-1

            // Assign color based on position (higher = greener for most, inverted for "lower is better")
            if (isLowerBetter) {
              // Lower is better: low position = green, high position = red
              if (position <= 0.33) color = '#22c55e';      // Green (low/good)
              else if (position <= 0.66) color = '#eab308'; // Yellow (medium)
              else color = '#ef4444';                        // Red (high/bad)
            } else {
              // Higher is better: high position = green, low position = red
              if (position >= 0.66) color = '#22c55e';      // Green (high/good)
              else if (position >= 0.33) color = '#eab308'; // Yellow (medium)
              else color = '#ef4444';                        // Red (low/bad)
            }
          }
          fieldColors[fieldName] = color;
          fieldColors[fieldName + '_stats'] = stats;

          // Track color distribution
          if (color === '#22c55e') colorCounts.green++;
          else if (color === '#eab308') colorCounts.yellow++;
          else if (color === '#ef4444') colorCounts.red++;
        });

        console.log('Field color distribution:', colorCounts, 'Total fields colored:', Object.keys(fieldAverages).length);
      } else if (allFieldAvgs.length === 1) {
        // Single field with data - use threshold-based coloring
        Object.entries(fieldAverages).forEach(([fieldName, stats]) => {
          const color = Utils.getColor(stats.avg, selectedAttribute, settings, bufferPct, allFieldAvgs);
          fieldColors[fieldName] = color;
          fieldColors[fieldName + '_stats'] = stats;
        });
      }
      // If allFieldAvgs.length === 0, all fields are grey (no data)

      // Update stats box - use field averages when "All Fields" selected
      if (selectedField === 'all' && allFieldAvgs.length > 0) {
        // Show stats based on field averages
        updateStats(allFieldAvgs, 'field');
      } else {
        // Single field selected - show individual sample points
        let filtered = sampleData.filter(s => {
          if (selectedField !== 'all' && s.field !== selectedField) return false;
          if (selectedYear !== 'all' && String(s.year) !== String(selectedYear)) return false;
          return true;
        });
        const allValues = filtered
          .map(s => Utils.getNumericValue(s[selectedAttribute], selectedAttribute))
          .filter(v => v !== null);
        updateStats(allValues, 'sample');
      }

      // Draw boundaries with shading
      drawBoundaries(true, fieldColors);
    }
    
    function drawSampleMarkers() {
      const settings = Utils.loadSettings();

      // Filter samples for selected year
      let filtered = sampleData.filter(s => {
        if (selectedField !== 'all' && s.field !== selectedField) return false;
        if (selectedYear !== 'all' && String(s.year) !== String(selectedYear)) return false;
        return true;
      });

      console.log('drawSampleMarkers - total samples:', sampleData.length, 'filtered:', filtered.length, 'for year:', selectedYear);
      if (filtered.length > 0) {
        const years = [...new Set(filtered.map(s => s.year))];
        console.log('Years in filtered samples:', years);
      }

      // Get all VALID values for median-based coloring and stats (filters out 0s for nutrients where 0 = no data)
      const allValues = filtered
        .map(s => Utils.getNumericValue(s[selectedAttribute], selectedAttribute))
        .filter(v => v !== null);

      // Update stats box (always sample points when showing markers)
      updateStats(allValues, 'sample');

      // Render point markers
      filtered.forEach(sample => {
        const rawValue = sample[selectedAttribute];
        const numValue = Utils.getNumericValue(rawValue, selectedAttribute);
        const hasValidData = numValue !== null;

        // Skip samples with no GPS
        if (!sample.lat || !sample.lon) return;

        const bufferPct = settings.bufferPercent || 25;
        const size = fieldModeActive ? 44 : 32;
        const fontSize = fieldModeActive ? 14 : 11;

        let color, displayVal;
        if (hasValidData) {
          color = Utils.getColor(numValue, selectedAttribute, settings, bufferPct, allValues);
          displayVal = selectedAttribute === 'sampleId'
            ? rawValue
            : Utils.formatValue(numValue, selectedAttribute);
        } else {
          // No valid data - skip this sample entirely (don't show on map)
          return;
        }

        const icon = L.divIcon({
          html: `<div class="sample-marker" style="width:${size}px;height:${size}px;background:${color};font-size:${fontSize}px;line-height:${size}px;">${displayVal}</div>`,
          className: '', iconSize: [size, size], iconAnchor: [size/2, size/2]
        });
        const marker = L.marker([sample.lat, sample.lon], { icon }).addTo(map);
        marker.bindPopup(buildSamplePopup(sample));
        currentLayers.push(marker);
      });
    }

    function buildSamplePopup(sample) {
      const visibleNutrients = getVisibleNutrients();
      let html = `<div style="max-height: 300px; overflow-y: auto; min-width: 200px;">`;
      html += `<div style="font-weight: 700; font-size: 14px; margin-bottom: 8px; border-bottom: 2px solid #3b82f6; padding-bottom: 4px;">`;
      html += `Sample ${sample.sampleId || 'Unknown'}</div>`;
      html += `<div style="margin-bottom: 8px; color: #64748b; font-size: 12px;">`;
      html += `<strong>Field:</strong> ${sample.field || 'Unknown'}<br>`;
      html += `<strong>Year:</strong> ${sample.year || 'N/A'}`;
      if (sample.depth) html += `<br><strong>Depth:</strong> ${sample.depth}"`;
      html += `</div>`;
      html += `<table style="width: 100%; font-size: 12px; border-collapse: collapse;">`;

      visibleNutrients.forEach(n => {
        if (n.key === 'sampleId') return; // Already shown in header
        const value = sample[n.key];
        if (value === undefined || value === null) return;
        const displayVal = typeof value === 'number' ? Utils.formatValue(value, n.key) : value;
        const unit = CONFIG.NUTRIENT_UNITS[n.key] || '';
        const isSelected = n.key === selectedAttribute;
        html += `<tr style="${isSelected ? 'background: #dbeafe; font-weight: 600;' : ''}">`;
        html += `<td style="padding: 3px 6px; border-bottom: 1px solid #e2e8f0;">${n.name}</td>`;
        html += `<td style="padding: 3px 6px; border-bottom: 1px solid #e2e8f0; text-align: right;">${displayVal} ${unit}</td>`;
        html += `</tr>`;
      });

      html += `</table></div>`;
      return html;
    }

    function renderCompareMode() {
      // Get samples from selected year (later) and compare year (earlier)
      const laterYear = selectedYear;
      const earlierYear = compareYear;

      // Update the compare info bar with year values
      document.getElementById('compareFromYear').textContent = earlierYear;
      document.getElementById('compareToYear').textContent = laterYear;

      const laterSamples = sampleData.filter(s => {
        if (selectedField !== 'all' && s.field !== selectedField) return false;
        return String(s.year) === String(laterYear);
      });

      const earlierSamples = sampleData.filter(s => {
        if (selectedField !== 'all' && s.field !== selectedField) return false;
        return String(s.year) === String(earlierYear);
      });

      // Calculate change stats
      const changes = [];
      
      // For each later sample, find nearest earlier sample and show change
      laterSamples.forEach(laterSample => {
        const value = laterSample[selectedAttribute];
        if (value === undefined || value === null) return;
        
        // Find nearest earlier sample (same field or closest by location)
        let earlierSample = earlierSamples.find(s => s.field === laterSample.field && s.sampleId === laterSample.sampleId);
        if (!earlierSample) {
          // Find closest by location within same field
          const fieldEarlier = earlierSamples.filter(s => s.field === laterSample.field);
            if (fieldEarlier.length > 0) {
              let minDist = Infinity;
              fieldEarlier.forEach(s => {
                const dist = Math.sqrt((s.lat - laterSample.lat) ** 2 + (s.lon - laterSample.lon) ** 2);
                if (dist < minDist) { minDist = dist; earlierSample = s; }
              });
            }
          }
          
          const earlierValue = earlierSample ? earlierSample[selectedAttribute] : null;
          const change = earlierValue !== null && earlierValue !== undefined ? value - earlierValue : null;
          const percentChange = earlierValue && earlierValue !== 0 ? ((value - earlierValue) / earlierValue) * 100 : 0;
          
          const color = change !== null ? Utils.getChangeColor(change, percentChange) : '#94a3b8';
          const size = fieldModeActive ? 44 : 32;
          const fontSize = fieldModeActive ? 12 : 10;
          
          let displayVal;
          const attrDecimals = Utils.getDecimals(selectedAttribute);
          if (change !== null) {
            const sign = change >= 0 ? '+' : '';
            displayVal = sign + Utils.formatNumber(change, attrDecimals);
          } else {
            displayVal = Utils.formatNumber(value, attrDecimals);
          }
          
          const icon = L.divIcon({
            html: `<div class="sample-marker" style="width:${size}px;height:${size}px;background:${color};font-size:${fontSize}px;line-height:${size}px;">${displayVal}</div>`,
            className: '', iconSize: [size, size], iconAnchor: [size/2, size/2]
          });
          const marker = L.marker([laterSample.lat, laterSample.lon], { icon }).addTo(map);
          
          const decimals = Utils.getDecimals(selectedAttribute);
          let popupText = `<strong>Sample ${laterSample.sampleId || ''}</strong><br>Field: ${laterSample.field || 'Unknown'}`;
          popupText += `<br>${earlierYear}: ${earlierValue !== null ? Utils.formatNumber(earlierValue, decimals) : 'N/A'}`;
          popupText += `<br>${laterYear}: ${Utils.formatNumber(value, decimals)}`;
          if (change !== null) {
            popupText += `<br><strong>Change: ${change >= 0 ? '+' : ''}${Utils.formatNumber(change, decimals)} (${percentChange >= 0 ? '+' : ''}${Utils.formatNumber(percentChange, 0)}%)</strong>`;
            changes.push(change);
          }
          marker.bindPopup(popupText);
          currentLayers.push(marker);
        });
      
      // Update stats for compare mode
      const attrName = CONFIG.NUTRIENT_NAMES[selectedAttribute] || selectedAttribute;
      const unit = CONFIG.NUTRIENT_UNITS[selectedAttribute] || '';

      if (changes.length > 0) {
        const avg = changes.reduce((a, b) => a + b, 0) / changes.length;
        const high = Math.max(...changes);
        const low = Math.min(...changes);
        const changeDecimals = Utils.getDecimals(selectedAttribute);
        document.getElementById('statsTitle').textContent = 'Change Stats';
        document.getElementById('statsAvg').textContent = (avg >= 0 ? '+' : '') + avg.toFixed(changeDecimals);
        document.getElementById('statsHigh').textContent = (high >= 0 ? '+' : '') + high.toFixed(changeDecimals);
        document.getElementById('statsLow').textContent = (low >= 0 ? '+' : '') + low.toFixed(changeDecimals);
        document.getElementById('statsNote').textContent = 'Year-over-year change';

        // Update compare info bar summary
        const sign = avg >= 0 ? '+' : '';
        const direction = avg > 0.5 ? 'increase' : (avg < -0.5 ? 'decrease' : 'no change');
        const summaryColor = avg > 0.5 ? '#16a34a' : (avg < -0.5 ? '#dc2626' : '#64748b');
        document.getElementById('compareSummary').innerHTML =
          `<span style="font-weight: 600; color: ${summaryColor}">${attrName}: ${sign}${avg.toFixed(changeDecimals)}${unit ? ' ' + unit : ''} avg ${direction}</span>`;
      } else {
        document.getElementById('compareSummary').innerHTML =
          `<span style="color: #94a3b8;">No matching samples between ${earlierYear} and ${laterYear}</span>`;
      }
    }

    function zoomToField(fieldName) {
      if (fieldName === 'all') {
        const allCoords = [];
        Object.values(fieldBoundaries).forEach(p => { const a = Array.isArray(p[0]?.[0]) ? p.flat() : p; allCoords.push(...a); });
        sampleData.forEach(s => allCoords.push([s.lat, s.lon]));
        if (allCoords.length > 0) map.fitBounds(allCoords, { padding: [50,50] });
      } else if (fieldBoundaries[fieldName]) {
        const p = fieldBoundaries[fieldName];
        const a = Array.isArray(p[0]?.[0]) ? p.flat() : p;
        map.fitBounds(a, { padding: [50,50] });
      }
    }

    function toggleFieldMode() {
      fieldModeActive = !fieldModeActive;
      const btn = document.getElementById('fieldModeBtn');
      const mobileBtn = document.getElementById('mobileFieldModeBtn');
      if (fieldModeActive) {
        btn.classList.add('active');
        btn.textContent = 'üì± Field Mode ON';
        mobileBtn.classList.add('active');
        mobileBtn.textContent = 'üì± ON';
        document.body.classList.add('field-mode');
        startGPS();
      } else {
        btn.classList.remove('active');
        btn.textContent = 'üì± Field Mode';
        mobileBtn.classList.remove('active');
        mobileBtn.textContent = 'üì± Field Mode';
        document.body.classList.remove('field-mode');
        stopGPS();
      }
      updateMap();
    }

    function startGPS() {
      if (!navigator.geolocation) { Utils.showStatus('GPS not supported', false); return; }
      gpsWatchId = navigator.geolocation.watchPosition(
        (pos) => {
          const { latitude, longitude, accuracy } = pos.coords;
          if (gpsMarker) { gpsMarker.setLatLng([latitude, longitude]); gpsCircle.setLatLng([latitude, longitude]); gpsCircle.setRadius(accuracy); }
          else {
            const gpsIcon = L.divIcon({
              html: '<div class="gps-marker"><div class="gps-pulse"></div><div class="gps-dot"></div></div>',
              className: '',
              iconSize: [22, 22],
              iconAnchor: [11, 11]
            });
            gpsMarker = L.marker([latitude, longitude], { icon: gpsIcon }).addTo(map);
            gpsCircle = L.circle([latitude, longitude], { radius: accuracy, color: '#3b82f6', fillColor: '#3b82f6', fillOpacity: 0.1, weight: 2, dashArray: '4' }).addTo(map);
          }
          map.setView([latitude, longitude], map.getZoom());
        },
        (e) => Utils.showStatus('GPS error: ' + e.message, false),
        { enableHighAccuracy: true, maximumAge: 5000 }
      );
    }

    function stopGPS() {
      if (gpsWatchId) { navigator.geolocation.clearWatch(gpsWatchId); gpsWatchId = null; }
      if (gpsMarker) { map.removeLayer(gpsMarker); map.removeLayer(gpsCircle); gpsMarker = null; gpsCircle = null; }
    }

    function toggleStatsBox() {
      const statsBox = document.getElementById('statsBox');
      const toggle = statsBox.querySelector('.stats-toggle');
      if (statsBox.classList.contains('collapsed')) {
        statsBox.classList.remove('collapsed');
        toggle.textContent = '‚ñº';
      } else {
        statsBox.classList.add('collapsed');
        toggle.textContent = '‚ñ∂';
      }
    }

    function updateBackupFooter() {
      const backupTime = localStorage.getItem('soilDataBackupTime');
      const footer = document.getElementById('backupFooter');
      const buildDate = new Date(BUILD_DATE);
      const buildStr = buildDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) + ', ' +
                       buildDate.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
      const versionInfo = `App ${APP_VERSION} ‚Ä¢ Built: ${buildStr}`;

      if (backupTime) {
        const date = new Date(parseInt(backupTime));
        const backupStr = date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
        footer.innerHTML = `${versionInfo} <span style="margin: 0 0.5rem; color: #cbd5e1;">|</span> Data backup: ${backupStr}`;
      } else {
        footer.innerHTML = `${versionInfo} <span style="margin: 0 0.5rem; color: #cbd5e1;">|</span> No backup yet`;
      }
    }
  </script>
  <div class="backup-footer" id="backupFooter">No backup yet</div>
</body>
</html>
