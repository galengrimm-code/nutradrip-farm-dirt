<!DOCTYPE html>
<!-- v15 - Status message moved below nav -->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Soil Sample Analysis - Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f8fafc; color: #1e293b; }
    .app-container { display: flex; flex-direction: column; height: 100vh; }
    .top-bar { background: linear-gradient(135deg, #1e293b 0%, #334155 100%); color: white; padding: 1rem 1.5rem; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem; }
    .top-bar h1 { font-size: 1.5rem; font-weight: 700; }
    .top-bar p { font-size: 0.875rem; opacity: 0.8; margin-top: 0.25rem; }
    .nav-links { display: flex; gap: 0.5rem; flex-wrap: wrap; }
    .nav-link { padding: 0.5rem 1rem; background: rgba(255,255,255,0.1); color: white; text-decoration: none; border-radius: 0.375rem; font-size: 0.875rem; font-weight: 500; transition: background 0.2s; }
    .nav-link:hover { background: rgba(255,255,255,0.2); }
    .nav-link.active { background: #3b82f6; }
    .auth-section { display: flex; align-items: center; gap: 1rem; }
    .user-info { font-size: 0.875rem; color: rgba(255,255,255,0.9); }
    .sign-in-btn { padding: 0.5rem 1rem; background: #4285f4; color: white; border: none; border-radius: 0.375rem; font-size: 0.875rem; cursor: pointer; }
    .sign-in-btn:hover { background: #3367d6; }
    .sign-in-btn.signed-in { background: #22c55e; }
    .sign-in-btn.signed-in:hover { background: #16a34a; }
    .controls-bar { background: white; border-bottom: 1px solid #e2e8f0; padding: 0.75rem 1.5rem; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem; }
    .controls-left, .controls-right { display: flex; align-items: center; gap: 1rem; flex-wrap: wrap; }
    .control-group { display: flex; flex-direction: column; gap: 0.25rem; }
    .control-group label { font-size: 0.6875rem; font-weight: 600; color: #64748b; text-transform: uppercase; letter-spacing: 0.05em; }
    select, input[type="text"], input[type="number"] { padding: 0.5rem 0.75rem; border: 1px solid #cbd5e1; border-radius: 0.375rem; font-size: 0.875rem; background: white; min-width: 120px; }
    select:focus, input:focus { outline: none; border-color: #3b82f6; box-shadow: 0 0 0 3px rgba(59,130,246,0.1); }
    .button { padding: 0.5rem 1rem; border: 1px solid #cbd5e1; border-radius: 0.375rem; background: white; font-size: 0.875rem; font-weight: 500; cursor: pointer; transition: all 0.2s; display: inline-flex; align-items: center; gap: 0.5rem; }
    .button:hover { background: #f1f5f9; border-color: #94a3b8; }
    .button.active { background: #3b82f6; color: white; border-color: #3b82f6; }
    .toggle-group { display: flex; border: 1px solid #cbd5e1; border-radius: 0.375rem; overflow: hidden; }
    .toggle-btn { padding: 0.5rem 1rem; background: white; border: none; font-size: 0.875rem; cursor: pointer; transition: all 0.2s; }
    .toggle-btn:not(:last-child) { border-right: 1px solid #cbd5e1; }
    .toggle-btn:hover { background: #f1f5f9; }
    .toggle-btn.active { background: #3b82f6; color: white; }
    .legend { background: white; border-bottom: 1px solid #e2e8f0; padding: 0.5rem 1rem; display: flex; align-items: center; gap: 0.5rem; font-size: 0.75rem; }
    .legend-label { font-weight: 600; color: #64748b; }
    .main-content { display: flex; flex-direction: column; flex: 1; }
    #map { flex: 1; min-height: 500px; }
    .sample-marker { border-radius: 6px; border: none; box-shadow: 0 3px 8px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.25); display: flex; align-items: center; justify-content: center; font-weight: 600; color: white; text-shadow: 0 1px 2px rgba(0,0,0,0.5); letter-spacing: -0.5px; }
    .gps-marker { position: relative; }
    .gps-dot { width: 16px; height: 16px; background: #3b82f6; border: 3px solid white; border-radius: 50%; box-shadow: 0 2px 6px rgba(0,0,0,0.3); }
    .gps-pulse { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 16px; height: 16px; background: rgba(59,130,246,0.4); border-radius: 50%; animation: gpsPulse 2s ease-out infinite; }
    @keyframes gpsPulse { 0% { width: 16px; height: 16px; opacity: 1; } 100% { width: 50px; height: 50px; opacity: 0; } }
    #statusMessage { display: none; position: fixed; top: 5rem; left: 50%; transform: translateX(-50%); z-index: 9999; max-width: 90%; box-shadow: 0 4px 12px rgba(0,0,0,0.15); padding: 0.75rem 1rem; border-radius: 0.375rem; }
    .field-tooltip { background: white; border: 2px solid #1e293b; border-radius: 0.5rem; padding: 0.5rem 0.75rem; font-size: 0.875rem; font-weight: 500; box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
    .field-mode .sample-marker { min-width: 44px !important; min-height: 44px !important; font-size: 14px !important; }
    .field-mode .controls-left { display: none; }
    .field-mode .legend { display: none; }
    @media (max-width: 639px) {
      .top-bar { padding: 0.5rem 0.75rem; }
      .top-bar h1 { font-size: 1rem; }
      .top-bar > div:first-child { display: none; }
      .nav-links { width: 100%; justify-content: center; order: -1; }
      .nav-link { padding: 0.4rem 0.6rem; font-size: 0.75rem; }
      .auth-section { display: none; }
      
      /* Simplified mobile controls */
      .controls-bar { padding: 0.5rem; gap: 0.5rem; flex-direction: column; }
      .controls-left { display: flex; flex-wrap: wrap; gap: 0.5rem; width: 100%; }
      .control-group { flex: 1; min-width: calc(50% - 0.25rem); }
      .control-group label { font-size: 0.6rem; }
      .control-group.compare-mode { display: none; } /* Hide on mobile - use bottom bar */
      .controls-right { display: none; }
      select, input { font-size: 14px !important; padding: 0.5rem; min-width: 0; width: 100%; }
      .legend { display: none; } /* Hide legend on mobile */
      .mobile-toolbar { display: flex !important; }
      .stats-box { bottom: 60px !important; right: 0.5rem !important; font-size: 0.75rem !important; padding: 0.5rem !important; min-width: 100px !important; }
      .stats-box h4 { font-size: 0.7rem !important; }
      #compareYearGroup { display: none !important; } /* Hide compare year on mobile */
    }
    .mobile-toolbar { display: none; position: fixed; bottom: 0; left: 0; right: 0; background: white; border-top: 1px solid #e2e8f0; padding: 0.5rem; z-index: 1000; justify-content: space-around; box-shadow: 0 -2px 10px rgba(0,0,0,0.1); }
    .mobile-toolbar button { flex: 1; margin: 0 0.25rem; padding: 0.6rem 0.5rem; border: 1px solid #cbd5e1; border-radius: 0.375rem; background: white; font-size: 0.7rem; cursor: pointer; font-weight: 500; }
    .mobile-toolbar button.active { background: #3b82f6; color: white; border-color: #3b82f6; }
  </style>
</head>
<body>
  <div class="app-container">
    <div class="top-bar">
      <div>
        <h1>üå± Soil Sample Analysis</h1>
        <p id="operationSubtitle">Precision Farms Field Management</p>
      </div>
      <nav class="nav-links">
        <a href="index.html" class="nav-link active">üìç Map</a>
        <a href="analysis.html" class="nav-link">üìä Analysis</a>
        <a href="import.html" class="nav-link">üìÅ Import</a>
        <a href="settings.html" class="nav-link">‚öôÔ∏è Settings</a>
      </nav>
      <div class="auth-section">
        <span class="user-info" id="userInfo"></span>
        <button class="sign-in-btn" id="authBtn" onclick="handleAuth()">Sign In with Google</button>
      </div>
    </div>
    
    <div class="controls-bar">
      <div class="controls-left">
        <div class="control-group">
          <label>FIELD</label>
          <select id="fieldSelect"><option value="all">All Fields</option></select>
        </div>
        <div class="control-group">
          <label>ATTRIBUTE</label>
          <select id="attributeSelect"></select>
        </div>
        <div class="control-group">
          <label>YEAR</label>
          <select id="yearSelect"><option value="all">All Years</option></select>
        </div>
        <div class="control-group compare-mode">
          <label>COMPARE MODE</label>
          <div class="toggle-group">
            <button class="toggle-btn active" id="singleYearBtn">Single Year</button>
            <button class="toggle-btn" id="compareYearsBtn">Compare Years</button>
          </div>
        </div>
        <div class="control-group" id="compareYearGroup" style="display:none;">
          <label>VS YEAR</label>
          <select id="compareYearSelect"><option value="">Select Earlier Year</option></select>
        </div>
      </div>
      <div class="controls-right">
        <button class="button" id="fieldModeBtn">üì± Field Mode</button>
        <button class="button" id="refreshBtn">üîÑ Refresh</button>
      </div>
    </div>
    
    <div class="legend" id="legendBar">
      <span class="legend-label">Legend:</span>
      <div style="width: 100px; height: 16px; background: linear-gradient(to right, #ef4444, #eab308, #22c55e); border-radius: 8px; border: 1px solid #cbd5e1;"></div>
      <span id="legendText">Low ‚Üí High</span>
    </div>
    
    <!-- Mobile bottom toolbar -->
    <div class="mobile-toolbar">
      <button id="mobileFieldModeBtn">üì± Field</button>
      <button id="mobileCompareBtn">üìä Compare</button>
      <button id="mobileRefreshBtn">üîÑ Refresh</button>
    </div>
    
    <div class="main-content" style="position: relative;">
      <div id="map"></div>
      <div id="statsBox" style="position: absolute; top: 80px; right: 10px; background: white; padding: 10px 15px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); z-index: 1000; font-size: 13px; min-width: 140px;">
        <div style="font-weight: 600; margin-bottom: 6px; color: #374151;" id="statsTitle">Field Attribute Stats</div>
        <div style="display: flex; justify-content: space-between; margin-bottom: 3px;"><span style="color: #64748b;">Avg:</span> <span id="statsAvg" style="font-weight: 600;">-</span></div>
        <div style="display: flex; justify-content: space-between; margin-bottom: 3px;"><span style="color: #64748b;">High:</span> <span id="statsHigh" style="font-weight: 600; color: #22c55e;">-</span></div>
        <div style="display: flex; justify-content: space-between;"><span style="color: #64748b;">Low:</span> <span id="statsLow" style="font-weight: 600; color: #ef4444;">-</span></div>
      </div>
    </div>
    
    <div id="statusMessage"></div>
  </div>

  <script src="https://apis.google.com/js/api.js"></script>
  <script src="https://accounts.google.com/gsi/client"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  
  <script>
    // ========== CONFIG ==========
    const CONFIG = {
      CLIENT_ID: '714780458094-9rde31taeottmavhl5t0uo8b9kfpergc.apps.googleusercontent.com',
      API_KEY: 'AIzaSyCOSDbrAlc3ct2-lRvJv1y7V0nV7haWc9E',
      get SHEET_ID() { return localStorage.getItem('googleSheetId') || '1buu-8KXoM1kRJSOAWtHaAk40seQT5kqGFY9RICYwdRY'; },
      DEFAULT_LAT: 39.8528,
      DEFAULT_LON: -95.5347,
      DEFAULT_ZOOM: 13,
      NUTRIENT_NAMES: {
        sampleId: 'Sample ID', pH: 'pH', OM: 'Organic Matter', P: 'Phosphorus (P)', P2: 'Phosphorus P2', K: 'Potassium (K)',
        CEC: 'CEC', Ca_sat: 'Calcium Base Sat', Mg_sat: 'Magnesium Base Sat', K_Sat: 'Potassium Base Sat', H_Sat: 'Hydrogen Base Sat', Na_Sat: 'Sodium Base Sat',
        Zn: 'Zinc', Cu: 'Copper', Mn: 'Manganese', Fe: 'Iron', Boron: 'Boron', S: 'Sulfur', Buffer_pH: 'Buffer pH',
        Na: 'Sodium', Ca: 'Calcium', Mg: 'Magnesium', NO3: 'Nitrate', NH4: 'Ammonium', Soluble_Salts: 'Soluble Salts', EC: 'EC'
      },
      NUTRIENT_UNITS: {
        sampleId: '', pH: '', OM: '%', P: 'ppm', P2: 'ppm', K: 'ppm', CEC: 'meq/100g',
        Ca_sat: '%', Mg_sat: '%', K_Sat: '%', H_Sat: '%', Na_Sat: '%',
        Zn: 'ppm', Cu: 'ppm', Mn: 'ppm', Fe: 'ppm', Boron: 'ppm', S: 'ppm', Buffer_pH: '',
        Na: 'ppm', Ca: 'ppm', Mg: 'ppm', NO3: 'ppm', NH4: 'ppm', Soluble_Salts: 'mmhos/cm', EC: 'dS/m'
      },
      LOWER_IS_BETTER: ['Mg_sat', 'H_Sat', 'Na_Sat', 'Soluble_Salts'],
      
      // All nutrients in display order with default visibility
      ALL_NUTRIENTS: [
        { key: 'sampleId', name: 'Sample ID', defaultVisible: true },
        { key: 'pH', name: 'pH', defaultVisible: true },
        { key: 'P', name: 'Phosphorus (P)', defaultVisible: true },
        { key: 'K', name: 'Potassium (K)', defaultVisible: true },
        { key: 'OM', name: 'Organic Matter', defaultVisible: true },
        { key: 'CEC', name: 'CEC', defaultVisible: true },
        { key: 'Ca_sat', name: 'Calcium %', defaultVisible: true },
        { key: 'Mg_sat', name: 'Magnesium %', defaultVisible: true },
        { key: 'K_Sat', name: 'K Base Sat %', defaultVisible: true },
        { key: 'H_Sat', name: 'H Base Sat %', defaultVisible: true },
        { key: 'Zn', name: 'Zinc', defaultVisible: true },
        { key: 'Cu', name: 'Copper', defaultVisible: true },
        { key: 'Mn', name: 'Manganese', defaultVisible: true },
        { key: 'Fe', name: 'Iron', defaultVisible: true },
        { key: 'Boron', name: 'Boron', defaultVisible: true },
        { key: 'S', name: 'Sulfur', defaultVisible: true },
        { key: 'Buffer_pH', name: 'Buffer pH', defaultVisible: true },
        // Hidden by default
        { key: 'P2', name: 'Phosphorus P2', defaultVisible: false },
        { key: 'Na_Sat', name: 'Na Base Sat %', defaultVisible: false },
        { key: 'Na', name: 'Sodium', defaultVisible: false },
        { key: 'Ca', name: 'Calcium (ppm)', defaultVisible: false },
        { key: 'Mg', name: 'Magnesium (ppm)', defaultVisible: false },
        { key: 'NO3', name: 'Nitrate', defaultVisible: false },
        { key: 'NH4', name: 'Ammonium', defaultVisible: false },
        { key: 'Soluble_Salts', name: 'Soluble Salts', defaultVisible: false },
        { key: 'EC', name: 'EC', defaultVisible: false }
      ]
    };
    
    // Get visible nutrients based on settings
    function getVisibleNutrients() {
      const saved = JSON.parse(localStorage.getItem('nutrientVisibility') || '{}');
      return CONFIG.ALL_NUTRIENTS.filter(n => {
        return saved[n.key] !== undefined ? saved[n.key] : n.defaultVisible;
      });
    }
    
    // Populate attribute dropdown with visible nutrients
    function populateAttributeDropdown() {
      const select = document.getElementById('attributeSelect');
      const currentValue = select.value;
      const visible = getVisibleNutrients();
      
      select.innerHTML = visible.map(n => 
        `<option value="${n.key}">${n.name}</option>`
      ).join('');
      
      // Restore previous selection if still visible, otherwise default to P
      if (visible.some(n => n.key === currentValue)) {
        select.value = currentValue;
      } else if (visible.some(n => n.key === 'P')) {
        select.value = 'P';
        selectedAttribute = 'P';
      }
    }

    // ========== SHEETS API ==========
    let tokenClient;
    let accessToken = null;
    let tokenExpiry = null;
    
    const SheetsAPI = {
      isInitialized: false,
      isSignedIn: false,
      SHEETS: { FIELDS: 'Fields', SAMPLES: 'Samples', SETTINGS: 'Settings' },
      
      async init() {
        return new Promise((resolve, reject) => {
          // Load the Google API client library
          gapi.load('client', async () => {
            try {
              await gapi.client.init({
                apiKey: CONFIG.API_KEY,
                discoveryDocs: ['https://sheets.googleapis.com/$discovery/rest?version=v4'],
              });
              this.isInitialized = true;
              
              // Initialize the token client for Google Identity Services
              tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: CONFIG.CLIENT_ID,
                scope: 'https://www.googleapis.com/auth/spreadsheets',
                callback: (response) => {
                  if (response.error) {
                    console.error('Token error:', response);
                    return;
                  }
                  accessToken = response.access_token;
                  // Token expires in 1 hour, set expiry with buffer
                  tokenExpiry = Date.now() + (response.expires_in * 1000) - 60000;
                  // Save token to localStorage
                  localStorage.setItem('googleAccessToken', accessToken);
                  localStorage.setItem('googleTokenExpiry', tokenExpiry.toString());
                  this.isSignedIn = true;
                  this.onSignInChange(true);
                },
              });
              
              // Check for saved token
              const savedToken = localStorage.getItem('googleAccessToken');
              const savedExpiry = localStorage.getItem('googleTokenExpiry');
              if (savedToken && savedExpiry && Date.now() < parseInt(savedExpiry)) {
                accessToken = savedToken;
                tokenExpiry = parseInt(savedExpiry);
                this.isSignedIn = true;
                // Set the token for gapi client
                gapi.client.setToken({ access_token: accessToken });
                this.onSignInChange(true);
              }
              
              // Set up token refresh check every 5 minutes
              setInterval(() => this.checkTokenRefresh(), 300000);
              
              resolve(true);
            } catch (error) {
              console.error('Error initializing Google API:', error);
              reject(error);
            }
          });
        });
      },
      
      checkTokenRefresh() {
        // If token expires in less than 10 minutes, refresh it silently
        if (this.isSignedIn && tokenExpiry && Date.now() > tokenExpiry - 600000) {
          console.log('Token expiring soon, refreshing...');
          tokenClient.requestAccessToken({ prompt: '' }); // Silent refresh
        }
      },

      // Validate token by making a lightweight API call
      async validateToken() {
        try {
          // Try to get spreadsheet metadata (lightweight call)
          await gapi.client.sheets.spreadsheets.get({
            spreadsheetId: CONFIG.SHEET_ID,
            fields: 'spreadsheetId'  // Only request minimal data
          });
          return true;
        } catch (e) {
          console.log('Token validation failed:', e?.result?.error?.code || e.message);
          return false;
        }
      },

      // Attempt to refresh token and retry the operation
      async refreshTokenAndRetry(operation) {
        return new Promise((resolve, reject) => {
          console.log('Attempting token refresh...');
          const originalCallback = tokenClient.callback;
          tokenClient.callback = async (response) => {
            if (response.error) {
              console.error('Token refresh failed:', response);
              tokenClient.callback = originalCallback;
              reject(new Error('Token refresh failed'));
              return;
            }
            accessToken = response.access_token;
            tokenExpiry = Date.now() + (response.expires_in * 1000) - 60000;
            localStorage.setItem('googleAccessToken', accessToken);
            localStorage.setItem('googleTokenExpiry', tokenExpiry.toString());
            gapi.client.setToken({ access_token: accessToken });
            tokenClient.callback = originalCallback;

            try {
              const result = await operation();
              resolve(result);
            } catch (e) {
              reject(e);
            }
          };
          tokenClient.requestAccessToken({ prompt: '' });
        });
      },
      
      async signIn() { 
        tokenClient.requestAccessToken({ prompt: 'consent' }); 
      },
      async signOut() { 
        if (accessToken) {
          google.accounts.oauth2.revoke(accessToken);
          accessToken = null;
          tokenExpiry = null;
        }
        localStorage.removeItem('googleAccessToken');
        localStorage.removeItem('googleTokenExpiry');
        this.isSignedIn = false;
        this.onSignInChange(false);
      },
      onSignInChange(isSignedIn) { console.log('Sign-in state:', isSignedIn); },
      
      async getFields() {
        try {
          const sheetId = CONFIG.SHEET_ID;
          console.log('Loading fields from sheet:', sheetId);
          const response = await gapi.client.sheets.spreadsheets.values.get({
            spreadsheetId: sheetId,
            range: `${this.SHEETS.FIELDS}!A2:E1000`
          });
          const rows = response.result.values || [];
          return rows.map(row => ({
            id: row[0], name: row[1],
            boundary: row[2] ? JSON.parse(row[2]) : null,
            acres: parseFloat(row[3]) || 0
          }));
        } catch (e) { 
          console.error('getFields error:', e); 
          throw e; // Re-throw so loadFromSheets knows it failed
        }
      },
      
      async getSamples() {
        try {
          const sheetId = CONFIG.SHEET_ID;
          console.log('Loading samples from sheet:', sheetId);
          const response = await gapi.client.sheets.spreadsheets.values.get({
            spreadsheetId: sheetId,
            range: `${this.SHEETS.SAMPLES}!A1:ZZ10000`
          });
          const rows = response.result.values || [];
          if (rows.length < 2) return [];
          const headers = rows[0];
          const samples = [];
          for (let i = 1; i < rows.length; i++) {
            const row = rows[i];
            const sample = {};
            headers.forEach((header, idx) => {
              const value = row[idx];
              if (header !== 'sampleId' && header !== 'field' && value) {
                const num = parseFloat(value);
                sample[header] = isNaN(num) ? value : num;
              } else {
                sample[header] = value || '';
              }
            });
            samples.push(sample);
          }
          return samples;
        } catch (e) { 
          console.error('getSamples error:', e); 
          throw e; // Re-throw so loadFromSheets knows it failed
        }
      },
      
      async getSettings() {
        try {
          const sheetId = CONFIG.SHEET_ID;
          const response = await gapi.client.sheets.spreadsheets.values.get({
            spreadsheetId: sheetId,
            range: `${this.SHEETS.SETTINGS}!A2:D100`
          });
          const rows = response.result.values || [];
          const settings = {};
          rows.forEach(row => {
            settings[row[0]] = { min: parseFloat(row[1]) || null, target: parseFloat(row[2]) || null, max: parseFloat(row[3]) || null };
          });
          return settings;
        } catch (e) { 
          console.error('getSettings error:', e); 
          return {}; // Settings are optional, don't throw
        }
      }
    };

    // ========== UTILS ==========
    const Utils = {
      showStatus(message, isSuccess = true) {
        const el = document.getElementById('statusMessage');
        if (!el) return;
        el.textContent = message;
        el.style.display = 'block';
        el.style.background = isSuccess ? '#dcfce7' : '#fee2e2';
        el.style.color = isSuccess ? '#166534' : '#991b1b';
        setTimeout(() => el.style.display = 'none', 4000);
      },

      // Return the global settings object
      loadSettings() {
        return settings;
      },

      // Get median-based color using IQR to handle outliers
      // isLowerBetter: if true, lower values get green, higher get red (for Mg_sat, H_Sat, etc.)
      getMedianBasedColor(value, values, isLowerBetter = false) {
        if (!values || values.length === 0) return '#94a3b8';
        const sorted = [...values].sort((a, b) => a - b);
        const len = sorted.length;

        // Calculate quartiles
        const q1 = sorted[Math.floor(len * 0.25)];
        const median = sorted[Math.floor(len * 0.5)];
        const q3 = sorted[Math.floor(len * 0.75)];
        const iqr = q3 - q1;

        // Use IQR-based bounds (ignore outliers beyond 1.5*IQR)
        const lowerBound = Math.max(sorted[0], q1 - 1.5 * iqr);
        const upperBound = Math.min(sorted[len - 1], q3 + 1.5 * iqr);
        const range = upperBound - lowerBound;

        if (range === 0) return '#eab308'; // All same value = yellow

        const red = '#ef4444', yellow = '#eab308', green = '#22c55e';

        // Clamp value to bounds for color calculation
        const clampedValue = Math.max(lowerBound, Math.min(upperBound, value));
        const position = (clampedValue - lowerBound) / range; // 0 to 1

        // For "lower is better" attributes, invert the scale
        if (isLowerBetter) {
          if (position > 0.66) return red;
          if (position > 0.33) return yellow;
          return green;
        }

        if (position < 0.33) return red;
        if (position < 0.66) return yellow;
        return green;
      },
      
      // Get color for year-over-year change
      getChangeColor(change, percentChange) {
        const red = '#ef4444', white = '#f8fafc', green = '#22c55e';
        
        if (Math.abs(percentChange) < 2) return white; // Less than 2% change = neutral
        if (percentChange > 15) return green; // Big increase = bright green
        if (percentChange > 5) return '#86efac'; // Medium increase = light green
        if (percentChange > 0) return '#bbf7d0'; // Small increase = very light green
        if (percentChange > -5) return '#fecaca'; // Small decrease = very light red
        if (percentChange > -15) return '#f87171'; // Medium decrease = light red
        return red; // Big decrease = bright red
      },
      
      getColor(value, attribute, settings = {}, bufferPercent = 25, allValues = null) {
        // Sample ID gets neutral blue color
        if (attribute === 'sampleId') return '#3b82f6';
        
        // CEC and micronutrients use median-based coloring if allValues provided
        const medianBasedAttrs = ['CEC', 'Zn', 'Cu', 'Mn', 'Fe', 'Boron', 'S'];
        if (medianBasedAttrs.includes(attribute) && allValues && allValues.length > 0) {
          return this.getMedianBasedColor(value, allValues);
        }
        
        // Default thresholds if none provided
        const defaultThresholds = {
          pH: { min: 6.3, max: 6.9 },
          P: { min: 20, max: null },
          K: { min: 150, max: null },
          OM: { min: 3.0, max: null },
          Ca_sat: { min: 65, max: 75 },
          Mg_sat: { min: null, max: 15 },
          K_Sat: { min: 3.0, max: null },
          H_Sat: { min: null, max: 5.0 }
        };
        
        const threshold = settings[attribute] || defaultThresholds[attribute];
        const red = '#ef4444', yellow = '#eab308', green = '#22c55e';
        
        if (!threshold) {
          return '#94a3b8';
        }
        if (threshold.min !== null && threshold.max !== null) {
          if (value >= threshold.min && value <= threshold.max) return green;
          const buffer = (threshold.max - threshold.min) * (bufferPercent / 100);
          if (value < threshold.min) return (threshold.min - value) > buffer ? red : yellow;
          return (value - threshold.max) > buffer ? red : yellow;
        } else if (threshold.min !== null) {
          const buffer = threshold.min * (bufferPercent / 100);
          if (value >= threshold.min) return green;
          return value >= threshold.min - buffer ? yellow : red;
        } else if (threshold.max !== null) {
          const buffer = threshold.max * (bufferPercent / 100);
          if (value <= threshold.max) return green;
          return value <= threshold.max + buffer ? yellow : red;
        }
        return '#94a3b8';
      },
      
      formatNumber(value, decimals = 1) {
        if (value === null || value === undefined || isNaN(value)) return '-';
        return Number(value).toFixed(decimals);
      },
      
      getUniqueYears(samples) {
        return [...new Set(samples.map(s => s.year).filter(y => y))].sort();
      },
      
      getUniqueFields(samples) {
        return [...new Set(samples.map(s => s.field).filter(f => f))].sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));
      },
      
      groupByField(samples) {
        const groups = {};
        samples.forEach(s => {
          const f = s.field || 'Unknown';
          if (!groups[f]) groups[f] = [];
          groups[f].push(s);
        });
        return groups;
      },
      
      calculateFieldAverage(samples, nutrient) {
        const values = samples.map(s => s[nutrient]).filter(v => v !== undefined && v !== null && !isNaN(v));
        if (values.length === 0) return null;
        return values.reduce((a, b) => a + b, 0) / values.length;
      }
    };

    // ========== APP STATE ==========
    let map;
    let sampleData = [];
    let fieldBoundaries = {};
    let settings = {};
    let currentLayers = [];
    let selectedField = 'all';
    let selectedAttribute = 'P';
    let selectedYear = 'all';
    let compareYear = '';
    let compareMode = false;
    let fieldModeActive = false;
    let gpsMarker = null, gpsCircle = null, gpsWatchId = null;

    // ========== INIT ==========
    document.addEventListener('DOMContentLoaded', async () => {
      populateAttributeDropdown(); // Populate nutrients based on visibility settings
      initMap();
      try {
        await SheetsAPI.init();
        SheetsAPI.onSignInChange = handleSignInChange;
        handleSignInChange(SheetsAPI.isSignedIn);
      } catch (e) {
        console.warn('Google API init error:', e);
        Utils.showStatus('Configure Google API to enable cloud sync', false);
      }
      setupEventListeners();
      loadLocalData();
      
      // Load operation name
      const opName = localStorage.getItem('operationName');
      if (opName) {
        document.getElementById('operationSubtitle').textContent = opName;
      }
      
      // Listen for visibility changes from settings page
      window.addEventListener('storage', (e) => {
        if (e.key === 'nutrientVisibility') {
          populateAttributeDropdown();
        }
        if (e.key === 'operationName') {
          document.getElementById('operationSubtitle').textContent = e.newValue || 'Precision Farms Field Management';
        }
      });
    });

    function initMap() {
      map = L.map('map').setView([CONFIG.DEFAULT_LAT, CONFIG.DEFAULT_LON], CONFIG.DEFAULT_ZOOM);
      const street = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '¬© OpenStreetMap', maxZoom: 19 });
      const satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: '¬© Esri', maxZoom: 19 });
      satellite.addTo(map); // Default to satellite
      L.control.layers({ "Street": street, "Satellite": satellite }).addTo(map);
      
      // Listen for zoom changes to switch between field view and sample view
      map.on('zoomend', function() {
        updateMap();
      });
      
      // Add "Center on Me" button for mobile
      const centerControl = L.control({ position: 'topleft' });
      centerControl.onAdd = function() {
        const div = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
        div.innerHTML = '<a href="#" title="Center on my location" style="display:flex;align-items:center;justify-content:center;width:34px;height:34px;background:white;font-size:18px;">‚äï</a>';
        div.onclick = function(e) {
          e.preventDefault();
          e.stopPropagation();
          centerOnMe();
          return false;
        };
        return div;
      };
      centerControl.addTo(map);
    }
    
    function centerOnMe() {
      if (!navigator.geolocation) {
        Utils.showStatus('Geolocation not supported', false);
        return;
      }
      Utils.showStatus('Getting your location...', true);
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          const { latitude, longitude, accuracy } = pos.coords;
          map.setView([latitude, longitude], 16);
          
          // Update or create GPS marker
          if (gpsMarker) {
            gpsMarker.setLatLng([latitude, longitude]);
            gpsCircle.setLatLng([latitude, longitude]).setRadius(accuracy);
          } else {
            const gpsIcon = L.divIcon({
              html: '<div class="gps-marker"><div class="gps-pulse"></div><div class="gps-dot"></div></div>',
              className: '',
              iconSize: [22, 22],
              iconAnchor: [11, 11]
            });
            gpsMarker = L.marker([latitude, longitude], { icon: gpsIcon }).addTo(map);
            gpsCircle = L.circle([latitude, longitude], {
              radius: accuracy, color: '#3b82f6', fillColor: '#3b82f6', fillOpacity: 0.1, weight: 2, dashArray: '4'
            }).addTo(map);
          }
          Utils.showStatus('Centered on your location', true);
        },
        (err) => {
          Utils.showStatus('Could not get location: ' + err.message, false);
        },
        { enableHighAccuracy: true, timeout: 10000 }
      );
    }

    function setupEventListeners() {
      document.getElementById('fieldSelect').addEventListener('change', (e) => { 
        selectedField = e.target.value; 
        updateYearSelector(); // Update years based on selected field
        updateMap(); 
        zoomToField(selectedField); 
      });
      document.getElementById('attributeSelect').addEventListener('change', (e) => { selectedAttribute = e.target.value; updateMap(); updateLegend(); });
      document.getElementById('yearSelect').addEventListener('change', (e) => { selectedYear = e.target.value; updateCompareYearOptions(); updateMap(); });
      document.getElementById('compareYearSelect').addEventListener('change', (e) => { compareYear = e.target.value; updateMap(); });
      document.getElementById('singleYearBtn').addEventListener('click', () => { 
        compareMode = false; 
        document.getElementById('singleYearBtn').classList.add('active'); 
        document.getElementById('compareYearsBtn').classList.remove('active'); 
        document.getElementById('compareYearGroup').style.display = 'none';
        updateLegend();
        updateMap(); 
      });
      document.getElementById('compareYearsBtn').addEventListener('click', () => { 
        compareMode = true; 
        document.getElementById('compareYearsBtn').classList.add('active'); 
        document.getElementById('singleYearBtn').classList.remove('active'); 
        document.getElementById('compareYearGroup').style.display = 'block';
        updateCompareYearOptions();
        // Auto-select the most recent year before selected year
        const sel = document.getElementById('compareYearSelect');
        if (sel.options.length > 1) {
          sel.selectedIndex = 1; // First year after "Select Earlier Year"
          compareYear = sel.value;
        }
        updateLegend();
        updateMap(); 
      });
      document.getElementById('fieldModeBtn').addEventListener('click', toggleFieldMode);
      document.getElementById('refreshBtn').addEventListener('click', () => {
        // Reload data from localStorage (in case it was changed on another page)
        sampleData = [];
        fieldBoundaries = {};
        loadLocalData();
        Utils.showStatus('Data refreshed', true);
      });
      
      // Mobile toolbar buttons
      document.getElementById('mobileFieldModeBtn').addEventListener('click', toggleFieldMode);
      document.getElementById('mobileRefreshBtn').addEventListener('click', () => {
        sampleData = [];
        fieldBoundaries = {};
        loadLocalData();
        Utils.showStatus('Data refreshed', true);
      });
      document.getElementById('mobileCompareBtn').addEventListener('click', toggleMobileCompare);
    }
    
    function toggleMobileCompare() {
      const btn = document.getElementById('mobileCompareBtn');
      compareMode = !compareMode;
      
      if (compareMode) {
        btn.textContent = 'üìä Compare ON';
        btn.classList.add('active');
        document.getElementById('compareYearsBtn').classList.add('active');
        document.getElementById('singleYearBtn').classList.remove('active');
        updateCompareYearOptions();
        // Auto-select first available compare year
        const sel = document.getElementById('compareYearSelect');
        if (sel.options.length > 1) {
          sel.selectedIndex = 1;
          compareYear = sel.value;
        }
      } else {
        btn.textContent = 'üìä Compare';
        btn.classList.remove('active');
        document.getElementById('singleYearBtn').classList.add('active');
        document.getElementById('compareYearsBtn').classList.remove('active');
        compareYear = '';
      }
      updateLegend();
      updateMap();
    }
    
    function updateCompareYearOptions() {
      const sel = document.getElementById('compareYearSelect');
      sel.innerHTML = '<option value="">Select Earlier Year</option>';
      const years = Utils.getUniqueYears(sampleData).filter(y => String(y) !== String(selectedYear));
      years.forEach(y => { const o = document.createElement('option'); o.value = y; o.textContent = y; sel.appendChild(o); });
    }
    
    function updateLegend() {
      const legendText = document.getElementById('legendText');
      if (compareMode) {
        legendText.textContent = 'Decrease ‚Üê ‚Üí Increase';
        document.querySelector('#legendBar div').style.background = 'linear-gradient(to right, #ef4444, #f8fafc, #22c55e)';
      } else {
        legendText.textContent = 'Low ‚Üí High';
        document.querySelector('#legendBar div').style.background = 'linear-gradient(to right, #ef4444, #eab308, #22c55e)';
      }
    }
    
    function updateStats(values) {
      const statsTitle = document.getElementById('statsTitle');
      const statsAvg = document.getElementById('statsAvg');
      const statsHigh = document.getElementById('statsHigh');
      const statsLow = document.getElementById('statsLow');
      
      const attrName = CONFIG.NUTRIENT_NAMES[selectedAttribute] || selectedAttribute;
      const unit = CONFIG.NUTRIENT_UNITS[selectedAttribute] || '';
      statsTitle.textContent = attrName;
      
      if (!values || values.length === 0) {
        statsAvg.textContent = '-';
        statsHigh.textContent = '-';
        statsLow.textContent = '-';
        return;
      }
      
      const avg = values.reduce((a, b) => a + b, 0) / values.length;
      const high = Math.max(...values);
      const low = Math.min(...values);
      const decimals = selectedAttribute === 'pH' ? 2 : 1;
      
      statsAvg.textContent = avg.toFixed(decimals) + (unit ? ' ' + unit : '');
      statsHigh.textContent = high.toFixed(decimals) + (unit ? ' ' + unit : '');
      statsLow.textContent = low.toFixed(decimals) + (unit ? ' ' + unit : '');
    }

    async function handleAuth() {
      if (SheetsAPI.isSignedIn) await SheetsAPI.signOut();
      else await SheetsAPI.signIn();
    }

    function handleSignInChange(isSignedIn) {
      const authBtn = document.getElementById('authBtn');
      const userInfo = document.getElementById('userInfo');
      if (isSignedIn) {
        userInfo.textContent = 'Connected';
        authBtn.textContent = '‚úì Signed In';
        authBtn.classList.add('signed-in');
        // Load from Google Sheets (the database)
        loadFromSheets();
      } else {
        userInfo.textContent = '';
        authBtn.textContent = 'Sign In with Google';
        authBtn.classList.remove('signed-in');
      }
      updateMobileAuthBtn();
    }

    function updateMobileAuthBtn() {
      // Mobile toolbar doesn't have a dedicated auth button
      // The refresh button can be used to sync when signed in
    }

    async function loadFromSheets(isRetry = false) {
      Utils.showStatus('Loading from Google Sheets...', true);

      const doLoad = async () => {
        console.log('Attempting to load from sheet ID:', CONFIG.SHEET_ID);
        const fields = await SheetsAPI.getFields();
        fieldBoundaries = {};
        fields.forEach(f => { if (f.boundary) fieldBoundaries[f.name] = f.boundary; });
        sampleData = await SheetsAPI.getSamples();
        settings = await SheetsAPI.getSettings();
        updateFieldSelector();
        updateYearSelector();
        updateMap();
        saveLocalData();
        Utils.showStatus(`‚úì Loaded ${sampleData.length} samples, ${Object.keys(fieldBoundaries).length} fields`, true);
      };

      try {
        await doLoad();
      } catch (e) {
        console.error('loadFromSheets error:', e);
        const errorCode = e.result?.error?.code;
        const errorMsg = e.result?.error?.message || e.message || 'Unknown error';

        // Handle 401 (unauthorized) - token may be expired/revoked
        if (errorCode === 401 && !isRetry) {
          console.log('Got 401, attempting token refresh and retry...');
          Utils.showStatus('Refreshing authentication...', true);
          try {
            await SheetsAPI.refreshTokenAndRetry(doLoad);
            Utils.showStatus(`‚úì Loaded ${sampleData.length} samples, ${Object.keys(fieldBoundaries).length} fields`, true);
            return;
          } catch (retryError) {
            console.error('Retry after refresh failed:', retryError);
            // Clear invalid token and fall through to error handling
            localStorage.removeItem('googleAccessToken');
            localStorage.removeItem('googleTokenExpiry');
            SheetsAPI.isSignedIn = false;
            handleSignInChange(false);
            Utils.showStatus('Session expired - please sign in again', false);
            loadLocalData();
            return;
          }
        }

        // Handle 403 (forbidden) - no access to sheet
        if (errorCode === 403) {
          Utils.showStatus('No access to this Google Sheet - check sharing settings', false);
          loadLocalData();
          return;
        }

        // Handle 404 (not found) - sheet doesn't exist
        if (errorCode === 404) {
          Utils.showStatus('Google Sheet not found - check Sheet ID in Settings', false);
          loadLocalData();
          return;
        }

        // Generic error
        Utils.showStatus(`Error loading from Sheets: ${errorMsg} - using local cache`, false);
        loadLocalData();
      }
    }

    async function loadData() {
      if (SheetsAPI.isSignedIn) {
        await loadFromSheets();
      } else {
        loadLocalData();
      }
    }

    function loadLocalData() {
      try {
        const s = localStorage.getItem('soilSamples');
        const b = localStorage.getItem('fieldBoundaries');
        const st = localStorage.getItem('soilSettings');
        if (s) sampleData = JSON.parse(s);
        if (b) fieldBoundaries = JSON.parse(b);
        if (st) {
          const rawSettings = JSON.parse(st);
          // Convert flat settings (pH_min, pH_max) to nested format ({pH: {min, max}})
          settings = {
            pH: { min: rawSettings.pH_min || 6.3, max: rawSettings.pH_max || 6.9 },
            P: { min: rawSettings.P_min || 20, max: null },
            K: { min: rawSettings.K_min || 150, max: null },
            OM: { min: rawSettings.OM_min || 3.0, max: null },
            Ca_sat: { min: rawSettings.Ca_sat_min || 65, max: rawSettings.Ca_sat_max || 75 },
            Mg_sat: { min: rawSettings.Mg_sat_min || null, max: rawSettings.Mg_sat_max || 15 },
            K_Sat: { min: rawSettings.K_sat_min || 3.0, max: null },
            H_Sat: { min: null, max: rawSettings.H_sat_max || 5.0 },
            bufferPercent: rawSettings.bufferPercent || 25
          };
        }
        updateFieldSelector();
        updateYearSelector();
        updateMap();
        if (sampleData.length > 0) Utils.showStatus(`Loaded ${sampleData.length} samples from local storage`, true);
      } catch (e) { console.error(e); }
    }

    function saveLocalData() {
      try {
        localStorage.setItem('soilSamples', JSON.stringify(sampleData));
        localStorage.setItem('fieldBoundaries', JSON.stringify(fieldBoundaries));
        localStorage.setItem('soilSettings', JSON.stringify(settings));
      } catch (e) { console.error(e); }
    }

    function updateFieldSelector() {
      const sel = document.getElementById('fieldSelect');
      const val = sel.value;
      sel.innerHTML = '<option value="all">All Fields</option>';
      const fields = [...new Set([...Utils.getUniqueFields(sampleData), ...Object.keys(fieldBoundaries)])].sort((a,b) => a.localeCompare(b, undefined, {numeric:true}));
      fields.forEach(f => { const o = document.createElement('option'); o.value = f; o.textContent = f; sel.appendChild(o); });
      if (fields.includes(val)) sel.value = val;
    }

    function updateYearSelector() {
      const sel = document.getElementById('yearSelect');
      const val = sel.value;
      sel.innerHTML = '<option value="all">All Years</option>';
      
      // Filter samples by selected field if one is selected
      const filteredSamples = selectedField === 'all' 
        ? sampleData 
        : sampleData.filter(s => s.field === selectedField);
      
      const years = Utils.getUniqueYears(filteredSamples);
      years.forEach(y => { const o = document.createElement('option'); o.value = y; o.textContent = y; sel.appendChild(o); });
      
      // Keep previous selection if still valid, otherwise reset to 'all'
      if (years.includes(parseInt(val))) {
        sel.value = val;
      } else {
        sel.value = 'all';
        selectedYear = 'all';
      }
    }

    function updateMap() {
      currentLayers.forEach(l => map.removeLayer(l));
      currentLayers = [];
      
      const zoomLevel = map.getZoom();
      const isZoomedOut = zoomLevel < 13; // Threshold for switching to field view
      
      // Compare mode - show year-over-year change (always show samples)
      if (compareMode && selectedYear !== 'all' && compareYear) {
        drawBoundaries(false);
        renderCompareMode();
        return;
      }
      
      // Zoomed out: show field-level shading
      if (isZoomedOut && Object.keys(fieldBoundaries).length > 0 && selectedAttribute !== 'sampleId') {
        drawFieldShading();
        return;
      }
      
      // Zoomed in: show individual samples
      drawBoundaries(false);
      drawSampleMarkers();
    }
    
    function drawBoundaries(withShading, fieldColors = {}) {
      Object.entries(fieldBoundaries).forEach(([name, polys]) => {
        if (selectedField !== 'all' && selectedField !== name) return;
        const arr = Array.isArray(polys[0]?.[0]) ? polys : [polys];
        arr.forEach(coords => {
          const color = fieldColors[name] || '#22c55e';
          const fillOpacity = withShading ? 0.6 : 0.1;
          const poly = L.polygon(coords, { 
            color: withShading ? color : '#22c55e', 
            weight: withShading ? 2 : 3, 
            fillOpacity: fillOpacity, 
            fillColor: color 
          }).addTo(map);
          
          if (withShading && fieldColors[name]) {
            const fieldStats = fieldColors[name + '_stats'];
            if (fieldStats) {
              poly.bindTooltip(`<strong>${name}</strong><br>Avg ${CONFIG.NUTRIENT_NAMES[selectedAttribute] || selectedAttribute}: ${fieldStats.avg.toFixed(1)} ${CONFIG.NUTRIENT_UNITS[selectedAttribute] || ''}`, 
                { permanent: false, direction: 'center', className: 'field-tooltip' });
            }
          } else {
            poly.bindTooltip(name, { permanent: false, direction: 'center' });
          }
          currentLayers.push(poly);
        });
      });
    }
    
    function drawFieldShading() {
      const settings = Utils.loadSettings();
      const bufferPct = settings.bufferPercent || 25;
      
      // Calculate average for each field
      const fieldAverages = {};
      const fieldColors = {};
      
      // Get all values for context (for relative coloring)
      let allFieldAvgs = [];
      
      Object.keys(fieldBoundaries).forEach(fieldName => {
        if (selectedField !== 'all' && selectedField !== fieldName) return;
        
        let fieldSamples = sampleData.filter(s => s.field === fieldName);
        if (selectedYear !== 'all') {
          fieldSamples = fieldSamples.filter(s => String(s.year) === String(selectedYear));
        }
        
        const values = fieldSamples.map(s => s[selectedAttribute]).filter(v => v !== undefined && v !== null && !isNaN(v));
        
        if (values.length > 0) {
          const avg = values.reduce((a, b) => a + b, 0) / values.length;
          fieldAverages[fieldName] = { avg, count: values.length };
          allFieldAvgs.push(avg);
        }
      });
      
      // Calculate colors based on field averages using relative coloring
      // This ensures fields are colored relative to each other, not just absolute thresholds
      const isLowerBetter = CONFIG.LOWER_IS_BETTER.includes(selectedAttribute);

      if (allFieldAvgs.length > 1) {
        // Sort field averages to determine relative positions
        const sortedAvgs = [...allFieldAvgs].sort((a, b) => a - b);
        const minAvg = sortedAvgs[0];
        const maxAvg = sortedAvgs[sortedAvgs.length - 1];
        const range = maxAvg - minAvg;

        Object.entries(fieldAverages).forEach(([fieldName, stats]) => {
          let color;
          if (range === 0) {
            color = '#eab308'; // All same value = yellow
          } else {
            // Calculate position from 0 to 1
            const position = (stats.avg - minAvg) / range;
            // Assign color based on position (higher = greener for most, inverted for "lower is better")
            if (isLowerBetter) {
              // Lower is better: low position = green, high position = red
              if (position <= 0.33) color = '#22c55e';      // Green (low/good)
              else if (position <= 0.66) color = '#eab308'; // Yellow (medium)
              else color = '#ef4444';                        // Red (high/bad)
            } else {
              // Higher is better: high position = green, low position = red
              if (position >= 0.66) color = '#22c55e';      // Green (high/good)
              else if (position >= 0.33) color = '#eab308'; // Yellow (medium)
              else color = '#ef4444';                        // Red (low/bad)
            }
          }
          fieldColors[fieldName] = color;
          fieldColors[fieldName + '_stats'] = stats;
        });
      } else {
        // Single field - use threshold-based coloring
        Object.entries(fieldAverages).forEach(([fieldName, stats]) => {
          const color = Utils.getColor(stats.avg, selectedAttribute, settings, bufferPct, allFieldAvgs);
          fieldColors[fieldName] = color;
          fieldColors[fieldName + '_stats'] = stats;
        });
      }
      
      // Update stats box with all samples
      let filtered = sampleData.filter(s => {
        if (selectedField !== 'all' && s.field !== selectedField) return false;
        if (selectedYear !== 'all' && String(s.year) !== String(selectedYear)) return false;
        return true;
      });
      const allValues = filtered.map(s => s[selectedAttribute]).filter(v => v !== undefined && v !== null && !isNaN(v));
      updateStats(allValues);
      
      // Draw boundaries with shading
      drawBoundaries(true, fieldColors);
    }
    
    function drawSampleMarkers() {
      const settings = Utils.loadSettings();
      
      // Filter samples for selected year
      let filtered = sampleData.filter(s => {
        if (selectedField !== 'all' && s.field !== selectedField) return false;
        if (selectedYear !== 'all' && String(s.year) !== String(selectedYear)) return false;
        return true;
      });
      
      // Get all values for median-based coloring and stats
      const allValues = filtered.map(s => s[selectedAttribute]).filter(v => v !== undefined && v !== null && !isNaN(v));
      
      // Update stats box
      updateStats(allValues);
      
      // Render point markers
      filtered.forEach(sample => {
        const value = sample[selectedAttribute];
        if (value === undefined || value === null) return;
        const bufferPct = settings.bufferPercent || 25;
        const color = Utils.getColor(value, selectedAttribute, settings, bufferPct, allValues);
        const size = fieldModeActive ? 44 : 32;
        const fontSize = fieldModeActive ? 14 : 11;
        // For sampleId, display as-is; for other attributes, format as number
        const displayVal = selectedAttribute === 'sampleId' 
          ? value 
          : Utils.formatNumber(value, selectedAttribute === 'pH' ? 1 : 0);
        const icon = L.divIcon({
          html: `<div class="sample-marker" style="width:${size}px;height:${size}px;background:${color};font-size:${fontSize}px;line-height:${size}px;">${displayVal}</div>`,
          className: '', iconSize: [size, size], iconAnchor: [size/2, size/2]
        });
        const marker = L.marker([sample.lat, sample.lon], { icon }).addTo(map);
        marker.bindPopup(buildSamplePopup(sample));
        currentLayers.push(marker);
      });
    }

    function buildSamplePopup(sample) {
      const visibleNutrients = getVisibleNutrients();
      let html = `<div style="max-height: 300px; overflow-y: auto; min-width: 200px;">`;
      html += `<div style="font-weight: 700; font-size: 14px; margin-bottom: 8px; border-bottom: 2px solid #3b82f6; padding-bottom: 4px;">`;
      html += `Sample ${sample.sampleId || 'Unknown'}</div>`;
      html += `<div style="margin-bottom: 8px; color: #64748b; font-size: 12px;">`;
      html += `<strong>Field:</strong> ${sample.field || 'Unknown'}<br>`;
      html += `<strong>Year:</strong> ${sample.year || 'N/A'}`;
      if (sample.depth) html += `<br><strong>Depth:</strong> ${sample.depth}"`;
      html += `</div>`;
      html += `<table style="width: 100%; font-size: 12px; border-collapse: collapse;">`;

      visibleNutrients.forEach(n => {
        if (n.key === 'sampleId') return; // Already shown in header
        const value = sample[n.key];
        if (value === undefined || value === null) return;
        const displayVal = typeof value === 'number' ? value.toFixed(n.key === 'pH' || n.key === 'Buffer_pH' ? 1 : (value < 10 ? 2 : 1)) : value;
        const unit = CONFIG.NUTRIENT_UNITS[n.key] || '';
        const isSelected = n.key === selectedAttribute;
        html += `<tr style="${isSelected ? 'background: #dbeafe; font-weight: 600;' : ''}">`;
        html += `<td style="padding: 3px 6px; border-bottom: 1px solid #e2e8f0;">${n.name}</td>`;
        html += `<td style="padding: 3px 6px; border-bottom: 1px solid #e2e8f0; text-align: right;">${displayVal} ${unit}</td>`;
        html += `</tr>`;
      });

      html += `</table></div>`;
      return html;
    }

    function renderCompareMode() {
      // Get samples from selected year (later) and compare year (earlier)
      const laterYear = selectedYear;
      const earlierYear = compareYear;
      
      const laterSamples = sampleData.filter(s => {
        if (selectedField !== 'all' && s.field !== selectedField) return false;
        return String(s.year) === String(laterYear);
      });
      
      const earlierSamples = sampleData.filter(s => {
        if (selectedField !== 'all' && s.field !== selectedField) return false;
        return String(s.year) === String(earlierYear);
      });
      
      // Calculate change stats
      const changes = [];
      
      // For each later sample, find nearest earlier sample and show change
      laterSamples.forEach(laterSample => {
        const value = laterSample[selectedAttribute];
        if (value === undefined || value === null) return;
        
        // Find nearest earlier sample (same field or closest by location)
        let earlierSample = earlierSamples.find(s => s.field === laterSample.field && s.sampleId === laterSample.sampleId);
        if (!earlierSample) {
          // Find closest by location within same field
          const fieldEarlier = earlierSamples.filter(s => s.field === laterSample.field);
            if (fieldEarlier.length > 0) {
              let minDist = Infinity;
              fieldEarlier.forEach(s => {
                const dist = Math.sqrt((s.lat - laterSample.lat) ** 2 + (s.lon - laterSample.lon) ** 2);
                if (dist < minDist) { minDist = dist; earlierSample = s; }
              });
            }
          }
          
          const earlierValue = earlierSample ? earlierSample[selectedAttribute] : null;
          const change = earlierValue !== null && earlierValue !== undefined ? value - earlierValue : null;
          const percentChange = earlierValue && earlierValue !== 0 ? ((value - earlierValue) / earlierValue) * 100 : 0;
          
          const color = change !== null ? Utils.getChangeColor(change, percentChange) : '#94a3b8';
          const size = fieldModeActive ? 44 : 32;
          const fontSize = fieldModeActive ? 12 : 10;
          
          let displayVal;
          if (change !== null) {
            const sign = change >= 0 ? '+' : '';
            displayVal = sign + Utils.formatNumber(change, 1);
          } else {
            displayVal = Utils.formatNumber(value, 1);
          }
          
          const icon = L.divIcon({
            html: `<div class="sample-marker" style="width:${size}px;height:${size}px;background:${color};font-size:${fontSize}px;line-height:${size}px;">${displayVal}</div>`,
            className: '', iconSize: [size, size], iconAnchor: [size/2, size/2]
          });
          const marker = L.marker([laterSample.lat, laterSample.lon], { icon }).addTo(map);
          
          let popupText = `<strong>Sample ${laterSample.sampleId || ''}</strong><br>Field: ${laterSample.field || 'Unknown'}`;
          popupText += `<br>${earlierYear}: ${earlierValue !== null ? Utils.formatNumber(earlierValue, 1) : 'N/A'}`;
          popupText += `<br>${laterYear}: ${Utils.formatNumber(value, 1)}`;
          if (change !== null) {
            popupText += `<br><strong>Change: ${change >= 0 ? '+' : ''}${Utils.formatNumber(change, 1)} (${percentChange >= 0 ? '+' : ''}${Utils.formatNumber(percentChange, 0)}%)</strong>`;
            changes.push(change);
          }
          marker.bindPopup(popupText);
          currentLayers.push(marker);
        });
      
      // Update stats for compare mode
      if (changes.length > 0) {
        const avg = changes.reduce((a, b) => a + b, 0) / changes.length;
        const high = Math.max(...changes);
        const low = Math.min(...changes);
        document.getElementById('statsTitle').textContent = 'Change Stats';
        document.getElementById('statsAvg').textContent = (avg >= 0 ? '+' : '') + avg.toFixed(1);
        document.getElementById('statsHigh').textContent = (high >= 0 ? '+' : '') + high.toFixed(1);
        document.getElementById('statsLow').textContent = (low >= 0 ? '+' : '') + low.toFixed(1);
      }
    }

    function zoomToField(fieldName) {
      if (fieldName === 'all') {
        const allCoords = [];
        Object.values(fieldBoundaries).forEach(p => { const a = Array.isArray(p[0]?.[0]) ? p.flat() : p; allCoords.push(...a); });
        sampleData.forEach(s => allCoords.push([s.lat, s.lon]));
        if (allCoords.length > 0) map.fitBounds(allCoords, { padding: [50,50] });
      } else if (fieldBoundaries[fieldName]) {
        const p = fieldBoundaries[fieldName];
        const a = Array.isArray(p[0]?.[0]) ? p.flat() : p;
        map.fitBounds(a, { padding: [50,50] });
      }
    }

    function toggleFieldMode() {
      fieldModeActive = !fieldModeActive;
      const btn = document.getElementById('fieldModeBtn');
      const mobileBtn = document.getElementById('mobileFieldModeBtn');
      if (fieldModeActive) {
        btn.classList.add('active');
        btn.textContent = 'üì± Field Mode ON';
        mobileBtn.classList.add('active');
        mobileBtn.textContent = 'üì± ON';
        document.body.classList.add('field-mode');
        startGPS();
      } else {
        btn.classList.remove('active');
        btn.textContent = 'üì± Field Mode';
        mobileBtn.classList.remove('active');
        mobileBtn.textContent = 'üì± Field Mode';
        document.body.classList.remove('field-mode');
        stopGPS();
      }
      updateMap();
    }

    function startGPS() {
      if (!navigator.geolocation) { Utils.showStatus('GPS not supported', false); return; }
      gpsWatchId = navigator.geolocation.watchPosition(
        (pos) => {
          const { latitude, longitude, accuracy } = pos.coords;
          if (gpsMarker) { gpsMarker.setLatLng([latitude, longitude]); gpsCircle.setLatLng([latitude, longitude]); gpsCircle.setRadius(accuracy); }
          else {
            const gpsIcon = L.divIcon({
              html: '<div class="gps-marker"><div class="gps-pulse"></div><div class="gps-dot"></div></div>',
              className: '',
              iconSize: [22, 22],
              iconAnchor: [11, 11]
            });
            gpsMarker = L.marker([latitude, longitude], { icon: gpsIcon }).addTo(map);
            gpsCircle = L.circle([latitude, longitude], { radius: accuracy, color: '#3b82f6', fillColor: '#3b82f6', fillOpacity: 0.1, weight: 2, dashArray: '4' }).addTo(map);
          }
          map.setView([latitude, longitude], map.getZoom());
        },
        (e) => Utils.showStatus('GPS error: ' + e.message, false),
        { enableHighAccuracy: true, maximumAge: 5000 }
      );
    }

    function stopGPS() {
      if (gpsWatchId) { navigator.geolocation.clearWatch(gpsWatchId); gpsWatchId = null; }
      if (gpsMarker) { map.removeLayer(gpsMarker); map.removeLayer(gpsCircle); gpsMarker = null; gpsCircle = null; }
    }
  </script>
</body>
</html>
