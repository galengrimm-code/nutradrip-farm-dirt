<!DOCTYPE html>
<!-- v18 - Smooth color gradients, year filtering by attribute -->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/svg+xml" href="favicon.svg">
  <link rel="apple-touch-icon" href="logo.png">
  <title>Soil Sample Analysis - Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f8fafc; color: #1e293b; }
    .app-container { display: flex; flex-direction: column; height: 100vh; }
    .top-bar { background: linear-gradient(135deg, #1e293b 0%, #334155 100%); color: white; padding: 1rem 1.5rem; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem; }
    .top-bar h1 { font-size: 1.5rem; font-weight: 700; }
    .top-bar p { font-size: 0.875rem; opacity: 0.8; margin-top: 0.25rem; }
    .nav-links { display: flex; gap: 0.5rem; flex-wrap: wrap; }
    .nav-link { padding: 0.5rem 1rem; background: rgba(255,255,255,0.1); color: white; text-decoration: none; border-radius: 0.375rem; font-size: 0.875rem; font-weight: 500; transition: background 0.2s; }
    .nav-link:hover { background: rgba(255,255,255,0.2); }
    .nav-link.active { background: #3b82f6; }
    .auth-section { display: flex; align-items: center; gap: 1rem; }
    .user-info { font-size: 0.875rem; color: rgba(255,255,255,0.9); }
    .sign-in-btn { padding: 0.5rem 1rem; background: #4285f4; color: white; border: none; border-radius: 0.375rem; font-size: 0.875rem; cursor: pointer; }
    .sign-in-btn:hover { background: #3367d6; }
    .sign-in-btn.signed-in { background: #22c55e; }
    .sign-in-btn.signed-in:hover { background: #16a34a; }
    .controls-bar { background: white; border-bottom: 1px solid #e2e8f0; padding: 0.75rem 1.5rem; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem; }
    .controls-left, .controls-right { display: flex; align-items: center; gap: 1rem; flex-wrap: wrap; }
    .control-group { display: flex; flex-direction: column; gap: 0.25rem; }
    .control-group label { font-size: 0.6875rem; font-weight: 600; color: #64748b; text-transform: uppercase; letter-spacing: 0.05em; }
    select, input[type="text"], input[type="number"] { padding: 0.5rem 0.75rem; border: 1px solid #cbd5e1; border-radius: 0.375rem; font-size: 0.875rem; background: white; min-width: 120px; }
    select:focus, input:focus { outline: none; border-color: #3b82f6; box-shadow: 0 0 0 3px rgba(59,130,246,0.1); }
    .button { padding: 0.5rem 1rem; border: 1px solid #cbd5e1; border-radius: 0.375rem; background: white; font-size: 0.875rem; font-weight: 500; cursor: pointer; transition: all 0.2s; display: inline-flex; align-items: center; gap: 0.5rem; }
    .button:hover { background: #f1f5f9; border-color: #94a3b8; }
    .button.active { background: #3b82f6; color: white; border-color: #3b82f6; }
    .toggle-group { display: flex; border: 1px solid #cbd5e1; border-radius: 0.375rem; overflow: hidden; }
    .toggle-btn { padding: 0.5rem 1rem; background: white; border: none; font-size: 0.875rem; cursor: pointer; transition: all 0.2s; }
    .toggle-btn:not(:last-child) { border-right: 1px solid #cbd5e1; }
    .toggle-btn:hover { background: #f1f5f9; }
    .toggle-btn.active { background: #3b82f6; color: white; }
    .legend { background: white; border-bottom: 1px solid #e2e8f0; padding: 0.5rem 1rem; display: flex; align-items: center; gap: 0.5rem; font-size: 0.75rem; }
    .legend-label { font-weight: 600; color: #64748b; }
    .main-content { display: flex; flex-direction: column; flex: 1; }
    #map { flex: 1; min-height: 500px; }
    .sample-marker { border-radius: 6px; border: none; box-shadow: 0 3px 8px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.25); display: flex; align-items: center; justify-content: center; font-weight: 600; color: white; text-shadow: 0 1px 2px rgba(0,0,0,0.5); letter-spacing: -0.5px; }
    .gps-marker { position: relative; }
    .gps-dot { width: 16px; height: 16px; background: #3b82f6; border: 3px solid white; border-radius: 50%; box-shadow: 0 2px 6px rgba(0,0,0,0.3); }
    .gps-pulse { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 16px; height: 16px; background: rgba(59,130,246,0.4); border-radius: 50%; animation: gpsPulse 2s ease-out infinite; }
    @keyframes gpsPulse { 0% { width: 16px; height: 16px; opacity: 1; } 100% { width: 50px; height: 50px; opacity: 0; } }
    #statusMessage { display: none; position: fixed; top: 5rem; left: 50%; transform: translateX(-50%); z-index: 9999; max-width: 90%; box-shadow: 0 4px 12px rgba(0,0,0,0.15); padding: 0.75rem 1rem; border-radius: 0.375rem; }
    .field-tooltip { background: white; border: 2px solid #1e293b; border-radius: 0.5rem; padding: 0.5rem 0.75rem; font-size: 0.875rem; font-weight: 500; box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
    .field-mode .sample-marker { min-width: 44px !important; min-height: 44px !important; font-size: 14px !important; }
    .field-mode .controls-left { display: none; }
    .field-mode .legend { display: none; }
    @media (max-width: 639px) {
      .top-bar { padding: 0.5rem 0.75rem; }
      .top-bar h1 { font-size: 1rem; }
      .top-bar > div:first-child { display: none; }
      .nav-links { width: 100%; justify-content: center; order: -1; }
      .nav-link { padding: 0.4rem 0.6rem; font-size: 0.75rem; }
      .auth-section { display: none; }
      
      /* Simplified mobile controls */
      .controls-bar { padding: 0.5rem; gap: 0.5rem; flex-direction: column; }
      .controls-left { display: flex; flex-wrap: wrap; gap: 0.5rem; width: 100%; }
      .control-group { flex: 1; min-width: calc(50% - 0.25rem); }
      .control-group label { font-size: 0.6rem; }
      .control-group.compare-mode { display: none; } /* Hide compare toggle on mobile */
      .controls-right { display: none; }
      select, input { font-size: 14px !important; padding: 0.5rem; min-width: 0; width: 100%; }
      .legend { display: none; } /* Hide legend on mobile */
      .mobile-toolbar { display: flex !important; }
      /* Compact stats box on mobile - minimal footprint */
      .stats-box {
        bottom: 60px !important;
        top: auto !important;
        right: 0.5rem !important;
        padding: 0 !important;
        min-width: 85px !important;
        max-width: 100px !important;
        height: auto !important;
        font-size: 11px !important;
      }
      .stats-box .stats-header {
        padding: 4px 6px !important;
        margin: 0 !important;
        font-size: 10px !important;
      }
      .stats-box .stats-header span:first-child { font-size: 10px !important; }
      .stats-box .stats-toggle { font-size: 8px !important; }
      .stats-box .stats-content {
        padding: 0 6px 4px 6px !important;
      }
      .stats-box .stats-content > div {
        margin-bottom: 0 !important;
        font-size: 11px !important;
        line-height: 1.3 !important;
      }
      .stats-box #statsNote {
        margin-top: 2px !important;
        padding-top: 2px !important;
        font-size: 8px !important;
        line-height: 1.2 !important;
      }
      .stats-box #statsNote:empty { display: none !important; }
      .stats-box.collapsed .stats-content { display: none !important; }
      /* Hide stats box in Field View mode */
      .stats-box.field-view-hidden { display: none !important; }
      /* Hide nav tabs in Field View mode */
      .nav-links.field-view-hidden { display: none !important; }
      /* Back button to show nav - hamburger icon */
      .back-to-menu-btn { display: none; background: rgba(255,255,255,0.95); border: 1px solid #cbd5e1; border-radius: 6px; padding: 6px 10px; font-size: 1rem; font-weight: 500; cursor: pointer; position: absolute; top: 10px; left: 10px; z-index: 1001; box-shadow: 0 2px 6px rgba(0,0,0,0.15); line-height: 1; }
      .back-to-menu-btn.visible { display: block !important; }

      /* Compare mode is desktop-only - hide all compare elements on mobile */
      #compareYearStack { display: none !important; }
      #compareInfoBar { display: none !important; }
      #mobileCompareBtn { display: none !important; }
      .compare-legend { display: none !important; }

      /* Move zoom indicator above mobile toolbar */
      #zoomIndicator {
        bottom: 60px !important;
        left: 8px !important;
        padding: 4px 8px !important;
        font-size: 10px !important;
      }

      /* Push zoom controls below hamburger menu button */
      .leaflet-control-zoom {
        margin-top: 45px !important;
      }

      /* Fix Leaflet attribution on mobile */
      .leaflet-control-attribution {
        bottom: 60px !important;
        font-size: 8px !important;
        max-width: 150px !important;
      }
    }
    .mobile-toolbar { display: none; position: fixed; bottom: 0; left: 0; right: 0; background: white; border-top: 1px solid #e2e8f0; padding: 0.5rem; z-index: 1000; justify-content: space-around; box-shadow: 0 -2px 10px rgba(0,0,0,0.1); }
    .mobile-toolbar button { flex: 1; margin: 0 0.25rem; padding: 0.6rem 0.5rem; border: 1px solid #cbd5e1; border-radius: 0.375rem; background: white; font-size: 0.7rem; cursor: pointer; font-weight: 500; }
    .mobile-toolbar button.active { background: #3b82f6; color: white; border-color: #3b82f6; }

    /* Pin Drop Mode */
    .pin-drop-mode #map { cursor: crosshair !important; }
    .pin-drop-mode .leaflet-container { cursor: crosshair !important; }
    .pin-drop-mode .leaflet-interactive { cursor: crosshair !important; }
    .sample-site-marker { border-radius: 50%; border: 3px solid white; box-shadow: 0 3px 8px rgba(0,0,0,0.35); display: flex; align-items: center; justify-content: center; font-size: 14px; }
    .temp-pin-marker { width: 28px; height: 28px; background: #7c3aed; border-radius: 50%; border: 3px solid white; box-shadow: 0 3px 8px rgba(0,0,0,0.35); animation: tempPinPulse 1.5s ease-in-out infinite; }
    @keyframes tempPinPulse { 0%, 100% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.15); opacity: 0.8; } }

    .backup-footer { position: fixed; bottom: 0; left: 0; right: 0; background: #f8fafc; border-top: 1px solid #e2e8f0; padding: 0.25rem 1rem; font-size: 0.7rem; color: #64748b; text-align: center; z-index: 900; }
    @media (max-width: 639px) { .backup-footer { bottom: 50px; } }
  </style>
</head>
<body>
  <div class="app-container">
    <div class="top-bar">
      <div>
        <h1>üå± Soil Sample Analysis</h1>
        <p id="operationSubtitle">Precision Farms Field Management</p>
      </div>
      <nav class="nav-links">
        <a href="index.html" class="nav-link active">üìç Map</a>
        <a href="analysis.html" class="nav-link">üìä Analysis</a>
        <a href="import.html" class="nav-link">üìÅ Import</a>
        <a href="settings.html" class="nav-link">‚öôÔ∏è Settings</a>
      </nav>
      <div class="auth-section">
        <span class="user-info" id="userInfo"></span>
        <button class="sign-in-btn" id="authBtn" onclick="handleAuth()">Sign In to Edit</button>
      </div>
    </div>

    <!-- Active Operation Indicator (shown when filtering by client/farm) -->
    <div id="activeOperationIndicator" style="display: none; padding: 0.35rem 1rem; background: #f5f3ff; border-bottom: 1px solid #ddd6fe; font-size: 0.75rem; color: #6b21a8;"></div>

    <div class="controls-bar">
      <div class="controls-left">
        <div class="control-group">
          <label>FIELD</label>
          <select id="fieldSelect"><option value="all">All Fields</option></select>
        </div>
        <div class="control-group">
          <label>ATTRIBUTE</label>
          <select id="attributeSelect"></select>
        </div>
        <div class="control-group" id="viewYearGroup">
          <label>YEAR</label>
          <select id="yearSelect"><option value="all">All Years</option></select>
        </div>
        <div class="control-group">
          <label>MODE</label>
          <div class="toggle-group">
            <button class="toggle-btn active" id="singleYearBtn">View</button>
            <button class="toggle-btn" id="compareYearsBtn">Compare</button>
          </div>
        </div>
      </div>
      <!-- Compare Mode Year Stack -->
      <div id="compareYearStack" style="display: none; background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%); border: 2px solid #3b82f6; border-radius: 0.5rem; padding: 0.75rem 1rem; text-align: center;">
        <div style="display: flex; align-items: center; gap: 1rem;">
          <div style="text-align: center;">
            <label style="font-size: 0.6rem; font-weight: 600; color: #64748b; text-transform: uppercase; display: block; margin-bottom: 0.25rem;">BASELINE YEAR</label>
            <select id="compareYearSelect" style="padding: 0.4rem 0.6rem; border: 2px solid #93c5fd; border-radius: 0.375rem; font-size: 0.875rem; font-weight: 600; min-width: 90px;"><option value="">Select...</option></select>
          </div>
          <div style="display: flex; flex-direction: column; align-items: center; color: #3b82f6;">
            <span style="font-size: 1.25rem; font-weight: bold;">‚Üí</span>
          </div>
          <div style="text-align: center;">
            <label style="font-size: 0.6rem; font-weight: 600; color: #64748b; text-transform: uppercase; display: block; margin-bottom: 0.25rem;">COMPARE TO</label>
            <select id="compareToYearSelect" style="padding: 0.4rem 0.6rem; border: 2px solid #93c5fd; border-radius: 0.375rem; font-size: 0.875rem; font-weight: 600; min-width: 90px;"><option value="">Select...</option></select>
          </div>
        </div>
        <div id="compareSummaryText" style="margin-top: 0.5rem; font-size: 0.75rem; color: #1e40af; font-weight: 500;">Select years to compare</div>
      </div>
      <div class="controls-right">
        <button class="button" id="addSampleSiteBtn">üìç Add Sample Site</button>
        <button class="button" id="fieldModeBtn">üì± Field Mode</button>
        <button class="button" id="refreshBtn">üîÑ Refresh</button>
      </div>
    </div>
    
    <div class="legend" id="legendBar">
      <span class="legend-label">Legend:</span>
      <div style="width: 100px; height: 16px; background: linear-gradient(to right, #dc2626, #f97316, #eab308, #84cc16, #16a34a); border-radius: 8px; border: 1px solid #cbd5e1;"></div>
      <span id="legendText">Low ‚Üí High</span>
      <span id="legendRange" style="color: #475569; font-weight: 500; margin-left: 0.5rem;"></span>
      <span style="margin-left: auto; color: #64748b; font-size: 0.75rem;" id="lastUpdated"></span>
    </div>

    <!-- Compare mode info bar -->
    <div id="compareInfoBar" style="display:none; background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%); border: 2px solid #3b82f6; border-radius: 0.5rem; padding: 0.75rem 1rem; margin: 0 1rem 0.5rem 1rem; font-size: 0.875rem;">
      <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 0.5rem;">
        <div style="display: flex; align-items: center; gap: 0.5rem;">
          <span style="font-weight: 700; color: #1d4ed8;">üìä Comparing:</span>
          <span id="compareFromYear" style="background: #fef3c7; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-weight: 600;">-</span>
          <span style="color: #64748b;">‚Üí</span>
          <span id="compareToYear" style="background: #dcfce7; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-weight: 600;">-</span>
        </div>
        <div id="compareSummary" style="color: #475569;"></div>
      </div>
      <div style="margin-top: 0.5rem; font-size: 0.75rem; color: #64748b;">
        <div style="margin-bottom: 0.25rem;">Each marker shows the change in value from baseline to current year. Samples are matched by location within each field.</div>
        <div style="display: flex; gap: 1rem; align-items: center; flex-wrap: wrap;">
          <span style="font-weight: 500;">Color scale:</span>
          <span><span style="color: #dc2626; font-weight: 700;">‚óè</span> Large decrease</span>
          <span><span style="color: #f87171; font-weight: 700;">‚óè</span> Small decrease</span>
          <span><span style="color: #94a3b8; font-weight: 700;">‚óè</span> No change</span>
          <span><span style="color: #86efac; font-weight: 700;">‚óè</span> Small increase</span>
          <span><span style="color: #16a34a; font-weight: 700;">‚óè</span> Large increase</span>
        </div>
      </div>
    </div>
    
    <!-- Mobile bottom toolbar -->
    <div class="mobile-toolbar">
      <button id="mobileSampleSiteBtn">üìç Site</button>
      <button id="mobileFieldModeBtn">üì± Field</button>
      <button id="mobileCompareBtn">üìä Compare</button>
      <button id="mobileRefreshBtn">üîÑ Refresh</button>
    </div>
    
    <div class="main-content" style="position: relative;">
      <div id="map"></div>
      <button id="backToMenuBtn" class="back-to-menu-btn" onclick="showNavTabs()" title="Menu">‚ò∞</button>
      <div id="statsBox" class="stats-box" style="position: absolute; top: 80px; right: 10px; background: white; padding: 8px 12px; border-radius: 6px; box-shadow: 0 2px 6px rgba(0,0,0,0.15); z-index: 1000; font-size: 12px;">
        <div class="stats-header" onclick="toggleStatsBox()" style="font-weight: 600; color: #374151; display: flex; justify-content: space-between; align-items: center;">
          <span id="statsTitle">Stats</span>
          <span class="stats-toggle" style="display: none; font-size: 9px; color: #94a3b8; margin-left: 4px;">‚ñº</span>
        </div>
        <div class="stats-content">
          <div style="display: flex; justify-content: space-between;"><span style="color: #64748b;">Avg:</span> <span id="statsAvg" style="font-weight: 600;">-</span></div>
          <div style="display: flex; justify-content: space-between;"><span style="color: #64748b;">High:</span> <span id="statsHigh" style="font-weight: 600; color: #22c55e;">-</span></div>
          <div style="display: flex; justify-content: space-between;"><span style="color: #64748b;">Low:</span> <span id="statsLow" style="font-weight: 600; color: #ef4444;">-</span></div>
          <div id="statsNote" style="font-size: 9px; color: #94a3b8; font-style: italic; border-top: 1px solid #e5e7eb; padding-top: 3px; margin-top: 3px;"></div>
        </div>
      </div>
      <div id="zoomIndicator" style="position: absolute; bottom: 30px; left: 10px; background: white; padding: 6px 10px; border-radius: 6px; box-shadow: 0 2px 6px rgba(0,0,0,0.15); z-index: 1000; font-size: 11px; font-weight: 500;">
        <div style="display: flex; align-items: center; gap: 8px;">
          <span style="color: #64748b;">Zoom: <span id="zoomLevel">13</span></span>
          <span style="color: #94a3b8;">|</span>
          <span id="viewMode" style="color: #3b82f6;">Sample View</span>
        </div>
      </div>
    </div>
    
    <div id="statusMessage"></div>

    <!-- Welcome Screen for New Users -->
    <div id="welcomeScreen" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 10000; align-items: center; justify-content: center; padding: 1rem;">
      <div style="background: white; border-radius: 1rem; max-width: 500px; width: 100%; box-shadow: 0 25px 50px rgba(0,0,0,0.25); overflow: hidden;">
        <div style="background: linear-gradient(135deg, #1e293b 0%, #334155 100%); color: white; padding: 2rem; text-align: center;">
          <div style="font-size: 3rem; margin-bottom: 0.5rem;">üå±</div>
          <h2 style="margin: 0; font-size: 1.5rem; font-weight: 700;">Welcome to Soil Analysis</h2>
          <p style="margin: 0.5rem 0 0 0; opacity: 0.8; font-size: 0.875rem;">Precision agriculture made simple</p>
        </div>
        <div style="padding: 1.5rem;">
          <p style="color: #475569; margin: 0 0 1.5rem 0; font-size: 0.9375rem; line-height: 1.6;">
            To get started, connect a Google Sheet to store your soil sample data. Your data stays in your Google account.
          </p>

          <button id="createSheetBtn" onclick="createSheetManual()" style="width: 100%; padding: 1rem; background: #22c55e; color: white; border: none; border-radius: 0.5rem; font-size: 1rem; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 0.5rem; margin-bottom: 0.5rem;">
            üìÑ Create New Google Sheet
          </button>
          <div id="createSheetInstructions" style="display: none; background: #fffbeb; border: 1px solid #fcd34d; border-radius: 0.375rem; padding: 0.75rem; margin-bottom: 1rem;">
            <p style="color: #92400e; font-size: 0.75rem; margin: 0 0 0.5rem 0; font-weight: 600;">üëÜ Your new sheet opened in a new tab. Now:</p>
            <ol style="color: #78350f; font-size: 0.7rem; margin: 0; padding-left: 1.25rem; line-height: 1.6;">
              <li>Rename the first tab to <strong>Samples</strong> (right-click tab ‚Üí Rename)</li>
              <li>Add 2 more tabs: <strong>Fields</strong> and <strong>Settings</strong> (click + button)</li>
              <li>Copy the full URL from your browser</li>
              <li>Paste it below and click Connect</li>
            </ol>
          </div>
          <p id="createSheetStatus" style="color: #64748b; font-size: 0.75rem; margin: 0 0 1rem 0; text-align: center;">
            Opens Google Sheets to create your data storage
          </p>

          <div style="border-top: 1px solid #e2e8f0; padding-top: 1rem;">
            <p style="color: #64748b; font-size: 0.8125rem; margin: 0 0 0.75rem 0; font-weight: 500;">Already have a Google Sheet?</p>
            <div style="display: flex; gap: 0.5rem;">
              <input type="text" id="welcomeSheetId" placeholder="Paste Google Sheet URL or ID..."
                style="flex: 1; padding: 0.75rem; border: 1px solid #cbd5e1; border-radius: 0.375rem; font-size: 0.875rem; font-family: monospace;">
              <button onclick="connectWelcomeSheet()" style="padding: 0.75rem 1rem; background: #3b82f6; color: white; border: none; border-radius: 0.375rem; font-weight: 600; cursor: pointer;">
                Connect
              </button>
            </div>
            <p id="welcomeSheetDetected" style="color: #22c55e; font-size: 0.75rem; margin: 0.5rem 0 0 0; display: none;"></p>
          </div>

          <div style="border-top: 1px solid #e2e8f0; margin-top: 1.5rem; padding-top: 1rem;">
            <button onclick="enterDemoMode()" style="width: 100%; padding: 0.875rem; background: white; color: #475569; border: 2px dashed #cbd5e1; border-radius: 0.5rem; font-size: 0.875rem; font-weight: 500; cursor: pointer;">
              üëÄ Try Demo Mode
            </button>
            <p style="color: #94a3b8; font-size: 0.75rem; margin: 0.5rem 0 0 0; text-align: center;">
              Explore with sample data (read-only)
            </p>
          </div>
        </div>
      </div>
    </div>

    <!-- Demo Mode Banner -->
    <div id="demoBanner" style="display: none; position: fixed; top: 0; left: 0; right: 0; background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: white; padding: 0.5rem 1rem; z-index: 9999; text-align: center; font-size: 0.875rem; font-weight: 500;">
      <span>üìä Demo Mode - Exploring with sample data</span>
      <button onclick="exitDemoMode()" style="margin-left: 1rem; padding: 0.25rem 0.75rem; background: white; color: #d97706; border: none; border-radius: 0.25rem; font-weight: 600; cursor: pointer; font-size: 0.8125rem;">
        Connect Your Sheet
      </button>
    </div>

    <!-- Sample Site Modal -->
    <div id="sampleSiteModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 10000; align-items: center; justify-content: center; padding: 1rem;">
      <div style="background: white; border-radius: 1rem; max-width: 420px; width: 100%; box-shadow: 0 25px 50px rgba(0,0,0,0.25); overflow: hidden; max-height: 90vh; overflow-y: auto;">
        <div style="background: linear-gradient(135deg, #7c3aed 0%, #a855f7 100%); color: white; padding: 1.25rem; text-align: center;">
          <div style="font-size: 1.75rem; margin-bottom: 0.25rem;">üìç</div>
          <h2 style="margin: 0; font-size: 1.125rem; font-weight: 700;">Add Sample Site</h2>
        </div>
        <div style="padding: 1.25rem;">
          <!-- GPS Display with Track Location button -->
          <div style="background: #f8fafc; border-radius: 0.5rem; padding: 0.625rem; margin-bottom: 1rem;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
              <div style="font-family: monospace; font-size: 0.8125rem;">
                <div style="display: flex; gap: 0.5rem; margin-bottom: 0.25rem;">
                  <span style="color: #64748b;">Lat:</span>
                  <span id="siteModalLat" style="font-weight: 600;">-</span>
                </div>
                <div style="display: flex; gap: 0.5rem;">
                  <span style="color: #64748b;">Lng:</span>
                  <span id="siteModalLng" style="font-weight: 600;">-</span>
                </div>
              </div>
              <button id="trackLocationBtn" onclick="toggleLocationTracking()" style="padding: 0.5rem 0.75rem; background: #3b82f6; color: white; border: none; border-radius: 0.375rem; font-size: 0.75rem; font-weight: 600; cursor: pointer; white-space: nowrap;">
                üìç Use My Location
              </button>
            </div>
            <div id="gpsAccuracyDisplay" style="display: none; font-size: 0.6875rem; color: #64748b; text-align: center;">
              GPS Accuracy: <span id="gpsAccuracyValue">--</span>m
            </div>
          </div>

          <!-- Type Checkboxes (multi-select) -->
          <div style="margin-bottom: 0.875rem;">
            <label style="font-size: 0.6875rem; font-weight: 600; color: #64748b; text-transform: uppercase; display: block; margin-bottom: 0.5rem;">SAMPLE TYPES (select all that apply)</label>
            <div id="siteTypeCheckboxes" style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
              <label style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem 0.75rem; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 0.375rem; cursor: pointer; font-size: 0.875rem;">
                <input type="checkbox" name="siteType" value="TIS" style="width: 1rem; height: 1rem; accent-color: #22c55e;">
                <span>üåø Tissue</span>
              </label>
              <label style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem 0.75rem; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 0.375rem; cursor: pointer; font-size: 0.875rem;">
                <input type="checkbox" name="siteType" value="SAP" style="width: 1rem; height: 1rem; accent-color: #f59e0b;">
                <span>üß™ Sap</span>
              </label>
              <label style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem 0.75rem; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 0.375rem; cursor: pointer; font-size: 0.875rem;">
                <input type="checkbox" name="siteType" value="ISS" style="width: 1rem; height: 1rem; accent-color: #8b5cf6;">
                <span>üå± In-Season Soil</span>
              </label>
              <label style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem 0.75rem; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 0.375rem; cursor: pointer; font-size: 0.875rem;">
                <input type="checkbox" name="siteType" value="WAT" style="width: 1rem; height: 1rem; accent-color: #3b82f6;">
                <span>üíß Water</span>
              </label>
            </div>
          </div>

          <!-- Client Dropdown -->
          <div style="margin-bottom: 0.875rem;">
            <label style="font-size: 0.6875rem; font-weight: 600; color: #64748b; text-transform: uppercase; display: block; margin-bottom: 0.25rem;">CLIENT</label>
            <select id="siteClientSelect" style="width: 100%; padding: 0.5rem 0.75rem; border: 1px solid #cbd5e1; border-radius: 0.375rem; font-size: 0.875rem;">
            </select>
          </div>

          <!-- Farm Dropdown -->
          <div style="margin-bottom: 0.875rem;">
            <label style="font-size: 0.6875rem; font-weight: 600; color: #64748b; text-transform: uppercase; display: block; margin-bottom: 0.25rem;">FARM</label>
            <select id="siteFarmSelect" style="width: 100%; padding: 0.5rem 0.75rem; border: 1px solid #cbd5e1; border-radius: 0.375rem; font-size: 0.875rem;">
            </select>
          </div>

          <!-- Field Display (auto-detected) -->
          <div style="margin-bottom: 0.875rem;">
            <label style="font-size: 0.6875rem; font-weight: 600; color: #64748b; text-transform: uppercase; display: block; margin-bottom: 0.25rem;">DETECTED FIELD</label>
            <div id="siteFieldDisplay" style="padding: 0.5rem 0.75rem; background: #f1f5f9; border-radius: 0.375rem; font-size: 0.875rem; font-weight: 500; color: #475569;">
              (Click on map to detect)
            </div>
          </div>

          <!-- Site ID Input -->
          <div style="margin-bottom: 0.875rem;">
            <label style="font-size: 0.6875rem; font-weight: 600; color: #64748b; text-transform: uppercase; display: block; margin-bottom: 0.25rem;">SITE ID</label>
            <div style="display: flex; gap: 0.5rem;">
              <input type="text" id="siteIdInput" placeholder="Enter or generate ID" style="flex: 1; padding: 0.5rem 0.75rem; border: 1px solid #cbd5e1; border-radius: 0.375rem; font-size: 0.875rem; font-family: monospace;">
              <button type="button" onclick="autoGenerateSiteId()" style="padding: 0.5rem 0.75rem; background: #f1f5f9; color: #475569; border: 1px solid #cbd5e1; border-radius: 0.375rem; font-size: 0.75rem; font-weight: 600; cursor: pointer; white-space: nowrap;">
                Auto
              </button>
            </div>
          </div>

          <!-- Notes -->
          <div style="margin-bottom: 1.25rem;">
            <label style="font-size: 0.6875rem; font-weight: 600; color: #64748b; text-transform: uppercase; display: block; margin-bottom: 0.25rem;">NOTES (OPTIONAL)</label>
            <textarea id="siteNotesInput" placeholder="e.g., Near waterway, check Zn" style="width: 100%; padding: 0.5rem 0.75rem; border: 1px solid #cbd5e1; border-radius: 0.375rem; font-size: 0.875rem; min-height: 50px; resize: vertical; box-sizing: border-box;"></textarea>
          </div>

          <!-- Buttons -->
          <div style="display: flex; gap: 0.5rem;">
            <button onclick="closeSampleSiteModal()" style="flex: 1; padding: 0.75rem; background: #f1f5f9; color: #475569; border: 1px solid #cbd5e1; border-radius: 0.375rem; font-weight: 600; cursor: pointer;">
              Cancel
            </button>
            <button id="saveSiteBtn" onclick="saveSampleSite()" style="flex: 1; padding: 0.75rem; background: #7c3aed; color: white; border: none; border-radius: 0.375rem; font-weight: 600; cursor: pointer;">
              Save Site
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script src="https://apis.google.com/js/api.js"></script>
  <script src="https://accounts.google.com/gsi/client"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="js/core/data.js"></script>
  <script src="js/core/utils.js"></script>

  <script>
    // ========== APP VERSION ==========
    const APP_VERSION = "v1.0.177";
    const BUILD_DATE = "2026-01-26T10:49:06";

    // ========== CONFIG ==========
    // Reference shared data config and add app-specific config
    const CONFIG = {
      // Data config from shared module
      get CLIENT_ID() { return DataCore.config.CLIENT_ID; },
      get API_KEY() { return DataCore.config.API_KEY; },
      get SHEET_ID() { return DataCore.config.SHEET_ID; },

      // Map defaults
      DEFAULT_LAT: 39.8528,
      DEFAULT_LON: -95.5347,
      DEFAULT_ZOOM: 13,
      NUTRIENT_NAMES: {
        sampleId: 'Sample ID', pH: 'pH', OM: 'Organic Matter', P: 'Phosphorus (P)', P2: 'Phosphorus P2', K: 'Potassium (K)',
        CEC: 'CEC', Ca_sat: 'Calcium Base Sat', Mg_sat: 'Magnesium Base Sat', K_Sat: 'Potassium Base Sat', H_Sat: 'Hydrogen Base Sat', Na_Sat: 'Sodium Base Sat',
        Zn: 'Zinc', Cu: 'Copper', Mn: 'Manganese', Fe: 'Iron', Boron: 'Boron', S: 'Sulfur', Buffer_pH: 'Buffer pH',
        Na: 'Sodium', Ca: 'Calcium', Mg: 'Magnesium', NO3: 'Nitrate', NH4: 'Ammonium', Soluble_Salts: 'Soluble Salts', EC: 'EC'
      },
      NUTRIENT_UNITS: {
        sampleId: '', pH: '', OM: '%', P: 'ppm', P2: 'ppm', K: 'ppm', CEC: 'meq/100g',
        Ca_sat: '%', Mg_sat: '%', K_Sat: '%', H_Sat: '%', Na_Sat: '%',
        Zn: 'ppm', Cu: 'ppm', Mn: 'ppm', Fe: 'ppm', Boron: 'ppm', S: 'ppm', Buffer_pH: '',
        Na: 'ppm', Ca: 'ppm', Mg: 'ppm', NO3: 'ppm', NH4: 'ppm', Soluble_Salts: 'mmhos/cm', EC: 'dS/m'
      },
      LOWER_IS_BETTER: ['Mg_sat', 'H_Sat', 'Na_Sat', 'Soluble_Salts'],

      // Attributes where 0 typically means "no data" rather than actual zero
      // For these, we filter out 0 values from display and calculations
      ZERO_MEANS_NO_DATA: ['P', 'P2', 'K', 'OM', 'CEC', 'Zn', 'Cu', 'Mn', 'Fe', 'Boron', 'S', 'Ca', 'Mg', 'Na', 'NO3', 'NH4'],

      // Field-level shading thresholds (absolute values for 3-zone coloring)
      // { yellow: X, green: Y } means: red < X, yellow X-Y, green >= Y
      // For "lower is better" attributes, thresholds are inverted
      FIELD_SHADING_THRESHOLDS: {
        P: { yellow: 35, green: 70 },
        P2: { yellow: 35, green: 70 },
        K: { yellow: 125, green: 175 },
        OM: { yellow: 2.5, green: 4.0 },
        pH: { yellow: 6.0, green: 6.5, max: 7.2 },
        CEC: { yellow: 10, green: 20 },
        Ca_sat: { yellow: 60, green: 70 },
        Mg_sat: { green: 10, yellow: 15 }, // Lower is better - inverted
        K_Sat: { yellow: 2.5, green: 4.0 },
        Zn: { yellow: 1.0, green: 2.0 },
        S: { yellow: 8, green: 15 },
        Ca: { yellow: 1000, green: 2000 },
        Mg: { yellow: 150, green: 300 }
      },

      // Default decimal places for each attribute (can be overridden in settings)
      DECIMAL_PLACES: {
        pH: 2,
        Buffer_pH: 2,
        OM: 2,
        P: 0,
        P2: 0,
        K: 0,
        CEC: 1,
        Ca_sat: 1,
        Mg_sat: 1,
        K_Sat: 1,
        H_Sat: 1,
        Na_Sat: 1,
        Zn: 2,
        Cu: 2,
        Mn: 1,
        Fe: 1,
        Boron: 2,
        S: 1,
        Ca: 0,
        Mg: 0,
        Na: 0,
        NO3: 1,
        NH4: 1,
        Soluble_Salts: 2,
        EC: 2,
        P_Zn_Ratio: 1
      },

      // All nutrients in display order with default visibility
      ALL_NUTRIENTS: [
        { key: 'sampleId', name: 'Sample ID', defaultVisible: true },
        { key: 'pH', name: 'pH', defaultVisible: true },
        { key: 'P_Zn_Ratio', name: 'P:Zn Ratio', defaultVisible: true },
        { key: 'P', name: 'Phosphorus (P)', defaultVisible: true },
        { key: 'K', name: 'Potassium (K)', defaultVisible: true },
        { key: 'OM', name: 'Organic Matter', defaultVisible: true },
        { key: 'CEC', name: 'CEC', defaultVisible: true },
        { key: 'Ca_sat', name: 'Calcium %', defaultVisible: true },
        { key: 'Mg_sat', name: 'Magnesium %', defaultVisible: true },
        { key: 'K_Sat', name: 'K Base Sat %', defaultVisible: true },
        { key: 'H_Sat', name: 'H Base Sat %', defaultVisible: true },
        { key: 'Zn', name: 'Zinc', defaultVisible: true },
        { key: 'Cu', name: 'Copper', defaultVisible: true },
        { key: 'Mn', name: 'Manganese', defaultVisible: true },
        { key: 'Fe', name: 'Iron', defaultVisible: true },
        { key: 'Boron', name: 'Boron', defaultVisible: true },
        { key: 'S', name: 'Sulfur', defaultVisible: true },
        { key: 'Buffer_pH', name: 'Buffer pH', defaultVisible: true },
        // Hidden by default
        { key: 'P2', name: 'Phosphorus P2', defaultVisible: false },
        { key: 'Na_Sat', name: 'Na Base Sat %', defaultVisible: false },
        { key: 'Na', name: 'Sodium', defaultVisible: false },
        { key: 'Ca', name: 'Calcium (ppm)', defaultVisible: false },
        { key: 'Mg', name: 'Magnesium (ppm)', defaultVisible: false },
        { key: 'NO3', name: 'Nitrate', defaultVisible: false },
        { key: 'NH4', name: 'Ammonium', defaultVisible: false },
        { key: 'Soluble_Salts', name: 'Soluble Salts', defaultVisible: false },
        { key: 'EC', name: 'EC', defaultVisible: false }
      ]
    };
    
    // Get visible nutrients based on settings
    function getVisibleNutrients() {
      const saved = JSON.parse(localStorage.getItem('nutrientVisibility') || '{}');
      return CONFIG.ALL_NUTRIENTS.filter(n => {
        return saved[n.key] !== undefined ? saved[n.key] : n.defaultVisible;
      });
    }
    
    // Populate attribute dropdown with visible nutrients
    function populateAttributeDropdown() {
      const select = document.getElementById('attributeSelect');
      const currentValue = select.value;
      const visible = getVisibleNutrients();

      // Build main nutrient options
      let html = visible.map(n =>
        `<option value="${n.key}">${n.name}</option>`
      ).join('');

      // Add stability section with separator
      const stabilityNutrients = ['P', 'K', 'OM', 'pH', 'CEC', 'Ca_sat', 'Mg_sat', 'Zn', 'S'];
      html += '<option disabled>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</option>';
      html += '<option disabled>üìä Stability (CV%)</option>';
      stabilityNutrients.forEach(key => {
        const name = CONFIG.NUTRIENT_NAMES?.[key] || key;
        html += `<option value="${key}_Stability">${name} Stability</option>`;
      });

      select.innerHTML = html;

      // Restore previous selection if still visible, otherwise default to P
      if (currentValue && (visible.some(n => n.key === currentValue) || currentValue.endsWith('_Stability'))) {
        select.value = currentValue;
      } else if (visible.some(n => n.key === 'P')) {
        select.value = 'P';
        selectedAttribute = 'P';
      }
    }

    // Check if attribute is a stability attribute
    function isStabilityAttribute(attr) {
      return attr && attr.endsWith('_Stability');
    }

    // Get base nutrient from stability attribute (e.g., "P_Stability" -> "P")
    function getBaseNutrient(stabilityAttr) {
      return stabilityAttr.replace('_Stability', '');
    }

    // ========== SHEETS API ==========
    // Use shared SheetsAPI from DataCore module
    const SheetsAPI = DataCore.SheetsAPI;

    // ========== UTILS ==========
    // Extend shared Utils with page-specific methods
    const Utils = Object.assign({}, window.Utils, {
      // Return the global settings object (page-specific)
      loadSettings() {
        return settings;
      },

      // Override getDecimals to use page CONFIG
      getDecimals(attr) {
        return window.Utils.getDecimals(attr, CONFIG.DECIMAL_PLACES);
      },

      // Override formatValue to use page CONFIG
      formatValue(value, attr) {
        return window.Utils.formatValue(value, attr, CONFIG.DECIMAL_PLACES);
      },

      // Override getColor to use page CONFIG
      getColor(value, attribute, settingsArg = {}, bufferPercent = 25, allValues = null) {
        return window.Utils.getColor(value, attribute, settingsArg, bufferPercent, allValues, CONFIG.LOWER_IS_BETTER);
      },

      // Override calculateFieldAverage to use page CONFIG
      calculateFieldAverage(samples, nutrient) {
        return window.Utils.calculateFieldAverage(samples, nutrient, CONFIG.ZERO_MEANS_NO_DATA);
      },

      // Override isValidValue to use page CONFIG
      isValidValue(value, attribute) {
        return window.Utils.isValidValue(value, attribute, CONFIG.ZERO_MEANS_NO_DATA);
      },

      // Override getNumericValue to use page CONFIG
      getNumericValue(value, attribute) {
        return window.Utils.getNumericValue(value, attribute, CONFIG.ZERO_MEANS_NO_DATA);
      }
    });

    // ========== APP STATE ==========
    let map;
    let sampleData = [];
    let fieldBoundaries = {};
    let settings = {};
    let currentLayers = [];
    let selectedField = 'all';
    let selectedAttribute = 'P';
    let selectedYear = 'all';
    let compareYear = '';
    let compareMode = false;
    let fieldModeActive = false;
    let isLoadingFromSheets = false; // Flag to prevent updateMap during sheets loading

    // ========== SAMPLE SITE STATE ==========
    let pinDropMode = false;
    let tempPinMarker = null;
    let pendingSiteCoords = null;
    let sampleSitesData = [];
    let sampleSiteMarkers = [];

    // ========== CACHED STABILITY DATA ==========
    // Calculated once when data loads, not on every render
    let cachedStabilityData = null;

    function refreshStabilityCache() {
      if (sampleData && sampleData.length > 0) {
        console.log('Refreshing stability cache for', sampleData.length, 'samples');
        cachedStabilityData = Utils.calculateStabilityData(sampleData);
        console.log('Stability cache updated:', Object.keys(cachedStabilityData).length, 'locations');
      } else {
        cachedStabilityData = {};
      }
    }

    function getStabilityData() {
      if (cachedStabilityData === null) {
        refreshStabilityCache();
      }
      return cachedStabilityData;
    }

    // ========== CLIENT/FARM DATA ==========
    let clientsData = [];
    let farmsData = [];
    let activeClientId = 'all';
    let activeFarmId = 'all';

    // Use shared functions from DataCore
    function loadClientsData() {
      clientsData = DataCore.loadClientsData();
      return clientsData;
    }

    function loadFarmsData() {
      farmsData = DataCore.loadFarmsData();
      return farmsData;
    }

    function loadActiveSelection() {
      const selection = DataCore.loadActiveSelection();
      activeClientId = selection.clientId;
      activeFarmId = selection.farmId;
    }

    // Get fields filtered by active client/farm selection (uses local state)
    function getActiveFields() {
      const fields = DataCore.getActiveFields(fieldBoundaries, farmsData, activeClientId, activeFarmId);
      console.log('getActiveFields:', { activeClientId, activeFarmId, totalBoundaries: Object.keys(fieldBoundaries).length, activeFieldsCount: fields.length });
      return fields;
    }

    // Get boundary coordinates for a field
    function getFieldBoundaryCoords(fieldName) {
      return DataCore.getFieldBoundaryCoords(fieldBoundaries, fieldName);
    }

    // Update active operation indicator
    function updateActiveOperationIndicator() {
      const indicator = document.getElementById('activeOperationIndicator');
      if (!indicator) return;

      // Hide if viewing all clients
      if (activeClientId === 'all') {
        indicator.style.display = 'none';
        return;
      }

      const client = clientsData.find(c => c.id === activeClientId);
      let text = client?.name || 'Unknown Client';

      if (activeFarmId !== 'all') {
        const farm = farmsData.find(f => f.id === activeFarmId);
        text += ` > ${farm?.name || 'Unknown Farm'}`;
      }

      indicator.innerHTML = `<span style="margin-right: 0.5rem;">üë§</span>${text} <a href="settings.html" style="color: #3b82f6; margin-left: 0.5rem;">[change]</a>`;
      indicator.style.display = 'block';
    }

    // Check if device is mobile (Compare mode is desktop-only)
    function isMobileDevice() {
      return window.innerWidth < 768;
    }
    let gpsMarker = null, gpsCircle = null, gpsWatchId = null;
    let isDemoMode = false;

    // ========== NEW USER / DEMO MODE ==========
    const isNewUser = DataCore.isNewUser;

    function showWelcomeScreen() {
      const welcomeScreen = document.getElementById('welcomeScreen');
      welcomeScreen.style.display = 'flex';
    }

    function hideWelcomeScreen() {
      const welcomeScreen = document.getElementById('welcomeScreen');
      welcomeScreen.style.display = 'none';
    }

    function createSheetManual() {
      // Open Google Sheets to create a new blank spreadsheet
      window.open('https://sheets.new', '_blank');

      // Show instructions
      document.getElementById('createSheetInstructions').style.display = 'block';
      document.getElementById('createSheetStatus').style.display = 'none';

      // Focus the sheet ID input
      setTimeout(() => {
        document.getElementById('welcomeSheetId').focus();
      }, 500);
    }

    const extractSheetId = DataCore.extractSheetId;

    function connectWelcomeSheet() {
      const input = document.getElementById('welcomeSheetId').value.trim();
      if (!input) {
        Utils.showStatus('Please enter a Google Sheet URL or ID', false);
        return;
      }

      // Extract Sheet ID from URL if needed
      const sheetId = extractSheetId(input);

      // Validate format (basic check)
      if (sheetId.length < 20) {
        Utils.showStatus('Could not find a valid Sheet ID - check the URL', false);
        return;
      }

      // Show what was detected
      const detectedEl = document.getElementById('welcomeSheetDetected');
      detectedEl.textContent = `‚úì Sheet ID detected: ${sheetId.substring(0, 20)}...`;
      detectedEl.style.display = 'block';

      // Save and reload
      localStorage.setItem('googleSheetId', sheetId);
      hideWelcomeScreen();
      Utils.showStatus('Sheet connected! Loading data...', true);
      // Reload to initialize with the new sheet
      setTimeout(() => window.location.reload(), 500);
    }

    // Demo data for new users to explore
    const DEMO_DATA = {
      samples: [
        { sampleId: 'D1', field: 'Demo North', lat: 39.858, lon: -95.535, year: 2024, pH: 6.5, P: 45, K: 180, OM: 3.2, CEC: 15.2, Ca_sat: 68, Mg_sat: 12, K_Sat: 4.1, Zn: 1.8, S: 12 },
        { sampleId: 'D2', field: 'Demo North', lat: 39.859, lon: -95.532, year: 2024, pH: 6.3, P: 38, K: 165, OM: 2.9, CEC: 14.8, Ca_sat: 65, Mg_sat: 14, K_Sat: 3.8, Zn: 1.5, S: 10 },
        { sampleId: 'D3', field: 'Demo North', lat: 39.857, lon: -95.538, year: 2024, pH: 6.7, P: 52, K: 195, OM: 3.5, CEC: 16.1, Ca_sat: 71, Mg_sat: 11, K_Sat: 4.5, Zn: 2.1, S: 14 },
        { sampleId: 'D4', field: 'Demo South', lat: 39.848, lon: -95.535, year: 2024, pH: 5.9, P: 28, K: 145, OM: 2.4, CEC: 12.5, Ca_sat: 58, Mg_sat: 18, K_Sat: 3.2, Zn: 0.9, S: 7 },
        { sampleId: 'D5', field: 'Demo South', lat: 39.849, lon: -95.532, year: 2024, pH: 6.1, P: 32, K: 158, OM: 2.7, CEC: 13.2, Ca_sat: 62, Mg_sat: 16, K_Sat: 3.5, Zn: 1.2, S: 9 },
        { sampleId: 'D6', field: 'Demo South', lat: 39.847, lon: -95.538, year: 2024, pH: 6.0, P: 25, K: 138, OM: 2.2, CEC: 11.8, Ca_sat: 55, Mg_sat: 19, K_Sat: 2.9, Zn: 0.7, S: 6 },
        { sampleId: 'D7', field: 'Demo North', lat: 39.858, lon: -95.535, year: 2023, pH: 6.2, P: 40, K: 170, OM: 3.0, CEC: 14.5, Ca_sat: 66, Mg_sat: 13, K_Sat: 3.9, Zn: 1.6, S: 11 },
        { sampleId: 'D8', field: 'Demo North', lat: 39.859, lon: -95.532, year: 2023, pH: 6.1, P: 35, K: 155, OM: 2.7, CEC: 14.0, Ca_sat: 63, Mg_sat: 15, K_Sat: 3.6, Zn: 1.3, S: 9 },
        { sampleId: 'D9', field: 'Demo South', lat: 39.848, lon: -95.535, year: 2023, pH: 5.7, P: 22, K: 130, OM: 2.1, CEC: 11.5, Ca_sat: 54, Mg_sat: 20, K_Sat: 2.8, Zn: 0.6, S: 5 },
      ],
      fields: {
        'Demo North': { name: 'Demo North', acres: 80, boundary: [[39.855, -95.540], [39.855, -95.528], [39.862, -95.528], [39.862, -95.540]] },
        'Demo South': { name: 'Demo South', acres: 65, boundary: [[39.845, -95.540], [39.845, -95.528], [39.852, -95.528], [39.852, -95.540]] }
      }
    };

    function enterDemoMode() {
      isDemoMode = true;
      hideWelcomeScreen();

      // Load demo data
      sampleData = DEMO_DATA.samples;
      fieldBoundaries = DEMO_DATA.fields;

      // Show demo banner
      document.getElementById('demoBanner').style.display = 'block';
      // Adjust app container for banner
      document.querySelector('.app-container').style.marginTop = '40px';

      // Update UI dropdowns
      updateFieldSelector();
      updateYearSelector();
      refreshStabilityCache(); // Pre-calculate stability data
      updateMap();
      zoomToData();

      Utils.showStatus('Demo mode - explore the app with sample data!', true);
    }

    function exitDemoMode() {
      isDemoMode = false;
      document.getElementById('demoBanner').style.display = 'none';
      document.querySelector('.app-container').style.marginTop = '0';

      // Clear demo data
      sampleData = [];
      fieldBoundaries = {};

      // Show welcome screen to connect real data
      showWelcomeScreen();
    }

    function zoomToData() {
      if (sampleData.length === 0) return;

      // Filter samples by active client/farm
      const activeFields = getActiveFields();
      const filteredSamples = sampleData.filter(s => activeFields.includes(s.field));
      if (filteredSamples.length === 0) return;

      const lats = filteredSamples.map(s => s.lat).filter(l => l);
      const lons = filteredSamples.map(s => s.lon).filter(l => l);
      if (lats.length === 0) return;
      const bounds = L.latLngBounds(
        [Math.min(...lats), Math.min(...lons)],
        [Math.max(...lats), Math.max(...lons)]
      );
      map.fitBounds(bounds, { padding: [50, 50] });
    }

    // ========== SAMPLE SITE FUNCTIONS ==========

    // Point-in-polygon detection using ray casting algorithm
    function pointInPolygon(point, polygon) {
      if (!polygon || polygon.length < 3) return false;
      const [lat, lon] = point;
      let inside = false;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const [yi, xi] = polygon[i];
        const [yj, xj] = polygon[j];
        if (((yi > lat) !== (yj > lat)) && (lon < (xj - xi) * (lat - yi) / (yj - yi) + xi)) {
          inside = !inside;
        }
      }
      return inside;
    }

    // Detect which field a point falls within
    function detectFieldFromPoint(lat, lon) {
      console.log('Detecting field for:', lat, lon);
      console.log('Fields with boundaries:', Object.keys(fieldBoundaries).length);

      for (const [fieldName, fieldData] of Object.entries(fieldBoundaries)) {
        const polys = fieldData.boundary || fieldData;
        if (!polys || !Array.isArray(polys) || polys.length === 0) {
          console.log(`Field ${fieldName} has no valid boundary`);
          continue;
        }

        // Determine polygon format:
        // - Single polygon: [[lat,lng], [lat,lng], ...] - polys[0][0] is a number (lat)
        // - Multi-polygon:  [[[lat,lng], ...], [[lat,lng], ...]] - polys[0][0] is an array [lat,lng]
        const isMultiPoly = Array.isArray(polys[0]?.[0]);
        const polyArray = isMultiPoly ? polys : [polys];

        for (const poly of polyArray) {
          if (pointInPolygon([lat, lon], poly)) {
            console.log('Detected field:', fieldName, 'farmId:', fieldData.farmId);
            return { fieldName, farmId: fieldData.farmId || '' };
          }
        }
      }
      console.log('No field detected at this location');
      return null;
    }

    // Toggle pin drop mode (desktop)
    function togglePinDropMode() {
      pinDropMode = !pinDropMode;
      const btn = document.getElementById('addSampleSiteBtn');
      const appContainer = document.querySelector('.app-container');

      if (pinDropMode) {
        btn?.classList.add('active');
        appContainer?.classList.add('pin-drop-mode');
        Utils.showStatus('Click on map to place sample site', true);
        map.on('click', handlePinDropClick);
      } else {
        btn?.classList.remove('active');
        appContainer?.classList.remove('pin-drop-mode');
        map.off('click', handlePinDropClick);
        if (tempPinMarker) {
          map.removeLayer(tempPinMarker);
          tempPinMarker = null;
        }
        pendingSiteCoords = null;
      }
    }

    // Handle map click in pin drop mode (desktop)
    function handlePinDropClick(e) {
      const { lat, lng } = e.latlng;
      placeTempMarkerAndOpenModal(lat, lng);
    }

    // Mobile: toggle pin drop mode (same as desktop now)
    function mobileSiteFromCurrentLocation() {
      togglePinDropMode();
      if (pinDropMode) {
        Utils.showStatus('Tap on map to place sample site', true);
      }
    }

    // Place temp marker and open modal
    function placeTempMarkerAndOpenModal(lat, lng) {
      if (tempPinMarker) map.removeLayer(tempPinMarker);

      const tempIcon = L.divIcon({
        html: '<div class="temp-pin-marker"></div>',
        className: '',
        iconSize: [28, 28],
        iconAnchor: [14, 14]
      });
      tempPinMarker = L.marker([lat, lng], { icon: tempIcon }).addTo(map);

      pendingSiteCoords = { lat, lng };
      const fieldInfo = detectFieldFromPoint(lat, lng);
      openSampleSiteModal(lat, lng, fieldInfo);
    }

    // Open sample site modal
    function openSampleSiteModal(lat, lng, fieldInfo) {
      const modal = document.getElementById('sampleSiteModal');

      document.getElementById('siteModalLat').textContent = lat.toFixed(6);
      document.getElementById('siteModalLng').textContent = lng.toFixed(6);

      // Populate client dropdown
      const clientSelect = document.getElementById('siteClientSelect');
      let clientHtml = '<option value="">-- Select Client --</option>';
      clientsData.forEach(c => {
        clientHtml += `<option value="${c.id}">${c.name}</option>`;
      });
      clientSelect.innerHTML = clientHtml;
      clientSelect.onchange = updateSiteFarmDropdown;

      // Clear farm dropdown
      document.getElementById('siteFarmSelect').innerHTML = '<option value="">-- Select Farm --</option>';

      // Show detected field
      const fieldDisplay = document.getElementById('siteFieldDisplay');
      if (fieldInfo) {
        fieldDisplay.textContent = fieldInfo.fieldName;
        fieldDisplay.style.color = '#16a34a';
        fieldDisplay.style.background = '#dcfce7';

        // Auto-select client/farm if we can determine from fieldInfo
        if (fieldInfo.farmId) {
          const farm = farmsData.find(f => f.id === fieldInfo.farmId);
          if (farm) {
            clientSelect.value = farm.clientId;
            updateSiteFarmDropdown();
            document.getElementById('siteFarmSelect').value = fieldInfo.farmId;
          }
        }
      } else {
        fieldDisplay.textContent = 'No field detected at this location';
        fieldDisplay.style.color = '#ef4444';
        fieldDisplay.style.background = '#fee2e2';
      }

      // Clear Site ID input and notes
      document.getElementById('siteIdInput').value = '';
      document.getElementById('siteNotesInput').value = '';

      // Clear all type checkboxes
      document.querySelectorAll('input[name="siteType"]').forEach(cb => cb.checked = false);

      // Reset GPS tracking button state
      stopLocationTracking();

      modal.style.display = 'flex';
    }

    // Update farm dropdown based on client selection
    function updateSiteFarmDropdown() {
      const clientId = document.getElementById('siteClientSelect').value;
      const farmSelect = document.getElementById('siteFarmSelect');

      let farmHtml = '<option value="">-- Select Farm --</option>';
      farmsData.filter(f => f.clientId === clientId).forEach(f => {
        farmHtml += `<option value="${f.id}">${f.name}</option>`;
      });
      farmSelect.innerHTML = farmHtml;
    }

    // Close modal
    function closeSampleSiteModal() {
      document.getElementById('sampleSiteModal').style.display = 'none';
      if (tempPinMarker) {
        map.removeLayer(tempPinMarker);
        tempPinMarker = null;
      }
      pendingSiteCoords = null;

      // Clear edit mode state and reset checkboxes
      window.editModeExistingTypes = null;
      document.querySelectorAll('input[name="siteType"]').forEach(cb => {
        cb.disabled = false;
        cb.parentElement.style.opacity = '1';
        cb.parentElement.style.background = '#f8fafc';
        cb.parentElement.title = '';
      });

      // Stop GPS tracking if active
      stopLocationTracking();

      // Exit pin drop mode on desktop
      if (pinDropMode) {
        togglePinDropMode();
      }
    }

    // Edit sample site - add more types to existing location
    function editSampleSite(lat, lng) {
      // Close popup first
      map.closePopup();

      // Find all existing sites at this location (within ~10ft tolerance)
      const tolerance = 0.0001; // ~30ft
      const existingSites = sampleSitesData.filter(s =>
        s.Active !== 'FALSE' &&
        Math.abs(s.Lat - lat) < tolerance &&
        Math.abs(s.Lng - lng) < tolerance
      );

      if (existingSites.length === 0) {
        Utils.showStatus('No sites found at this location', false);
        return;
      }

      // Use the first site for field/client/farm info
      const baseSite = existingSites[0];
      const existingTypes = existingSites.map(s => s.Type);

      // Open modal
      const modal = document.getElementById('sampleSiteModal');
      document.getElementById('siteModalLat').textContent = lat.toFixed(6);
      document.getElementById('siteModalLng').textContent = lng.toFixed(6);

      // Populate client dropdown and pre-select
      const clientSelect = document.getElementById('siteClientSelect');
      let clientHtml = '<option value="">-- Select Client --</option>';
      clientsData.forEach(c => {
        const selected = c.name === baseSite.Client ? 'selected' : '';
        clientHtml += `<option value="${c.id}" ${selected}>${c.name}</option>`;
      });
      clientSelect.innerHTML = clientHtml;
      clientSelect.onchange = updateSiteFarmDropdown;

      // Populate farm dropdown and pre-select
      updateSiteFarmDropdown();
      const matchingFarm = farmsData.find(f => f.name === baseSite.Farm);
      if (matchingFarm) {
        document.getElementById('siteFarmSelect').value = matchingFarm.id;
      }

      // Show detected field
      const fieldDisplay = document.getElementById('siteFieldDisplay');
      if (baseSite.Field) {
        fieldDisplay.textContent = baseSite.Field;
        fieldDisplay.style.color = '#16a34a';
        fieldDisplay.style.background = '#dcfce7';
      } else {
        fieldDisplay.textContent = 'No field';
        fieldDisplay.style.color = '#64748b';
        fieldDisplay.style.background = '#f1f5f9';
      }

      // Clear Site ID (will auto-generate for new types)
      document.getElementById('siteIdInput').value = '';
      document.getElementById('siteNotesInput').value = baseSite.Notes || '';

      // Set checkboxes - existing types checked (can uncheck to delete), others unchecked
      document.querySelectorAll('input[name="siteType"]').forEach(cb => {
        if (existingTypes.includes(cb.value)) {
          cb.checked = true;
          cb.disabled = false;
          cb.parentElement.style.background = '#dcfce7'; // Green tint for existing
          cb.parentElement.title = 'Uncheck to remove this type';
        } else {
          cb.checked = false;
          cb.disabled = false;
          cb.parentElement.style.background = '#f8fafc';
          cb.parentElement.title = '';
        }
      });

      // Store edit mode info
      pendingSiteCoords = { lat, lng };
      window.editModeExistingTypes = existingTypes;

      modal.style.display = 'flex';
    }

    // Toggle GPS location tracking
    function toggleLocationTracking() {
      const btn = document.getElementById('trackLocationBtn');
      const accuracyDisplay = document.getElementById('gpsAccuracyDisplay');

      if (gpsWatchId !== null) {
        // Stop tracking
        stopLocationTracking();
      } else {
        // Start tracking
        if (!navigator.geolocation) {
          Utils.showStatus('Geolocation not supported', false);
          return;
        }

        btn.textContent = '‚è≥ Getting GPS...';
        btn.style.background = '#f59e0b';

        gpsWatchId = navigator.geolocation.watchPosition(
          (pos) => {
            const lat = pos.coords.latitude;
            const lng = pos.coords.longitude;
            const accuracy = pos.coords.accuracy;

            // Update coordinates display
            document.getElementById('siteModalLat').textContent = lat.toFixed(6);
            document.getElementById('siteModalLng').textContent = lng.toFixed(6);

            // Update accuracy display
            accuracyDisplay.style.display = 'block';
            document.getElementById('gpsAccuracyValue').textContent = accuracy.toFixed(1);

            // Update pending coords
            pendingSiteCoords = { lat, lng };

            // Update or create temp marker
            if (tempPinMarker) {
              tempPinMarker.setLatLng([lat, lng]);
            } else {
              const tempIcon = L.divIcon({
                html: '<div class="temp-pin-marker"></div>',
                className: '',
                iconSize: [28, 28],
                iconAnchor: [14, 14]
              });
              tempPinMarker = L.marker([lat, lng], { icon: tempIcon }).addTo(map);
            }

            // Re-detect field at new location
            const fieldInfo = detectFieldFromPoint(lat, lng);
            const fieldDisplay = document.getElementById('siteFieldDisplay');
            if (fieldInfo) {
              fieldDisplay.textContent = fieldInfo.fieldName;
              fieldDisplay.style.color = '#16a34a';
              fieldDisplay.style.background = '#dcfce7';
            } else {
              fieldDisplay.textContent = 'No field detected at this location';
              fieldDisplay.style.color = '#ef4444';
              fieldDisplay.style.background = '#fee2e2';
            }

            // Center map on location
            map.setView([lat, lng], Math.max(map.getZoom(), 16));

            // Update button state
            btn.textContent = 'üî¥ Tracking...';
            btn.style.background = '#16a34a';
          },
          (err) => {
            Utils.showStatus('GPS error: ' + err.message, false);
            stopLocationTracking();
          },
          { enableHighAccuracy: true, timeout: 15000, maximumAge: 0 }
        );
      }
    }

    // Stop GPS tracking
    function stopLocationTracking() {
      if (gpsWatchId !== null) {
        navigator.geolocation.clearWatch(gpsWatchId);
        gpsWatchId = null;
      }
      const btn = document.getElementById('trackLocationBtn');
      if (btn) {
        btn.textContent = 'üìç Use My Location';
        btn.style.background = '#3b82f6';
      }
      const accuracyDisplay = document.getElementById('gpsAccuracyDisplay');
      if (accuracyDisplay) {
        accuracyDisplay.style.display = 'none';
      }
    }

    // Auto-generate Site ID based on current selections
    function autoGenerateSiteId() {
      // Get first selected type from checkboxes
      const selectedType = document.querySelector('input[name="siteType"]:checked');
      const typeCode = selectedType ? selectedType.value : 'TIS';
      const fieldName = document.getElementById('siteFieldDisplay').textContent;
      const siteId = generateSiteId(typeCode, fieldName);
      document.getElementById('siteIdInput').value = siteId;
    }

    // Generate Site ID at save time
    function generateSiteId(typeCode, fieldName) {
      // Generate field initials
      let fieldInitials = 'XX';
      if (fieldName && !fieldName.includes('No field')) {
        const words = fieldName.replace(/[^a-zA-Z0-9\s]/g, '').split(/\s+/).filter(w => w);
        if (words.length >= 2) {
          fieldInitials = (words[0][0] + words[1][0]).toUpperCase();
        } else if (words[0]) {
          fieldInitials = words[0].substring(0, 2).toUpperCase();
        }
      }

      // Get next sequence number
      const prefix = `${typeCode}-${fieldInitials}`;
      const existingCount = sampleSitesData.filter(s => s.SiteID && s.SiteID.startsWith(prefix)).length;
      const seqNum = String(existingCount + 1).padStart(3, '0');

      return `${prefix}-${seqNum}`;
    }

    // Save sample site(s) - supports add/remove types at same location
    async function saveSampleSite() {
      if (!pendingSiteCoords) {
        Utils.showStatus('No location selected', false);
        return;
      }

      if (!SheetsAPI.isSignedIn) {
        Utils.showStatus('Please sign in to save sample sites', false);
        return;
      }

      // Get selected types from checkboxes
      const selectedTypes = Array.from(document.querySelectorAll('input[name="siteType"]:checked')).map(cb => cb.value);
      const existingTypes = window.editModeExistingTypes || [];

      // Determine what to add and remove
      const typesToAdd = selectedTypes.filter(t => !existingTypes.includes(t));
      const typesToRemove = existingTypes.filter(t => !selectedTypes.includes(t));

      // Validate - must have at least one type selected OR be removing types
      if (selectedTypes.length === 0 && typesToRemove.length === 0) {
        Utils.showStatus('Please select at least one sample type', false);
        return;
      }

      // In edit mode with no changes
      if (existingTypes.length > 0 && typesToAdd.length === 0 && typesToRemove.length === 0) {
        Utils.showStatus('No changes made', false);
        return;
      }

      const clientId = document.getElementById('siteClientSelect').value;
      const farmId = document.getElementById('siteFarmSelect').value;
      const fieldName = document.getElementById('siteFieldDisplay').textContent;
      const notes = document.getElementById('siteNotesInput').value.trim();

      // Validate required fields (only if adding new types)
      if (typesToAdd.length > 0) {
        if (!clientId) {
          Utils.showStatus('Please select a Client', false);
          return;
        }
        if (!farmId) {
          Utils.showStatus('Please select a Farm', false);
          return;
        }
      }

      const client = clientsData.find(c => c.id === clientId);
      const farm = farmsData.find(f => f.id === farmId);

      // Get base Site ID from input (user-entered or will auto-generate per type)
      const baseSiteId = document.getElementById('siteIdInput').value.trim();

      // Stop GPS tracking before saving
      stopLocationTracking();

      try {
        document.getElementById('saveSiteBtn').textContent = 'Saving...';
        document.getElementById('saveSiteBtn').disabled = true;

        const typeNames = { 'TIS': 'Tissue', 'WAT': 'Water', 'SAP': 'Sap', 'ISS': 'In-Season Soil' };
        const messages = [];

        // Remove unchecked types (soft delete)
        if (typesToRemove.length > 0) {
          const tolerance = 0.0001;
          const sitesToRemove = sampleSitesData.filter(s =>
            s.Active !== 'FALSE' &&
            Math.abs(s.Lat - pendingSiteCoords.lat) < tolerance &&
            Math.abs(s.Lng - pendingSiteCoords.lng) < tolerance &&
            typesToRemove.includes(s.Type)
          );

          for (const site of sitesToRemove) {
            await deleteSampleSiteById(site.SiteID, true); // silent delete
          }

          const removedNames = typesToRemove.map(t => typeNames[t] || t).join(', ');
          messages.push(`Removed: ${removedNames}`);
        }

        // Add new types
        if (typesToAdd.length > 0) {
          await ensureSampleSitesTab();

          for (const typeCode of typesToAdd) {
            const siteId = baseSiteId || generateSiteId(typeCode, fieldName);

            const siteData = {
              SiteID: siteId,
              Type: typeCode,
              Client: client?.name || '',
              Farm: farm?.name || '',
              Field: fieldName.includes('No field') ? '' : fieldName,
              Lat: pendingSiteCoords.lat,
              Lng: pendingSiteCoords.lng,
              Notes: notes,
              Active: 'TRUE',
              CreatedDate: new Date().toISOString()
            };

            await appendSampleSiteToSheet(siteData);
            sampleSitesData.push(siteData);
            addSampleSiteMarker(siteData);
          }

          const addedNames = typesToAdd.map(t => typeNames[t] || t).join(', ');
          messages.push(`Added: ${addedNames}`);
        }

        closeSampleSiteModal();
        Utils.showStatus(`‚úì ${messages.join(' | ')}`, true);
      } catch (error) {
        console.error('Error saving sample site:', error);
        Utils.showStatus('Error saving: ' + error.message, false);
      } finally {
        document.getElementById('saveSiteBtn').textContent = 'Save Site';
        document.getElementById('saveSiteBtn').disabled = false;
      }
    }

    // Delete a sample site by SiteID
    async function deleteSampleSite(siteId) {
      const site = sampleSitesData.find(s => s.SiteID === siteId);
      if (!site) {
        Utils.showStatus('Site not found', false);
        return;
      }

      const typeNames = { 'TIS': 'Tissue', 'WAT': 'Water', 'SAP': 'Sap', 'ISS': 'In-Season Soil' };
      const typeName = typeNames[site.Type] || site.Type;

      if (!confirm(`Delete sample site "${siteId}"?\n\nType: ${typeName}\nField: ${site.Field || 'N/A'}\n\nThis will remove the site from the map.`)) {
        return;
      }

      // Close any open popups
      map.closePopup();

      try {
        // Update Google Sheet - set Active to FALSE (soft delete)
        if (SheetsAPI.isSignedIn) {
          const response = await gapi.client.sheets.spreadsheets.values.get({
            spreadsheetId: CONFIG.SHEET_ID,
            range: 'SampleSites!A:J'
          });

          const rows = response.result.values || [];
          const headerRow = rows[0] || [];
          const siteIdCol = headerRow.indexOf('SiteID');
          const activeCol = headerRow.indexOf('Active');

          if (siteIdCol >= 0 && activeCol >= 0) {
            // Find the row with this SiteID
            for (let i = 1; i < rows.length; i++) {
              if (rows[i][siteIdCol] === siteId) {
                // Update Active to FALSE
                const range = `SampleSites!${String.fromCharCode(65 + activeCol)}${i + 1}`;
                await gapi.client.sheets.spreadsheets.values.update({
                  spreadsheetId: CONFIG.SHEET_ID,
                  range: range,
                  valueInputOption: 'RAW',
                  resource: { values: [['FALSE']] }
                });
                break;
              }
            }
          }
        }

        // Mark as inactive in local data
        site.Active = 'FALSE';

        // Refresh markers (will filter out inactive sites)
        displaySampleSiteMarkers();

        Utils.showStatus(`‚úì Deleted site "${siteId}"`, true);
      } catch (error) {
        console.error('Error deleting sample site:', error);
        Utils.showStatus('Error deleting site: ' + error.message, false);
      }
    }

    // Silent delete for edit mode (no confirmation, no status message)
    async function deleteSampleSiteById(siteId, silent = false) {
      const site = sampleSitesData.find(s => s.SiteID === siteId);
      if (!site) return;

      try {
        if (SheetsAPI.isSignedIn) {
          const response = await gapi.client.sheets.spreadsheets.values.get({
            spreadsheetId: CONFIG.SHEET_ID,
            range: 'SampleSites!A:J'
          });

          const rows = response.result.values || [];
          const headerRow = rows[0] || [];
          const siteIdCol = headerRow.indexOf('SiteID');
          const activeCol = headerRow.indexOf('Active');

          if (siteIdCol >= 0 && activeCol >= 0) {
            for (let i = 1; i < rows.length; i++) {
              if (rows[i][siteIdCol] === siteId) {
                const range = `SampleSites!${String.fromCharCode(65 + activeCol)}${i + 1}`;
                await gapi.client.sheets.spreadsheets.values.update({
                  spreadsheetId: CONFIG.SHEET_ID,
                  range: range,
                  valueInputOption: 'RAW',
                  resource: { values: [['FALSE']] }
                });
                break;
              }
            }
          }
        }

        site.Active = 'FALSE';
        displaySampleSiteMarkers();
      } catch (error) {
        console.error('Error deleting sample site:', error);
        if (!silent) throw error;
      }
    }

    // Ensure SampleSites tab exists with headers
    async function ensureSampleSitesTab() {
      const tabName = 'SampleSites';
      try {
        await gapi.client.sheets.spreadsheets.values.get({
          spreadsheetId: CONFIG.SHEET_ID,
          range: `${tabName}!A1`
        });
        return true;
      } catch (e) {
        if (e.result?.error?.code === 400 || e.result?.error?.message?.includes('Unable to parse range')) {
          try {
            await gapi.client.sheets.spreadsheets.batchUpdate({
              spreadsheetId: CONFIG.SHEET_ID,
              resource: { requests: [{ addSheet: { properties: { title: tabName } } }] }
            });

            await gapi.client.sheets.spreadsheets.values.update({
              spreadsheetId: CONFIG.SHEET_ID,
              range: `${tabName}!A1:J1`,
              valueInputOption: 'RAW',
              resource: { values: [['SiteID', 'Type', 'Client', 'Farm', 'Field', 'Lat', 'Lng', 'Notes', 'Active', 'CreatedDate']] }
            });

            console.log('Created SampleSites tab with headers');
            return true;
          } catch (createError) {
            console.error('Failed to create SampleSites tab:', createError);
            throw createError;
          }
        }
        throw e;
      }
    }

    // Append site to sheet
    async function appendSampleSiteToSheet(siteData) {
      const row = [
        siteData.SiteID, siteData.Type, siteData.Client, siteData.Farm, siteData.Field,
        siteData.Lat, siteData.Lng, siteData.Notes, siteData.Active, siteData.CreatedDate
      ];

      await gapi.client.sheets.spreadsheets.values.append({
        spreadsheetId: CONFIG.SHEET_ID,
        range: 'SampleSites!A:J',
        valueInputOption: 'RAW',
        resource: { values: [row] }
      });
    }

    // Load sample sites from sheet
    async function loadSampleSitesFromSheet() {
      try {
        const response = await gapi.client.sheets.spreadsheets.values.get({
          spreadsheetId: CONFIG.SHEET_ID,
          range: 'SampleSites!A2:J1000'
        });

        const rows = response.result.values || [];
        sampleSitesData = rows.map(row => ({
          SiteID: row[0] || '',
          Type: row[1] || '',
          Client: row[2] || '',
          Farm: row[3] || '',
          Field: row[4] || '',
          Lat: parseFloat(row[5]) || 0,
          Lng: parseFloat(row[6]) || 0,
          Notes: row[7] || '',
          Active: row[8] || 'TRUE',
          CreatedDate: row[9] || ''
        })).filter(s => s.Lat && s.Lng);

        console.log(`Loaded ${sampleSitesData.length} sample sites`);
      } catch (e) {
        console.log('SampleSites tab not found or empty');
        sampleSitesData = [];
      }
    }

    // Add marker for a sample site
    function addSampleSiteMarker(site) {
      if (!site.Lat || !site.Lng) return;

      const typeColors = { 'TIS': '#22c55e', 'WAT': '#3b82f6', 'SAP': '#f59e0b', 'ISS': '#8b5cf6' };
      const typeEmoji = { 'TIS': 'üåø', 'WAT': 'üíß', 'SAP': 'üß™', 'ISS': 'üå±' };
      const typeNames = { 'TIS': 'Tissue', 'WAT': 'Water', 'SAP': 'Sap', 'ISS': 'In-Season Soil' };

      const color = typeColors[site.Type] || '#6b7280';
      const emoji = typeEmoji[site.Type] || 'üìç';

      const icon = L.divIcon({
        html: `<div class="sample-site-marker" style="width:28px;height:28px;background:${color};">${emoji}</div>`,
        className: '',
        iconSize: [28, 28],
        iconAnchor: [14, 14]
      });

      const marker = L.marker([site.Lat, site.Lng], { icon }).addTo(map);

      const popupContent = `
        <div style="min-width: 160px;">
          <div style="font-weight: 700; font-size: 1rem; color: #1e293b; margin-bottom: 0.5rem;">${emoji} ${site.SiteID}</div>
          <div style="font-size: 0.8125rem; color: #475569;">
            <div><strong>Type:</strong> ${typeNames[site.Type] || site.Type}</div>
            ${site.Client ? `<div><strong>Client:</strong> ${site.Client}</div>` : ''}
            ${site.Farm ? `<div><strong>Farm:</strong> ${site.Farm}</div>` : ''}
            ${site.Field ? `<div><strong>Field:</strong> ${site.Field}</div>` : ''}
            ${site.Notes ? `<div style="margin-top:0.375rem;font-style:italic;color:#64748b;">${site.Notes}</div>` : ''}
            <div style="margin-top:0.375rem;font-size:0.6875rem;color:#94a3b8;">Added: ${new Date(site.CreatedDate).toLocaleDateString()}</div>
          </div>
          <div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid #e2e8f0; display: flex; gap: 0.5rem; justify-content: center;">
            <button onclick="editSampleSite(${site.Lat}, ${site.Lng})"
              style="padding: 4px 12px; font-size: 11px; background: #dbeafe; color: #1e40af; border: 1px solid #93c5fd; border-radius: 4px; cursor: pointer;">
              ‚úèÔ∏è Edit
            </button>
            <button onclick="deleteSampleSite('${site.SiteID}')"
              style="padding: 4px 12px; font-size: 11px; background: #fee2e2; color: #991b1b; border: 1px solid #fca5a5; border-radius: 4px; cursor: pointer;">
              üóëÔ∏è Delete
            </button>
          </div>
        </div>
      `;
      marker.bindPopup(popupContent);

      // Double-click to delete
      marker.on('dblclick', (e) => {
        L.DomEvent.stopPropagation(e);
        deleteSampleSite(site.SiteID);
      });

      sampleSiteMarkers.push(marker);
    }

    // Display all sample site markers
    function displaySampleSiteMarkers() {
      sampleSiteMarkers.forEach(m => map.removeLayer(m));
      sampleSiteMarkers = [];
      sampleSitesData.filter(s => s.Active !== 'FALSE').forEach(addSampleSiteMarker);
    }

    // ========== INIT ==========
    document.addEventListener('DOMContentLoaded', async () => {
      // Run migration first to ensure data structures are up to date
      DataCore.migrateDataIfNeeded();
      loadClientsData();
      loadFarmsData();
      loadActiveSelection();

      populateAttributeDropdown(); // Populate nutrients based on visibility settings
      initMap();
      setupEventListeners();
      updateZoomIndicator(); // Initialize zoom indicator
      updateActiveOperationIndicator(); // Show active client/farm indicator

      // Force View mode on mobile (Compare is desktop-only)
      if (isMobileDevice() && compareMode) {
        compareMode = false;
      }

      // Load operation name
      const opName = localStorage.getItem('operationName');
      if (opName) {
        document.getElementById('operationSubtitle').textContent = opName;
      }

      // Initialize Sheets API (needed for create sheet button)
      try {
        await SheetsAPI.init();
        SheetsAPI.onSignInChange = handleSignInChange;
        // Update UI with current sign-in state (may have been restored from localStorage)
        handleSignInChange(SheetsAPI.isSignedIn);
      } catch (e) {
        console.warn('Google API init error:', e);
      }

      // Check if this is a new user (no sheet ID and no local data)
      if (isNewUser()) {
        console.log('New user detected - showing welcome screen');
        showWelcomeScreen();
        updateBackupFooter();
        return; // Don't try to load data yet
      }

      // Load cached data first for instant display
      loadLocalData();
      updateLastUpdated();
      updateBackupFooter();

      // If we have no Sheet ID configured, don't try to load from sheets
      if (!CONFIG.SHEET_ID) {
        console.log('No Sheet ID configured - using local data only');
        if (sampleData.length === 0) {
          // Show welcome screen if no data
          showWelcomeScreen();
        }
        return;
      }

      // Check if cache is fresh (less than 5 minutes old) AND has field boundaries
      const cacheTime = localStorage.getItem('soilDataCacheTime');
      const cacheFresh = cacheTime && (Date.now() - parseInt(cacheTime)) < 300000; // 5 minutes
      const hasFieldData = Object.keys(fieldBoundaries).length > 0;
      console.log('Cache check:', { cacheFresh, hasFieldData, fieldCount: Object.keys(fieldBoundaries).length, sampleCount: sampleData.length });

      try {
        // Try to load from Google Sheets if cache is stale OR missing field boundaries
        if (!cacheFresh || !hasFieldData) {
          if (!hasFieldData) console.log('No field boundaries in cache, loading from sheets...');
          const loaded = await loadFromSheetsPublic();
          // If Sheets failed and we have no data, try backup
          if (!loaded && sampleData.length === 0) {
            loadFromBackup();
          }
        } else {
          console.log('Using fresh cached data (cache fresh and has', Object.keys(fieldBoundaries).length, 'fields)');
          // Still restore token state for UI
          if (SheetsAPI.restoreSavedToken()) {
            handleSignInChange(true);
          }
        }
      } catch (e) {
        console.warn('Google API init error:', e);
        // If we have no data, try loading from backup
        if (sampleData.length === 0) {
          loadFromBackup();
        }
      }

      // Listen for visibility changes from settings page
      window.addEventListener('storage', (e) => {
        if (e.key === 'nutrientVisibility') {
          populateAttributeDropdown();
        }
        if (e.key === 'operationName') {
          document.getElementById('operationSubtitle').textContent = e.newValue || 'Precision Farms Field Management';
        }
      });
    });

    function initMap() {
      map = L.map('map').setView([CONFIG.DEFAULT_LAT, CONFIG.DEFAULT_LON], CONFIG.DEFAULT_ZOOM);
      const street = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '¬© OpenStreetMap', maxZoom: 19 });
      const satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: '¬© Esri', maxZoom: 19 });
      satellite.addTo(map); // Default to satellite
      L.control.layers({ "Street": street, "Satellite": satellite }).addTo(map);
      
      // Debounced map update to avoid excessive recalculations during pan/zoom
      let mapUpdateTimeout;
      const DEBOUNCE_DELAY = 250; // ms to wait after pan/zoom stops

      function debouncedMapUpdate() {
        clearTimeout(mapUpdateTimeout);
        mapUpdateTimeout = setTimeout(function() {
          updateMap();
        }, DEBOUNCE_DELAY);
      }

      // Listen for zoom changes to switch between field view and sample view
      map.on('zoomend', function() {
        updateZoomIndicator();
        debouncedMapUpdate();
      });

      // Also update on zoom start for smoother feel
      map.on('zoom', function() {
        updateZoomIndicator();
      });

      // Update on pan end (debounced)
      map.on('moveend', function() {
        // Only update visible field colors when zoomed out (field shading mode)
        const zoomLevel = map.getZoom();
        const isZoomedOut = zoomLevel < ZOOM_THRESHOLD && selectedField === 'all';
        if (isZoomedOut && !compareMode && selectedAttribute !== 'sampleId') {
          debouncedMapUpdate();
        }
      });
      
      // Add "Center on Me" button for mobile
      const centerControl = L.control({ position: 'topleft' });
      centerControl.onAdd = function() {
        const div = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
        div.innerHTML = '<a href="#" title="Center on my location" style="display:flex;align-items:center;justify-content:center;width:34px;height:34px;background:white;font-size:18px;">‚äï</a>';
        div.onclick = function(e) {
          e.preventDefault();
          e.stopPropagation();
          centerOnMe();
          return false;
        };
        return div;
      };
      centerControl.addTo(map);
    }
    
    function centerOnMe() {
      if (!navigator.geolocation) {
        Utils.showStatus('Geolocation not supported', false);
        return;
      }
      Utils.showStatus('Getting your location...', true);
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          const { latitude, longitude, accuracy } = pos.coords;
          map.setView([latitude, longitude], 16);
          
          // Update or create GPS marker
          if (gpsMarker) {
            gpsMarker.setLatLng([latitude, longitude]);
            gpsCircle.setLatLng([latitude, longitude]).setRadius(accuracy);
          } else {
            const gpsIcon = L.divIcon({
              html: '<div class="gps-marker"><div class="gps-pulse"></div><div class="gps-dot"></div></div>',
              className: '',
              iconSize: [22, 22],
              iconAnchor: [11, 11]
            });
            gpsMarker = L.marker([latitude, longitude], { icon: gpsIcon }).addTo(map);
            gpsCircle = L.circle([latitude, longitude], {
              radius: accuracy, color: '#3b82f6', fillColor: '#3b82f6', fillOpacity: 0.1, weight: 2, dashArray: '4'
            }).addTo(map);
          }
          Utils.showStatus('Centered on your location', true);
        },
        (err) => {
          Utils.showStatus('Could not get location: ' + err.message, false);
        },
        { enableHighAccuracy: true, timeout: 10000 }
      );
    }

    function setupEventListeners() {
      document.getElementById('fieldSelect').addEventListener('change', (e) => {
        selectedField = e.target.value;
        updateYearSelector(); // Update years based on selected field

        // If in compare mode, update compare year options for new field
        if (compareMode) {
          console.log('Field changed while in compare mode - updating compare years');
          updateCompareYearOptions();
          updateCompareSummary();
        }

        updateMap();
        zoomToField(selectedField);
        updateMobileFieldViewUI(); // Update mobile UI when field changes
      });
      document.getElementById('attributeSelect').addEventListener('change', (e) => {
        selectedAttribute = e.target.value;
        updateYearSelector();
        updateCompareYearOptions();
        updateMap();
        updateLegend();
        // Hide year dropdown for stability attributes (stability uses all years)
        const viewYearGroup = document.getElementById('viewYearGroup');
        if (isStabilityAttribute(selectedAttribute)) {
          viewYearGroup.style.display = 'none';
        } else if (!compareMode) {
          viewYearGroup.style.display = 'block';
        }
      });
      document.getElementById('yearSelect').addEventListener('change', (e) => {
        selectedYear = e.target.value;
        console.log('Year changed to:', selectedYear);
        updateCompareYearOptions();
        updateMap();
      });
      document.getElementById('compareYearSelect').addEventListener('change', (e) => { compareYear = e.target.value; updateCompareSummary(); updateMap(); });
      document.getElementById('compareToYearSelect').addEventListener('change', (e) => { selectedYear = e.target.value; updateCompareSummary(); updateMap(); });
      document.getElementById('singleYearBtn').addEventListener('click', () => {
        compareMode = false;
        document.getElementById('singleYearBtn').classList.add('active');
        document.getElementById('compareYearsBtn').classList.remove('active');
        document.getElementById('compareYearStack').style.display = 'none';
        // Show year dropdown only if not in stability mode
        document.getElementById('viewYearGroup').style.display = isStabilityAttribute(selectedAttribute) ? 'none' : 'block';
        document.getElementById('compareInfoBar').style.display = 'none';
        // Sync selectedYear with the View mode dropdown
        selectedYear = document.getElementById('yearSelect').value;
        updateLegend();
        updateMap();
      });
      document.getElementById('compareYearsBtn').addEventListener('click', () => {
        // Compare mode is desktop-only
        if (isMobileDevice()) {
          Utils.showStatus('Compare mode is available on desktop', false);
          return;
        }
        compareMode = true;
        document.getElementById('compareYearsBtn').classList.add('active');
        document.getElementById('singleYearBtn').classList.remove('active');
        document.getElementById('compareYearStack').style.display = 'block';
        document.getElementById('viewYearGroup').style.display = 'none';
        document.getElementById('compareInfoBar').style.display = 'block';
        updateCompareYearOptions();
        updateCompareSummary();
        updateLegend();
        updateMap();
      });
      document.getElementById('fieldModeBtn').addEventListener('click', toggleFieldMode);
      document.getElementById('refreshBtn').addEventListener('click', () => {
        // Reload data from localStorage (in case it was changed on another page)
        sampleData = [];
        fieldBoundaries = {};
        loadLocalData();
        Utils.showStatus('Data refreshed', true);
      });

      // Sample site buttons
      document.getElementById('addSampleSiteBtn').addEventListener('click', togglePinDropMode);
      document.getElementById('mobileSampleSiteBtn').addEventListener('click', mobileSiteFromCurrentLocation);

      // Mobile toolbar buttons
      document.getElementById('mobileFieldModeBtn').addEventListener('click', toggleFieldMode);
      document.getElementById('mobileRefreshBtn').addEventListener('click', () => {
        sampleData = [];
        fieldBoundaries = {};
        loadLocalData();
        Utils.showStatus('Data refreshed', true);
      });
      document.getElementById('mobileCompareBtn').addEventListener('click', toggleMobileCompare);

      // Force View mode when window resizes to mobile
      window.addEventListener('resize', () => {
        if (isMobileDevice() && compareMode) {
          exitCompareMode();
        }
      });
    }

    // Exit compare mode and switch to View mode
    function exitCompareMode() {
      compareMode = false;
      document.getElementById('singleYearBtn').classList.add('active');
      document.getElementById('compareYearsBtn').classList.remove('active');
      document.getElementById('compareYearStack').style.display = 'none';
      // Show year dropdown only if not in stability mode
      document.getElementById('viewYearGroup').style.display = isStabilityAttribute(selectedAttribute) ? 'none' : 'block';
      document.getElementById('compareInfoBar').style.display = 'none';
      compareYear = '';
      const mobileBtn = document.getElementById('mobileCompareBtn');
      if (mobileBtn) {
        mobileBtn.textContent = 'üìä Compare';
        mobileBtn.classList.remove('active');
      }
      updateLegend();
      updateMap();
    }
    
    function toggleMobileCompare() {
      // Compare mode is desktop-only - this function shouldn't be called on mobile
      // but CSS hides the button anyway. This is a safety net.
      if (isMobileDevice()) {
        Utils.showStatus('Compare mode is available on desktop', false);
        return;
      }

      const btn = document.getElementById('mobileCompareBtn');
      compareMode = !compareMode;

      if (compareMode) {
        btn.textContent = 'üìä Compare ON';
        btn.classList.add('active');
        document.getElementById('compareYearsBtn').classList.add('active');
        document.getElementById('singleYearBtn').classList.remove('active');
        document.getElementById('compareYearStack').style.display = 'block';
        document.getElementById('viewYearGroup').style.display = 'none';
        document.getElementById('compareInfoBar').style.display = 'block';
        updateCompareYearOptions();
        updateCompareSummary();
      } else {
        btn.textContent = 'üìä Compare';
        btn.classList.remove('active');
        document.getElementById('singleYearBtn').classList.add('active');
        document.getElementById('compareYearsBtn').classList.remove('active');
        document.getElementById('compareYearStack').style.display = 'none';
        // Show year dropdown only if not in stability mode
        document.getElementById('viewYearGroup').style.display = isStabilityAttribute(selectedAttribute) ? 'none' : 'block';
        document.getElementById('compareInfoBar').style.display = 'none';
        compareYear = '';
      }
      updateLegend();
      updateMap();
    }

    function updateCompareSummary() {
      const baselineYear = document.getElementById('compareYearSelect').value;
      const compareToYear = document.getElementById('compareToYearSelect').value;
      const summaryEl = document.getElementById('compareSummaryText');

      if (baselineYear && compareToYear) {
        summaryEl.innerHTML = `Showing change from <strong>${baselineYear}</strong> ‚Üí <strong>${compareToYear}</strong>`;
        summaryEl.style.color = '#166534';
      } else if (baselineYear || compareToYear) {
        summaryEl.textContent = 'Select both years to compare';
        summaryEl.style.color = '#d97706';
      } else {
        summaryEl.textContent = 'Select years to compare';
        summaryEl.style.color = '#1e40af';
      }
    }

    function updateCompareYearOptions() {
      const baselineSel = document.getElementById('compareYearSelect');
      const compareToSel = document.getElementById('compareToYearSelect');

      // Filter samples by field and attribute
      let filteredSamples = selectedField === 'all'
        ? sampleData
        : sampleData.filter(s => s.field === selectedField);

      // Only include years that have data for the selected attribute
      filteredSamples = filteredSamples.filter(s => {
        const v = s[selectedAttribute];
        return v !== undefined && v !== null && (selectedAttribute === 'sampleId' || !isNaN(v));
      });

      const years = Utils.getUniqueYears(filteredSamples);

      // Populate baseline dropdown (older years first)
      baselineSel.innerHTML = '<option value="">Select...</option>';
      years.forEach(y => {
        const o = document.createElement('option');
        o.value = y; o.textContent = y;
        baselineSel.appendChild(o);
      });

      // Populate compare-to dropdown (newer years first, reversed)
      compareToSel.innerHTML = '<option value="">Select...</option>';
      [...years].reverse().forEach(y => {
        const o = document.createElement('option');
        o.value = y; o.textContent = y;
        compareToSel.appendChild(o);
      });

      // Auto-select: baseline = oldest year, compare-to = newest year
      // Only auto-set selectedYear when in Compare mode (not View mode)
      if (years.length >= 2) {
        baselineSel.value = years[0]; // Oldest
        compareYear = years[0];
        compareToSel.value = years[years.length - 1]; // Newest
        if (compareMode) {
          selectedYear = years[years.length - 1];
        }
      } else if (years.length === 1) {
        baselineSel.value = years[0];
        compareYear = years[0];
      }
    }
    
    function updateLegend() {
      const legendText = document.getElementById('legendText');
      if (compareMode) {
        legendText.textContent = 'Decrease ‚Üê ‚Üí Increase';
        document.querySelector('#legendBar div').style.background = 'linear-gradient(to right, #b91c1c, #f87171, #d1d5db, #86efac, #15803d)';
      } else {
        legendText.textContent = 'Low ‚Üí High';
        document.querySelector('#legendBar div').style.background = 'linear-gradient(to right, #dc2626, #f97316, #eab308, #84cc16, #16a34a)';
      }
    }
    
    function updateStats(values, mode = 'sample') {
      const statsTitle = document.getElementById('statsTitle');
      const statsAvg = document.getElementById('statsAvg');
      const statsHigh = document.getElementById('statsHigh');
      const statsLow = document.getElementById('statsLow');
      const statsNote = document.getElementById('statsNote');

      const attrName = CONFIG.NUTRIENT_NAMES[selectedAttribute] || selectedAttribute;
      const unit = CONFIG.NUTRIENT_UNITS[selectedAttribute] || '';
      statsTitle.textContent = attrName;

      // Update note based on mode
      if (mode === 'stability') {
        statsNote.textContent = 'CV% (lower = more stable)';
      } else if (mode === 'field') {
        statsNote.textContent = 'Based on field averages';
      } else {
        statsNote.textContent = 'Based on sample points';
      }

      if (!values || values.length === 0) {
        statsAvg.textContent = '-';
        statsHigh.textContent = '-';
        statsLow.textContent = '-';
        return;
      }

      const avg = values.reduce((a, b) => a + b, 0) / values.length;
      const high = Math.max(...values);
      const low = Math.min(...values);
      const decimals = Utils.getDecimals(selectedAttribute);

      statsAvg.textContent = avg.toFixed(decimals) + (unit ? ' ' + unit : '');
      statsHigh.textContent = high.toFixed(decimals) + (unit ? ' ' + unit : '');
      statsLow.textContent = low.toFixed(decimals) + (unit ? ' ' + unit : '');

      // For stability mode, flip colors (low is good/green, high is bad/red)
      if (mode === 'stability') {
        statsHigh.style.color = '#ef4444'; // red for high (bad)
        statsLow.style.color = '#22c55e';  // green for low (good)
      } else {
        statsHigh.style.color = '#22c55e'; // green for high (default)
        statsLow.style.color = '#ef4444';  // red for low (default)
      }
    }

    async function handleAuth() {
      if (SheetsAPI.isSignedIn) await SheetsAPI.signOut();
      else await SheetsAPI.signIn();
    }

    function handleSignInChange(isSignedIn) {
      const authBtn = document.getElementById('authBtn');
      const userInfo = document.getElementById('userInfo');
      if (isSignedIn) {
        userInfo.textContent = 'Connected';
        authBtn.textContent = '‚úì Signed In';
        authBtn.classList.add('signed-in');
        // Only reload if user explicitly signed in (not on initial load with saved token)
        // The initial load already happened via loadFromSheetsPublic
      } else {
        userInfo.textContent = '';
        authBtn.textContent = 'Sign In to Edit';
        authBtn.classList.remove('signed-in');
      }
      updateMobileAuthBtn();
    }

    function updateMobileAuthBtn() {
      // Mobile toolbar doesn't have a dedicated auth button
      // The refresh button can be used to sync when signed in
    }

    // Load data using API key only (public access) - no OAuth required
    async function loadFromSheetsPublic() {
      Utils.showStatus('Loading data...', true);
      isLoadingFromSheets = true; // Prevent updateMap during load

      try {
        console.log('Attempting public load from sheet ID:', CONFIG.SHEET_ID);
        const fields = await SheetsAPI.getFields();
        // Build new boundaries object before replacing (avoid race condition)
        // Store full field data including farmId for auto-fill in sample site modal
        const newBoundaries = {};
        fields.forEach(f => {
          if (f.boundary) {
            newBoundaries[f.name] = {
              boundary: f.boundary,
              farmId: f.farmId || '',
              acres: f.acres || 0
            };
          }
        });
        console.log('Built fieldBoundaries with', Object.keys(newBoundaries).length, 'fields');
        fieldBoundaries = newBoundaries;
        sampleData = await SheetsAPI.getSamples();
        settings = await SheetsAPI.getSettings();
        updateFieldSelector();
        updateYearSelector();
        refreshStabilityCache(); // Pre-calculate stability data

        // Re-enable updateMap BEFORE calling it
        isLoadingFromSheets = false;
        updateMap();
        saveLocalData();

        // Load sample sites (may not exist yet, so wrapped in try/catch)
        try {
          await loadSampleSitesFromSheet();
          displaySampleSiteMarkers();
        } catch (e) { console.log('Sample sites not loaded:', e); }

        Utils.showStatus(`Loaded ${sampleData.length} samples, ${Object.keys(fieldBoundaries).length} fields`, true);

        // Restore saved OAuth token for edit capabilities (if available)
        if (SheetsAPI.restoreSavedToken()) {
          handleSignInChange(true);
        }
        return true;
      } catch (e) {
        isLoadingFromSheets = false; // Re-enable updateMap on error
        console.log('Public access failed:', e?.result?.error?.code || e.message);
        const errorCode = e.result?.error?.code;

        // 403 = sheet is not public, need to sign in
        if (errorCode === 403) {
          console.log('Sheet is not public, checking for saved OAuth token...');
          // Try with saved OAuth token if available
          if (SheetsAPI.restoreSavedToken()) {
            handleSignInChange(true);
            return loadFromSheets();
          }
          Utils.showStatus('Sign in required to access this sheet', false);
          return false;
        }

        // 404 = sheet not found
        if (errorCode === 404) {
          Utils.showStatus('Google Sheet not found - check Sheet ID in Settings', false);
          return false;
        }

        // Other errors - use cached data
        Utils.showStatus('Could not connect to Google Sheets', false);
        return false;
      }
    }

    async function loadFromSheets(isRetry = false) {
      Utils.showStatus('Loading from Google Sheets...', true);
      isLoadingFromSheets = true; // Prevent updateMap during load

      const doLoad = async () => {
        console.log('Attempting to load from sheet ID:', CONFIG.SHEET_ID);
        const fields = await SheetsAPI.getFields();
        // Build new boundaries object before replacing (avoid race condition)
        // Store full field data including farmId for auto-fill in sample site modal
        const newBoundaries = {};
        fields.forEach(f => {
          if (f.boundary) {
            newBoundaries[f.name] = {
              boundary: f.boundary,
              farmId: f.farmId || '',
              acres: f.acres || 0
            };
          }
        });
        console.log('Built fieldBoundaries with', Object.keys(newBoundaries).length, 'fields');
        fieldBoundaries = newBoundaries;
        sampleData = await SheetsAPI.getSamples();
        settings = await SheetsAPI.getSettings();
        updateFieldSelector();
        updateYearSelector();
        refreshStabilityCache(); // Pre-calculate stability data

        // Re-enable updateMap BEFORE calling it
        isLoadingFromSheets = false;
        updateMap();
        saveLocalData();

        // Load sample sites
        try {
          await loadSampleSitesFromSheet();
          displaySampleSiteMarkers();
        } catch (e) { console.log('Sample sites not loaded:', e); }

        Utils.showStatus(`‚úì Loaded ${sampleData.length} samples, ${Object.keys(fieldBoundaries).length} fields`, true);
      };

      try {
        await doLoad();
      } catch (e) {
        isLoadingFromSheets = false; // Re-enable updateMap on error
        console.error('loadFromSheets error:', e);
        const errorCode = e.result?.error?.code;
        const errorMsg = e.result?.error?.message || e.message || 'Unknown error';

        // Handle 401 (unauthorized) - token may be expired/revoked
        if (errorCode === 401 && !isRetry) {
          console.log('Got 401, attempting token refresh and retry...');
          Utils.showStatus('Refreshing authentication...', true);
          try {
            await SheetsAPI.refreshTokenAndRetry(doLoad);
            Utils.showStatus(`‚úì Loaded ${sampleData.length} samples, ${Object.keys(fieldBoundaries).length} fields`, true);
            return;
          } catch (retryError) {
            console.error('Retry after refresh failed:', retryError);
            // Clear invalid token and fall through to error handling
            localStorage.removeItem('googleAccessToken');
            localStorage.removeItem('googleTokenExpiry');
            SheetsAPI.isSignedIn = false;
            handleSignInChange(false);
            Utils.showStatus('Session expired - please sign in again', false);
            loadLocalData();
            return;
          }
        }

        // Handle 403 (forbidden) - no access to sheet
        if (errorCode === 403) {
          Utils.showStatus('No access to this Google Sheet - check sharing settings', false);
          loadLocalData();
          return;
        }

        // Handle 404 (not found) - sheet doesn't exist
        if (errorCode === 404) {
          Utils.showStatus('Google Sheet not found - check Sheet ID in Settings', false);
          loadLocalData();
          return;
        }

        // Generic error
        Utils.showStatus(`Error loading from Sheets: ${errorMsg} - using local cache`, false);
        loadLocalData();
      }
    }

    async function loadData() {
      if (SheetsAPI.isSignedIn) {
        await loadFromSheets();
      } else {
        loadLocalData();
      }
    }

    // IndexedDB functions from DataCore
    const openDB = DataCore.openDB;
    const loadFromIndexedDB = DataCore.loadFromIndexedDB;

    async function loadLocalData() {
      try {
        // Check IndexedDB first if flagged
        if (localStorage.getItem('usingIndexedDB') === 'true') {
          const idbData = await loadFromIndexedDB();
          if (idbData) {
            // Load samples and boundaries independently
            if (idbData.samples && idbData.samples.length > 0) {
              sampleData = idbData.samples;
            }
            if (idbData.boundaries && Object.keys(idbData.boundaries).length > 0) {
              fieldBoundaries = idbData.boundaries;
            }
            console.log('Loaded from IndexedDB:', sampleData.length, 'samples,', Object.keys(fieldBoundaries).length, 'fields');
          }
        } else {
          // Fallback to localStorage
          const s = localStorage.getItem('soilSamples');
          const b = localStorage.getItem('fieldBoundaries');
          if (s) sampleData = JSON.parse(s);
          if (b) fieldBoundaries = JSON.parse(b);
        }

        // Calculate P_Zn_Ratio on-the-fly for samples that have P and Zn
        sampleData.forEach(s => {
          if (s.P !== undefined && s.Zn !== undefined && s.Zn > 0) {
            s.P_Zn_Ratio = s.P / s.Zn;
          }
        });

        // Load settings (always in localStorage)
        const st = localStorage.getItem('soilSettings');
        if (st) {
          const rawSettings = JSON.parse(st);
          settings = {
            pH: { min: rawSettings.pH_min || 6.3, max: rawSettings.pH_max || 6.9 },
            P: { min: rawSettings.P_min || 20, max: null },
            K: { min: rawSettings.K_min || 150, max: null },
            OM: { min: rawSettings.OM_min || 3.0, max: null },
            Ca_sat: { min: rawSettings.Ca_sat_min || 65, max: rawSettings.Ca_sat_max || 75 },
            Mg_sat: { min: rawSettings.Mg_sat_min || null, max: rawSettings.Mg_sat_max || 15 },
            K_Sat: { min: rawSettings.K_sat_min || 3.0, max: null },
            H_Sat: { min: null, max: rawSettings.H_sat_max || 5.0 },
            bufferPercent: rawSettings.bufferPercent || 25
          };
        }
        updateFieldSelector();
        updateYearSelector();
        refreshStabilityCache(); // Pre-calculate stability data
        updateMap();
        if (sampleData.length > 0) Utils.showStatus(`Loaded ${sampleData.length} samples`, true);
      } catch (e) { console.error(e); }
    }

    function saveLocalData() {
      try {
        // Always save settings (small)
        localStorage.setItem('soilSettings', JSON.stringify(settings));
        localStorage.setItem('soilDataCacheTime', Date.now().toString());

        // Only save samples/boundaries to localStorage if small enough
        // Large datasets use IndexedDB as primary storage
        const samplesJson = JSON.stringify(sampleData);
        const boundariesJson = JSON.stringify(fieldBoundaries);

        // Skip localStorage for large datasets (> 4MB) - IndexedDB handles these
        if (samplesJson.length < 4000000) {
          localStorage.setItem('soilSamples', samplesJson);
        }
        if (boundariesJson.length < 1000000) {
          localStorage.setItem('fieldBoundaries', boundariesJson);
        }

        updateLastUpdated();
      } catch (e) {
        // Quota exceeded - that's OK, IndexedDB is the primary storage
        console.log('localStorage quota exceeded, using IndexedDB only');
      }
    }

    function updateLastUpdated() {
      const cacheTime = localStorage.getItem('soilDataCacheTime');
      const el = document.getElementById('lastUpdated');
      if (cacheTime && el) {
        const date = new Date(parseInt(cacheTime));
        const now = new Date();
        const isToday = date.toDateString() === now.toDateString();
        if (isToday) {
          el.textContent = `Updated ${date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' })}`;
        } else {
          el.textContent = `Updated ${date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}`;
        }
      }
    }

    // Load from localStorage backup if primary data fails
    function loadFromBackup() {
      try {
        const backup = localStorage.getItem('soilDataBackup');
        if (!backup) return false;

        const data = JSON.parse(backup);
        if (data.sampleData) sampleData = data.sampleData;
        if (data.fieldBoundaries) fieldBoundaries = data.fieldBoundaries;
        if (data.settings) settings = data.settings;

        updateFieldSelector();
        updateYearSelector();
        refreshStabilityCache(); // Pre-calculate stability data
        updateMap();
        Utils.showStatus(`Loaded ${sampleData.length} samples from backup`, true);
        return true;
      } catch (e) {
        console.error('Failed to load from backup:', e);
        return false;
      }
    }

    function updateFieldSelector() {
      const sel = document.getElementById('fieldSelect');
      const val = sel.value;
      sel.innerHTML = '<option value="all">All Fields</option>';

      // Get all unique fields from samples and boundaries
      let allFields = [...new Set([...Utils.getUniqueFields(sampleData), ...Object.keys(fieldBoundaries)])];

      // Filter by active client/farm selection
      const activeFields = getActiveFields();
      const fields = allFields.filter(f => activeFields.includes(f)).sort((a,b) => a.localeCompare(b, undefined, {numeric:true}));

      fields.forEach(f => { const o = document.createElement('option'); o.value = f; o.textContent = f; sel.appendChild(o); });
      if (fields.includes(val)) sel.value = val;
      else if (val !== 'all') { selectedField = 'all'; sel.value = 'all'; }
    }

    function updateYearSelector() {
      const sel = document.getElementById('yearSelect');
      const val = sel.value;

      // Filter samples by selected field if one is selected
      let filteredSamples = selectedField === 'all'
        ? sampleData
        : sampleData.filter(s => s.field === selectedField);

      // Only include years that have data for the selected attribute
      filteredSamples = filteredSamples.filter(s => {
        const v = s[selectedAttribute];
        return v !== undefined && v !== null && (selectedAttribute === 'sampleId' || !isNaN(v));
      });

      const years = Utils.getUniqueYears(filteredSamples);

      // When "All Fields" selected: show "Most Recent" (per field) instead of "All Years"
      // When specific field selected: show "All Years" for detailed analysis
      if (selectedField === 'all') {
        sel.innerHTML = '<option value="all">Most Recent</option>';
      } else {
        sel.innerHTML = '<option value="all">All Years</option>';
      }

      years.forEach(y => { const o = document.createElement('option'); o.value = y; o.textContent = y; sel.appendChild(o); });

      // Determine which year to select
      if (selectedField === 'all') {
        // All Fields: default to "Most Recent" (shows each field's latest year)
        if (val === 'all' || !years.includes(parseInt(val))) {
          sel.value = 'all';
          selectedYear = 'all';
        } else {
          sel.value = val;
        }
      } else {
        // Specific field: keep previous selection if valid, otherwise 'all'
        if (years.includes(parseInt(val))) {
          sel.value = val;
        } else {
          sel.value = 'all';
          selectedYear = 'all';
        }
      }
    }

    const ZOOM_THRESHOLD = 15; // Zoom level threshold for switching views

    // Threshold for mobile Field View detection
    const MOBILE_FIELD_VIEW_ZOOM = 14;

    // Detect if we're in "Field View" mode on mobile (zoomed in or single field selected)
    function isMobileFieldViewMode() {
      if (!isMobileDevice()) return false;
      const zoomLevel = map.getZoom();
      // Field View = zoomed in past threshold OR viewing a single field
      return zoomLevel > MOBILE_FIELD_VIEW_ZOOM || selectedField !== 'all';
    }

    // Update mobile UI based on Field View vs All Fields View
    function updateMobileFieldViewUI() {
      if (!isMobileDevice()) return;

      const isFieldView = isMobileFieldViewMode();
      const statsBox = document.getElementById('statsBox');
      const navLinks = document.querySelector('.nav-links');
      const backBtn = document.getElementById('backToMenuBtn');

      if (isFieldView) {
        // Hide stats box and nav tabs in Field View
        statsBox.classList.add('field-view-hidden');
        navLinks.classList.add('field-view-hidden');
        backBtn.classList.add('visible');
      } else {
        // Show stats box and nav tabs in All Fields View
        statsBox.classList.remove('field-view-hidden');
        navLinks.classList.remove('field-view-hidden');
        backBtn.classList.remove('visible');
      }
    }

    // Show nav tabs when back button is clicked
    function showNavTabs() {
      const navLinks = document.querySelector('.nav-links');
      const backBtn = document.getElementById('backToMenuBtn');
      navLinks.classList.remove('field-view-hidden');
      backBtn.classList.remove('visible');
    }

    function updateZoomIndicator() {
      const zoomLevel = map.getZoom();
      const isZoomedOut = zoomLevel < ZOOM_THRESHOLD && selectedField === 'all';

      document.getElementById('zoomLevel').textContent = Math.round(zoomLevel);
      const viewModeEl = document.getElementById('viewMode');

      if (isZoomedOut && Object.keys(fieldBoundaries).length > 0 && selectedAttribute !== 'sampleId') {
        viewModeEl.textContent = 'Field View';
        viewModeEl.style.color = '#22c55e';
      } else {
        viewModeEl.textContent = 'Sample View';
        viewModeEl.style.color = '#3b82f6';
      }

      // Update mobile UI based on view mode
      updateMobileFieldViewUI();
    }

    function updateMap() {
      // Skip update if we're in the middle of loading from sheets (avoid race condition)
      if (isLoadingFromSheets) {
        console.log('updateMap skipped - loading from sheets in progress');
        return;
      }

      console.log('updateMap called - selectedYear:', selectedYear, 'selectedField:', selectedField, 'selectedAttribute:', selectedAttribute);
      console.log('Compare state - compareMode:', compareMode, 'compareYear:', compareYear);

      // Close any open popups before clearing layers
      map.closePopup();

      currentLayers.forEach(l => map.removeLayer(l));
      currentLayers = [];

      const zoomLevel = map.getZoom();
      const isZoomedOut = zoomLevel < ZOOM_THRESHOLD && selectedField === 'all'; // Only use field view when "All Fields" selected

      // Stability mode - show CV values
      if (isStabilityAttribute(selectedAttribute)) {
        if (isZoomedOut && Object.keys(fieldBoundaries).length > 0) {
          console.log('Rendering: Stability field shading (zoomed out)');
          drawStabilityFieldShading();
        } else {
          console.log('Rendering: Stability markers (zoomed in)');
          drawBoundaries(false);
          drawStabilityMarkers();
        }
        updateStabilityLegend();
        updateZoomIndicator();
        return;
      }

      // Compare mode - show year-over-year change (always show samples)
      if (compareMode && selectedYear !== 'all' && compareYear) {
        console.log('Rendering: Compare mode - baseline:', compareYear, 'compare to:', selectedYear);
        drawBoundaries(false);
        renderCompareMode();
        return;
      }

      // Zoomed out with All Fields: show field-level shading
      if (isZoomedOut && Object.keys(fieldBoundaries).length > 0 && selectedAttribute !== 'sampleId') {
        console.log('Rendering: Field shading (zoomed out)');
        drawFieldShading();
        updateZoomIndicator();
        return;
      }

      // Zoomed in or specific field: show individual samples
      console.log('Rendering: Sample markers');
      drawBoundaries(false);
      drawSampleMarkers();
      updateZoomIndicator();
    }
    
    function drawBoundaries(withShading, fieldColors = {}) {
      // Filter by active client/farm
      const activeFields = getActiveFields();

      Object.entries(fieldBoundaries).forEach(([name, fieldData]) => {
        if (selectedField !== 'all' && selectedField !== name) return;
        if (!activeFields.includes(name)) return; // Skip fields not in active selection

        // Get boundary coordinates (handles both legacy and new format)
        const polys = getFieldBoundaryCoords(name);
        if (!polys) return;

        const arr = Array.isArray(polys[0]?.[0]) ? polys : [polys];
        arr.forEach((coords, idx) => {
          const color = fieldColors[name] || '#22c55e';
          const hasNoData = fieldColors[name + '_nodata'] === true;
          const fillOpacity = withShading ? (hasNoData ? 0.3 : 0.6) : 0.1;
          const poly = L.polygon(coords, {
            color: withShading ? color : '#22c55e',
            weight: withShading ? 2 : 3,
            fillOpacity: fillOpacity,
            fillColor: color
          }).addTo(map);

          if (withShading && fieldColors[name]) {
            const fieldStats = fieldColors[name + '_stats'];
            let tooltipContent;
            if (hasNoData) {
              tooltipContent = `<strong>${name}</strong><br><em style="color: #9ca3af;">No data for ${CONFIG.NUTRIENT_NAMES[selectedAttribute] || selectedAttribute}</em>`;
            } else if (fieldStats) {
              tooltipContent = `<strong>${name}</strong><br>Avg ${CONFIG.NUTRIENT_NAMES[selectedAttribute] || selectedAttribute}: ${Utils.formatValue(fieldStats.avg, selectedAttribute)} ${CONFIG.NUTRIENT_UNITS[selectedAttribute] || ''}`;
            } else {
              tooltipContent = name;
            }
            poly.bindTooltip(tooltipContent, { permanent: false, direction: 'center', className: 'field-tooltip' });

            // Add permanent field name label in center (only on first polygon of multi-polygon)
            // Hide labels when zoomed out past level 14 to avoid cluttering the map
            if (idx === 0 && map.getZoom() >= 14) {
              const center = poly.getBounds().getCenter();
              const label = L.marker(center, {
                icon: L.divIcon({
                  className: 'field-label',
                  html: `<div style="background: rgba(255,255,255,0.9); padding: 3px 8px; border-radius: 4px; font-size: 12px; font-weight: 600; color: #1e293b; white-space: nowrap; box-shadow: 0 1px 3px rgba(0,0,0,0.2); border: 1px solid ${color};">${name}</div>`,
                  iconSize: null,
                  iconAnchor: [0, 0]
                }),
                interactive: false
              }).addTo(map);
              currentLayers.push(label);
            }
          } else {
            poly.bindTooltip(name, { permanent: false, direction: 'center' });
          }
          currentLayers.push(poly);
        });
      });
    }
    
    // Helper: check if a field is visible in the current map bounds
    function isFieldVisible(fieldName) {
      const polys = getFieldBoundaryCoords(fieldName);
      if (!polys) return false;
      const mapBounds = map.getBounds();
      const arr = Array.isArray(polys[0]?.[0]) ? polys : [polys];
      // Check if any polygon of the field intersects with map bounds
      for (const coords of arr) {
        for (const [lat, lon] of coords) {
          if (mapBounds.contains([lat, lon])) return true;
        }
      }
      return false;
    }

    // Update legend with visible range
    function updateLegendRange(minVal, maxVal, unit) {
      const legendRange = document.getElementById('legendRange');
      if (legendRange && minVal !== null && maxVal !== null) {
        const formatVal = (v) => Number.isInteger(v) ? v : v.toFixed(1);
        legendRange.textContent = `(${formatVal(minVal)} - ${formatVal(maxVal)}${unit ? ' ' + unit : ''})`;
      } else if (legendRange) {
        legendRange.textContent = '';
      }
    }

    function drawFieldShading() {
      const settings = Utils.loadSettings();
      const bufferPct = settings.bufferPercent || 25;

      // Calculate average for each field
      const fieldAverages = {};
      const fieldColors = {};
      const fieldsWithNoData = [];

      // Get all values for context (for relative coloring)
      let allFieldAvgs = [];

      // Filter by active client/farm
      const activeFields = getActiveFields();

      Object.keys(fieldBoundaries).forEach(fieldName => {
        if (selectedField !== 'all' && selectedField !== fieldName) return;
        if (!activeFields.includes(fieldName)) return; // Skip fields not in active selection

        let fieldSamples = sampleData.filter(s => s.field === fieldName);
        if (selectedYear !== 'all') {
          fieldSamples = fieldSamples.filter(s => String(s.year) === String(selectedYear));
        } else {
          // "All" selected - use only the most recent year for this field
          const years = [...new Set(fieldSamples.map(s => s.year).filter(y => y))].sort((a, b) => b - a);
          if (years.length > 0) {
            const mostRecentYear = years[0];
            fieldSamples = fieldSamples.filter(s => String(s.year) === String(mostRecentYear));
          }
        }

        // Robust value extraction - handle strings, empty values, zeros for no-data attributes
        const values = fieldSamples
          .map(s => Utils.getNumericValue(s[selectedAttribute], selectedAttribute))
          .filter(v => v !== null);

        if (values.length > 0) {
          const sum = values.reduce((a, b) => a + b, 0);
          const avg = sum / values.length;

          // Debug: check for bad calculations
          if (!isFinite(avg)) {
            console.warn(`Field ${fieldName}: Bad avg calculation - sum=${sum}, count=${values.length}, values sample:`, values.slice(0, 5));
            fieldsWithNoData.push(fieldName);
          } else {
            fieldAverages[fieldName] = { avg, count: values.length };
            allFieldAvgs.push(avg);
          }
        } else {
          // Field has no valid data for this attribute/year
          fieldsWithNoData.push(fieldName);
        }
      });

      // Debug logging
      console.log('Field shading debug:', {
        attribute: selectedAttribute,
        year: selectedYear,
        fieldsWithData: Object.keys(fieldAverages).length,
        fieldsWithNoData: fieldsWithNoData.length,
        allFieldAvgs: allFieldAvgs.slice(0, 5),
        fieldAverages: Object.entries(fieldAverages).slice(0, 3).map(([k, v]) => `${k}: ${v.avg.toFixed(1)}`)
      });

      // Mark fields with no data as grey
      fieldsWithNoData.forEach(fieldName => {
        fieldColors[fieldName] = '#9ca3af'; // Grey for no data
        fieldColors[fieldName + '_stats'] = null; // No stats
        fieldColors[fieldName + '_nodata'] = true;
      });

      // DYNAMIC ZOOM-BASED COLOR SCALING
      // Filter to only visible fields for color scale calculation
      const visibleFieldNames = Object.keys(fieldAverages).filter(fieldName => isFieldVisible(fieldName));
      const visibleFieldAvgs = visibleFieldNames.map(fn => fieldAverages[fn].avg);

      // Use visible fields for color scale, fallback to all if none visible
      const colorScaleAvgs = visibleFieldAvgs.length > 0 ? visibleFieldAvgs : allFieldAvgs;

      console.log('Dynamic color scaling:', {
        totalFields: Object.keys(fieldAverages).length,
        visibleFields: visibleFieldNames.length,
        visibleAvgs: visibleFieldAvgs.slice(0, 5)
      });

      // Calculate colors based on field averages using relative coloring
      // This ensures fields are colored relative to each other, not just absolute thresholds
      const isLowerBetter = CONFIG.LOWER_IS_BETTER.includes(selectedAttribute);

      // Remove outliers using IQR method to prevent skewed color gradients
      const removeOutliers = (values) => {
        if (values.length < 4) return values;
        const sorted = [...values].sort((a, b) => a - b);
        const q1 = sorted[Math.floor(sorted.length * 0.25)];
        const q3 = sorted[Math.floor(sorted.length * 0.75)];
        const iqr = q3 - q1;
        const lowerBound = q1 - 1.5 * iqr;
        const upperBound = q3 + 1.5 * iqr;
        const filtered = values.filter(v => v >= lowerBound && v <= upperBound);
        // Log if we removed any outliers
        if (filtered.length < values.length) {
          const outliers = values.filter(v => v < lowerBound || v > upperBound);
          console.log(`Removed ${outliers.length} outlier(s) from color range:`, outliers);
        }
        return filtered.length > 0 ? filtered : values; // Fallback to original if all filtered
      };

      // Debug: track color distribution
      const colorCounts = { green: 0, yellow: 0, red: 0 };

      // Special handling for P:Zn Ratio - use threshold-based coloring
      if (selectedAttribute === 'P_Zn_Ratio') {
        Object.entries(fieldAverages).forEach(([fieldName, stats]) => {
          const color = Utils.getPZnRatioColor(stats.avg);
          fieldColors[fieldName] = color;
          fieldColors[fieldName + '_stats'] = stats;
          if (color === '#16a34a') colorCounts.green++;
          else if (color === '#eab308') colorCounts.yellow++;
          else if (color === '#ef4444') colorCounts.red++;
        });
        // Update legend for P:Zn ratio
        updateLegendRange(null, null, null); // Will use custom legend text
        document.getElementById('legendText').innerHTML = '<span style="color:#16a34a">8-10 Optimal</span> <span style="color:#eab308">5-12 Acceptable</span> <span style="color:#ef4444">&lt;5 or &gt;12</span>';
      }
      // ALWAYS use relative coloring based on VISIBLE fields (dynamic zoom-based scaling)
      else if (colorScaleAvgs.length > 1) {
        // Fallback: relative coloring for attributes without defined thresholds
        // Use visible fields for color scale (dynamic zoom-based scaling)
        const filteredAvgs = removeOutliers(colorScaleAvgs);
        const sortedAvgs = [...filteredAvgs].sort((a, b) => a - b);
        const minAvg = sortedAvgs[0];
        const maxAvg = sortedAvgs[sortedAvgs.length - 1];
        const range = maxAvg - minAvg;

        // Update legend with visible range
        const unit = CONFIG.NUTRIENT_UNITS[selectedAttribute] || '';
        updateLegendRange(minAvg, maxAvg, unit);

        console.log('Using relative color gradient (visible fields):', { minAvg, maxAvg, range, isLowerBetter, visibleCount: colorScaleAvgs.length, filteredCount: filteredAvgs.length });

        Object.entries(fieldAverages).forEach(([fieldName, stats]) => {
          let color;
          if (range === 0) {
            color = '#eab308'; // All same value = yellow
          } else {
            // Calculate position from 0 to 1, clamping outliers to the range
            let position = (stats.avg - minAvg) / range;
            position = Math.max(0, Math.min(1, position)); // Clamp to 0-1

            // Assign color based on position (higher = greener for most, inverted for "lower is better")
            if (isLowerBetter) {
              // Lower is better: low position = green, high position = red
              if (position <= 0.33) color = '#22c55e';      // Green (low/good)
              else if (position <= 0.66) color = '#eab308'; // Yellow (medium)
              else color = '#ef4444';                        // Red (high/bad)
            } else {
              // Higher is better: high position = green, low position = red
              if (position >= 0.66) color = '#22c55e';      // Green (high/good)
              else if (position >= 0.33) color = '#eab308'; // Yellow (medium)
              else color = '#ef4444';                        // Red (low/bad)
            }
          }
          fieldColors[fieldName] = color;
          fieldColors[fieldName + '_stats'] = stats;

          // Track color distribution
          if (color === '#22c55e') colorCounts.green++;
          else if (color === '#eab308') colorCounts.yellow++;
          else if (color === '#ef4444') colorCounts.red++;
        });

        console.log('Field color distribution:', colorCounts, 'Total fields colored:', Object.keys(fieldAverages).length);
      } else if (colorScaleAvgs.length === 1) {
        // Single field with data - use threshold-based coloring
        const singleAvg = colorScaleAvgs[0];
        updateLegendRange(singleAvg, singleAvg, CONFIG.NUTRIENT_UNITS[selectedAttribute] || '');
        Object.entries(fieldAverages).forEach(([fieldName, stats]) => {
          const color = Utils.getColor(stats.avg, selectedAttribute, settings, bufferPct, allFieldAvgs);
          fieldColors[fieldName] = color;
          fieldColors[fieldName + '_stats'] = stats;
        });
      } else {
        // No visible fields with data - clear legend range
        updateLegendRange(null, null, null);
      }
      // If allFieldAvgs.length === 0, all fields are grey (no data)

      // Update stats box - use field averages when "All Fields" selected
      if (selectedField === 'all' && allFieldAvgs.length > 0) {
        // Show stats based on field averages
        updateStats(allFieldAvgs, 'field');
      } else {
        // Single field selected - show individual sample points
        let filtered = sampleData.filter(s => {
          if (selectedField !== 'all' && s.field !== selectedField) return false;
          if (selectedYear !== 'all' && String(s.year) !== String(selectedYear)) return false;
          return true;
        });
        const allValues = filtered
          .map(s => Utils.getNumericValue(s[selectedAttribute], selectedAttribute))
          .filter(v => v !== null);
        updateStats(allValues, 'sample');
      }

      // Draw boundaries with shading
      drawBoundaries(true, fieldColors);
    }

    // Update field colors based on visible fields (called on map pan)
    function updateVisibleFieldColors() {
      // Re-render field shading with updated visible bounds
      // This recalculates colors based on currently visible fields
      currentLayers.forEach(l => map.removeLayer(l));
      currentLayers = [];
      drawFieldShading();
    }

    function drawSampleMarkers() {
      const settings = Utils.loadSettings();

      // Filter by active client/farm
      const activeFields = getActiveFields();

      // Build map of most recent year per field (for "All Fields" + "All Years" view)
      const mostRecentYearByField = {};
      if (selectedField === 'all' && selectedYear === 'all') {
        activeFields.forEach(fieldName => {
          const fieldYears = sampleData
            .filter(s => s.field === fieldName)
            .map(s => s.year)
            .filter(y => y);
          if (fieldYears.length > 0) {
            mostRecentYearByField[fieldName] = Math.max(...fieldYears);
          }
        });
      }

      // Filter samples for selected year and active client/farm
      let filtered = sampleData.filter(s => {
        if (!activeFields.includes(s.field)) return false; // Filter by active client/farm
        if (selectedField !== 'all' && s.field !== selectedField) return false;

        // Year filtering logic
        if (selectedYear !== 'all') {
          // Specific year selected - filter to that year
          if (String(s.year) !== String(selectedYear)) return false;
        } else if (selectedField === 'all') {
          // "All Fields" + "All Years" - show only most recent year per field
          const mostRecent = mostRecentYearByField[s.field];
          if (mostRecent && String(s.year) !== String(mostRecent)) return false;
        }
        // If specific field + "All Years", show all years (no filter)

        return true;
      });

      console.log('drawSampleMarkers - total samples:', sampleData.length, 'filtered:', filtered.length, 'for year:', selectedYear);
      if (filtered.length > 0) {
        const years = [...new Set(filtered.map(s => s.year))];
        console.log('Years in filtered samples:', years);
      }

      // Use cached stability data (for high variability flags)
      const stabilityData = getStabilityData();

      // Build spatial index for stability data to speed up lookups
      const CELL_SIZE = 0.0003; // ~100ft grid cells
      const stabilityIndex = new Map();
      for (const [hash, data] of Object.entries(stabilityData)) {
        const gridLat = Math.floor(data.lat / CELL_SIZE);
        const gridLon = Math.floor(data.lon / CELL_SIZE);
        const gridKey = `${gridLat}_${gridLon}`;
        if (!stabilityIndex.has(gridKey)) {
          stabilityIndex.set(gridKey, []);
        }
        stabilityIndex.get(gridKey).push({ hash, data });
      }

      // Helper to find stability info using spatial index
      function findStabilityInfo(lat, lon) {
        const gridLat = Math.floor(lat / CELL_SIZE);
        const gridLon = Math.floor(lon / CELL_SIZE);
        // Check 3x3 grid of cells
        for (let dLat = -1; dLat <= 1; dLat++) {
          for (let dLon = -1; dLon <= 1; dLon++) {
            const cellKey = `${gridLat + dLat}_${gridLon + dLon}`;
            const cellData = stabilityIndex.get(cellKey);
            if (!cellData) continue;
            for (const { hash, data } of cellData) {
              const dist = Utils.getDistanceFeet(lat, lon, data.lat, data.lon);
              if (dist < 50) {
                return { hash, data };
              }
            }
          }
        }
        return null;
      }

      // Get all VALID values for median-based coloring and stats (filters out 0s for nutrients where 0 = no data)
      const allValues = filtered
        .map(s => Utils.getNumericValue(s[selectedAttribute], selectedAttribute))
        .filter(v => v !== null);

      // Update stats box (always sample points when showing markers)
      updateStats(allValues, 'sample');

      // Track which stability locations we've matched samples to (for popup binding)
      const sampleToStability = new Map();

      // Render point markers with integrated warning badges
      filtered.forEach(sample => {
        const rawValue = sample[selectedAttribute];
        const numValue = Utils.getNumericValue(rawValue, selectedAttribute);
        const hasValidData = numValue !== null;

        // Skip samples with no GPS
        if (!sample.lat || !sample.lon) return;

        const bufferPct = settings.bufferPercent || 25;
        const size = fieldModeActive ? 44 : 32;
        const fontSize = fieldModeActive ? 14 : 11;

        let color, displayVal;
        if (hasValidData) {
          // Use special color function for P:Zn Ratio
          if (selectedAttribute === 'P_Zn_Ratio') {
            color = Utils.getPZnRatioColor(numValue);
          } else {
            color = Utils.getColor(numValue, selectedAttribute, settings, bufferPct, allValues);
          }
          displayVal = selectedAttribute === 'sampleId'
            ? rawValue
            : Utils.formatValue(numValue, selectedAttribute);
        } else {
          // No valid data - skip this sample entirely (don't show on map)
          return;
        }

        // Find stability info for this location using spatial index (O(1) lookup)
        let stabilityInfo = null;
        let hasHighVariability = false;
        const stabilityMatch = findStabilityInfo(sample.lat, sample.lon);
        if (stabilityMatch) {
          stabilityInfo = stabilityMatch.data;
          sampleToStability.set(stabilityMatch.hash, stabilityMatch.data);
          // Check if high variability for selected attribute
          const selectedCV = stabilityInfo.cvByNutrient[selectedAttribute];
          hasHighVariability = selectedCV !== null && selectedCV !== undefined && selectedCV > 30;
        }

        // Build marker HTML with optional warning badge integrated
        const warningBadge = hasHighVariability
          ? '<div style="position:absolute;top:-6px;right:-6px;background:#ef4444;color:white;border-radius:50%;width:14px;height:14px;font-size:9px;display:flex;align-items:center;justify-content:center;box-shadow:0 1px 2px rgba(0,0,0,0.3);border:1px solid white;">!</div>'
          : '';
        const icon = L.divIcon({
          html: `<div class="sample-marker" style="position:relative;width:${size}px;height:${size}px;background:${color};font-size:${fontSize}px;line-height:${size}px;">${displayVal}${warningBadge}</div>`,
          className: '', iconSize: [size, size], iconAnchor: [size/2, size/2]
        });
        const marker = L.marker([sample.lat, sample.lon], { icon }).addTo(map);
        marker.bindPopup(buildSamplePopup(sample, stabilityInfo));
        currentLayers.push(marker);
      });
    }

    function buildSamplePopup(sample, stabilityInfo = null) {
      const visibleNutrients = getVisibleNutrients();
      let html = `<div style="max-height: 350px; overflow-y: auto; min-width: 220px;">`;
      html += `<div style="font-weight: 700; font-size: 14px; margin-bottom: 8px; border-bottom: 2px solid #3b82f6; padding-bottom: 4px;">`;
      html += `Sample ${sample.sampleId || 'Unknown'}</div>`;
      html += `<div style="margin-bottom: 8px; color: #64748b; font-size: 12px;">`;
      html += `<strong>Field:</strong> ${sample.field || 'Unknown'}<br>`;
      html += `<strong>Year:</strong> ${sample.year || 'N/A'}`;
      if (sample.depth) html += `<br><strong>Depth:</strong> ${sample.depth}"`;
      html += `</div>`;

      // Show stability info for selected attribute
      if (stabilityInfo && stabilityInfo.yearCount > 1) {
        const selectedCV = stabilityInfo.cvByNutrient[selectedAttribute];
        const attrName = CONFIG.NUTRIENT_NAMES?.[selectedAttribute] || selectedAttribute;

        if (selectedCV !== null && selectedCV !== undefined && selectedCV > 30) {
          // High variability for selected attribute
          html += `<div style="margin-bottom: 8px; padding: 6px 8px; background: #fef2f2; border-left: 3px solid #ef4444; border-radius: 0 4px 4px 0; font-size: 11px; color: #991b1b;">`;
          html += `<strong>‚ö†Ô∏è High ${attrName} Variability:</strong> CV ${selectedCV.toFixed(0)}%`;
          html += `<div style="font-size: 10px; margin-top: 2px;">Values vary significantly at this location</div>`;
          html += `</div>`;
        } else if (selectedCV !== null && selectedCV !== undefined) {
          // Stable for selected attribute
          const label = selectedCV < 15 ? 'Stable' : 'Moderate';
          html += `<div style="margin-bottom: 8px; padding: 6px 8px; background: #f0fdf4; border-left: 3px solid #22c55e; border-radius: 0 4px 4px 0; font-size: 11px; color: #166534;">`;
          html += `‚úì ${label} ${attrName} (CV: ${selectedCV.toFixed(0)}%, ${stabilityInfo.yearCount} years)`;
          html += `</div>`;
        }
      }

      html += `<table style="width: 100%; font-size: 12px; border-collapse: collapse;">`;

      visibleNutrients.forEach(n => {
        if (n.key === 'sampleId') return; // Already shown in header
        const value = sample[n.key];
        if (value === undefined || value === null) return;
        const displayVal = typeof value === 'number' ? Utils.formatValue(value, n.key) : value;
        const unit = CONFIG.NUTRIENT_UNITS[n.key] || '';
        const isSelected = n.key === selectedAttribute;
        html += `<tr style="${isSelected ? 'background: #dbeafe; font-weight: 600;' : ''}">`;
        html += `<td style="padding: 3px 6px; border-bottom: 1px solid #e2e8f0;">${n.name}</td>`;
        html += `<td style="padding: 3px 6px; border-bottom: 1px solid #e2e8f0; text-align: right;">${displayVal} ${unit}</td>`;
        html += `</tr>`;
      });

      html += `</table></div>`;
      return html;
    }

    // ========== STABILITY VIEW ==========

    // Draw stability markers showing CV for each sample location
    function drawStabilityMarkers() {
      const baseNutrient = getBaseNutrient(selectedAttribute);
      const activeFields = getActiveFields();

      // Use cached stability data, filtered by active fields
      const allStabilityData = getStabilityData();
      const stabilityData = {};
      for (const [hash, data] of Object.entries(allStabilityData)) {
        if (!activeFields.includes(data.field)) continue;
        if (selectedField !== 'all' && data.field !== selectedField) continue;
        stabilityData[hash] = data;
      }

      // Collect all CV values for stats
      const allCVs = [];
      const size = fieldModeActive ? 44 : 32;
      const fontSize = fieldModeActive ? 11 : 9;

      Object.entries(stabilityData).forEach(([hash, data]) => {
        const cv = data.cvByNutrient[baseNutrient];
        if (cv === null || cv === undefined) return;

        allCVs.push(cv);

        const color = Utils.getStabilityColor(cv);
        const label = Utils.getStabilityLabel(cv);

        const icon = L.divIcon({
          html: `<div class="sample-marker" style="width:${size}px;height:${size}px;background:${color};font-size:${fontSize}px;line-height:${size}px;">${cv.toFixed(0)}%</div>`,
          className: '', iconSize: [size, size], iconAnchor: [size/2, size/2]
        });

        const marker = L.marker([data.lat, data.lon], { icon }).addTo(map);
        marker.bindPopup(buildStabilityPopup(data, baseNutrient));
        currentLayers.push(marker);
      });

      // Update stats display
      if (allCVs.length > 0) {
        updateStats(allCVs, 'stability');
      } else {
        document.getElementById('statsBox').innerHTML = '<em>No stability data (need 2+ years)</em>';
      }
    }

    // Build popup for stability view
    function buildStabilityPopup(data, highlightNutrient) {
      let html = `<div style="max-height: 350px; overflow-y: auto; min-width: 240px;">`;
      html += `<div style="font-weight: 700; font-size: 14px; margin-bottom: 8px; border-bottom: 2px solid #8b5cf6; padding-bottom: 4px;">`;
      html += `üìä Stability Analysis</div>`;
      html += `<div style="margin-bottom: 8px; color: #64748b; font-size: 12px;">`;
      html += `<strong>Field:</strong> ${data.field || 'Unknown'}<br>`;
      html += `<strong>Years:</strong> ${data.years.join(', ')} (${data.yearCount} samples)`;
      html += `</div>`;

      html += `<table style="width: 100%; font-size: 12px; border-collapse: collapse;">`;
      html += `<tr style="background: #f1f5f9;"><th style="padding: 4px; text-align: left;">Nutrient</th><th style="padding: 4px; text-align: right;">CV%</th><th style="padding: 4px; text-align: center;">Rating</th></tr>`;

      // Sort nutrients with highlighted one first
      const nutrients = Object.keys(data.cvByNutrient).sort((a, b) => {
        if (a === highlightNutrient) return -1;
        if (b === highlightNutrient) return 1;
        return a.localeCompare(b);
      });

      nutrients.forEach(nutrient => {
        const cv = data.cvByNutrient[nutrient];
        if (cv === null || cv === undefined) return;
        const isHighlighted = nutrient === highlightNutrient;
        const color = Utils.getStabilityColor(cv);
        const label = Utils.getStabilityLabel(cv);
        const name = CONFIG.NUTRIENT_NAMES?.[nutrient] || nutrient;
        html += `<tr style="${isHighlighted ? 'background: #ede9fe; font-weight: 600;' : ''}">`;
        html += `<td style="padding: 3px 6px; border-bottom: 1px solid #e2e8f0;">${name}</td>`;
        html += `<td style="padding: 3px 6px; border-bottom: 1px solid #e2e8f0; text-align: right;">${cv.toFixed(1)}%</td>`;
        html += `<td style="padding: 3px 6px; border-bottom: 1px solid #e2e8f0; text-align: center; color: ${color}; font-weight: 600;">${label}</td>`;
        html += `</tr>`;
      });

      html += `</table>`;

      // Show high variability warnings
      if (data.highVariabilityNutrients && data.highVariabilityNutrients.length > 0) {
        html += `<div style="margin-top: 8px; padding: 6px; background: #fef2f2; border-radius: 4px; font-size: 11px; color: #991b1b;">`;
        html += `‚ö†Ô∏è <strong>Volatile:</strong> ${data.highVariabilityNutrients.map(n => n.attr).join(', ')}`;
        html += `</div>`;
      }

      html += `</div>`;
      return html;
    }

    // Update legend for stability view
    function updateStabilityLegend() {
      const legendText = document.getElementById('legendText');
      const legendRange = document.getElementById('legendRange');
      const baseNutrient = getBaseNutrient(selectedAttribute);
      const attrName = CONFIG.NUTRIENT_NAMES[baseNutrient] || baseNutrient;

      if (legendText) {
        legendText.innerHTML = `
          <span style="color: #16a34a; font-weight: 600;">‚óè Stable (&lt;15%)</span>
          <span style="color: #eab308; margin-left: 0.5rem; font-weight: 600;">‚óè Moderate (15-30%)</span>
          <span style="color: #ef4444; margin-left: 0.5rem; font-weight: 600;">‚óè Volatile (&gt;30%)</span>
        `;
      }
      if (legendRange) {
        legendRange.innerHTML = `<strong>${attrName} Stability</strong> &nbsp;|&nbsp; CV% across all years`;
      }
    }

    // Draw field-level stability shading (zoomed out view)
    function drawStabilityFieldShading() {
      const baseNutrient = getBaseNutrient(selectedAttribute);
      const activeFields = getActiveFields();

      // Use cached stability data, grouped by field
      const allStabilityData = getStabilityData();
      const fieldCVs = {};
      const allCVs = [];

      // Group stability locations by field and calculate average CV
      activeFields.forEach(fieldName => {
        const fieldLocationCVs = [];
        Object.values(allStabilityData).forEach(data => {
          if (data.field !== fieldName) return;
          const cv = data.cvByNutrient[baseNutrient];
          if (cv !== null && cv !== undefined) {
            fieldLocationCVs.push(cv);
          }
        });

        if (fieldLocationCVs.length > 0) {
          const avgCV = fieldLocationCVs.reduce((a, b) => a + b, 0) / fieldLocationCVs.length;
          fieldCVs[fieldName] = { avgCV, locationCount: fieldLocationCVs.length };
          allCVs.push(avgCV);
        }
      });

      // Draw boundaries with stability colors
      const fieldColors = {};
      Object.entries(fieldCVs).forEach(([fieldName, data]) => {
        fieldColors[fieldName] = Utils.getStabilityColor(data.avgCV);
      });

      // Draw shaded boundaries
      Object.entries(fieldBoundaries).forEach(([fieldName, fieldData]) => {
        if (!activeFields.includes(fieldName)) return;

        const coords = Utils.getFieldBoundaryCoords({ [fieldName]: fieldData }, fieldName);
        if (!coords) return;

        const color = fieldColors[fieldName] || '#94a3b8';
        const cvData = fieldCVs[fieldName];
        const polygons = Array.isArray(coords[0][0]) ? coords : [coords];

        polygons.forEach((ring, idx) => {
          const latLngs = ring.map(c => [c[0], c[1]]);
          const poly = L.polygon(latLngs, {
            color: color,
            weight: 2,
            fillColor: color,
            fillOpacity: 0.5
          }).addTo(map);

          // Build popup
          let popupContent = `<strong>${fieldName}</strong><br>`;
          if (cvData) {
            const label = Utils.getStabilityLabel(cvData.avgCV);
            popupContent += `<span style="color: ${color}; font-weight: 600;">Avg CV: ${cvData.avgCV.toFixed(1)}% (${label})</span><br>`;
            popupContent += `<span style="color: #64748b; font-size: 11px;">${cvData.locationCount} sample locations</span>`;
          } else {
            popupContent += `<span style="color: #94a3b8;">No stability data</span>`;
          }
          poly.bindPopup(popupContent);
          currentLayers.push(poly);

          // Add field label with CV value
          if (idx === 0 && map.getZoom() >= 12) {
            const center = poly.getBounds().getCenter();
            const labelText = cvData ? `${cvData.avgCV.toFixed(0)}%` : '-';
            const label = L.marker(center, {
              icon: L.divIcon({
                html: `<div style="background:${color};color:white;padding:2px 6px;border-radius:4px;font-size:11px;font-weight:600;white-space:nowrap;text-shadow:0 1px 2px rgba(0,0,0,0.3);box-shadow:0 1px 3px rgba(0,0,0,0.2);">${fieldName}: ${labelText}</div>`,
                className: '',
                iconAnchor: [0, 0]
              }),
              interactive: false
            }).addTo(map);
            currentLayers.push(label);
          }
        });
      });

      // Update stats
      if (allCVs.length > 0) {
        updateStats(allCVs, 'stability');
      } else {
        document.getElementById('statsBox').innerHTML = '<em>No stability data (need 2+ years at same locations)</em>';
      }
    }

    // Calculate distance between two lat/lon points in feet
    function getDistanceFeet(lat1, lon1, lat2, lon2) {
      const R = 20902231; // Earth's radius in feet
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }

    function renderCompareMode() {
      // Get samples from selected year (later) and compare year (earlier)
      const laterYear = selectedYear;
      const earlierYear = compareYear;
      const MAX_DISTANCE_FEET = 200; // Maximum distance to match baseline samples

      // Update the compare info bar with year values
      document.getElementById('compareFromYear').textContent = earlierYear;
      document.getElementById('compareToYear').textContent = laterYear;

      const laterSamples = sampleData.filter(s => {
        if (selectedField !== 'all' && s.field !== selectedField) return false;
        return String(s.year) === String(laterYear);
      });

      const earlierSamples = sampleData.filter(s => {
        if (selectedField !== 'all' && s.field !== selectedField) return false;
        return String(s.year) === String(earlierYear);
      });

      // Calculate change stats
      const changes = [];
      let noMatchCount = 0;

      // For each later sample, find nearest earlier sample and show change
      laterSamples.forEach(laterSample => {
        const value = laterSample[selectedAttribute];
        if (value === undefined || value === null) return;

        // Find nearest earlier sample (same field or closest by location)
        let earlierSample = null;
        let minDistFeet = Infinity;

        // First try exact sampleId match
        const idMatch = earlierSamples.find(s => s.field === laterSample.field && s.sampleId === laterSample.sampleId);
        if (idMatch) {
          earlierSample = idMatch;
          minDistFeet = getDistanceFeet(laterSample.lat, laterSample.lon, idMatch.lat, idMatch.lon);
        } else {
          // Find closest by location within same field
          const fieldEarlier = earlierSamples.filter(s => s.field === laterSample.field);
          fieldEarlier.forEach(s => {
            const dist = getDistanceFeet(laterSample.lat, laterSample.lon, s.lat, s.lon);
            if (dist < minDistFeet) {
              minDistFeet = dist;
              earlierSample = s;
            }
          });
        }

        // Check if nearest baseline is within 200 feet
        const hasNearbyBaseline = earlierSample && minDistFeet <= MAX_DISTANCE_FEET;

        const earlierValue = hasNearbyBaseline ? earlierSample[selectedAttribute] : null;
        const change = earlierValue !== null && earlierValue !== undefined ? value - earlierValue : null;
        const percentChange = earlierValue && earlierValue !== 0 ? ((value - earlierValue) / earlierValue) * 100 : 0;

        // Gray out if no baseline sample within 200 feet
        const color = hasNearbyBaseline && change !== null ? Utils.getChangeColor(change, percentChange) : '#94a3b8';
        const size = fieldModeActive ? 44 : 32;
        const fontSize = fieldModeActive ? 12 : 10;

        let displayVal;
        const attrDecimals = Utils.getDecimals(selectedAttribute);
        if (hasNearbyBaseline && change !== null) {
          const sign = change >= 0 ? '+' : '';
          displayVal = sign + Utils.formatNumber(change, attrDecimals);
        } else {
          // Show current value (grayed out) if no baseline match
          displayVal = Utils.formatNumber(value, attrDecimals);
          noMatchCount++;
        }

        const icon = L.divIcon({
          html: `<div class="sample-marker" style="width:${size}px;height:${size}px;background:${color};font-size:${fontSize}px;line-height:${size}px;">${displayVal}</div>`,
          className: '', iconSize: [size, size], iconAnchor: [size/2, size/2]
        });
        const marker = L.marker([laterSample.lat, laterSample.lon], { icon }).addTo(map);

        const decimals = Utils.getDecimals(selectedAttribute);
        let popupText = `<strong>Sample ${laterSample.sampleId || ''}</strong><br>Field: ${laterSample.field || 'Unknown'}`;
        if (hasNearbyBaseline) {
          popupText += `<br>${earlierYear}: ${Utils.formatNumber(earlierValue, decimals)}`;
          popupText += `<br>${laterYear}: ${Utils.formatNumber(value, decimals)}`;
          if (change !== null) {
            popupText += `<br><strong>Change: ${change >= 0 ? '+' : ''}${Utils.formatNumber(change, decimals)} (${percentChange >= 0 ? '+' : ''}${Utils.formatNumber(percentChange, 0)}%)</strong>`;
            popupText += `<br><span style="color: #64748b; font-size: 0.8em;">Baseline ${Math.round(minDistFeet)} ft away</span>`;
            changes.push(change);
          }
        } else {
          popupText += `<br>${laterYear}: ${Utils.formatNumber(value, decimals)}`;
          popupText += `<br><em style="color: #94a3b8;">No baseline within 200 ft</em>`;
          if (earlierSample) {
            popupText += `<br><span style="color: #94a3b8; font-size: 0.8em;">Nearest: ${Math.round(minDistFeet)} ft</span>`;
          }
        }
        marker.bindPopup(popupText);
        currentLayers.push(marker);
      });
      
      // Update stats for compare mode
      const attrName = CONFIG.NUTRIENT_NAMES[selectedAttribute] || selectedAttribute;
      const unit = CONFIG.NUTRIENT_UNITS[selectedAttribute] || '';

      if (changes.length > 0) {
        const avg = changes.reduce((a, b) => a + b, 0) / changes.length;
        const high = Math.max(...changes);
        const low = Math.min(...changes);
        const changeDecimals = Utils.getDecimals(selectedAttribute);
        document.getElementById('statsTitle').textContent = 'Change Stats';
        document.getElementById('statsAvg').textContent = (avg >= 0 ? '+' : '') + avg.toFixed(changeDecimals);
        document.getElementById('statsHigh').textContent = (high >= 0 ? '+' : '') + high.toFixed(changeDecimals);
        document.getElementById('statsLow').textContent = (low >= 0 ? '+' : '') + low.toFixed(changeDecimals);
        document.getElementById('statsNote').textContent = noMatchCount > 0
          ? `${changes.length} matched, ${noMatchCount} unmatched`
          : 'Year-over-year change';

        // Update compare info bar summary
        const sign = avg >= 0 ? '+' : '';
        const direction = avg > 0.5 ? 'increase' : (avg < -0.5 ? 'decrease' : 'no change');
        const summaryColor = avg > 0.5 ? '#16a34a' : (avg < -0.5 ? '#dc2626' : '#64748b');
        let summaryHtml = `<span style="font-weight: 600; color: ${summaryColor}">${attrName}: ${sign}${avg.toFixed(changeDecimals)}${unit ? ' ' + unit : ''} avg ${direction}</span>`;
        if (noMatchCount > 0) {
          summaryHtml += `<span style="color: #94a3b8; font-size: 0.85em; margin-left: 8px;">(${noMatchCount} gray = no baseline)</span>`;
        }
        document.getElementById('compareSummary').innerHTML = summaryHtml;
      } else {
        document.getElementById('compareSummary').innerHTML =
          `<span style="color: #94a3b8;">No matching samples between ${earlierYear} and ${laterYear}</span>`;
      }
    }

    function zoomToField(fieldName) {
      if (fieldName === 'all') {
        const allCoords = [];
        Object.values(fieldBoundaries).forEach(fieldData => {
          const p = fieldData.boundary || fieldData;
          const a = Array.isArray(p[0]?.[0]) ? p.flat() : p;
          allCoords.push(...a);
        });
        sampleData.forEach(s => allCoords.push([s.lat, s.lon]));
        if (allCoords.length > 0) map.fitBounds(allCoords, { padding: [50,50] });
      } else if (fieldBoundaries[fieldName]) {
        const fieldData = fieldBoundaries[fieldName];
        const p = fieldData.boundary || fieldData;
        const a = Array.isArray(p[0]?.[0]) ? p.flat() : p;
        map.fitBounds(a, { padding: [50,50] });
      }
    }

    function toggleFieldMode() {
      fieldModeActive = !fieldModeActive;
      const btn = document.getElementById('fieldModeBtn');
      const mobileBtn = document.getElementById('mobileFieldModeBtn');
      if (fieldModeActive) {
        btn.classList.add('active');
        btn.textContent = 'üì± Field Mode ON';
        mobileBtn.classList.add('active');
        mobileBtn.textContent = 'üì± ON';
        document.body.classList.add('field-mode');
        startGPS();
      } else {
        btn.classList.remove('active');
        btn.textContent = 'üì± Field Mode';
        mobileBtn.classList.remove('active');
        mobileBtn.textContent = 'üì± Field Mode';
        document.body.classList.remove('field-mode');
        stopGPS();
      }
      updateMap();
    }

    function startGPS() {
      if (!navigator.geolocation) { Utils.showStatus('GPS not supported', false); return; }
      gpsWatchId = navigator.geolocation.watchPosition(
        (pos) => {
          const { latitude, longitude, accuracy } = pos.coords;
          if (gpsMarker) { gpsMarker.setLatLng([latitude, longitude]); gpsCircle.setLatLng([latitude, longitude]); gpsCircle.setRadius(accuracy); }
          else {
            const gpsIcon = L.divIcon({
              html: '<div class="gps-marker"><div class="gps-pulse"></div><div class="gps-dot"></div></div>',
              className: '',
              iconSize: [22, 22],
              iconAnchor: [11, 11]
            });
            gpsMarker = L.marker([latitude, longitude], { icon: gpsIcon }).addTo(map);
            gpsCircle = L.circle([latitude, longitude], { radius: accuracy, color: '#3b82f6', fillColor: '#3b82f6', fillOpacity: 0.1, weight: 2, dashArray: '4' }).addTo(map);
          }
          map.setView([latitude, longitude], map.getZoom());
        },
        (e) => Utils.showStatus('GPS error: ' + e.message, false),
        { enableHighAccuracy: true, maximumAge: 5000 }
      );
    }

    function stopGPS() {
      if (gpsWatchId) { navigator.geolocation.clearWatch(gpsWatchId); gpsWatchId = null; }
      if (gpsMarker) { map.removeLayer(gpsMarker); map.removeLayer(gpsCircle); gpsMarker = null; gpsCircle = null; }
    }

    function toggleStatsBox() {
      const statsBox = document.getElementById('statsBox');
      const toggle = statsBox.querySelector('.stats-toggle');
      if (statsBox.classList.contains('collapsed')) {
        statsBox.classList.remove('collapsed');
        toggle.textContent = '‚ñº';
      } else {
        statsBox.classList.add('collapsed');
        toggle.textContent = '‚ñ∂';
      }
    }

    function updateBackupFooter() {
      const backupTime = localStorage.getItem('soilDataBackupTime');
      const footer = document.getElementById('backupFooter');
      const buildDate = new Date(BUILD_DATE);
      const buildStr = buildDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) + ', ' +
                       buildDate.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
      const versionInfo = `App ${APP_VERSION} ‚Ä¢ Built: ${buildStr}`;
      const legalLinks = `<span style="margin: 0 0.5rem; color: #cbd5e1;">|</span> <a href="methodology.html" style="color: #3b82f6; text-decoration: underline;">How We Calculate</a> <span style="color: #cbd5e1;">|</span> <a href="privacy-policy.html" style="color: #3b82f6; text-decoration: underline;">Privacy</a> <span style="color: #cbd5e1;">|</span> <a href="terms-of-service.html" style="color: #3b82f6; text-decoration: underline;">Terms</a>`;

      const sampleData = JSON.parse(localStorage.getItem('soilSamples') || '[]');

      if (backupTime) {
        const date = new Date(parseInt(backupTime));
        const backupStr = date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
        footer.innerHTML = `${versionInfo} <span style="margin: 0 0.5rem; color: #cbd5e1;">|</span> <span style="color: #22c55e;">Data backup: ${backupStr}</span>${legalLinks}`;
      } else if (sampleData.length === 0) {
        // No data yet - don't show backup warning
        footer.innerHTML = versionInfo + legalLinks;
      } else {
        // Has data but no backup - show warning
        footer.innerHTML = `${versionInfo} <span style="margin: 0 0.5rem; color: #cbd5e1;">|</span> <span style="color: #f59e0b;">No backup yet</span>${legalLinks}`;
      }
    }
  </script>
  <div class="backup-footer" id="backupFooter"></div>
</body>
</html>
