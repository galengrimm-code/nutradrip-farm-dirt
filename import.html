<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Soil Sample Analysis - Import</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f8fafc; color: #1e293b; min-height: 100vh; }
    .top-bar { background: linear-gradient(135deg, #1e293b 0%, #334155 100%); color: white; padding: 1rem 1.5rem; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem; }
    .top-bar h1 { font-size: 1.5rem; font-weight: 700; }
    .top-bar p { font-size: 0.875rem; opacity: 0.8; margin-top: 0.25rem; }
    .nav-links { display: flex; gap: 0.5rem; flex-wrap: wrap; }
    .nav-link { padding: 0.5rem 1rem; background: rgba(255,255,255,0.1); color: white; text-decoration: none; border-radius: 0.375rem; font-size: 0.875rem; font-weight: 500; }
    .nav-link:hover { background: rgba(255,255,255,0.2); }
    .nav-link.active { background: #3b82f6; }
    .auth-section { display: flex; align-items: center; gap: 1rem; }
    .user-info { font-size: 0.875rem; color: rgba(255,255,255,0.9); }
    .sign-in-btn { padding: 0.5rem 1rem; background: #4285f4; color: white; border: none; border-radius: 0.375rem; font-size: 0.875rem; cursor: pointer; }
    .sign-in-btn.signed-in { background: #22c55e; }
    .sign-in-btn.signed-in:hover { background: #16a34a; }
    .import-container { max-width: 800px; margin: 0 auto; padding: 1.5rem; }
    .data-summary { background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1.5rem; }
    .data-summary h4 { margin: 0 0 0.75rem 0; color: #475569; }
    .summary-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; }
    .summary-item { text-align: center; padding: 0.75rem; background: white; border-radius: 0.375rem; }
    .summary-item .number { font-size: 1.5rem; font-weight: 700; color: #1e293b; }
    .summary-item .label { font-size: 0.75rem; color: #64748b; text-transform: uppercase; }
    .import-section { background: white; border-radius: 0.75rem; padding: 1.5rem; margin-bottom: 1.5rem; box-shadow: 0 2px 8px rgba(0,0,0,0.08); border: 2px solid transparent; }
    .import-section h3 { margin: 0 0 1rem 0; display: flex; align-items: center; gap: 0.5rem; font-size: 1.25rem; }
    .import-section.boundaries { background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%); border-color: #3b82f6; }
    .import-section.boundaries h3 { color: #1d4ed8; }
    .import-section.samples { background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%); border-color: #22c55e; }
    .import-section.samples h3 { color: #15803d; }
    .import-section.yield { background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%); border-color: #f59e0b; }
    .import-section.yield h3 { color: #b45309; }
    .import-section.export { background: linear-gradient(135deg, #f5f3ff 0%, #ede9fe 100%); border-color: #8b5cf6; }
    .import-section.export h3 { color: #7c3aed; }
    .import-section.management { background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%); border-color: #64748b; }
    .import-section.management h3 { color: #475569; }
    .form-group { margin-bottom: 1rem; }
    .form-group label { display: block; font-weight: 600; margin-bottom: 0.5rem; color: #374151; font-size: 0.875rem; }
    .form-group input[type="file"], .form-group input[type="text"] { width: 100%; padding: 0.75rem; border: 2px dashed #cbd5e1; border-radius: 0.375rem; background: #f8fafc; }
    .form-group input[type="file"]:hover { border-color: #94a3b8; background: #f1f5f9; }
    .form-group input::placeholder { color: #94a3b8; font-weight: 400; font-style: italic; }
    .form-group small { display: block; margin-top: 0.25rem; color: #64748b; font-size: 0.75rem; }
    .button { padding: 0.75rem 1.5rem; border: none; border-radius: 0.375rem; font-size: 0.875rem; font-weight: 600; cursor: pointer; width: 100%; }
    .button.primary { background: #3b82f6; color: white; }
    .button.success { background: #22c55e; color: white; }
    .button.danger { background: #ef4444; color: white; }
    .button:hover { opacity: 0.9; }
    .btn-row { display: flex; gap: 1rem; flex-wrap: wrap; }
    .btn-row .button { flex: 1; }
    #statusMessage { display: none; position: fixed; top: 1rem; left: 50%; transform: translateX(-50%); z-index: 9999; padding: 0.75rem 1rem; border-radius: 0.375rem; box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
    
    /* Column Mapping Modal */
    .modal-overlay { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10000; justify-content: center; align-items: center; }
    .modal-overlay.active { display: flex; }
    .modal { background: white; border-radius: 0.5rem; max-width: 700px; width: 90%; max-height: 80vh; overflow: hidden; display: flex; flex-direction: column; }
    .modal-header { padding: 1rem 1.5rem; border-bottom: 1px solid #e2e8f0; display: flex; justify-content: space-between; align-items: center; }
    .modal-header h3 { margin: 0; font-size: 1.125rem; }
    .modal-close { background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #64748b; }
    .modal-body { padding: 1.5rem; overflow-y: auto; flex: 1; }
    .modal-footer { padding: 1rem 1.5rem; border-top: 1px solid #e2e8f0; display: flex; justify-content: flex-end; gap: 0.75rem; }
    .mapping-section { margin-bottom: 1.5rem; }
    .mapping-section h4 { margin: 0 0 0.75rem 0; font-size: 0.875rem; color: #475569; display: flex; align-items: center; gap: 0.5rem; }
    .mapping-section h4 .icon { font-size: 1rem; }
    .mapping-row { display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem; background: #f8fafc; border-radius: 0.375rem; margin-bottom: 0.5rem; }
    .mapping-row.matched { background: #dcfce7; }
    .mapping-row.unmatched { background: #fef3c7; }
    .mapping-row .file-col { flex: 1; font-family: monospace; font-size: 0.875rem; color: #1e293b; }
    .mapping-row .arrow { color: #64748b; }
    .mapping-row select { padding: 0.375rem 0.5rem; border: 1px solid #cbd5e1; border-radius: 0.25rem; font-size: 0.875rem; min-width: 120px; }
    .mapping-row .matched-label { color: #166534; font-size: 0.875rem; font-weight: 500; }
    .save-alias-row { display: flex; align-items: center; gap: 0.5rem; margin-top: 0.5rem; }
    .save-alias-row input[type="checkbox"] { width: 1rem; height: 1rem; }
    .save-alias-row label { font-size: 0.875rem; color: #475569; }
    .modal .button { padding: 0.5rem 1rem; width: auto; }
    .backup-footer { position: fixed; bottom: 0; left: 0; right: 0; background: #f8fafc; border-top: 1px solid #e2e8f0; padding: 0.25rem 1rem; font-size: 0.7rem; color: #64748b; text-align: center; z-index: 900; }
  </style>
</head>
<body>
  <div class="top-bar">
    <div>
      <h1>üìÅ Import Data</h1>
      <p>Upload boundaries and soil samples</p>
    </div>
    <nav class="nav-links">
      <a href="index.html" class="nav-link">üìç Map</a>
      <a href="analysis.html" class="nav-link">üìä Analysis</a>
      <a href="import.html" class="nav-link active">üìÅ Import</a>
      <a href="settings.html" class="nav-link">‚öôÔ∏è Settings</a>
    </nav>
    <div class="auth-section">
      <span class="user-info" id="userInfo"></span>
      <button class="sign-in-btn" id="authBtn" onclick="handleAuth()">Sign In to Sync</button>
    </div>
  </div>

  <div class="import-container">
    <div class="data-summary">
      <h4>üìä Current Data</h4>
      <div class="summary-grid">
        <div class="summary-item"><div class="number" id="fieldCount">0</div><div class="label">Fields</div></div>
        <div class="summary-item"><div class="number" id="sampleCount">0</div><div class="label">Samples</div></div>
        <div class="summary-item"><div class="number" id="yearCount">0</div><div class="label">Years</div><div class="year-list" id="yearList" style="font-size: 0.75rem; color: #64748b; margin-top: 0.25rem;"></div></div>
        <div class="summary-item"><div class="number" id="yieldCount">0</div><div class="label">Samples w/ Yield</div><div class="field-list" id="yieldFieldList" style="font-size: 0.75rem; color: #64748b; margin-top: 0.25rem;"></div></div>
      </div>
      <div id="backupStatus" style="margin-top: 1rem; padding: 0.75rem; border-radius: 0.375rem; font-size: 0.8125rem; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 0.5rem;"></div>
    </div>

    <div class="import-section boundaries">
      <h3>üì¶ Import Field Boundaries</h3>
      <div class="form-group">
        <label>Field Name (optional)</label>
        <input type="text" id="boundaryFieldName" placeholder="Auto-detects from file">
      </div>
      <div class="form-group">
        <label>Boundary File(s)</label>
        <input type="file" id="boundaryFiles" multiple accept=".shp,.dbf,.prj,.shx,.zip,.geojson,.json">
        <small>GeoJSON, Shapefile, or ZIP ‚Ä¢ Select multiple for batch import</small>
      </div>
      <button class="button primary" id="uploadBoundaryBtn">Upload Boundaries</button>
    </div>

    <div class="import-section samples">
      <h3>üî¨ Import Soil Samples</h3>
      <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
        <div class="form-group">
          <label>Sample Year <span style="font-weight: 400; font-size: 0.75rem; color: #dc2626;">(required)</span></label>
          <input type="text" id="sampleYear" placeholder="e.g., 2024" style="width: 120px; border: 2px solid #dc2626; background: #fef2f2;" required>
        </div>
        <div class="form-group">
          <label>Sample Depth <span style="font-weight: 400; font-size: 0.75rem; color: #166534;">(default: 6")</span></label>
          <input type="text" id="sampleDepth" value="6" style="width: 80px; border: 2px solid #22c55e; background: #f0fdf4;">
          <small>inches</small>
        </div>
      </div>
      <div class="form-group">
        <label>Sample File(s)</label>
        <input type="file" id="sampleFiles" multiple accept=".shp,.dbf,.prj,.shx,.zip,.geojson,.json,.csv">
        <small>CSV, Shapefile, or GeoJSON ‚Ä¢ Auto-assigns to fields by GPS</small>
      </div>
      <button class="button success" id="uploadSampleBtn">Upload Samples</button>
    </div>

    <div class="import-section yield">
      <h3>üåæ Import Yield Data</h3>
      <p style="color: #92400e; font-size: 0.875rem; margin-bottom: 1rem;">Upload yield maps to correlate soil nutrients with crop performance.</p>
      <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
        <div class="form-group">
          <label>Crop Year <small style="font-weight: normal; color: #64748b;">(auto-detects)</small></label>
          <input type="text" id="yieldYear" placeholder="auto or enter" style="width: 120px;">
        </div>
        <div class="form-group">
          <label>Crop Type</label>
          <select id="yieldCrop" style="width: 140px;">
            <option value="corn">üåΩ Corn</option>
            <option value="soybeans">ü´ò Soybeans</option>
            <option value="amylose">üçö Amylose</option>
          </select>
        </div>
        <div class="form-group">
          <label>Sample Radius</label>
          <select id="yieldRadius" style="width: 100px;">
            <option value="50">50 ft</option>
            <option value="100" selected>100 ft</option>
            <option value="150">150 ft</option>
          </select>
        </div>
      </div>
      <div class="form-group">
        <label>Yield File (Shapefile)</label>
        <input type="file" id="yieldFiles" multiple accept=".shp,.dbf,.prj,.shx,.zip">
        <small>Batch upload supported: select up to 250 ZIPs or .shp/.dbf pairs at once (auto-matched by name)</small>
      </div>
      <button class="button" id="uploadYieldBtn" style="background: #f59e0b; color: white;">Upload Yield Data</button>
      <div id="yieldStatus" style="margin-top: 0.75rem;"></div>
    </div>

    <div class="import-section export">
      <h3>üì§ Export Data</h3>
      <p style="color: #64748b; font-size: 0.875rem; margin-bottom: 1rem;">Export all sample data with visible attributes and yield correlations.</p>
      <div class="btn-row">
        <button class="button" id="exportCSVBtn" style="background: #8b5cf6; color: white;">üìä Export CSV</button>
        <button class="button" id="exportPDFBtn" style="background: #6366f1; color: white;">üìÑ Export PDF Report</button>
        <button class="button" id="exportJSONBtn" style="background: #059669; color: white;">üíæ Download Full Backup</button>
      </div>
    </div>

    <div class="import-section management">
      <h3>üîÑ Data Management</h3>
      <div class="btn-row">
        <button class="button primary" id="syncBtn">‚òÅÔ∏è Sync to Google Sheets</button>
      </div>
      <div class="btn-row" style="margin-top: 0.75rem;">
        <button class="button" id="reassignBtn" style="background: #3b82f6; color: white;">üîÑ Reassign Samples to Boundaries</button>
      </div>
      <div class="btn-row" style="margin-top: 0.75rem;">
        <button class="button danger" id="clearSamplesBtn">üóëÔ∏è Clear Samples</button>
        <button class="button danger" id="clearBoundariesBtn">üóëÔ∏è Clear Boundaries</button>
        <button class="button danger" id="clearYieldBtn">üóëÔ∏è Clear Yield Data</button>
        <button class="button danger" id="clearAllBtn">üóëÔ∏è Clear All</button>
      </div>
      <small style="display:block; margin-top:0.75rem; color:#64748b;">Data is saved locally and synced to Google Sheets when signed in.</small>
    </div>
  </div>

  <div id="statusMessage"></div>

  <!-- Column Mapping Modal -->
  <div id="mappingModal" class="modal-overlay">
    <div class="modal">
      <div class="modal-header">
        <h3>üìã Column Mapping</h3>
        <button class="modal-close" onclick="closeMappingModal()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="mapping-section" id="matchedSection">
          <h4><span class="icon">‚úì</span> Matched Columns</h4>
          <div id="matchedColumns"></div>
        </div>
        <div class="mapping-section" id="unmatchedSection">
          <h4><span class="icon">‚ö†Ô∏è</span> Unmatched Columns (select mapping or skip)</h4>
          <div id="unmatchedColumns"></div>
        </div>
        <div class="save-alias-row">
          <input type="checkbox" id="saveNewAliases" checked>
          <label for="saveNewAliases">Save new mappings for future imports</label>
        </div>
      </div>
      <div class="modal-footer">
        <button class="button" style="background: #94a3b8;" onclick="closeMappingModal()">Cancel</button>
        <button class="button primary" onclick="proceedWithImport()">Import with Mappings</button>
      </div>
    </div>
  </div>

  <!-- Yield Import Summary Modal -->
  <div id="yieldSummaryModal" class="modal-overlay">
    <div class="modal" style="max-width: 900px;">
      <div class="modal-header" style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);">
        <h3>üåæ Yield Import Summary</h3>
        <button class="modal-close" onclick="closeYieldSummary()">&times;</button>
      </div>
      <div class="modal-body" style="padding: 0;">
        <!-- Summary Stats -->
        <div id="yieldSummaryStats" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; padding: 1rem; background: #f8fafc; border-bottom: 1px solid #e2e8f0;"></div>

        <!-- Tabs -->
        <div style="display: flex; border-bottom: 1px solid #e2e8f0;">
          <button class="yield-tab active" onclick="switchYieldTab('fields')" data-tab="fields" style="flex: 1; padding: 0.75rem; border: none; background: white; cursor: pointer; font-weight: 600; border-bottom: 2px solid #f59e0b;">üìä Per-Field Breakdown</button>
          <button class="yield-tab" onclick="switchYieldTab('unmatched')" data-tab="unmatched" style="flex: 1; padding: 0.75rem; border: none; background: #f8fafc; cursor: pointer; font-weight: 500; border-bottom: 2px solid transparent;">‚ö†Ô∏è Unmatched Samples</button>
          <button class="yield-tab" onclick="switchYieldTab('map')" data-tab="map" style="flex: 1; padding: 0.75rem; border: none; background: #f8fafc; cursor: pointer; font-weight: 500; border-bottom: 2px solid transparent;">üó∫Ô∏è Map View</button>
        </div>

        <!-- Tab Content -->
        <div id="yieldTabFields" class="yield-tab-content" style="padding: 1rem; max-height: 400px; overflow-y: auto;"></div>
        <div id="yieldTabUnmatched" class="yield-tab-content" style="display: none; padding: 1rem; max-height: 400px; overflow-y: auto;"></div>
        <div id="yieldTabMap" class="yield-tab-content" style="display: none; padding: 0;">
          <div id="yieldMatchMap" style="height: 400px; width: 100%;"></div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="button" style="background: #059669; color: white;" onclick="closeYieldSummary()">Done</button>
      </div>
    </div>
  </div>

  <script src="https://apis.google.com/js/api.js"></script>
  <script src="https://accounts.google.com/gsi/client"></script>
  <script src="https://unpkg.com/shpjs@latest/dist/shp.js"></script>
  <script>
    // ========== APP VERSION ==========
    const APP_VERSION = "v1.0.7";
    const BUILD_DATE = "2026-01-14T16:24:35";

    const CONFIG = {
      CLIENT_ID: '714780458094-9rde31taeottmavhl5t0uo8b9kfpergc.apps.googleusercontent.com',
      API_KEY: 'AIzaSyCOSDbrAlc3ct2-lRvJv1y7V0nV7haWc9E',
      get SHEET_ID() { return localStorage.getItem('googleSheetId') || '1buu-8KXoM1kRJSOAWtHaAk40seQT5kqGFY9RICYwdRY'; },
      DECIMAL_PLACES: {
        pH: 2, Buffer_pH: 2, OM: 2, P: 0, P2: 0, K: 0, CEC: 1,
        Ca_sat: 1, Mg_sat: 1, K_Sat: 1, H_Sat: 1, Na_Sat: 1,
        Zn: 2, Cu: 2, Mn: 1, Fe: 1, Boron: 2, S: 1,
        Ca: 0, Mg: 0, Na: 0, NO3: 1, NH4: 1, Soluble_Salts: 2, EC: 2
      }
    };

    // Get decimal places for an attribute (checks user settings, then CONFIG defaults)
    function getDecimals(attr) {
      const customDecimals = JSON.parse(localStorage.getItem('decimalPlaces') || '{}');
      if (customDecimals[attr] !== undefined) return customDecimals[attr];
      if (CONFIG.DECIMAL_PLACES[attr] !== undefined) return CONFIG.DECIMAL_PLACES[attr];
      return 1;
    }

    // Format a value using the configured decimal places for an attribute
    function formatValue(value, attr) {
      if (value === null || value === undefined || isNaN(value)) return '-';
      return Number(value).toFixed(getDecimals(attr));
    }

    let tokenClient;
    let accessToken = null;
    let tokenExpiry = null;
    
    const SheetsAPI = {
      isSignedIn: false,
      async init() {
        return new Promise((resolve, reject) => {
          gapi.load('client', async () => {
            try {
              await gapi.client.init({ apiKey: CONFIG.API_KEY, discoveryDocs: ['https://sheets.googleapis.com/$discovery/rest?version=v4'] });
              tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: CONFIG.CLIENT_ID,
                scope: 'https://www.googleapis.com/auth/spreadsheets',
                callback: (response) => {
                  if (response.error) return;
                  accessToken = response.access_token;
                  tokenExpiry = Date.now() + (response.expires_in * 1000) - 60000;
                  localStorage.setItem('googleAccessToken', accessToken);
                  localStorage.setItem('googleTokenExpiry', tokenExpiry.toString());
                  gapi.client.setToken({ access_token: accessToken });
                  this.isSignedIn = true;
                  this.onSignInChange(true);
                },
              });
              
              // Check for saved token
              const savedToken = localStorage.getItem('googleAccessToken');
              const savedExpiry = localStorage.getItem('googleTokenExpiry');
              if (savedToken && savedExpiry && Date.now() < parseInt(savedExpiry)) {
                accessToken = savedToken;
                tokenExpiry = parseInt(savedExpiry);
                this.isSignedIn = true;
                // Set the token for gapi client
                gapi.client.setToken({ access_token: accessToken });
                this.onSignInChange(true);
              }
              
              resolve(true);
            } catch (e) { reject(e); }
          });
        });
      },
      async signIn() { tokenClient.requestAccessToken({ prompt: 'consent' }); },
      async signOut() { 
        if (accessToken) google.accounts.oauth2.revoke(accessToken);
        accessToken = null;
        tokenExpiry = null;
        localStorage.removeItem('googleAccessToken');
        localStorage.removeItem('googleTokenExpiry');
        this.isSignedIn = false;
        this.onSignInChange(false);
      },
      onSignInChange(s) {},
      
      async initializeSheets() {
        // Create headers if needed
        const fieldsCheck = await gapi.client.sheets.spreadsheets.values.get({ spreadsheetId: CONFIG.SHEET_ID, range: 'Fields!A1:E1' });
        if (!fieldsCheck.result.values || fieldsCheck.result.values.length === 0) {
          await gapi.client.sheets.spreadsheets.values.update({ spreadsheetId: CONFIG.SHEET_ID, range: 'Fields!A1:E1', valueInputOption: 'RAW', resource: { values: [['id', 'name', 'boundary', 'acres', 'created']] } });
        }
        const samplesCheck = await gapi.client.sheets.spreadsheets.values.get({ spreadsheetId: CONFIG.SHEET_ID, range: 'Samples!A1:Z1' });
        if (!samplesCheck.result.values || samplesCheck.result.values.length === 0) {
          await gapi.client.sheets.spreadsheets.values.update({ spreadsheetId: CONFIG.SHEET_ID, range: 'Samples!A1:W1', valueInputOption: 'RAW', resource: { values: [['sampleId', 'field', 'lat', 'lon', 'year', 'depth', 'pH', 'P', 'K', 'OM', 'Ca_sat', 'Mg_sat', 'K_Sat', 'H_Sat', 'Zn', 'Cu', 'Mn', 'Fe', 'Boron', 'S', 'CEC', 'Buffer_pH', 'yieldCorrelations']] } });
        }
      },
      
      async addField(field) {
        await gapi.client.sheets.spreadsheets.values.append({ spreadsheetId: CONFIG.SHEET_ID, range: 'Fields!A:E', valueInputOption: 'RAW', resource: { values: [[field.id || Date.now().toString(36), field.name, JSON.stringify(field.boundary), field.acres || 0, new Date().toISOString()]] } });
      },
      
      async addSamples(samples) {
        const headerRes = await gapi.client.sheets.spreadsheets.values.get({ spreadsheetId: CONFIG.SHEET_ID, range: 'Samples!A1:ZZ1' });
        const headers = headerRes.result.values?.[0] || [];
        const rows = samples.map(s => headers.map(h => { const v = s[h]; if (v === undefined || v === null) return ''; if (typeof v === 'object') return JSON.stringify(v); return v; }));
        await gapi.client.sheets.spreadsheets.values.append({ spreadsheetId: CONFIG.SHEET_ID, range: 'Samples!A:ZZ', valueInputOption: 'RAW', resource: { values: rows } });
      }
    };

    let sampleData = [], fieldBoundaries = {}, yieldData = [];
    let backupDownloadedThisSession = false;

    document.addEventListener('DOMContentLoaded', async () => {
      await loadLocalData(); updateSummary(); updateBackupStatus(); updateBackupFooter();
      try { await SheetsAPI.init(); SheetsAPI.onSignInChange = handleSignInChange; handleSignInChange(SheetsAPI.isSignedIn); } catch (e) { console.warn(e); }
      document.getElementById('uploadBoundaryBtn').addEventListener('click', uploadBoundaries);
      document.getElementById('uploadSampleBtn').addEventListener('click', uploadSamples);
      document.getElementById('uploadYieldBtn').addEventListener('click', uploadYield);
      document.getElementById('syncBtn').addEventListener('click', syncToSheets);
      document.getElementById('clearSamplesBtn').addEventListener('click', clearSamples);
      document.getElementById('clearBoundariesBtn').addEventListener('click', clearBoundaries);
      document.getElementById('clearYieldBtn').addEventListener('click', clearYieldData);
      document.getElementById('clearAllBtn').addEventListener('click', clearAllData);
      document.getElementById('reassignBtn').addEventListener('click', reassignSamplesToBoundaries);
      document.getElementById('exportCSVBtn').addEventListener('click', exportToCSV);
      document.getElementById('exportPDFBtn').addEventListener('click', exportToPDF);
      document.getElementById('exportJSONBtn').addEventListener('click', exportToJSON);
    });

    async function handleAuth() { if (SheetsAPI.isSignedIn) await SheetsAPI.signOut(); else await SheetsAPI.signIn(); }
    function handleSignInChange(isSignedIn) {
      const authBtn = document.getElementById('authBtn'), userInfo = document.getElementById('userInfo');
      if (isSignedIn) {
        userInfo.textContent = 'Connected';
        authBtn.textContent = '‚úì Signed In';
        authBtn.classList.add('signed-in');
      } else {
        userInfo.textContent = '';
        authBtn.textContent = 'Sign In to Sync';
        authBtn.classList.remove('signed-in');
      }
    }

    // IndexedDB for large datasets (localStorage has ~5MB limit)
    const DB_NAME = 'SoilAppDB';
    const DB_VERSION = 1;
    let indexedDBAvailable = false;

    function openDB() {
      return new Promise((resolve, reject) => {
        if (!window.indexedDB) {
          reject(new Error('IndexedDB not supported'));
          return;
        }
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => {
          indexedDBAvailable = true;
          resolve(request.result);
        };
        request.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains('samples')) {
            db.createObjectStore('samples', { keyPath: 'id' });
          }
          if (!db.objectStoreNames.contains('boundaries')) {
            db.createObjectStore('boundaries', { keyPath: 'id' });
          }
        };
      });
    }

    async function saveToIndexedDB() {
      try {
        const db = await openDB();
        const tx = db.transaction(['samples', 'boundaries'], 'readwrite');
        const samplesStore = tx.objectStore('samples');
        const boundariesStore = tx.objectStore('boundaries');

        // Clear and save samples
        await new Promise((resolve, reject) => {
          const clearReq = samplesStore.clear();
          clearReq.onsuccess = resolve;
          clearReq.onerror = reject;
        });
        await new Promise((resolve, reject) => {
          const putReq = samplesStore.put({ id: 'all', data: sampleData });
          putReq.onsuccess = resolve;
          putReq.onerror = reject;
        });

        // Clear and save boundaries
        await new Promise((resolve, reject) => {
          const clearReq = boundariesStore.clear();
          clearReq.onsuccess = resolve;
          clearReq.onerror = reject;
        });
        await new Promise((resolve, reject) => {
          const putReq = boundariesStore.put({ id: 'all', data: fieldBoundaries });
          putReq.onsuccess = resolve;
          putReq.onerror = reject;
        });

        db.close();
        localStorage.setItem('usingIndexedDB', 'true');
        console.log('Data saved to IndexedDB');
        return true;
      } catch (e) {
        console.error('IndexedDB save failed:', e);
        return false;
      }
    }

    async function loadFromIndexedDB() {
      try {
        const db = await openDB();
        const tx = db.transaction(['samples', 'boundaries'], 'readonly');
        const samplesStore = tx.objectStore('samples');
        const boundariesStore = tx.objectStore('boundaries');

        const samplesData = await new Promise((resolve, reject) => {
          const req = samplesStore.get('all');
          req.onsuccess = () => resolve(req.result?.data || []);
          req.onerror = reject;
        });

        const boundariesData = await new Promise((resolve, reject) => {
          const req = boundariesStore.get('all');
          req.onsuccess = () => resolve(req.result?.data || {});
          req.onerror = reject;
        });

        db.close();
        return { samples: samplesData, boundaries: boundariesData };
      } catch (e) {
        console.error('IndexedDB load failed:', e);
        return null;
      }
    }

    async function loadLocalData() {
      try {
        // Check if we're using IndexedDB
        if (localStorage.getItem('usingIndexedDB') === 'true') {
          const idbData = await loadFromIndexedDB();
          if (idbData && idbData.samples.length > 0) {
            sampleData = idbData.samples;
            fieldBoundaries = idbData.boundaries;
            console.log('Loaded from IndexedDB:', sampleData.length, 'samples');
            return;
          }
        }
        // Fallback to localStorage
        const s = localStorage.getItem('soilSamples');
        const b = localStorage.getItem('fieldBoundaries');
        if (s) sampleData = JSON.parse(s);
        if (b) fieldBoundaries = JSON.parse(b);
      } catch (e) {
        console.error('Load error:', e);
      }
    }

    async function saveLocalData() {
      // Try localStorage first (faster for small datasets)
      try {
        const dataStr = JSON.stringify(sampleData);
        const boundariesStr = JSON.stringify(fieldBoundaries);

        // Check if data is likely too large for localStorage (~4MB limit with safety margin)
        if (dataStr.length + boundariesStr.length > 4000000) {
          throw new Error('Data too large for localStorage');
        }

        localStorage.setItem('soilSamples', dataStr);
        localStorage.setItem('fieldBoundaries', boundariesStr);
        localStorage.removeItem('usingIndexedDB');
        console.log('Data saved to localStorage');
      } catch (e) {
        // localStorage quota exceeded or data too large - use IndexedDB
        console.log('localStorage quota exceeded, switching to IndexedDB...');
        const success = await saveToIndexedDB();
        if (success) {
          // Clear localStorage to free up space
          localStorage.removeItem('soilSamples');
          localStorage.removeItem('fieldBoundaries');
          showStatus('Data saved (using IndexedDB for large dataset)', true);
        } else {
          showStatus('Warning: Could not save data locally. Data is synced to Google Sheets.', false);
        }
      }
    }

    // ========== BACKUP SYSTEM ==========
    function saveBackup() {
      // Save full backup to localStorage (skip if data too large)
      try {
        const backup = {
          version: 1,
          timestamp: Date.now(),
          operationName: localStorage.getItem('operationName') || '',
          sampleData: sampleData,
          fieldBoundaries: fieldBoundaries,
          settings: JSON.parse(localStorage.getItem('soilSettings') || '{}')
        };
        const backupStr = JSON.stringify(backup);
        // Skip localStorage backup if too large - data is in IndexedDB/Sheets
        if (backupStr.length < 4000000) {
          localStorage.setItem('soilDataBackup', backupStr);
        } else {
          localStorage.removeItem('soilDataBackup'); // Clear old backup to free space
        }
        localStorage.setItem('soilDataBackupTime', Date.now().toString());
        updateBackupStatus();
      } catch (e) {
        console.log('Backup to localStorage skipped (data too large)');
        localStorage.setItem('soilDataBackupTime', Date.now().toString());
        updateBackupStatus();
      }
    }

    function updateBackupStatus() {
      const container = document.getElementById('backupStatus');
      const backupTime = localStorage.getItem('soilDataBackupTime');
      const lastDownload = localStorage.getItem('lastBackupDownload');
      const autoBackup = localStorage.getItem('autoBackupFrequency') || 'weekly';

      if (!backupTime && sampleData.length === 0) {
        container.style.background = '#f8fafc';
        container.style.border = '1px solid #e2e8f0';
        container.innerHTML = '<span style="color: #64748b;">No data to backup yet</span>';
        return;
      }

      const now = Date.now();
      const daysSinceBackup = backupTime ? Math.floor((now - parseInt(backupTime)) / (1000 * 60 * 60 * 24)) : null;
      const daysSinceDownload = lastDownload ? Math.floor((now - parseInt(lastDownload)) / (1000 * 60 * 60 * 24)) : null;

      let statusColor, statusBg, statusBorder, statusIcon, statusText;

      if (!lastDownload) {
        // Never downloaded a backup
        statusIcon = '‚ö†Ô∏è';
        statusText = 'No backup file downloaded yet';
        statusBg = '#fef2f2';
        statusBorder = '#fca5a5';
        statusColor = '#991b1b';
      } else if (daysSinceDownload > 30) {
        // Backup is old
        statusIcon = '‚ö†Ô∏è';
        statusText = `Last backup download: ${formatDate(parseInt(lastDownload))} (${daysSinceDownload} days ago)`;
        statusBg = '#fffbeb';
        statusBorder = '#fcd34d';
        statusColor = '#92400e';
      } else {
        // Backup is recent
        statusIcon = '‚úì';
        statusText = `Last backup download: ${formatDate(parseInt(lastDownload))}`;
        statusBg = '#f0fdf4';
        statusBorder = '#86efac';
        statusColor = '#166534';
      }

      container.style.background = statusBg;
      container.style.border = `1px solid ${statusBorder}`;
      container.innerHTML = `
        <span style="color: ${statusColor};">${statusIcon} ${statusText}</span>
        <span style="color: #64748b; font-size: 0.75rem;">Auto-backup: ${autoBackup}</span>
      `;

      // Check if we should prompt for auto-backup
      checkAutoBackupPrompt();
    }

    function checkAutoBackupPrompt() {
      const autoBackup = localStorage.getItem('autoBackupFrequency') || 'weekly';
      const lastDownload = localStorage.getItem('lastBackupDownload');
      const lastPrompt = localStorage.getItem('lastBackupPrompt');
      const now = Date.now();

      // Don't prompt more than once per session
      if (lastPrompt && (now - parseInt(lastPrompt)) < 1000 * 60 * 60) return;

      if (autoBackup === 'weekly' && sampleData.length > 0) {
        const daysSince = lastDownload ? Math.floor((now - parseInt(lastDownload)) / (1000 * 60 * 60 * 24)) : 999;
        if (daysSince >= 7) {
          localStorage.setItem('lastBackupPrompt', now.toString());
          if (confirm(`It's been ${daysSince === 999 ? 'a while' : daysSince + ' days'} since your last backup.\n\nDownload a backup now?`)) {
            exportToJSON();
          }
        }
      }
    }

    function formatDate(timestamp) {
      return new Date(timestamp).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
    }

    function exportToJSON() {
      if (sampleData.length === 0 && Object.keys(fieldBoundaries).length === 0) {
        showStatus('No data to export', false);
        return;
      }

      const backup = {
        version: 1,
        exportDate: new Date().toISOString(),
        operationName: localStorage.getItem('operationName') || 'SoilData',
        sampleData: sampleData,
        fieldBoundaries: fieldBoundaries,
        settings: JSON.parse(localStorage.getItem('soilSettings') || '{}'),
        columnAliases: JSON.parse(localStorage.getItem('columnAliases') || '{}'),
        nutrientVisibility: JSON.parse(localStorage.getItem('nutrientVisibility') || '{}')
      };

      const blob = new Blob([JSON.stringify(backup, null, 2)], { type: 'application/json' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      const opName = (backup.operationName || 'SoilData').replace(/[^a-zA-Z0-9]/g, '_');
      link.download = `${opName}_backup_${new Date().toISOString().split('T')[0]}.json`;
      link.click();

      // Record the download
      localStorage.setItem('lastBackupDownload', Date.now().toString());
      updateBackupStatus();
      showStatus(`‚úì Backup downloaded (${sampleData.length} samples, ${Object.keys(fieldBoundaries).length} fields)`, true);
    }

    // Call saveBackup after successful imports
    function afterImportSuccess() {
      saveLocalData();
      saveBackup();
      updateSummary();
      updateBackupStatus();
      updateBackupFooter();

      // Auto-download only once per session if setting is 'after-import'
      const autoBackup = localStorage.getItem('autoBackupFrequency');
      if (autoBackup === 'after-import' && !backupDownloadedThisSession) {
        backupDownloadedThisSession = true;
        setTimeout(() => exportToJSON(), 500);
      }
    }

    function updateSummary() {
      document.getElementById('fieldCount').textContent = Object.keys(fieldBoundaries).length;
      document.getElementById('sampleCount').textContent = sampleData.length;
      const uniqueYears = [...new Set(sampleData.map(s => s.year).filter(y => y))].sort((a, b) => a - b);
      document.getElementById('yearCount').textContent = uniqueYears.length;
      document.getElementById('yearList').textContent = uniqueYears.join(', ');
      // Count samples with yield correlations and get unique fields
      const samplesWithYield = sampleData.filter(s => s.yieldCorrelations && Object.keys(s.yieldCorrelations).length > 0);
      document.getElementById('yieldCount').textContent = samplesWithYield.length;
      const fieldsWithYield = [...new Set(samplesWithYield.map(s => s.field).filter(f => f && f !== 'Unknown'))].sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));
      document.getElementById('yieldFieldList').textContent = fieldsWithYield.length > 0 ? fieldsWithYield.join(', ') : '';
    }

    async function uploadBoundaries() {
      const files = Array.from(document.getElementById('boundaryFiles').files);
      const fieldName = document.getElementById('boundaryFieldName').value.trim();
      if (files.length === 0) { showStatus('Please select file(s)', false); return; }
      showStatus('Processing...', true);
      try {
        let total = 0;
        const shpFile = files.find(f => f.name.toLowerCase().endsWith('.shp'));
        const dbfFile = files.find(f => f.name.toLowerCase().endsWith('.dbf'));
        const isZip = files.length === 1 && files[0].name.toLowerCase().endsWith('.zip');
        const jsonFiles = files.filter(f => f.name.toLowerCase().match(/\.(geo)?json$/));
        
        if (isZip) {
          const arrayBuffer = await files[0].arrayBuffer();
          const geojson = await shp(arrayBuffer);
          const parsed = geojsonToBoundaries(geojson, fieldName);
          Object.assign(fieldBoundaries, parsed); total = Object.keys(parsed).length;
        } else if (shpFile && dbfFile) {
          const shpBuffer = await shpFile.arrayBuffer();
          const dbfBuffer = await dbfFile.arrayBuffer();
          const geojson = await shp({ shp: shpBuffer, dbf: dbfBuffer });
          const parsed = geojsonToBoundaries(geojson, fieldName);
          Object.assign(fieldBoundaries, parsed); total = Object.keys(parsed).length;
        } else if (jsonFiles.length > 0) {
          for (const file of jsonFiles) {
            const text = await file.text(), geojson = JSON.parse(text);
            const parsed = geojsonToBoundaries(geojson, fieldName || file.name.replace(/\.(geo)?json$/i, ''));
            Object.assign(fieldBoundaries, parsed); total += Object.keys(parsed).length;
          }
        } else {
          throw new Error('Please select a ZIP, Shapefile (.shp + .dbf), or GeoJSON');
        }
        
        afterImportSuccess(); showStatus(`‚úì Imported ${total} field(s)`, true);
        document.getElementById('boundaryFiles').value = ''; document.getElementById('boundaryFieldName').value = '';
        // Auto-sync to Google Sheets if signed in
        if (SheetsAPI.isSignedIn) {
          showStatus('Syncing to Google Sheets...', true);
          await syncToSheets();
        }
      } catch (e) { showStatus('Error: ' + e.message, false); console.error(e); }
    }

    function geojsonToBoundaries(geojson, defaultName) {
      const boundaries = {}, features = geojson.features || [geojson];
      
      // Debug: log the geojson structure
      console.log('GeoJSON structure:', geojson);
      console.log('Features count:', features.length);
      console.log('defaultName parameter:', defaultName);
      if (features[0]) console.log('First feature properties:', features[0].properties);
      
      features.forEach(f => {
        if (!f.geometry) return;
        const type = f.geometry.type;
        if (type !== 'Polygon' && type !== 'MultiPolygon') return;
        const props = f.properties || {};
        
        // Debug: log properties for each feature
        console.log('Feature properties:', props);
        console.log('props.FIELD_NAME value:', props.FIELD_NAME);
        console.log('props.FIELD_NAME truthy?:', !!props.FIELD_NAME);
        
        // Get field name - prioritize FIELD_NAME from properties FIRST (before defaultName)
        let fieldName = null;
        
        // First priority: FIELD_NAME in properties (exact match)
        if (props.FIELD_NAME) {
          fieldName = props.FIELD_NAME;
          console.log('Using props.FIELD_NAME:', fieldName);
        }
        else if (props.Field_Name) {
          fieldName = props.Field_Name;
          console.log('Using props.Field_Name:', fieldName);
        }
        else if (props.field_name) {
          fieldName = props.field_name;
          console.log('Using props.field_name:', fieldName);
        }
        // Second priority: user-provided default name
        else if (defaultName) {
          fieldName = defaultName;
          console.log('Using defaultName:', fieldName);
        }
        // Third priority: extract from compound names
        else {
          const rawName = props.name || props.Name || props.Field || props.field || geojson.name || 'Unknown';
          console.log('Falling back to rawName:', rawName);
          // Extract last part after underscore (e.g., "Precision Farms_Precision Farms_WCG" -> "WCG")
          if (rawName.includes('_')) {
            fieldName = rawName.split('_').pop();
          } else {
            fieldName = rawName;
          }
        }
        
        console.log('Final resolved field name:', fieldName);
        
        if (!boundaries[fieldName]) boundaries[fieldName] = [];
        if (type === 'Polygon') { boundaries[fieldName].push(f.geometry.coordinates[0].map(c => [c[1], c[0]])); }
        else { f.geometry.coordinates.forEach(poly => { boundaries[fieldName].push(poly[0].map(c => [c[1], c[0]])); }); }
      });
      return boundaries;
    }

    async function uploadSamples() {
      const files = Array.from(document.getElementById('sampleFiles').files);
      const yearInput = document.getElementById('sampleYear').value.trim();
      const depth = document.getElementById('sampleDepth').value.trim() || '6';

      // Validate required year
      if (!yearInput) { showStatus('Sample Year is required', false); return; }
      const year = parseInt(yearInput);
      if (isNaN(year) || year < 1900 || year > 2100) { showStatus('Please enter a valid year (e.g., 2024)', false); return; }

      if (files.length === 0) { showStatus('Please select file(s)', false); return; }
      showStatus('Processing...', true);
      try {
        let samples = [];
        const shpFile = files.find(f => f.name.toLowerCase().endsWith('.shp'));
        const dbfFile = files.find(f => f.name.toLowerCase().endsWith('.dbf'));
        const isZip = files.length === 1 && files[0].name.toLowerCase().endsWith('.zip');
        const csvFile = files.find(f => f.name.toLowerCase().endsWith('.csv'));
        const jsonFile = files.find(f => f.name.toLowerCase().match(/\.(geo)?json$/));
        
        if (isZip) {
          // Zip file - may contain multiple shapefiles
          const arrayBuffer = await files[0].arrayBuffer();
          const result = await shp(arrayBuffer);

          // shp() returns array if multiple shapefiles in zip, single object if one
          if (Array.isArray(result)) {
            console.log(`Found ${result.length} shapefiles in zip`);
            result.forEach((geojson, i) => {
              console.log(`Processing shapefile ${i + 1}: ${geojson.fileName || 'unnamed'}`);
              const fileSamples = geojsonToSamples(geojson, year, depth);
              samples = [...samples, ...fileSamples];
            });
          } else {
            samples = geojsonToSamples(result, year, depth);
          }
        } else if (shpFile && dbfFile) {
          // Multiple shapefile components - combine them
          const shpBuffer = await shpFile.arrayBuffer();
          const dbfBuffer = await dbfFile.arrayBuffer();
          const geojson = await shp({ shp: shpBuffer, dbf: dbfBuffer });
          samples = geojsonToSamples(geojson, year, depth);
        } else if (csvFile) {
          const text = await csvFile.text();
          samples = parseCSV(text, year, depth);
        } else if (jsonFile) {
          const text = await jsonFile.text();
          const geojson = JSON.parse(text);
          samples = geojsonToSamples(geojson, year, depth);
        } else {
          throw new Error('Please select a ZIP, Shapefile (.shp + .dbf), CSV, or GeoJSON');
        }
        
        if (samples.length === 0) throw new Error('No samples found in file');
        
        // Analyze columns for mapping
        const firstSampleProps = samples[0] || {};
        const analysis = analyzeColumns(firstSampleProps);
        
        // If there are unmatched columns, show the mapping modal
        if (analysis.unmatched.length > 0) {
          showMappingModal(samples, analysis);
          return; // Modal will call finishSampleImport when user confirms
        }
        
        // No unmatched columns - proceed directly
        await finishSampleImport(samples);
        
      } catch (e) { showStatus('Error: ' + e.message, false); console.error(e); }
    }
    
    async function finishSampleImport(samples) {
        // Prevent duplicates - check by sampleId + year + location (not field since it's assigned later)
        const existingKeys = new Set(sampleData.map(s => `${s.sampleId}-${s.year}-${s.lat?.toFixed(5)}-${s.lon?.toFixed(5)}`));
        const newSamples = samples.filter(s => !existingKeys.has(`${s.sampleId}-${s.year}-${s.lat?.toFixed(5)}-${s.lon?.toFixed(5)}`));

        if (newSamples.length === 0) {
          showStatus('All samples already exist (duplicates skipped)', false);
          return;
        }

        const skipped = samples.length - newSamples.length;
        sampleData = [...sampleData, ...newSamples];

        // Assign field names based on boundary GPS matching
        if (Object.keys(fieldBoundaries).length > 0) {
          assignSamplesToFields();
          const assignedCount = newSamples.filter(s => s.field && s.field !== 'Unassigned').length;
          const unassignedCount = newSamples.length - assignedCount;
          afterImportSuccess();
          let msg = `‚úì Imported ${newSamples.length} samples, ${assignedCount} assigned to fields`;
          if (unassignedCount > 0) msg += ` (${unassignedCount} unassigned - outside boundaries)`;
          if (skipped > 0) msg += ` (${skipped} duplicates skipped)`;
          showStatus(msg, true);
        } else {
          afterImportSuccess();
          showStatus(`‚úì Imported ${newSamples.length} samples. Upload boundaries to assign field names.${skipped > 0 ? ` (${skipped} duplicates skipped)` : ''}`, true);
        }
        document.getElementById('sampleFiles').value = ''; document.getElementById('sampleYear').value = '';
        // Auto-sync to Google Sheets if signed in
        if (SheetsAPI.isSignedIn) {
          showStatus('Syncing to Google Sheets...', true);
          await syncToSheets();
        }
    }

    // Standard fields we care about
    const STANDARD_FIELDS = ['pH', 'P', 'P2', 'K', 'OM', 'CEC', 'Ca_sat', 'Mg_sat', 'K_Sat', 'H_Sat', 'Na_Sat', 'Zn', 'Cu', 'Mn', 'Fe', 'Boron', 'S', 'Buffer_pH', 'Na', 'Ca', 'Mg', 'NO3', 'NH4', 'Soluble_Salts', 'EC'];
    
    // Default aliases (built-in)
    const DEFAULT_ALIASES = {
      'P': ['P', 'P (M3)', 'P_M3', 'Phosphorus', 'Bray_P1', 'Bray P1', 'Mehlich2_P', 'Mehlich P', 'M3P', 'Olsen P', 'P1', 'P ppm'],
      'P2': ['P2', 'Bray_P2', 'Bray P2', 'P2 ppm'],
      'pH': ['pH', 'pH (1_1)', 'pH_1_1', 'ph', 'Soil_pH', 'pH 1:1', 'pH_s', 'soil pH'],
      'K': ['K', 'K (M3)', 'K_M3', 'Potassium', 'ExchK', 'Exch K', 'Mehlich K', 'M3K', 'K ppm'],
      'OM': ['OM', 'OM (LOI)', 'OM_LOI', 'Organic_Matter', 'Organic Matter', 'O.M.', 'OM %', 'SOM'],
      'CEC': ['CEC', 'CEC (Calc)', 'CEC_Calc', 'CEC (Cal_1', 'CEC meq'],
      'Ca_sat': ['Ca_sat', 'BS-Ca', 'BS_Ca', 'Ca_Base_Sat', 'Ca_Sat', 'Ca %', 'Ca Sat', '% Ca'],
      'Mg_sat': ['Mg_sat', 'BS-Mg', 'BS_Mg', 'Mg_Base_Sat', 'Mg_Sat', 'Mg %', 'Mg Sat', '% Mg'],
      'K_Sat': ['K_Sat', 'BS-K', 'BS_K', 'K_Base_Sat', 'K %', 'K Sat', '% K'],
      'H_Sat': ['H_Sat', 'BS-H', 'BS_H', 'H_Base_Sat', 'H %', 'H Sat', '% H'],
      'Na_Sat': ['Na_Sat', 'BS-Na', 'BS_Na', 'Na_Base_Sat', 'Na %', 'Na Sat', '% Na'],
      'Zn': ['Zn', 'Zn (M3)', 'Zn_M3', 'Zinc', 'Mehlich Zn'],
      'Cu': ['Cu', 'Cu (M3)', 'Cu_M3', 'Copper', 'Mehlich Cu'],
      'Mn': ['Mn', 'Mn (M3)', 'Mn_M3', 'Manganese', 'Mehlich Mn'],
      'Fe': ['Fe', 'Fe (M3)', 'Fe_M3', 'Iron', 'Mehlich Fe'],
      'Boron': ['Boron', 'B (M3)', 'B_M3', 'B'],
      'S': ['S', 'S (M3)', 'S_M3', 'Sulfur', 'SO4', 'SO4-S'],
      'Buffer_pH': ['Buffer_pH', 'BpH', 'Buffer pH', 'SMP', 'SMP pH', 'Buffer'],
      'Na': ['Na', 'Sodium', 'Na (M3)', 'ExchNa', 'Exch Na'],
      'Ca': ['Ca', 'Calcium', 'Ca (M3)', 'ExchCa', 'Exch Ca'],
      'Mg': ['Mg', 'Magnesium', 'Mg (M3)', 'ExchMg', 'Exch Mg'],
      'NO3': ['NO3', 'NO3-N', 'Nitrate', 'Nitrate-N', 'N03'],
      'NH4': ['NH4', 'NH4-N', 'Ammonium', 'Ammonium-N'],
      'Soluble_Salts': ['Soluble_Salts', 'Soluble_Sal', 'Sol_Salts', 'Salts', 'SS'],
      'EC': ['EC', 'EC (1:1)', 'Electrical Conductivity']
    };
    
    // Get combined aliases (default + user-saved)
    function getAliases() {
      const saved = JSON.parse(localStorage.getItem('columnAliases') || '{}');
      const combined = JSON.parse(JSON.stringify(DEFAULT_ALIASES));
      
      for (const [standard, aliases] of Object.entries(saved)) {
        if (combined[standard]) {
          // Add user aliases to the beginning (higher priority)
          combined[standard] = [...new Set([...aliases, ...combined[standard]])];
        } else {
          combined[standard] = aliases;
        }
      }
      return combined;
    }
    
    // Save a new alias
    function saveAlias(standardField, alias) {
      const saved = JSON.parse(localStorage.getItem('columnAliases') || '{}');
      if (!saved[standardField]) saved[standardField] = [];
      if (!saved[standardField].includes(alias)) {
        saved[standardField].push(alias);
        localStorage.setItem('columnAliases', JSON.stringify(saved));
      }
    }
    
    // Match a column name to a standard field
    function matchColumn(colName) {
      const aliases = getAliases();
      const colLower = colName.toLowerCase().trim();
      
      for (const [standard, alts] of Object.entries(aliases)) {
        for (const alt of alts) {
          if (alt.toLowerCase() === colLower || colName === alt) {
            return standard;
          }
        }
      }
      return null;
    }
    
    // Analyze columns from file and categorize as matched/unmatched
    function analyzeColumns(sampleProps) {
      const columns = Object.keys(sampleProps);
      const matched = [];
      const unmatched = [];
      
      // System fields we don't need to map
      const systemFields = ['lat', 'lon', 'Lat', 'Lon', 'LAT', 'LON', 'latitude', 'longitude', 
                           'sampleId', 'SampleID', 'ID', 'ORG_ID', 'field', 'Field', 'FIELD_NAME',
                           'year', 'Year', 'CropYear', 'date', 'depth', 'Depth', 'DEPTH',
                           'name', 'Name', 'CLIENT_NAM', 'FARM_NAME', 'Field_Name', 'field_name',
                           'POLYGONTYP', 'CLIENT_ID', 'FARM_ID', 'FIELD_ID', 'geometry', 'type'];
      
      for (const col of columns) {
        if (systemFields.some(sf => sf.toLowerCase() === col.toLowerCase())) continue;
        
        const match = matchColumn(col);
        if (match) {
          matched.push({ fileCol: col, standardCol: match });
        } else {
          unmatched.push({ fileCol: col, standardCol: null });
        }
      }
      
      return { matched, unmatched };
    }
    
    // Pending import data (while modal is open)
    let pendingImportData = null;
    let pendingMappings = {};
    
    function showMappingModal(samples, analysis) {
      pendingImportData = samples;
      pendingMappings = {};
      
      const matchedDiv = document.getElementById('matchedColumns');
      const unmatchedDiv = document.getElementById('unmatchedColumns');
      
      // Show matched
      if (analysis.matched.length > 0) {
        matchedDiv.innerHTML = analysis.matched.map(m => `
          <div class="mapping-row matched">
            <span class="file-col">${m.fileCol}</span>
            <span class="arrow">‚Üí</span>
            <span class="matched-label">${m.standardCol}</span>
          </div>
        `).join('');
        document.getElementById('matchedSection').style.display = 'block';
      } else {
        document.getElementById('matchedSection').style.display = 'none';
      }
      
      // Show unmatched with dropdown
      if (analysis.unmatched.length > 0) {
        const options = ['(skip)', ...STANDARD_FIELDS].map(f => `<option value="${f}">${f}</option>`).join('');
        unmatchedDiv.innerHTML = analysis.unmatched.map(u => {
          // Initialize to skip by default
          pendingMappings[u.fileCol] = '(skip)';
          return `
          <div class="mapping-row unmatched">
            <span class="file-col">${u.fileCol}</span>
            <span class="arrow">‚Üí</span>
            <select onchange="pendingMappings['${u.fileCol}']=this.value">
              ${options}
            </select>
          </div>
        `}).join('');
        document.getElementById('unmatchedSection').style.display = 'block';
      } else {
        document.getElementById('unmatchedSection').style.display = 'none';
      }
      
      document.getElementById('mappingModal').classList.add('active');
    }
    
    function closeMappingModal() {
      document.getElementById('mappingModal').classList.remove('active');
      pendingImportData = null;
      pendingMappings = {};
    }
    
    async function proceedWithImport() {
      if (!pendingImportData) {
        showStatus('No data to import', false);
        return;
      }
      
      const saveAliases = document.getElementById('saveNewAliases').checked;
      
      // Apply mappings and save aliases if requested
      for (const [fileCol, standardCol] of Object.entries(pendingMappings)) {
        if (standardCol && standardCol !== '(skip)') {
          // Apply mapping to all samples
          pendingImportData.forEach(sample => {
            if (sample[fileCol] !== undefined && sample[standardCol] === undefined) {
              const num = parseFloat(sample[fileCol]);
              sample[standardCol] = isNaN(num) ? sample[fileCol] : num;
            }
          });
          
          // Save alias for future
          if (saveAliases) {
            saveAlias(standardCol, fileCol);
          }
        }
      }
      
      // Store samples before closing modal
      const samplesToImport = pendingImportData;
      
      closeMappingModal();
      
      // Continue with import
      try {
        await finishSampleImport(samplesToImport);
      } catch (e) {
        showStatus('Import error: ' + e.message, false);
        console.error(e);
      }
    }
    
    // Normalize column names from different data formats (using aliases)
    function normalizeNutrientData(sample) {
      const aliases = getAliases();
      
      for (const [standard, alternatives] of Object.entries(aliases)) {
        if (sample[standard] === undefined) {
          for (const alt of alternatives) {
            if (sample[alt] !== undefined && sample[alt] !== null && sample[alt] !== '') {
              const num = parseFloat(sample[alt]);
              sample[standard] = isNaN(num) ? sample[alt] : num;
              break;
            }
          }
        }
      }
      return sample;
    }

    function geojsonToSamples(geojson, assignedYear, assignedDepth) {
      const samples = [], features = geojson.features || [geojson];

      // Get shapefile name for fallback field name (from multi-file zips)
      const shapefileName = geojson.fileName || geojson.name || null;

      // Debug
      console.log('Sample GeoJSON:', geojson);
      console.log('Shapefile name:', shapefileName);
      if (features[0]) console.log('First sample properties:', features[0].properties);

      features.forEach((f, idx) => {
        if (!f.geometry || f.geometry.type !== 'Point') return;
        const [lon, lat] = f.geometry.coordinates, props = f.properties || {};

        // Field name will be assigned from boundary matching after import
        // Don't extract from file data - let assignSamplesToFields() handle it
        let fieldName = null;
        
        // Get depth from file or use assigned depth
        const fileDepth = props.Depth || props.depth || props.DEPTH || props.DepthUnits;
        
        const sample = { 
          sampleId: props.ORG_ID || props.SampleID || props.sampleId || props.Sample_ID || props.SAMPLE_ID || props.ID || (idx + 1), 
          field: fieldName, 
          lat, 
          lon, 
          year: assignedYear || parseYear(props.CropYear || props.Year || props.year || props.date),
          depth: assignedDepth || fileDepth || '6'
        };
        Object.entries(props).forEach(([k, v]) => { if (sample[k] === undefined && v !== null) { const n = parseFloat(v); sample[k] = isNaN(n) ? v : n; } });
        
        // Normalize nutrient column names
        normalizeNutrientData(sample);
        
        samples.push(sample);
      });
      return samples;
    }

    function parseCSV(text, assignedYear, assignedDepth) {
      const lines = text.trim().split('\n'); if (lines.length < 2) return [];
      const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, '')), samples = [];
      for (let i = 1; i < lines.length; i++) {
        const values = lines[i].split(',').map(v => v.trim().replace(/"/g, '')), sample = {};
        headers.forEach((h, idx) => { const v = values[idx]; if (v) { const n = parseFloat(v); sample[h] = isNaN(n) ? v : n; } });
        sample.lat = sample.lat || sample.Lat || sample.LAT; sample.lon = sample.lon || sample.Lon || sample.LON || sample.lng;
        sample.field = sample.field || sample.Field || 'Unknown'; sample.year = assignedYear || parseYear(sample.year || sample.Year);
        sample.depth = assignedDepth || sample.depth || sample.Depth || '6';
        sample.sampleId = sample.sampleId || sample.SampleID || sample.ID || i;
        if (sample.lat && sample.lon) samples.push(sample);
      }
      return samples;
    }

    function parseYear(d) { if (!d) return null; if (typeof d === 'number') return d >= 1900 && d <= 2099 ? d : null; const m = String(d).match(/\b(19|20)\d{2}\b/); return m ? parseInt(m[0]) : null; }

    function assignSamplesToFields() {
      sampleData.forEach(sample => {
        let assigned = false;

        // Always try to match sample to a boundary by GPS location
        for (const [name, polys] of Object.entries(fieldBoundaries)) {
          if (assigned) break;
          const arr = Array.isArray(polys[0]?.[0]) ? polys : [polys];
          for (const poly of arr) {
            if (isPointInOrNearPolygon([sample.lat, sample.lon], poly)) {
              sample.field = name;
              assigned = true;
              break;
            }
          }
        }

        // Mark as Unassigned if no boundary match
        if (!assigned) {
          sample.field = 'Unassigned';
        }
      });
    }
    
    function reassignSamplesToBoundaries() {
      if (Object.keys(fieldBoundaries).length === 0) {
        showStatus('No boundaries loaded. Upload boundaries first.', false);
        return;
      }
      
      let reassignedCount = 0;
      sampleData.forEach(sample => {
        const oldField = sample.field;
        let assigned = false;
        
        // Try to find a matching boundary
        for (const [name, polys] of Object.entries(fieldBoundaries)) {
          if (assigned) break;
          const arr = Array.isArray(polys[0]?.[0]) ? polys : [polys];
          for (const poly of arr) { 
            if (isPointInOrNearPolygon([sample.lat, sample.lon], poly)) { 
              if (sample.field !== name) {
                sample.field = name;
                reassignedCount++;
              }
              assigned = true;
              break;
            } 
          }
        }
      });
      
      if (reassignedCount > 0) {
        afterImportSuccess();
        showStatus(`‚úì Reassigned ${reassignedCount} samples to boundaries`, true);
        
        // Sync to Google Sheets if signed in
        if (SheetsAPI.isSignedIn) {
          syncToSheets();
        }
      } else {
        showStatus('All samples already assigned to correct boundaries', true);
      }
    }

    function isPointInOrNearPolygon(point, polygon) {
      const [lat, lon] = point; 
      let inside = false;
      const epsilon = 0.0001; // Larger buffer (~10 meters) for edge cases
      
      // First check: is point very close to any vertex?
      for (let i = 0; i < polygon.length; i++) {
        const [plat, plon] = polygon[i];
        if (Math.abs(lat - plat) < epsilon && Math.abs(lon - plon) < epsilon) {
          return true;
        }
      }
      
      // Second check: is point very close to any edge?
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const [lat1, lon1] = polygon[i], [lat2, lon2] = polygon[j];
        
        // Distance from point to line segment
        const dx = lat2 - lat1;
        const dy = lon2 - lon1;
        const len2 = dx * dx + dy * dy;
        
        if (len2 > 0) {
          let t = Math.max(0, Math.min(1, ((lat - lat1) * dx + (lon - lon1) * dy) / len2));
          const nearestLat = lat1 + t * dx;
          const nearestLon = lon1 + t * dy;
          const dist = Math.sqrt((lat - nearestLat) ** 2 + (lon - nearestLon) ** 2);
          if (dist < epsilon) {
            return true;
          }
        }
      }
      
      // Third check: standard ray casting for inside
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const [lat1, lon1] = polygon[i], [lat2, lon2] = polygon[j];
        if (((lon1 > lon) !== (lon2 > lon)) && (lat < (lat2 - lat1) * (lon - lon1) / (lon2 - lon1) + lat1)) {
          inside = !inside;
        }
      }
      return inside;
    }

    // ========== YIELD DATA FUNCTIONS ==========
    
    async function uploadYield() {
      const fileInput = document.getElementById('yieldFiles');
      const files = fileInput.files;
      const yieldYearInput = document.getElementById('yieldYear');
      let yieldYear = yieldYearInput.value.trim();
      const yieldCrop = document.getElementById('yieldCrop').value;
      const radiusFeet = parseInt(document.getElementById('yieldRadius').value);
      const statusEl = document.getElementById('yieldStatus');

      if (!files.length) { showStatus('Please select yield file(s)', false); return; }

      statusEl.innerHTML = '<span style="color: #3b82f6;">‚è≥ Processing yield data...</span>';

      try {
        let yieldPoints = [];
        let detectedYear = null;
        let filesProcessed = 0;
        let fileErrors = [];
        let totalPointsLoaded = 0;

        // Helper to add points without stack overflow (use push in batches)
        const addPoints = (newPoints) => {
          // Push in chunks to avoid stack issues with very large arrays
          const chunkSize = 10000;
          for (let i = 0; i < newPoints.length; i += chunkSize) {
            const chunk = newPoints.slice(i, i + chunkSize);
            for (const p of chunk) {
              yieldPoints.push(p);
            }
          }
          totalPointsLoaded += newPoints.length;
        };

        // Small delay to let browser breathe and update UI
        const breathe = () => new Promise(resolve => setTimeout(resolve, 10));

        // Check for ZIP files and loose shapefiles
        const zipFiles = Array.from(files).filter(f => f.name.toLowerCase().endsWith('.zip'));
        const shpFiles = Array.from(files).filter(f => f.name.toLowerCase().endsWith('.shp'));
        const dbfFiles = Array.from(files).filter(f => f.name.toLowerCase().endsWith('.dbf'));

        if (zipFiles.length > 1) {
          // BATCH MODE: Multiple ZIP files (one per field)
          const totalFiles = zipFiles.length;
          statusEl.innerHTML = `<span style="color: #3b82f6;">‚è≥ Processing ${totalFiles} yield files...</span>`;

          for (let i = 0; i < zipFiles.length; i++) {
            const zipFile = zipFiles[i];
            try {
              statusEl.innerHTML = `<span style="color: #3b82f6;">‚è≥ Processing file ${i + 1} of ${totalFiles}: ${zipFile.name}<br><small>${totalPointsLoaded.toLocaleString()} points loaded so far</small></span>`;
              await breathe(); // Let UI update
              const result = await parseYieldFromZip(zipFile);
              addPoints(result.points);
              if (result.detectedYear && !detectedYear) {
                detectedYear = result.detectedYear;
              }
              filesProcessed++;
            } catch (err) {
              console.warn(`Error processing ${zipFile.name}:`, err);
              fileErrors.push({ file: zipFile.name, error: err.message });
            }
            // Breathe every file to prevent blocking
            if (i % 5 === 4) await breathe();
          }

          statusEl.innerHTML = `<span style="color: #3b82f6;">‚è≥ Processed ${filesProcessed}/${totalFiles} files, ${totalPointsLoaded.toLocaleString()} points...</span>`;

        } else if (zipFiles.length === 1) {
          // Single ZIP file
          const result = await parseYieldFromZip(zipFiles[0]);
          addPoints(result.points);
          detectedYear = result.detectedYear;
          filesProcessed = 1;

        } else if (shpFiles.length > 1) {
          // BATCH MODE: Multiple loose .shp/.dbf pairs - group by base filename
          const totalFiles = shpFiles.length;
          statusEl.innerHTML = `<span style="color: #3b82f6;">‚è≥ Processing ${totalFiles} shapefiles...</span>`;

          // Create lookup for dbf files by base name
          const dbfByName = {};
          for (const dbf of dbfFiles) {
            const baseName = dbf.name.toLowerCase().replace('.dbf', '');
            dbfByName[baseName] = dbf;
          }

          for (let i = 0; i < shpFiles.length; i++) {
            const shpFile = shpFiles[i];
            const baseName = shpFile.name.toLowerCase().replace('.shp', '');
            const dbfFile = dbfByName[baseName];

            if (!dbfFile) {
              fileErrors.push({ file: shpFile.name, error: 'No matching .dbf file found' });
              continue;
            }

            try {
              statusEl.innerHTML = `<span style="color: #3b82f6;">‚è≥ Processing file ${i + 1} of ${totalFiles}: ${shpFile.name}<br><small>${totalPointsLoaded.toLocaleString()} points loaded so far</small></span>`;
              await breathe(); // Let UI update
              const shpBuffer = await shpFile.arrayBuffer();
              const dbfBuffer = await dbfFile.arrayBuffer();
              const result = parseYieldShapefile(shpBuffer, dbfBuffer);
              addPoints(result.points);
              if (result.detectedYear && !detectedYear) {
                detectedYear = result.detectedYear;
              }
              filesProcessed++;
            } catch (err) {
              console.warn(`Error processing ${shpFile.name}:`, err);
              fileErrors.push({ file: shpFile.name, error: err.message });
            }
            // Breathe every file to prevent blocking
            if (i % 5 === 4) await breathe();
          }

          statusEl.innerHTML = `<span style="color: #3b82f6;">‚è≥ Processed ${filesProcessed}/${totalFiles} shapefiles, ${totalPointsLoaded.toLocaleString()} points...</span>`;

        } else {
          // Single shapefile (loose files)
          const result = await parseYieldFromShapefiles(files);
          addPoints(result.points);
          detectedYear = result.detectedYear;
          filesProcessed = 1;
        }

        // Auto-fill year if detected from file and input is empty
        if (detectedYear && !yieldYear) {
          yieldYear = String(detectedYear);
          yieldYearInput.value = yieldYear;
          statusEl.innerHTML = `<span style="color: #3b82f6;">üìÖ Detected year ${detectedYear} from file</span><br>`;
        }

        // Still require year even after auto-detect attempt
        if (!yieldYear) {
          statusEl.innerHTML = '<span style="color: #ef4444;">‚ùå Please enter the crop year (could not auto-detect from file)</span>';
          return;
        }

        if (yieldPoints.length === 0) {
          statusEl.innerHTML = '<span style="color: #ef4444;">‚ùå No yield points found in files</span>';
          if (fileErrors.length > 0) {
            statusEl.innerHTML += `<br><span style="color: #f59e0b;">‚ö†Ô∏è ${fileErrors.length} file(s) had errors</span>`;
          }
          return;
        }

        // Add metadata to each point
        statusEl.innerHTML = `<span style="color: #3b82f6;">‚è≥ Adding metadata to ${yieldPoints.length.toLocaleString()} points...</span>`;
        await breathe();
        for (const p of yieldPoints) {
          p.year = parseInt(yieldYear);
          p.crop = yieldCrop;
        }

        // Store yield data - avoid spread operator for large arrays
        statusEl.innerHTML = `<span style="color: #3b82f6;">‚è≥ Filtering duplicates...</span>`;
        await breathe();
        const existingKeys = new Set(yieldData.map(y => `${y.lat}-${y.lon}-${y.year}`));
        const newPoints = [];
        for (const p of yieldPoints) {
          const key = `${p.lat}-${p.lon}-${p.year}`;
          if (!existingKeys.has(key)) {
            newPoints.push(p);
          }
        }
        // Add to yieldData without spread
        for (const p of newPoints) {
          yieldData.push(p);
        }

        statusEl.innerHTML = `<span style="color: #22c55e;">‚úì Loaded ${newPoints.length.toLocaleString()} yield points from ${filesProcessed} file(s)</span>`;

        // Now correlate with soil samples
        statusEl.innerHTML += '<br><span style="color: #3b82f6;">‚è≥ Correlating with soil samples...</span>';

        const correlationResults = await correlateYieldToSamples(yieldYear, radiusFeet);

        // Clear raw yield data after correlation - only keep correlated summary on samples
        yieldData = [];
        localStorage.removeItem('yieldData');

        afterImportSuccess();

        const yearInfo = detectedYear ? `üìÖ Auto-detected year: ${detectedYear}<br>` : '';
        const batchInfo = filesProcessed > 1 ? `üìÅ Processed ${filesProcessed} yield files<br>` : '';
        const matchRate = correlationResults.totalSamples > 0
          ? Math.round((correlationResults.samplesWithYield / correlationResults.totalSamples) * 100)
          : 0;
        const matchColor = matchRate === 100 ? '#22c55e' : (matchRate >= 80 ? '#f59e0b' : '#ef4444');

        let errorInfo = '';
        if (fileErrors.length > 0) {
          errorInfo = `<br><span style="color: #f59e0b;">‚ö†Ô∏è ${fileErrors.length} file(s) skipped due to errors</span>`;
        }

        statusEl.innerHTML = `
          <span style="color: #22c55e;">${yearInfo}${batchInfo}‚úì Processed ${newPoints.length.toLocaleString()} yield points</span>${errorInfo}<br>
          <span style="color: ${matchColor};">‚úì ${correlationResults.samplesWithYield} of ${correlationResults.totalSamples} soil samples have yield data (${matchRate}%)</span><br>
          <span style="color: #64748b; font-size: 0.85rem;">Avg ${correlationResults.avgYieldPointsPerSample} yield points per sample</span><br>
          <button onclick="showYieldSummary(lastYieldResults)" style="margin-top: 0.5rem; padding: 0.5rem 1rem; background: #f59e0b; color: white; border: none; border-radius: 0.25rem; cursor: pointer; font-weight: 600;">
            üìä View Import Summary
          </button>
        `;

        // Store results for later viewing
        lastYieldResults = correlationResults;

        fileInput.value = '';

      } catch (e) {
        console.error('Yield upload error:', e);
        statusEl.innerHTML = `<span style="color: #ef4444;">‚ùå Error: ${e.message}</span>`;
      }
    }
    
    async function parseYieldFromZip(zipFile) {
      const JSZip = window.JSZip || (await loadJSZip());
      const zip = await JSZip.loadAsync(zipFile);
      
      let shpFile, dbfFile;
      for (const [name, file] of Object.entries(zip.files)) {
        const lower = name.toLowerCase();
        if (lower.endsWith('.shp')) shpFile = file;
        if (lower.endsWith('.dbf')) dbfFile = file;
      }
      
      if (!shpFile || !dbfFile) throw new Error('ZIP must contain .shp and .dbf files');
      
      const shpBuffer = await shpFile.async('arraybuffer');
      const dbfBuffer = await dbfFile.async('arraybuffer');
      
      return parseYieldShapefile(shpBuffer, dbfBuffer);
    }
    
    async function parseYieldFromShapefiles(files) {
      const fileMap = {};
      for (const f of files) {
        const ext = f.name.split('.').pop().toLowerCase();
        fileMap[ext] = await f.arrayBuffer();
      }
      
      if (!fileMap.shp || !fileMap.dbf) throw new Error('Need both .shp and .dbf files');
      
      return parseYieldShapefile(fileMap.shp, fileMap.dbf);
    }
    
    function parseYieldShapefile(shpBuffer, dbfBuffer) {
      const points = [];
      
      // Parse DBF for attributes
      const dbfView = new DataView(dbfBuffer);
      const numRecords = dbfView.getUint32(4, true);
      const headerSize = dbfView.getUint16(8, true);
      const recordSize = dbfView.getUint16(10, true);
      
      // Helper to convert bytes to string without spread operator (avoids stack overflow)
      const bytesToString = (buffer, start, length) => {
        const bytes = new Uint8Array(buffer.slice(start, start + length));
        let str = '';
        for (let i = 0; i < bytes.length; i++) {
          if (bytes[i] === 0) break; // Stop at null terminator
          str += String.fromCharCode(bytes[i]);
        }
        return str.trim();
      };

      // Parse field descriptors
      const fields = [];
      let offset = 32;
      while (offset < headerSize - 1) {
        const fieldName = bytesToString(dbfBuffer, offset, 11);
        if (!fieldName) break;
        const fieldType = String.fromCharCode(dbfView.getUint8(offset + 11));
        const fieldLen = dbfView.getUint8(offset + 16);
        fields.push({ name: fieldName, type: fieldType, length: fieldLen });
        offset += 32;
      }
      
      // Find yield field - common names from JD and Climate
      const yieldFieldNames = ['VRYIELDVO', 'Yld_Vol_Dr', 'YLD_VOL_DR', 'YIELD', 'DryYield', 'Dry_Yield', 'YldVolDry', 'YldMassDry', 'VRYIELDMA', 'Yld_Mass_D'];
      let yieldField = fields.find(f => yieldFieldNames.includes(f.name));
      if (!yieldField) {
        // Try partial match
        yieldField = fields.find(f => f.name.toLowerCase().includes('yield') || f.name.toLowerCase().includes('yld'));
      }

      if (!yieldField) {
        console.warn('Available fields:', fields.map(f => f.name));
        throw new Error('Could not find yield field. Available: ' + fields.map(f => f.name).join(', '));
      }

      // Find date/time field to auto-detect year - common names from JD and Climate
      const dateFieldNames = ['TIMESTAMP', 'TimeStamp', 'IsoTime', 'ISOTIME', 'Date', 'DATE', 'HarvestDat', 'Time', 'TIME', 'DATETIME', 'DateTime', 'Harvest_Da', 'VRLOGTIME'];
      let dateField = fields.find(f => dateFieldNames.includes(f.name));
      if (!dateField) {
        // Try partial match for date/time fields
        dateField = fields.find(f => f.name.toLowerCase().includes('time') || f.name.toLowerCase().includes('date'));
      }

      // Also look for explicit year field
      const yearFieldNames = ['Year', 'YEAR', 'CropYear', 'CROPYEAR', 'Crop_Year'];
      let yearField = fields.find(f => yearFieldNames.includes(f.name));
      
      // Parse SHP for coordinates
      const shpView = new DataView(shpBuffer);
      let shpOffset = 100; // Skip header
      
      const records = [];
      while (shpOffset < shpBuffer.byteLength - 8) {
        const recordNum = shpView.getInt32(shpOffset, false);
        const contentLen = shpView.getInt32(shpOffset + 4, false) * 2;
        const shapeType = shpView.getInt32(shpOffset + 8, true);
        
        if (shapeType === 1 || shapeType === 11) { // Point or PointZ
          const x = shpView.getFloat64(shpOffset + 12, true); // Longitude
          const y = shpView.getFloat64(shpOffset + 20, true); // Latitude
          records.push({ lon: x, lat: y });
        }
        
        shpOffset += 8 + contentLen;
      }
      
      // Parse DBF records and match with coordinates
      let dbfOffset = headerSize;
      let detectedYear = null;

      for (let i = 0; i < Math.min(numRecords, records.length); i++) {
        dbfOffset++; // Skip deletion flag

        let fieldOffset = 0;
        let yieldValue = null;

        for (const field of fields) {
          const rawValue = bytesToString(dbfBuffer, dbfOffset + fieldOffset, field.length);

          if (field.name === yieldField.name) {
            yieldValue = parseFloat(rawValue);
          }

          // Try to detect year from first record with valid data
          if (detectedYear === null && rawValue) {
            // Check explicit year field first
            if (yearField && field.name === yearField.name) {
              const yr = parseInt(rawValue);
              if (yr >= 1990 && yr <= 2100) {
                detectedYear = yr;
              }
            }
            // Check date/time field
            else if (dateField && field.name === dateField.name) {
              // Try various date formats
              // ISO format: 2024-09-15T... or 2024/09/15
              const isoMatch = rawValue.match(/^(20\d{2}|19\d{2})[-\/]/);
              if (isoMatch) {
                detectedYear = parseInt(isoMatch[1]);
              }
              // US format: 09/15/2024 or 09-15-2024
              const usMatch = rawValue.match(/[-\/](20\d{2}|19\d{2})($|\s|T)/);
              if (!detectedYear && usMatch) {
                detectedYear = parseInt(usMatch[1]);
              }
              // Just year: 2024
              const yearOnly = rawValue.match(/^(20\d{2}|19\d{2})$/);
              if (!detectedYear && yearOnly) {
                detectedYear = parseInt(yearOnly[1]);
              }
            }
          }

          fieldOffset += field.length;
        }

        dbfOffset += recordSize - 1;

        if (records[i] && yieldValue && !isNaN(yieldValue) && yieldValue > 0) {
          points.push({
            lat: records[i].lat,
            lon: records[i].lon,
            yield: yieldValue
          });
        }
      }

      return { points, detectedYear };
    }
    
    async function correlateYieldToSamples(yieldYear, radiusFeet) {
      // SOIL-SAMPLE-CENTRIC LOGIC:
      // For each soil sample location, find all yield points within the radius
      // Calculate average yield from those points and assign to the sample
      // This answers: "For this soil sample location, what was the average yield?"

      // Convert feet to approximate degrees (at ~40¬∞ latitude)
      const radiusLatDeg = radiusFeet / 364000;
      const radiusLonDeg = radiusFeet / 288000;

      const yieldYear_int = parseInt(yieldYear);

      // Filter yield data for this year
      const yearYield = yieldData.filter(y => y.year === yieldYear_int);

      if (yearYield.length === 0) {
        return {
          totalSamples: sampleData.length,
          samplesWithYield: 0,
          samplesWithoutYield: sampleData.length,
          totalYieldPoints: 0,
          avgYieldPointsPerSample: 0,
          noYieldData: true,
          fieldStats: {},
          yieldYear: yieldYear_int,
          radiusFeet
        };
      }

      // Helper for async breathing
      const breathe = () => new Promise(resolve => setTimeout(resolve, 0));

      // Track results
      let samplesWithYieldCount = 0;
      let samplesWithoutYieldCount = 0;
      let totalYieldPointsMatched = 0;

      // Per-field tracking
      const fieldStats = {};

      // Get unique fields that have samples
      const fieldsWithSamples = [...new Set(sampleData.map(s => s.field).filter(f => f))];

      // Initialize field stats
      fieldsWithSamples.forEach(field => {
        const fieldSamples = sampleData.filter(s => s.field === field);
        const samplesByYear = {};
        fieldSamples.forEach(s => {
          const yr = parseInt(s.year);
          if (!isNaN(yr)) {
            samplesByYear[yr] = (samplesByYear[yr] || 0) + 1;
          }
        });

        fieldStats[field] = {
          totalSamples: fieldSamples.length,
          samplesWithYield: 0,
          samplesWithoutYield: 0,
          totalYieldPointsMatched: 0,
          sampleInventory: samplesByYear
        };
      });

      console.log('=== YIELD MATCHING (SOIL-SAMPLE-CENTRIC) ===');
      console.log(`Total soil samples: ${sampleData.length}`);
      console.log(`Total yield points for ${yieldYear_int}: ${yearYield.length}`);
      console.log(`Search radius: ${radiusFeet}ft`);

      // Process each soil sample - find nearby yield points
      for (let sIdx = 0; sIdx < sampleData.length; sIdx++) {
        const sample = sampleData[sIdx];

        if (!sample.lat || !sample.lon) continue;

        // Find all yield points within radius of this sample
        const nearbyYieldPoints = [];
        for (let yIdx = 0; yIdx < yearYield.length; yIdx++) {
          const yp = yearYield[yIdx];
          const latDiff = Math.abs(sample.lat - yp.lat);
          const lonDiff = Math.abs(sample.lon - yp.lon);
          if (latDiff <= radiusLatDeg && lonDiff <= radiusLonDeg) {
            nearbyYieldPoints.push(yp);
          }
        }

        const field = sample.field || 'Unknown';

        if (nearbyYieldPoints.length > 0) {
          // Calculate average yield from nearby points
          let totalYield = 0;
          for (const yp of nearbyYieldPoints) {
            totalYield += yp.yield;
          }
          const avgYield = totalYield / nearbyYieldPoints.length;

          // Store yield correlation on the sample
          if (!sample.yieldCorrelations) sample.yieldCorrelations = {};
          sample.yieldCorrelations[yieldYear_int] = {
            avgYield: Math.round(avgYield * 10) / 10,
            pointCount: nearbyYieldPoints.length,
            crop: nearbyYieldPoints[0].crop,
            radiusFt: radiusFeet
          };

          samplesWithYieldCount++;
          totalYieldPointsMatched += nearbyYieldPoints.length;

          if (fieldStats[field]) {
            fieldStats[field].samplesWithYield++;
            fieldStats[field].totalYieldPointsMatched += nearbyYieldPoints.length;
          }
        } else {
          samplesWithoutYieldCount++;
          if (fieldStats[field]) {
            fieldStats[field].samplesWithoutYield++;
          }
        }

        // Breathe every 100 samples to keep UI responsive
        if (sIdx % 100 === 99) await breathe();
      }

      // Calculate per-field match rates
      for (const field of Object.keys(fieldStats)) {
        const stats = fieldStats[field];
        stats.matchRate = stats.totalSamples > 0
          ? Math.round((stats.samplesWithYield / stats.totalSamples) * 100)
          : 0;
        stats.avgYieldPointsPerSample = stats.samplesWithYield > 0
          ? Math.round(stats.totalYieldPointsMatched / stats.samplesWithYield)
          : 0;
      }

      // Save updated samples
      saveLocalData();

      const avgYieldPointsPerSample = samplesWithYieldCount > 0
        ? Math.round(totalYieldPointsMatched / samplesWithYieldCount)
        : 0;

      console.log('=== YIELD MATCHING RESULTS ===');
      console.log(`Samples with yield data: ${samplesWithYieldCount}`);
      console.log(`Samples without yield data: ${samplesWithoutYieldCount}`);
      console.log(`Avg yield points per matched sample: ${avgYieldPointsPerSample}`);

      return {
        totalSamples: sampleData.length,
        samplesWithYield: samplesWithYieldCount,
        samplesWithoutYield: samplesWithoutYieldCount,
        totalYieldPoints: yearYield.length,
        totalYieldPointsMatched,
        avgYieldPointsPerSample,
        yieldYear: yieldYear_int,
        radiusFeet,
        fieldStats
      };
    }

    // Helper: check if point is inside polygon
    function pointInPolygon(point, polygon) {
      if (!polygon || polygon.length < 3) return false;
      const [lat, lon] = point;
      let inside = false;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const [yi, xi] = polygon[i];
        const [yj, xj] = polygon[j];
        if (((yi > lat) !== (yj > lat)) && (lon < (xj - xi) * (lat - yi) / (yj - yi) + xi)) {
          inside = !inside;
        }
      }
      return inside;
    }

    // ========== YIELD SUMMARY MODAL ==========
    let yieldSummaryMap = null;
    let lastYieldResults = null;

    function showYieldSummary(results) {
      lastYieldResults = results;
      const modal = document.getElementById('yieldSummaryModal');

      // Calculate match rate
      const matchRate = results.totalSamples > 0
        ? Math.round((results.samplesWithYield / results.totalSamples) * 100)
        : 0;
      const matchColor = matchRate === 100 ? '#16a34a' : (matchRate >= 80 ? '#d97706' : '#dc2626');

      // Clear any existing debug section from previous opens
      const existingDebug = document.getElementById('gpsDebugSection');
      if (existingDebug) existingDebug.remove();

      // Summary stats - soil-sample-centric
      document.getElementById('yieldSummaryStats').innerHTML = `
        <div style="text-align: center; padding: 0.5rem; background: white; border-radius: 0.375rem; border: 1px solid #e2e8f0;">
          <div style="font-size: 1.5rem; font-weight: 700; color: #1e293b;">${results.totalSamples.toLocaleString()}</div>
          <div style="font-size: 0.75rem; color: #64748b;">Total Samples</div>
        </div>
        <div style="text-align: center; padding: 0.5rem; background: white; border-radius: 0.375rem; border: 1px solid #22c55e;">
          <div style="font-size: 1.5rem; font-weight: 700; color: #16a34a;">${results.samplesWithYield.toLocaleString()}</div>
          <div style="font-size: 0.75rem; color: #64748b;">With Yield Data</div>
        </div>
        <div style="text-align: center; padding: 0.5rem; background: white; border-radius: 0.375rem; border: 1px solid ${results.samplesWithoutYield > 0 ? '#f59e0b' : '#e2e8f0'};">
          <div style="font-size: 1.5rem; font-weight: 700; color: ${results.samplesWithoutYield > 0 ? '#d97706' : '#64748b'};">${results.samplesWithoutYield.toLocaleString()}</div>
          <div style="font-size: 0.75rem; color: #64748b;">No Yield Nearby</div>
        </div>
        <div style="text-align: center; padding: 0.5rem; background: white; border-radius: 0.375rem; border: 1px solid #e2e8f0;">
          <div style="font-size: 1.5rem; font-weight: 700; color: #1e293b;">${results.avgYieldPointsPerSample}</div>
          <div style="font-size: 0.75rem; color: #64748b;">Avg Pts/Sample</div>
        </div>
      `;

      // Per-field breakdown
      const fieldRows = Object.entries(results.fieldStats)
        .filter(([field, stats]) => stats.totalSamples > 0)
        .sort((a, b) => a[0].localeCompare(b[0], undefined, { numeric: true }))
        .map(([field, stats]) => {
          const fieldMatchRate = stats.matchRate || 0;
          const isLowMatch = fieldMatchRate < 80;
          const rateColor = fieldMatchRate === 100 ? '#16a34a' : (isLowMatch ? '#dc2626' : '#d97706');
          const rateBg = fieldMatchRate === 100 ? '#f0fdf4' : (isLowMatch ? '#fef2f2' : '#fffbeb');

          // Sample inventory display
          const inventory = stats.sampleInventory || {};
          const invYears = Object.keys(inventory).map(Number).sort((a,b) => b - a);
          const invDisplay = invYears.length > 0
            ? invYears.map(y => `${y}: ${inventory[y]}`).join(', ')
            : '<span style="color:#dc2626;">None</span>';

          return `
            <tr style="border-bottom: 1px solid #e2e8f0; vertical-align: top;">
              <td style="padding: 0.75rem 0.5rem;">
                <div style="font-weight: 600;">${field}</div>
                <div style="font-size: 0.7rem; color: #64748b; margin-top: 0.25rem;">
                  Samples by year: ${invDisplay}
                </div>
              </td>
              <td style="padding: 0.75rem 0.5rem; text-align: center;">
                <div style="color: #1e293b; font-weight: 500;">${stats.totalSamples}</div>
                <div style="font-size: 0.7rem; color: #64748b;">samples</div>
              </td>
              <td style="padding: 0.75rem 0.5rem; text-align: center;">
                <div style="color: #16a34a; font-weight: 500;">${stats.samplesWithYield}</div>
                <div style="font-size: 0.7rem; color: #64748b;">with yield</div>
              </td>
              <td style="padding: 0.75rem 0.5rem; text-align: center;">
                <span style="background: ${rateBg}; color: ${rateColor}; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-weight: 600;">
                  ${fieldMatchRate}%
                </span>
              </td>
              <td style="padding: 0.75rem 0.5rem; text-align: center;">
                <div style="color: #64748b;">${stats.avgYieldPointsPerSample || 0}</div>
                <div style="font-size: 0.7rem; color: #64748b;">pts/sample</div>
              </td>
            </tr>
          `;
        }).join('');

      document.getElementById('yieldTabFields').innerHTML = `
        <div style="margin-bottom: 1rem; padding: 0.75rem; background: #eff6ff; border-radius: 0.375rem; border: 1px solid #bfdbfe;">
          <div style="font-weight: 600; color: #1e40af; margin-bottom: 0.5rem;">How Yield Matching Works</div>
          <div style="font-size: 0.8rem; color: #1e40af;">
            For each <strong>soil sample location</strong>, we find all yield points within <strong>${results.radiusFeet}ft</strong> and calculate the average yield.<br>
            Samples with no yield points nearby will show "No Yield Nearby" - this means no harvester passed within ${results.radiusFeet}ft of that sample location.
          </div>
        </div>
        <table style="width: 100%; border-collapse: collapse; font-size: 0.875rem;">
          <thead>
            <tr style="background: #f8fafc; border-bottom: 2px solid #e2e8f0;">
              <th style="padding: 0.5rem; text-align: left;">Field</th>
              <th style="padding: 0.5rem; text-align: center;">Samples</th>
              <th style="padding: 0.5rem; text-align: center;">With Yield</th>
              <th style="padding: 0.5rem; text-align: center;">Match %</th>
              <th style="padding: 0.5rem; text-align: center;">Avg Pts</th>
            </tr>
          </thead>
          <tbody>${fieldRows}</tbody>
        </table>
        <div style="margin-top: 1rem; padding: 0.75rem; background: #f8fafc; border-radius: 0.375rem; font-size: 0.8125rem; color: #64748b;">
          <strong>Import Settings:</strong> Yield Year ${results.yieldYear}, Search Radius ${results.radiusFeet}ft, ${results.totalYieldPoints.toLocaleString()} yield points available
        </div>
      `;

      // Samples without yield - show which fields have gaps
      const fieldsWithGaps = Object.entries(results.fieldStats)
        .filter(([_, stats]) => stats.samplesWithoutYield > 0)
        .sort((a, b) => b[1].samplesWithoutYield - a[1].samplesWithoutYield);

      if (fieldsWithGaps.length > 0) {
        let gapsHtml = `
          <div style="margin-bottom: 1rem; padding: 0.75rem; background: #fef3c7; border-radius: 0.375rem; border: 1px solid #fcd34d;">
            <strong style="color: #92400e;">${results.samplesWithoutYield} soil samples</strong>
            <span style="color: #92400e;"> have no yield data within ${results.radiusFeet}ft</span>
          </div>
          <div style="font-size: 0.875rem; color: #64748b; margin-bottom: 0.75rem;">
            This typically means the harvester didn't pass close enough to these sample locations, or yield data wasn't uploaded for that field.
          </div>
          <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
        `;
        fieldsWithGaps.forEach(([field, stats]) => {
          gapsHtml += `
            <span style="background: #fef3c7; border: 1px solid #fcd34d; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-size: 0.8rem;">
              ${field}: ${stats.samplesWithoutYield} samples
            </span>
          `;
        });
        gapsHtml += '</div>';
        document.getElementById('yieldTabUnmatched').innerHTML = gapsHtml;
      } else {
        document.getElementById('yieldTabUnmatched').innerHTML = `
          <div style="text-align: center; padding: 2rem; color: #16a34a;">
            <div style="font-size: 2rem;">‚úì</div>
            <div style="font-weight: 600;">All soil samples have yield data nearby!</div>
          </div>
        `;
      }

      modal.classList.add('active');

      // Reset to first tab
      switchYieldTab('fields');
    }

    function switchYieldTab(tab) {
      // Update tab buttons
      document.querySelectorAll('.yield-tab').forEach(btn => {
        const isActive = btn.dataset.tab === tab;
        btn.style.background = isActive ? 'white' : '#f8fafc';
        btn.style.fontWeight = isActive ? '600' : '500';
        btn.style.borderBottom = isActive ? '2px solid #f59e0b' : '2px solid transparent';
      });

      // Show/hide content
      document.getElementById('yieldTabFields').style.display = tab === 'fields' ? 'block' : 'none';
      document.getElementById('yieldTabUnmatched').style.display = tab === 'unmatched' ? 'block' : 'none';
      document.getElementById('yieldTabMap').style.display = tab === 'map' ? 'block' : 'none';

      // Initialize map if switching to map tab
      if (tab === 'map' && lastYieldResults) {
        setTimeout(() => initYieldSummaryMap(), 100);
      }
    }

    function initYieldSummaryMap() {
      const mapContainer = document.getElementById('yieldMatchMap');

      // Destroy existing map if any
      if (yieldSummaryMap) {
        yieldSummaryMap.remove();
        yieldSummaryMap = null;
      }

      // Create map
      yieldSummaryMap = L.map(mapContainer).setView([40, -95], 4);
      L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        attribution: '¬© Esri'
      }).addTo(yieldSummaryMap);

      const allMarkers = [];
      const ageCounts = { sameYear: 0, oneYear: 0, twoThree: 0, stale: 0, noYield: 0 };

      // Add samples colored by sample age at harvest time
      sampleData.forEach((sample, idx) => {
        if (!sample.lat || !sample.lon) return;

        const yieldCorr = sample.yieldCorrelations && sample.yieldCorrelations[lastYieldResults.yieldYear];
        let color, fillColor, ageLabel;

        if (yieldCorr) {
          const age = yieldCorr.sampleAge || 0;
          if (age === 0) {
            color = '#166534'; fillColor = '#86efac'; ageLabel = 'Same year';
            ageCounts.sameYear++;
          } else if (age === 1) {
            color = '#1e40af'; fillColor = '#93c5fd'; ageLabel = '1 year prior';
            ageCounts.oneYear++;
          } else if (age <= 3) {
            color = '#92400e'; fillColor = '#fcd34d'; ageLabel = `${age} years prior`;
            ageCounts.twoThree++;
          } else {
            color = '#dc2626'; fillColor = '#fca5a5'; ageLabel = `${age} years (stale)`;
            ageCounts.stale++;
          }
        } else {
          color = '#64748b'; fillColor = '#cbd5e1'; ageLabel = 'No yield data';
          ageCounts.noYield++;
        }

        const marker = L.circleMarker([sample.lat, sample.lon], {
          radius: 6,
          fillColor: fillColor,
          color: color,
          weight: 2,
          opacity: 1,
          fillOpacity: 0.8
        });

        const yieldInfo = yieldCorr ? `<br>Yield: ${yieldCorr.avgYield}<br>Sample Age: ${ageLabel}` : '';
        marker.bindPopup(`<b>${sample.field}</b><br>Sample ${sample.sampleId || idx} (${sample.year})${yieldInfo}`);
        marker.addTo(yieldSummaryMap);
        allMarkers.push(marker);
      });

      // Add field boundaries
      for (const [name, coords] of Object.entries(fieldBoundaries)) {
        if (coords && coords.length > 2) {
          L.polygon(coords, {
            color: '#3b82f6',
            weight: 2,
            fillOpacity: 0.1
          }).addTo(yieldSummaryMap);
        }
      }

      // Fit to bounds
      if (allMarkers.length > 0) {
        const group = L.featureGroup(allMarkers);
        yieldSummaryMap.fitBounds(group.getBounds().pad(0.1));
      }

      // Add legend showing sample age colors
      const legend = L.control({ position: 'bottomright' });
      legend.onAdd = function() {
        const div = L.DomUtil.create('div', 'info legend');
        div.style.background = 'white';
        div.style.padding = '8px 12px';
        div.style.borderRadius = '4px';
        div.style.boxShadow = '0 1px 4px rgba(0,0,0,0.2)';
        div.style.fontSize = '11px';
        div.innerHTML = `
          <div style="font-weight:600;margin-bottom:4px;">Sample Age at Harvest</div>
          <div style="margin-bottom:2px;"><span style="display:inline-block;width:10px;height:10px;background:#86efac;border:2px solid #166534;border-radius:50%;margin-right:4px;"></span>Same year (${ageCounts.sameYear})</div>
          <div style="margin-bottom:2px;"><span style="display:inline-block;width:10px;height:10px;background:#93c5fd;border:2px solid #1e40af;border-radius:50%;margin-right:4px;"></span>1 year (${ageCounts.oneYear})</div>
          <div style="margin-bottom:2px;"><span style="display:inline-block;width:10px;height:10px;background:#fcd34d;border:2px solid #92400e;border-radius:50%;margin-right:4px;"></span>2-3 years (${ageCounts.twoThree})</div>
          <div style="margin-bottom:2px;"><span style="display:inline-block;width:10px;height:10px;background:#fca5a5;border:2px solid #dc2626;border-radius:50%;margin-right:4px;"></span>4+ stale (${ageCounts.stale})</div>
          <div><span style="display:inline-block;width:10px;height:10px;background:#cbd5e1;border:2px solid #64748b;border-radius:50%;margin-right:4px;"></span>No yield (${ageCounts.noYield})</div>
        `;
        return div;
      };
      legend.addTo(yieldSummaryMap);
    }

    function closeYieldSummary() {
      document.getElementById('yieldSummaryModal').classList.remove('active');
      if (yieldSummaryMap) {
        yieldSummaryMap.remove();
        yieldSummaryMap = null;
      }
    }

    async function loadJSZip() {
      // JSZip should already be loaded from earlier script
      if (window.JSZip) return window.JSZip;
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
        script.onload = () => resolve(window.JSZip);
        script.onerror = reject;
        document.head.appendChild(script);
      });
    }

    async function syncToSheets() {
      if (!SheetsAPI.isSignedIn) { showStatus('Please sign in first', false); return; }
      showStatus('Syncing to Google Sheets...', true);
      try {
        await SheetsAPI.initializeSheets();

        // Clear existing data first, then write fresh (prevents duplicates)
        await clearSheetsData('Fields');
        await clearSheetsData('Samples');

        // Write fields
        if (Object.keys(fieldBoundaries).length > 0) {
          const fieldRows = Object.entries(fieldBoundaries).map(([name, boundary]) => [
            Date.now().toString(36) + Math.random().toString(36).substr(2, 5),
            name,
            JSON.stringify(boundary),
            0,
            new Date().toISOString()
          ]);
          await gapi.client.sheets.spreadsheets.values.append({
            spreadsheetId: CONFIG.SHEET_ID,
            range: 'Fields!A:E',
            valueInputOption: 'RAW',
            resource: { values: fieldRows }
          });
        }

        // Write samples
        if (sampleData.length > 0) {
          const headerRes = await gapi.client.sheets.spreadsheets.values.get({
            spreadsheetId: CONFIG.SHEET_ID,
            range: 'Samples!A1:ZZ1'
          });
          let headers = headerRes.result.values?.[0] || [];

          // Ensure yieldCorrelations column exists in headers
          if (!headers.includes('yieldCorrelations')) {
            headers.push('yieldCorrelations');
            // Update header row to include new column
            await gapi.client.sheets.spreadsheets.values.update({
              spreadsheetId: CONFIG.SHEET_ID,
              range: 'Samples!A1:' + String.fromCharCode(65 + headers.length - 1) + '1',
              valueInputOption: 'RAW',
              resource: { values: [headers] }
            });
            console.log('Added yieldCorrelations column to Sheet headers');
          }

          // Debug: check how many samples have yield data
          const samplesWithYield = sampleData.filter(s => s.yieldCorrelations && Object.keys(s.yieldCorrelations).length > 0);
          console.log(`Syncing ${sampleData.length} samples, ${samplesWithYield.length} with yield data`);
          if (samplesWithYield.length > 0) {
            console.log('Sample yield data example:', JSON.stringify(samplesWithYield[0].yieldCorrelations));
          }

          const rows = sampleData.map(s => headers.map(h => {
            const v = s[h];
            if (v === undefined || v === null) return '';
            if (typeof v === 'object') return JSON.stringify(v);
            return v;
          }));

          await gapi.client.sheets.spreadsheets.values.append({
            spreadsheetId: CONFIG.SHEET_ID,
            range: 'Samples!A:ZZ',
            valueInputOption: 'RAW',
            resource: { values: rows }
          });
        }

        const samplesWithYield = sampleData.filter(s => s.yieldCorrelations && Object.keys(s.yieldCorrelations).length > 0).length;
        showStatus(`‚úì Synced ${Object.keys(fieldBoundaries).length} fields, ${sampleData.length} samples (${samplesWithYield} with yield)`, true);
      } catch (e) { showStatus('Sync error: ' + e.message, false); console.error(e); }
    }

    async function clearSamples() {
      if (!confirm('Clear all samples? Boundaries will be kept.')) return;

      sampleData = [];
      saveLocalData();
      saveBackup();
      updateSummary();
      updateBackupStatus();

      if (SheetsAPI.isSignedIn) {
        showStatus('Clearing from Google Sheets...', true);
        try {
          await clearSheetsData('Samples');
          showStatus('‚úì Samples cleared', true);
        } catch (e) {
          showStatus('Local cleared, but Sheets error: ' + e.message, false);
        }
      } else {
        showStatus('‚úì Samples cleared', true);
      }
    }

    async function clearBoundaries() {
      if (!confirm('Clear all field boundaries? Samples will be kept.')) return;

      fieldBoundaries = {};
      saveLocalData();
      saveBackup();
      updateSummary();
      updateBackupStatus();

      if (SheetsAPI.isSignedIn) {
        showStatus('Clearing from Google Sheets...', true);
        try {
          await clearSheetsData('Fields');
          showStatus('‚úì Boundaries cleared', true);
        } catch (e) {
          showStatus('Local cleared, but Sheets error: ' + e.message, false);
        }
      } else {
        showStatus('‚úì Boundaries cleared', true);
      }
    }

    async function clearYieldData() {
      if (!confirm('Clear all yield correlations from samples?')) return;

      // Remove yield correlations from all samples
      sampleData.forEach(s => {
        if (s.yieldCorrelations) delete s.yieldCorrelations;
      });

      saveLocalData();
      saveBackup();
      updateSummary();
      updateBackupStatus();
      showStatus('‚úì Yield correlations cleared', true);
    }

    async function clearAllData() {
      if (!confirm('Clear ALL data (samples, boundaries, and yield)?')) return;

      sampleData = [];
      fieldBoundaries = {};
      saveLocalData();
      saveBackup();
      updateSummary();
      updateBackupStatus();

      if (SheetsAPI.isSignedIn) {
        showStatus('Clearing from Google Sheets...', true);
        try {
          await clearSheetsData('Samples');
          await clearSheetsData('Fields');
          showStatus('‚úì All data cleared', true);
        } catch (e) {
          showStatus('Local cleared, but Sheets error: ' + e.message, false);
        }
      } else {
        showStatus('‚úì All data cleared', true);
      }
    }
    
    async function clearSheetsData(sheetName) {
      // Get the last row with data
      const response = await gapi.client.sheets.spreadsheets.values.get({
        spreadsheetId: CONFIG.SHEET_ID,
        range: `${sheetName}!A:A`
      });
      const numRows = response.result.values ? response.result.values.length : 1;
      
      if (numRows > 1) {
        // Clear all data rows (keep header row 1)
        await gapi.client.sheets.spreadsheets.values.clear({
          spreadsheetId: CONFIG.SHEET_ID,
          range: `${sheetName}!A2:ZZ${numRows}`
        });
      }
    }

    // ========== EXPORT FUNCTIONS ==========
    function getVisibleNutrients() {
      const saved = JSON.parse(localStorage.getItem('nutrientVisibility') || '{}');
      const defaultVisible = ['sampleId', 'pH', 'P', 'K', 'OM', 'CEC', 'Ca_sat', 'Mg_sat', 'K_Sat', 'H_Sat', 'Zn', 'Cu', 'Mn', 'Fe', 'Boron', 'S', 'Buffer_pH'];
      const allNutrients = ['sampleId', 'pH', 'P', 'K', 'OM', 'CEC', 'Ca_sat', 'Mg_sat', 'K_Sat', 'H_Sat', 'Zn', 'Cu', 'Mn', 'Fe', 'Boron', 'S', 'Buffer_pH', 'P2', 'Na_Sat', 'Na', 'Ca', 'Mg', 'NO3', 'NH4', 'Soluble_Salts', 'EC'];
      return allNutrients.filter(n => saved[n] !== undefined ? saved[n] : defaultVisible.includes(n));
    }

    function exportToCSV() {
      if (sampleData.length === 0) {
        showStatus('No sample data to export', false);
        return;
      }

      const visibleNutrients = getVisibleNutrients();
      const operationName = localStorage.getItem('operationName') || 'SoilData';

      // Build headers: base fields + visible nutrients + yield columns
      const headers = ['Field', 'Year', 'Lat', 'Lon', 'Depth', ...visibleNutrients, 'Yield_Year', 'Yield_Avg', 'Yield_Crop', 'Yield_Points'];

      // Build rows
      const rows = sampleData.map(sample => {
        const row = [
          sample.field || '',
          sample.year || '',
          sample.lat || '',
          sample.lon || '',
          sample.depth || '',
          ...visibleNutrients.map(n => sample[n] !== undefined ? sample[n] : ''),
        ];

        // Add yield data if available
        if (sample.yieldCorrelations && Object.keys(sample.yieldCorrelations).length > 0) {
          const yieldYears = Object.keys(sample.yieldCorrelations);
          const latestYear = yieldYears.sort().pop();
          const yieldInfo = sample.yieldCorrelations[latestYear];
          row.push(latestYear, yieldInfo.avgYield?.toFixed(1) || '', yieldInfo.crop || '', yieldInfo.pointCount || '');
        } else {
          row.push('', '', '', '');
        }

        return row;
      });

      // Create CSV content
      const csvContent = [headers, ...rows]
        .map(row => row.map(cell => {
          const str = String(cell);
          if (str.includes(',') || str.includes('"') || str.includes('\n')) {
            return '"' + str.replace(/"/g, '""') + '"';
          }
          return str;
        }).join(','))
        .join('\n');

      // Download
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = `${operationName}_samples_${new Date().toISOString().split('T')[0]}.csv`;
      link.click();

      showStatus(`‚úì Exported ${sampleData.length} samples to CSV`, true);
    }

    function exportToPDF() {
      if (sampleData.length === 0) {
        showStatus('No sample data to export', false);
        return;
      }

      const visibleNutrients = getVisibleNutrients();
      const operationName = localStorage.getItem('operationName') || 'Soil Analysis';
      const fields = [...new Set(sampleData.map(s => s.field))].filter(f => f);
      const years = [...new Set(sampleData.map(s => s.year))].filter(y => y).sort();

      // Create printable HTML
      const printWindow = window.open('', '_blank');
      printWindow.document.write(`
        <!DOCTYPE html>
        <html>
        <head>
          <title>${operationName} - Sample Data Report</title>
          <style>
            body { font-family: Arial, sans-serif; padding: 20px; font-size: 11px; }
            h1 { color: #1e293b; border-bottom: 2px solid #3b82f6; padding-bottom: 10px; }
            h2 { color: #334155; margin-top: 20px; }
            .summary { display: flex; gap: 20px; margin: 20px 0; }
            .summary-box { background: #f1f5f9; padding: 15px; border-radius: 8px; text-align: center; }
            .summary-box .number { font-size: 24px; font-weight: bold; color: #3b82f6; }
            .summary-box .label { color: #64748b; font-size: 12px; }
            table { width: 100%; border-collapse: collapse; margin: 15px 0; font-size: 10px; }
            th { background: #1e293b; color: white; padding: 8px 4px; text-align: left; }
            td { padding: 6px 4px; border-bottom: 1px solid #e2e8f0; }
            tr:nth-child(even) { background: #f8fafc; }
            .footer { margin-top: 30px; color: #94a3b8; font-size: 10px; text-align: center; }
            @media print { body { padding: 0; } }
          </style>
        </head>
        <body>
          <h1>${operationName} - Sample Data Report</h1>
          <p>Generated: ${new Date().toLocaleString()}</p>

          <div class="summary">
            <div class="summary-box"><div class="number">${sampleData.length}</div><div class="label">Total Samples</div></div>
            <div class="summary-box"><div class="number">${fields.length}</div><div class="label">Fields</div></div>
            <div class="summary-box"><div class="number">${years.join(', ') || 'N/A'}</div><div class="label">Years</div></div>
            <div class="summary-box"><div class="number">${sampleData.filter(s => s.yieldCorrelations && Object.keys(s.yieldCorrelations).length > 0).length}</div><div class="label">With Yield</div></div>
          </div>

          <h2>Sample Data</h2>
          <table>
            <thead>
              <tr>
                <th>Field</th>
                <th>Year</th>
                ${visibleNutrients.slice(0, 12).map(n => `<th>${n}</th>`).join('')}
                <th>Yield</th>
              </tr>
            </thead>
            <tbody>
              ${sampleData.map(s => `
                <tr>
                  <td>${s.field || ''}</td>
                  <td>${s.year || ''}</td>
                  ${visibleNutrients.slice(0, 12).map(n => `<td>${s[n] !== undefined ? (typeof s[n] === 'number' ? formatValue(s[n], n) : s[n]) : ''}</td>`).join('')}
                  <td>${s.yieldCorrelations ? Object.values(s.yieldCorrelations)[0]?.avgYield?.toFixed(0) || '' : ''}</td>
                </tr>
              `).join('')}
            </tbody>
          </table>

          <div class="footer">
            Soil Sample Analysis App ‚Ä¢ ${window.location.hostname}
          </div>
        </body>
        </html>
      `);
      printWindow.document.close();
      printWindow.print();

      showStatus('‚úì PDF report opened for printing', true);
    }

    function showStatus(msg, isSuccess) { const el = document.getElementById('statusMessage'); el.textContent = msg; el.style.display = 'block'; el.style.background = isSuccess ? '#dcfce7' : '#fee2e2'; el.style.color = isSuccess ? '#166534' : '#991b1b'; setTimeout(() => el.style.display = 'none', 4000); }

    function updateBackupFooter() {
      const backupTime = localStorage.getItem('soilDataBackupTime');
      const footer = document.getElementById('backupFooter');
      const buildDate = new Date(BUILD_DATE);
      const buildStr = buildDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) + ', ' +
                       buildDate.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
      const versionInfo = `App ${APP_VERSION} ‚Ä¢ Built: ${buildStr}`;

      if (backupTime) {
        const date = new Date(parseInt(backupTime));
        const backupStr = date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
        footer.innerHTML = `${versionInfo} <span style="margin: 0 0.5rem; color: #cbd5e1;">|</span> Data backup: ${backupStr}`;
      } else {
        footer.innerHTML = `${versionInfo} <span style="margin: 0 0.5rem; color: #cbd5e1;">|</span> No backup yet`;
      }
    }
  </script>
  <div class="backup-footer" id="backupFooter">No backup yet</div>
</body>
</html>
