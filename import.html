<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Soil Sample Analysis - Import</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f8fafc; color: #1e293b; min-height: 100vh; }
    .top-bar { background: linear-gradient(135deg, #1e293b 0%, #334155 100%); color: white; padding: 1rem 1.5rem; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem; }
    .top-bar h1 { font-size: 1.5rem; font-weight: 700; }
    .top-bar p { font-size: 0.875rem; opacity: 0.8; margin-top: 0.25rem; }
    .nav-links { display: flex; gap: 0.5rem; flex-wrap: wrap; }
    .nav-link { padding: 0.5rem 1rem; background: rgba(255,255,255,0.1); color: white; text-decoration: none; border-radius: 0.375rem; font-size: 0.875rem; font-weight: 500; }
    .nav-link:hover { background: rgba(255,255,255,0.2); }
    .nav-link.active { background: #3b82f6; }
    .auth-section { display: flex; align-items: center; gap: 1rem; }
    .user-info { font-size: 0.875rem; color: rgba(255,255,255,0.9); }
    .sign-in-btn { padding: 0.5rem 1rem; background: #4285f4; color: white; border: none; border-radius: 0.375rem; font-size: 0.875rem; cursor: pointer; }
    .sign-in-btn.signed-in { background: #22c55e; }
    .sign-in-btn.signed-in:hover { background: #16a34a; }
    .import-container { max-width: 800px; margin: 0 auto; padding: 1.5rem; }
    .data-summary { background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1.5rem; }
    .data-summary h4 { margin: 0 0 0.75rem 0; color: #475569; }
    .summary-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; }
    .summary-item { text-align: center; padding: 0.75rem; background: white; border-radius: 0.375rem; }
    .summary-item .number { font-size: 1.5rem; font-weight: 700; color: #1e293b; }
    .summary-item .label { font-size: 0.75rem; color: #64748b; text-transform: uppercase; }
    .import-section { background: white; border-radius: 0.75rem; padding: 1.5rem; margin-bottom: 1.5rem; box-shadow: 0 2px 8px rgba(0,0,0,0.08); border: 2px solid transparent; }
    .import-section h3 { margin: 0 0 1rem 0; display: flex; align-items: center; gap: 0.5rem; font-size: 1.25rem; }
    .import-section.boundaries { background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%); border-color: #3b82f6; }
    .import-section.boundaries h3 { color: #1d4ed8; }
    .import-section.samples { background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%); border-color: #22c55e; }
    .import-section.samples h3 { color: #15803d; }
    .import-section.yield { background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%); border-color: #f59e0b; }
    .import-section.yield h3 { color: #b45309; }
    .import-section.export { background: linear-gradient(135deg, #f5f3ff 0%, #ede9fe 100%); border-color: #8b5cf6; }
    .import-section.export h3 { color: #7c3aed; }
    .import-section.management { background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%); border-color: #64748b; }
    .import-section.management h3 { color: #475569; }
    .form-group { margin-bottom: 1rem; }
    .form-group label { display: block; font-weight: 600; margin-bottom: 0.5rem; color: #374151; font-size: 0.875rem; }
    .form-group input[type="file"], .form-group input[type="text"] { width: 100%; padding: 0.75rem; border: 2px dashed #cbd5e1; border-radius: 0.375rem; background: #f8fafc; }
    .form-group input[type="file"]:hover { border-color: #94a3b8; background: #f1f5f9; }
    .form-group small { display: block; margin-top: 0.25rem; color: #64748b; font-size: 0.75rem; }
    .button { padding: 0.75rem 1.5rem; border: none; border-radius: 0.375rem; font-size: 0.875rem; font-weight: 600; cursor: pointer; width: 100%; }
    .button.primary { background: #3b82f6; color: white; }
    .button.success { background: #22c55e; color: white; }
    .button.danger { background: #ef4444; color: white; }
    .button:hover { opacity: 0.9; }
    .btn-row { display: flex; gap: 1rem; flex-wrap: wrap; }
    .btn-row .button { flex: 1; }
    #statusMessage { display: none; position: fixed; top: 1rem; left: 50%; transform: translateX(-50%); z-index: 9999; padding: 0.75rem 1rem; border-radius: 0.375rem; box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
    
    /* Column Mapping Modal */
    .modal-overlay { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10000; justify-content: center; align-items: center; }
    .modal-overlay.active { display: flex; }
    .modal { background: white; border-radius: 0.5rem; max-width: 700px; width: 90%; max-height: 80vh; overflow: hidden; display: flex; flex-direction: column; }
    .modal-header { padding: 1rem 1.5rem; border-bottom: 1px solid #e2e8f0; display: flex; justify-content: space-between; align-items: center; }
    .modal-header h3 { margin: 0; font-size: 1.125rem; }
    .modal-close { background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #64748b; }
    .modal-body { padding: 1.5rem; overflow-y: auto; flex: 1; }
    .modal-footer { padding: 1rem 1.5rem; border-top: 1px solid #e2e8f0; display: flex; justify-content: flex-end; gap: 0.75rem; }
    .mapping-section { margin-bottom: 1.5rem; }
    .mapping-section h4 { margin: 0 0 0.75rem 0; font-size: 0.875rem; color: #475569; display: flex; align-items: center; gap: 0.5rem; }
    .mapping-section h4 .icon { font-size: 1rem; }
    .mapping-row { display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem; background: #f8fafc; border-radius: 0.375rem; margin-bottom: 0.5rem; }
    .mapping-row.matched { background: #dcfce7; }
    .mapping-row.unmatched { background: #fef3c7; }
    .mapping-row .file-col { flex: 1; font-family: monospace; font-size: 0.875rem; color: #1e293b; }
    .mapping-row .arrow { color: #64748b; }
    .mapping-row select { padding: 0.375rem 0.5rem; border: 1px solid #cbd5e1; border-radius: 0.25rem; font-size: 0.875rem; min-width: 120px; }
    .mapping-row .matched-label { color: #166534; font-size: 0.875rem; font-weight: 500; }
    .save-alias-row { display: flex; align-items: center; gap: 0.5rem; margin-top: 0.5rem; }
    .save-alias-row input[type="checkbox"] { width: 1rem; height: 1rem; }
    .save-alias-row label { font-size: 0.875rem; color: #475569; }
    .modal .button { padding: 0.5rem 1rem; width: auto; }
  </style>
</head>
<body>
  <div class="top-bar">
    <div>
      <h1>üìÅ Import Data</h1>
      <p>Upload boundaries and soil samples</p>
    </div>
    <nav class="nav-links">
      <a href="index.html" class="nav-link">üìç Map</a>
      <a href="analysis.html" class="nav-link">üìä Analysis</a>
      <a href="import.html" class="nav-link active">üìÅ Import</a>
      <a href="settings.html" class="nav-link">‚öôÔ∏è Settings</a>
    </nav>
    <div class="auth-section">
      <span class="user-info" id="userInfo"></span>
      <button class="sign-in-btn" id="authBtn" onclick="handleAuth()">Sign In to Sync</button>
    </div>
  </div>

  <div class="import-container">
    <div class="data-summary">
      <h4>üìä Current Data</h4>
      <div class="summary-grid">
        <div class="summary-item"><div class="number" id="fieldCount">0</div><div class="label">Fields</div></div>
        <div class="summary-item"><div class="number" id="sampleCount">0</div><div class="label">Samples</div></div>
        <div class="summary-item"><div class="number" id="yearCount">0</div><div class="label">Years</div><div class="year-list" id="yearList" style="font-size: 0.75rem; color: #64748b; margin-top: 0.25rem;"></div></div>
        <div class="summary-item"><div class="number" id="yieldCount">0</div><div class="label">Samples w/ Yield</div><div class="field-list" id="yieldFieldList" style="font-size: 0.75rem; color: #64748b; margin-top: 0.25rem;"></div></div>
      </div>
      <div id="backupStatus" style="margin-top: 1rem; padding: 0.75rem; border-radius: 0.375rem; font-size: 0.8125rem; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 0.5rem;"></div>
    </div>

    <div class="import-section boundaries">
      <h3>üì¶ Import Field Boundaries</h3>
      <div class="form-group">
        <label>Field Name (optional)</label>
        <input type="text" id="boundaryFieldName" placeholder="Auto-detects from file">
      </div>
      <div class="form-group">
        <label>Boundary File(s)</label>
        <input type="file" id="boundaryFiles" multiple accept=".shp,.dbf,.prj,.shx,.zip,.geojson,.json">
        <small>GeoJSON, Shapefile, or ZIP ‚Ä¢ Select multiple for batch import</small>
      </div>
      <button class="button primary" id="uploadBoundaryBtn">Upload Boundaries</button>
    </div>

    <div class="import-section samples">
      <h3>üî¨ Import Soil Samples</h3>
      <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
        <div class="form-group">
          <label>Sample Year <span style="font-weight: 400; font-size: 0.75rem; color: #dc2626;">(required)</span></label>
          <input type="text" id="sampleYear" placeholder="e.g., 2024" style="width: 120px; border: 2px solid #dc2626; background: #fef2f2;" required>
        </div>
        <div class="form-group">
          <label>Sample Depth <span style="font-weight: 400; font-size: 0.75rem; color: #166534;">(default: 6")</span></label>
          <input type="text" id="sampleDepth" value="6" style="width: 80px; border: 2px solid #22c55e; background: #f0fdf4;">
          <small>inches</small>
        </div>
      </div>
      <div class="form-group">
        <label>Sample File(s)</label>
        <input type="file" id="sampleFiles" multiple accept=".shp,.dbf,.prj,.shx,.zip,.geojson,.json,.csv">
        <small>CSV, Shapefile, or GeoJSON ‚Ä¢ Auto-assigns to fields by GPS</small>
      </div>
      <button class="button success" id="uploadSampleBtn">Upload Samples</button>
    </div>

    <div class="import-section yield">
      <h3>üåæ Import Yield Data</h3>
      <p style="color: #92400e; font-size: 0.875rem; margin-bottom: 1rem;">Upload yield maps to correlate soil nutrients with crop performance.</p>
      <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
        <div class="form-group">
          <label>Crop Year <small style="font-weight: normal; color: #64748b;">(auto-detects)</small></label>
          <input type="text" id="yieldYear" placeholder="auto or enter" style="width: 120px;">
        </div>
        <div class="form-group">
          <label>Crop Type</label>
          <select id="yieldCrop" style="width: 140px;">
            <option value="corn">üåΩ Corn</option>
            <option value="soybeans">ü´ò Soybeans</option>
          </select>
        </div>
        <div class="form-group">
          <label>Sample Radius</label>
          <select id="yieldRadius" style="width: 100px;">
            <option value="50">50 ft</option>
            <option value="100" selected>100 ft</option>
            <option value="150">150 ft</option>
          </select>
        </div>
      </div>
      <div class="form-group">
        <label>Yield File (Shapefile)</label>
        <input type="file" id="yieldFiles" multiple accept=".shp,.dbf,.prj,.shx,.zip">
        <small>John Deere or Climate FieldView shapefile export ‚Ä¢ ZIP or individual files</small>
      </div>
      <button class="button" id="uploadYieldBtn" style="background: #f59e0b; color: white;">Upload Yield Data</button>
      <div id="yieldStatus" style="margin-top: 0.75rem;"></div>
    </div>

    <div class="import-section export">
      <h3>üì§ Export Data</h3>
      <p style="color: #64748b; font-size: 0.875rem; margin-bottom: 1rem;">Export all sample data with visible attributes and yield correlations.</p>
      <div class="btn-row">
        <button class="button" id="exportCSVBtn" style="background: #8b5cf6; color: white;">üìä Export CSV</button>
        <button class="button" id="exportPDFBtn" style="background: #6366f1; color: white;">üìÑ Export PDF Report</button>
        <button class="button" id="exportJSONBtn" style="background: #059669; color: white;">üíæ Download Full Backup</button>
      </div>
    </div>

    <div class="import-section management">
      <h3>üîÑ Data Management</h3>
      <div class="btn-row">
        <button class="button primary" id="syncBtn">‚òÅÔ∏è Sync to Google Sheets</button>
      </div>
      <div class="btn-row" style="margin-top: 0.75rem;">
        <button class="button" id="reassignBtn" style="background: #3b82f6; color: white;">üîÑ Reassign Samples to Boundaries</button>
      </div>
      <div class="btn-row" style="margin-top: 0.75rem;">
        <button class="button danger" id="clearSamplesBtn">üóëÔ∏è Clear Samples</button>
        <button class="button danger" id="clearBoundariesBtn">üóëÔ∏è Clear Boundaries</button>
        <button class="button danger" id="clearYieldBtn">üóëÔ∏è Clear Yield Data</button>
        <button class="button danger" id="clearAllBtn">üóëÔ∏è Clear All</button>
      </div>
      <small style="display:block; margin-top:0.75rem; color:#64748b;">Data is saved locally and synced to Google Sheets when signed in.</small>
    </div>
  </div>

  <div id="statusMessage"></div>

  <!-- Column Mapping Modal -->
  <div id="mappingModal" class="modal-overlay">
    <div class="modal">
      <div class="modal-header">
        <h3>üìã Column Mapping</h3>
        <button class="modal-close" onclick="closeMappingModal()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="mapping-section" id="matchedSection">
          <h4><span class="icon">‚úì</span> Matched Columns</h4>
          <div id="matchedColumns"></div>
        </div>
        <div class="mapping-section" id="unmatchedSection">
          <h4><span class="icon">‚ö†Ô∏è</span> Unmatched Columns (select mapping or skip)</h4>
          <div id="unmatchedColumns"></div>
        </div>
        <div class="save-alias-row">
          <input type="checkbox" id="saveNewAliases" checked>
          <label for="saveNewAliases">Save new mappings for future imports</label>
        </div>
      </div>
      <div class="modal-footer">
        <button class="button" style="background: #94a3b8;" onclick="closeMappingModal()">Cancel</button>
        <button class="button primary" onclick="proceedWithImport()">Import with Mappings</button>
      </div>
    </div>
  </div>

  <script src="https://apis.google.com/js/api.js"></script>
  <script src="https://accounts.google.com/gsi/client"></script>
  <script src="https://unpkg.com/shpjs@latest/dist/shp.js"></script>
  <script>
    const CONFIG = {
      CLIENT_ID: '714780458094-9rde31taeottmavhl5t0uo8b9kfpergc.apps.googleusercontent.com',
      API_KEY: 'AIzaSyCOSDbrAlc3ct2-lRvJv1y7V0nV7haWc9E',
      get SHEET_ID() { return localStorage.getItem('googleSheetId') || '1buu-8KXoM1kRJSOAWtHaAk40seQT5kqGFY9RICYwdRY'; }
    };

    let tokenClient;
    let accessToken = null;
    let tokenExpiry = null;
    
    const SheetsAPI = {
      isSignedIn: false,
      async init() {
        return new Promise((resolve, reject) => {
          gapi.load('client', async () => {
            try {
              await gapi.client.init({ apiKey: CONFIG.API_KEY, discoveryDocs: ['https://sheets.googleapis.com/$discovery/rest?version=v4'] });
              tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: CONFIG.CLIENT_ID,
                scope: 'https://www.googleapis.com/auth/spreadsheets',
                callback: (response) => {
                  if (response.error) return;
                  accessToken = response.access_token;
                  tokenExpiry = Date.now() + (response.expires_in * 1000) - 60000;
                  localStorage.setItem('googleAccessToken', accessToken);
                  localStorage.setItem('googleTokenExpiry', tokenExpiry.toString());
                  gapi.client.setToken({ access_token: accessToken });
                  this.isSignedIn = true;
                  this.onSignInChange(true);
                },
              });
              
              // Check for saved token
              const savedToken = localStorage.getItem('googleAccessToken');
              const savedExpiry = localStorage.getItem('googleTokenExpiry');
              if (savedToken && savedExpiry && Date.now() < parseInt(savedExpiry)) {
                accessToken = savedToken;
                tokenExpiry = parseInt(savedExpiry);
                this.isSignedIn = true;
                // Set the token for gapi client
                gapi.client.setToken({ access_token: accessToken });
                this.onSignInChange(true);
              }
              
              resolve(true);
            } catch (e) { reject(e); }
          });
        });
      },
      async signIn() { tokenClient.requestAccessToken({ prompt: 'consent' }); },
      async signOut() { 
        if (accessToken) google.accounts.oauth2.revoke(accessToken);
        accessToken = null;
        tokenExpiry = null;
        localStorage.removeItem('googleAccessToken');
        localStorage.removeItem('googleTokenExpiry');
        this.isSignedIn = false;
        this.onSignInChange(false);
      },
      onSignInChange(s) {},
      
      async initializeSheets() {
        // Create headers if needed
        const fieldsCheck = await gapi.client.sheets.spreadsheets.values.get({ spreadsheetId: CONFIG.SHEET_ID, range: 'Fields!A1:E1' });
        if (!fieldsCheck.result.values || fieldsCheck.result.values.length === 0) {
          await gapi.client.sheets.spreadsheets.values.update({ spreadsheetId: CONFIG.SHEET_ID, range: 'Fields!A1:E1', valueInputOption: 'RAW', resource: { values: [['id', 'name', 'boundary', 'acres', 'created']] } });
        }
        const samplesCheck = await gapi.client.sheets.spreadsheets.values.get({ spreadsheetId: CONFIG.SHEET_ID, range: 'Samples!A1:Z1' });
        if (!samplesCheck.result.values || samplesCheck.result.values.length === 0) {
          await gapi.client.sheets.spreadsheets.values.update({ spreadsheetId: CONFIG.SHEET_ID, range: 'Samples!A1:W1', valueInputOption: 'RAW', resource: { values: [['sampleId', 'field', 'lat', 'lon', 'year', 'depth', 'pH', 'P', 'K', 'OM', 'Ca_sat', 'Mg_sat', 'K_Sat', 'H_Sat', 'Zn', 'Cu', 'Mn', 'Fe', 'Boron', 'S', 'CEC', 'Buffer_pH', 'yieldCorrelations']] } });
        }
      },
      
      async addField(field) {
        await gapi.client.sheets.spreadsheets.values.append({ spreadsheetId: CONFIG.SHEET_ID, range: 'Fields!A:E', valueInputOption: 'RAW', resource: { values: [[field.id || Date.now().toString(36), field.name, JSON.stringify(field.boundary), field.acres || 0, new Date().toISOString()]] } });
      },
      
      async addSamples(samples) {
        const headerRes = await gapi.client.sheets.spreadsheets.values.get({ spreadsheetId: CONFIG.SHEET_ID, range: 'Samples!A1:ZZ1' });
        const headers = headerRes.result.values?.[0] || [];
        const rows = samples.map(s => headers.map(h => { const v = s[h]; if (v === undefined || v === null) return ''; if (typeof v === 'object') return JSON.stringify(v); return v; }));
        await gapi.client.sheets.spreadsheets.values.append({ spreadsheetId: CONFIG.SHEET_ID, range: 'Samples!A:ZZ', valueInputOption: 'RAW', resource: { values: rows } });
      }
    };

    let sampleData = [], fieldBoundaries = {}, yieldData = [];

    document.addEventListener('DOMContentLoaded', async () => {
      loadLocalData(); updateSummary(); updateBackupStatus();
      try { await SheetsAPI.init(); SheetsAPI.onSignInChange = handleSignInChange; handleSignInChange(SheetsAPI.isSignedIn); } catch (e) { console.warn(e); }
      document.getElementById('uploadBoundaryBtn').addEventListener('click', uploadBoundaries);
      document.getElementById('uploadSampleBtn').addEventListener('click', uploadSamples);
      document.getElementById('uploadYieldBtn').addEventListener('click', uploadYield);
      document.getElementById('syncBtn').addEventListener('click', syncToSheets);
      document.getElementById('clearSamplesBtn').addEventListener('click', clearSamples);
      document.getElementById('clearBoundariesBtn').addEventListener('click', clearBoundaries);
      document.getElementById('clearYieldBtn').addEventListener('click', clearYieldData);
      document.getElementById('clearAllBtn').addEventListener('click', clearAllData);
      document.getElementById('reassignBtn').addEventListener('click', reassignSamplesToBoundaries);
      document.getElementById('exportCSVBtn').addEventListener('click', exportToCSV);
      document.getElementById('exportPDFBtn').addEventListener('click', exportToPDF);
      document.getElementById('exportJSONBtn').addEventListener('click', exportToJSON);
    });

    async function handleAuth() { if (SheetsAPI.isSignedIn) await SheetsAPI.signOut(); else await SheetsAPI.signIn(); }
    function handleSignInChange(isSignedIn) {
      const authBtn = document.getElementById('authBtn'), userInfo = document.getElementById('userInfo');
      if (isSignedIn) {
        userInfo.textContent = 'Connected';
        authBtn.textContent = '‚úì Signed In';
        authBtn.classList.add('signed-in');
      } else {
        userInfo.textContent = '';
        authBtn.textContent = 'Sign In to Sync';
        authBtn.classList.remove('signed-in');
      }
    }

    function loadLocalData() { try { const s = localStorage.getItem('soilSamples'), b = localStorage.getItem('fieldBoundaries'); if (s) sampleData = JSON.parse(s); if (b) fieldBoundaries = JSON.parse(b); } catch (e) {} }
    function saveLocalData() { localStorage.setItem('soilSamples', JSON.stringify(sampleData)); localStorage.setItem('fieldBoundaries', JSON.stringify(fieldBoundaries)); }

    // ========== BACKUP SYSTEM ==========
    function saveBackup() {
      // Save full backup to localStorage
      const backup = {
        version: 1,
        timestamp: Date.now(),
        operationName: localStorage.getItem('operationName') || '',
        sampleData: sampleData,
        fieldBoundaries: fieldBoundaries,
        settings: JSON.parse(localStorage.getItem('soilSettings') || '{}')
      };
      localStorage.setItem('soilDataBackup', JSON.stringify(backup));
      localStorage.setItem('soilDataBackupTime', Date.now().toString());
      updateBackupStatus();
    }

    function updateBackupStatus() {
      const container = document.getElementById('backupStatus');
      const backupTime = localStorage.getItem('soilDataBackupTime');
      const lastDownload = localStorage.getItem('lastBackupDownload');
      const autoBackup = localStorage.getItem('autoBackupFrequency') || 'weekly';

      if (!backupTime && sampleData.length === 0) {
        container.style.background = '#f8fafc';
        container.style.border = '1px solid #e2e8f0';
        container.innerHTML = '<span style="color: #64748b;">No data to backup yet</span>';
        return;
      }

      const now = Date.now();
      const daysSinceBackup = backupTime ? Math.floor((now - parseInt(backupTime)) / (1000 * 60 * 60 * 24)) : null;
      const daysSinceDownload = lastDownload ? Math.floor((now - parseInt(lastDownload)) / (1000 * 60 * 60 * 24)) : null;

      let statusColor, statusBg, statusBorder, statusIcon, statusText;

      if (!lastDownload) {
        // Never downloaded a backup
        statusIcon = '‚ö†Ô∏è';
        statusText = 'No backup file downloaded yet';
        statusBg = '#fef2f2';
        statusBorder = '#fca5a5';
        statusColor = '#991b1b';
      } else if (daysSinceDownload > 30) {
        // Backup is old
        statusIcon = '‚ö†Ô∏è';
        statusText = `Last backup download: ${formatDate(parseInt(lastDownload))} (${daysSinceDownload} days ago)`;
        statusBg = '#fffbeb';
        statusBorder = '#fcd34d';
        statusColor = '#92400e';
      } else {
        // Backup is recent
        statusIcon = '‚úì';
        statusText = `Last backup download: ${formatDate(parseInt(lastDownload))}`;
        statusBg = '#f0fdf4';
        statusBorder = '#86efac';
        statusColor = '#166534';
      }

      container.style.background = statusBg;
      container.style.border = `1px solid ${statusBorder}`;
      container.innerHTML = `
        <span style="color: ${statusColor};">${statusIcon} ${statusText}</span>
        <span style="color: #64748b; font-size: 0.75rem;">Auto-backup: ${autoBackup}</span>
      `;

      // Check if we should prompt for auto-backup
      checkAutoBackupPrompt();
    }

    function checkAutoBackupPrompt() {
      const autoBackup = localStorage.getItem('autoBackupFrequency') || 'weekly';
      const lastDownload = localStorage.getItem('lastBackupDownload');
      const lastPrompt = localStorage.getItem('lastBackupPrompt');
      const now = Date.now();

      // Don't prompt more than once per session
      if (lastPrompt && (now - parseInt(lastPrompt)) < 1000 * 60 * 60) return;

      if (autoBackup === 'weekly' && sampleData.length > 0) {
        const daysSince = lastDownload ? Math.floor((now - parseInt(lastDownload)) / (1000 * 60 * 60 * 24)) : 999;
        if (daysSince >= 7) {
          localStorage.setItem('lastBackupPrompt', now.toString());
          if (confirm(`It's been ${daysSince === 999 ? 'a while' : daysSince + ' days'} since your last backup.\n\nDownload a backup now?`)) {
            exportToJSON();
          }
        }
      }
    }

    function formatDate(timestamp) {
      return new Date(timestamp).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
    }

    function exportToJSON() {
      if (sampleData.length === 0 && Object.keys(fieldBoundaries).length === 0) {
        showStatus('No data to export', false);
        return;
      }

      const backup = {
        version: 1,
        exportDate: new Date().toISOString(),
        operationName: localStorage.getItem('operationName') || 'SoilData',
        sampleData: sampleData,
        fieldBoundaries: fieldBoundaries,
        settings: JSON.parse(localStorage.getItem('soilSettings') || '{}'),
        columnAliases: JSON.parse(localStorage.getItem('columnAliases') || '{}'),
        nutrientVisibility: JSON.parse(localStorage.getItem('nutrientVisibility') || '{}')
      };

      const blob = new Blob([JSON.stringify(backup, null, 2)], { type: 'application/json' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      const opName = (backup.operationName || 'SoilData').replace(/[^a-zA-Z0-9]/g, '_');
      link.download = `${opName}_backup_${new Date().toISOString().split('T')[0]}.json`;
      link.click();

      // Record the download
      localStorage.setItem('lastBackupDownload', Date.now().toString());
      updateBackupStatus();
      showStatus(`‚úì Backup downloaded (${sampleData.length} samples, ${Object.keys(fieldBoundaries).length} fields)`, true);
    }

    // Call saveBackup after successful imports
    function afterImportSuccess() {
      saveLocalData();
      saveBackup();
      updateSummary();
      updateBackupStatus();

      // Auto-download if setting is 'after-import'
      const autoBackup = localStorage.getItem('autoBackupFrequency');
      if (autoBackup === 'after-import') {
        setTimeout(() => exportToJSON(), 500);
      }
    }

    function updateSummary() {
      document.getElementById('fieldCount').textContent = Object.keys(fieldBoundaries).length;
      document.getElementById('sampleCount').textContent = sampleData.length;
      const uniqueYears = [...new Set(sampleData.map(s => s.year).filter(y => y))].sort((a, b) => a - b);
      document.getElementById('yearCount').textContent = uniqueYears.length;
      document.getElementById('yearList').textContent = uniqueYears.join(', ');
      // Count samples with yield correlations and get unique fields
      const samplesWithYield = sampleData.filter(s => s.yieldCorrelations && Object.keys(s.yieldCorrelations).length > 0);
      document.getElementById('yieldCount').textContent = samplesWithYield.length;
      const fieldsWithYield = [...new Set(samplesWithYield.map(s => s.field).filter(f => f && f !== 'Unknown'))].sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));
      document.getElementById('yieldFieldList').textContent = fieldsWithYield.length > 0 ? fieldsWithYield.join(', ') : '';
    }

    async function uploadBoundaries() {
      const files = Array.from(document.getElementById('boundaryFiles').files);
      const fieldName = document.getElementById('boundaryFieldName').value.trim();
      if (files.length === 0) { showStatus('Please select file(s)', false); return; }
      showStatus('Processing...', true);
      try {
        let total = 0;
        const shpFile = files.find(f => f.name.toLowerCase().endsWith('.shp'));
        const dbfFile = files.find(f => f.name.toLowerCase().endsWith('.dbf'));
        const isZip = files.length === 1 && files[0].name.toLowerCase().endsWith('.zip');
        const jsonFiles = files.filter(f => f.name.toLowerCase().match(/\.(geo)?json$/));
        
        if (isZip) {
          const arrayBuffer = await files[0].arrayBuffer();
          const geojson = await shp(arrayBuffer);
          const parsed = geojsonToBoundaries(geojson, fieldName);
          Object.assign(fieldBoundaries, parsed); total = Object.keys(parsed).length;
        } else if (shpFile && dbfFile) {
          const shpBuffer = await shpFile.arrayBuffer();
          const dbfBuffer = await dbfFile.arrayBuffer();
          const geojson = await shp({ shp: shpBuffer, dbf: dbfBuffer });
          const parsed = geojsonToBoundaries(geojson, fieldName);
          Object.assign(fieldBoundaries, parsed); total = Object.keys(parsed).length;
        } else if (jsonFiles.length > 0) {
          for (const file of jsonFiles) {
            const text = await file.text(), geojson = JSON.parse(text);
            const parsed = geojsonToBoundaries(geojson, fieldName || file.name.replace(/\.(geo)?json$/i, ''));
            Object.assign(fieldBoundaries, parsed); total += Object.keys(parsed).length;
          }
        } else {
          throw new Error('Please select a ZIP, Shapefile (.shp + .dbf), or GeoJSON');
        }
        
        afterImportSuccess(); showStatus(`‚úì Imported ${total} field(s)`, true);
        document.getElementById('boundaryFiles').value = ''; document.getElementById('boundaryFieldName').value = '';
        // Auto-sync to Google Sheets if signed in
        if (SheetsAPI.isSignedIn) {
          showStatus('Syncing to Google Sheets...', true);
          await syncToSheets();
        }
      } catch (e) { showStatus('Error: ' + e.message, false); console.error(e); }
    }

    function geojsonToBoundaries(geojson, defaultName) {
      const boundaries = {}, features = geojson.features || [geojson];
      
      // Debug: log the geojson structure
      console.log('GeoJSON structure:', geojson);
      console.log('Features count:', features.length);
      console.log('defaultName parameter:', defaultName);
      if (features[0]) console.log('First feature properties:', features[0].properties);
      
      features.forEach(f => {
        if (!f.geometry) return;
        const type = f.geometry.type;
        if (type !== 'Polygon' && type !== 'MultiPolygon') return;
        const props = f.properties || {};
        
        // Debug: log properties for each feature
        console.log('Feature properties:', props);
        console.log('props.FIELD_NAME value:', props.FIELD_NAME);
        console.log('props.FIELD_NAME truthy?:', !!props.FIELD_NAME);
        
        // Get field name - prioritize FIELD_NAME from properties FIRST (before defaultName)
        let fieldName = null;
        
        // First priority: FIELD_NAME in properties (exact match)
        if (props.FIELD_NAME) {
          fieldName = props.FIELD_NAME;
          console.log('Using props.FIELD_NAME:', fieldName);
        }
        else if (props.Field_Name) {
          fieldName = props.Field_Name;
          console.log('Using props.Field_Name:', fieldName);
        }
        else if (props.field_name) {
          fieldName = props.field_name;
          console.log('Using props.field_name:', fieldName);
        }
        // Second priority: user-provided default name
        else if (defaultName) {
          fieldName = defaultName;
          console.log('Using defaultName:', fieldName);
        }
        // Third priority: extract from compound names
        else {
          const rawName = props.name || props.Name || props.Field || props.field || geojson.name || 'Unknown';
          console.log('Falling back to rawName:', rawName);
          // Extract last part after underscore (e.g., "Precision Farms_Precision Farms_WCG" -> "WCG")
          if (rawName.includes('_')) {
            fieldName = rawName.split('_').pop();
          } else {
            fieldName = rawName;
          }
        }
        
        console.log('Final resolved field name:', fieldName);
        
        if (!boundaries[fieldName]) boundaries[fieldName] = [];
        if (type === 'Polygon') { boundaries[fieldName].push(f.geometry.coordinates[0].map(c => [c[1], c[0]])); }
        else { f.geometry.coordinates.forEach(poly => { boundaries[fieldName].push(poly[0].map(c => [c[1], c[0]])); }); }
      });
      return boundaries;
    }

    async function uploadSamples() {
      const files = Array.from(document.getElementById('sampleFiles').files);
      const yearInput = document.getElementById('sampleYear').value.trim();
      const depth = document.getElementById('sampleDepth').value.trim() || '6';

      // Validate required year
      if (!yearInput) { showStatus('Sample Year is required', false); return; }
      const year = parseInt(yearInput);
      if (isNaN(year) || year < 1900 || year > 2100) { showStatus('Please enter a valid year (e.g., 2024)', false); return; }

      if (files.length === 0) { showStatus('Please select file(s)', false); return; }
      showStatus('Processing...', true);
      try {
        let samples = [];
        const shpFile = files.find(f => f.name.toLowerCase().endsWith('.shp'));
        const dbfFile = files.find(f => f.name.toLowerCase().endsWith('.dbf'));
        const isZip = files.length === 1 && files[0].name.toLowerCase().endsWith('.zip');
        const csvFile = files.find(f => f.name.toLowerCase().endsWith('.csv'));
        const jsonFile = files.find(f => f.name.toLowerCase().match(/\.(geo)?json$/));
        
        if (isZip) {
          // Zip file - may contain multiple shapefiles
          const arrayBuffer = await files[0].arrayBuffer();
          const result = await shp(arrayBuffer);

          // shp() returns array if multiple shapefiles in zip, single object if one
          if (Array.isArray(result)) {
            console.log(`Found ${result.length} shapefiles in zip`);
            result.forEach((geojson, i) => {
              console.log(`Processing shapefile ${i + 1}: ${geojson.fileName || 'unnamed'}`);
              const fileSamples = geojsonToSamples(geojson, year, depth);
              samples = [...samples, ...fileSamples];
            });
          } else {
            samples = geojsonToSamples(result, year, depth);
          }
        } else if (shpFile && dbfFile) {
          // Multiple shapefile components - combine them
          const shpBuffer = await shpFile.arrayBuffer();
          const dbfBuffer = await dbfFile.arrayBuffer();
          const geojson = await shp({ shp: shpBuffer, dbf: dbfBuffer });
          samples = geojsonToSamples(geojson, year, depth);
        } else if (csvFile) {
          const text = await csvFile.text();
          samples = parseCSV(text, year, depth);
        } else if (jsonFile) {
          const text = await jsonFile.text();
          const geojson = JSON.parse(text);
          samples = geojsonToSamples(geojson, year, depth);
        } else {
          throw new Error('Please select a ZIP, Shapefile (.shp + .dbf), CSV, or GeoJSON');
        }
        
        if (samples.length === 0) throw new Error('No samples found in file');
        
        // Analyze columns for mapping
        const firstSampleProps = samples[0] || {};
        const analysis = analyzeColumns(firstSampleProps);
        
        // If there are unmatched columns, show the mapping modal
        if (analysis.unmatched.length > 0) {
          showMappingModal(samples, analysis);
          return; // Modal will call finishSampleImport when user confirms
        }
        
        // No unmatched columns - proceed directly
        await finishSampleImport(samples);
        
      } catch (e) { showStatus('Error: ' + e.message, false); console.error(e); }
    }
    
    async function finishSampleImport(samples) {
        // Prevent duplicates - check by sampleId + year + location (not field since it's assigned later)
        const existingKeys = new Set(sampleData.map(s => `${s.sampleId}-${s.year}-${s.lat?.toFixed(5)}-${s.lon?.toFixed(5)}`));
        const newSamples = samples.filter(s => !existingKeys.has(`${s.sampleId}-${s.year}-${s.lat?.toFixed(5)}-${s.lon?.toFixed(5)}`));

        if (newSamples.length === 0) {
          showStatus('All samples already exist (duplicates skipped)', false);
          return;
        }

        const skipped = samples.length - newSamples.length;
        sampleData = [...sampleData, ...newSamples];

        // Assign field names based on boundary GPS matching
        if (Object.keys(fieldBoundaries).length > 0) {
          assignSamplesToFields();
          const assignedCount = newSamples.filter(s => s.field && s.field !== 'Unassigned').length;
          const unassignedCount = newSamples.length - assignedCount;
          afterImportSuccess();
          let msg = `‚úì Imported ${newSamples.length} samples, ${assignedCount} assigned to fields`;
          if (unassignedCount > 0) msg += ` (${unassignedCount} unassigned - outside boundaries)`;
          if (skipped > 0) msg += ` (${skipped} duplicates skipped)`;
          showStatus(msg, true);
        } else {
          afterImportSuccess();
          showStatus(`‚úì Imported ${newSamples.length} samples. Upload boundaries to assign field names.${skipped > 0 ? ` (${skipped} duplicates skipped)` : ''}`, true);
        }
        document.getElementById('sampleFiles').value = ''; document.getElementById('sampleYear').value = '';
        // Auto-sync to Google Sheets if signed in
        if (SheetsAPI.isSignedIn) {
          showStatus('Syncing to Google Sheets...', true);
          await syncToSheets();
        }
    }

    // Standard fields we care about
    const STANDARD_FIELDS = ['pH', 'P', 'P2', 'K', 'OM', 'CEC', 'Ca_sat', 'Mg_sat', 'K_Sat', 'H_Sat', 'Na_Sat', 'Zn', 'Cu', 'Mn', 'Fe', 'Boron', 'S', 'Buffer_pH', 'Na', 'Ca', 'Mg', 'NO3', 'NH4', 'Soluble_Salts', 'EC'];
    
    // Default aliases (built-in)
    const DEFAULT_ALIASES = {
      'P': ['P', 'P (M3)', 'P_M3', 'Phosphorus', 'Bray_P1', 'Bray P1', 'Mehlich2_P', 'Mehlich P', 'M3P', 'Olsen P', 'P1', 'P ppm'],
      'P2': ['P2', 'Bray_P2', 'Bray P2', 'P2 ppm'],
      'pH': ['pH', 'pH (1_1)', 'pH_1_1', 'ph', 'Soil_pH', 'pH 1:1', 'pH_s', 'soil pH'],
      'K': ['K', 'K (M3)', 'K_M3', 'Potassium', 'ExchK', 'Exch K', 'Mehlich K', 'M3K', 'K ppm'],
      'OM': ['OM', 'OM (LOI)', 'OM_LOI', 'Organic_Matter', 'Organic Matter', 'O.M.', 'OM %', 'SOM'],
      'CEC': ['CEC', 'CEC (Calc)', 'CEC_Calc', 'CEC (Cal_1', 'CEC meq'],
      'Ca_sat': ['Ca_sat', 'BS-Ca', 'BS_Ca', 'Ca_Base_Sat', 'Ca_Sat', 'Ca %', 'Ca Sat', '% Ca'],
      'Mg_sat': ['Mg_sat', 'BS-Mg', 'BS_Mg', 'Mg_Base_Sat', 'Mg_Sat', 'Mg %', 'Mg Sat', '% Mg'],
      'K_Sat': ['K_Sat', 'BS-K', 'BS_K', 'K_Base_Sat', 'K %', 'K Sat', '% K'],
      'H_Sat': ['H_Sat', 'BS-H', 'BS_H', 'H_Base_Sat', 'H %', 'H Sat', '% H'],
      'Na_Sat': ['Na_Sat', 'BS-Na', 'BS_Na', 'Na_Base_Sat', 'Na %', 'Na Sat', '% Na'],
      'Zn': ['Zn', 'Zn (M3)', 'Zn_M3', 'Zinc', 'Mehlich Zn'],
      'Cu': ['Cu', 'Cu (M3)', 'Cu_M3', 'Copper', 'Mehlich Cu'],
      'Mn': ['Mn', 'Mn (M3)', 'Mn_M3', 'Manganese', 'Mehlich Mn'],
      'Fe': ['Fe', 'Fe (M3)', 'Fe_M3', 'Iron', 'Mehlich Fe'],
      'Boron': ['Boron', 'B (M3)', 'B_M3', 'B'],
      'S': ['S', 'S (M3)', 'S_M3', 'Sulfur', 'SO4', 'SO4-S'],
      'Buffer_pH': ['Buffer_pH', 'BpH', 'Buffer pH', 'SMP', 'SMP pH', 'Buffer'],
      'Na': ['Na', 'Sodium', 'Na (M3)', 'ExchNa', 'Exch Na'],
      'Ca': ['Ca', 'Calcium', 'Ca (M3)', 'ExchCa', 'Exch Ca'],
      'Mg': ['Mg', 'Magnesium', 'Mg (M3)', 'ExchMg', 'Exch Mg'],
      'NO3': ['NO3', 'NO3-N', 'Nitrate', 'Nitrate-N', 'N03'],
      'NH4': ['NH4', 'NH4-N', 'Ammonium', 'Ammonium-N'],
      'Soluble_Salts': ['Soluble_Salts', 'Soluble_Sal', 'Sol_Salts', 'Salts', 'SS'],
      'EC': ['EC', 'EC (1:1)', 'Electrical Conductivity']
    };
    
    // Get combined aliases (default + user-saved)
    function getAliases() {
      const saved = JSON.parse(localStorage.getItem('columnAliases') || '{}');
      const combined = JSON.parse(JSON.stringify(DEFAULT_ALIASES));
      
      for (const [standard, aliases] of Object.entries(saved)) {
        if (combined[standard]) {
          // Add user aliases to the beginning (higher priority)
          combined[standard] = [...new Set([...aliases, ...combined[standard]])];
        } else {
          combined[standard] = aliases;
        }
      }
      return combined;
    }
    
    // Save a new alias
    function saveAlias(standardField, alias) {
      const saved = JSON.parse(localStorage.getItem('columnAliases') || '{}');
      if (!saved[standardField]) saved[standardField] = [];
      if (!saved[standardField].includes(alias)) {
        saved[standardField].push(alias);
        localStorage.setItem('columnAliases', JSON.stringify(saved));
      }
    }
    
    // Match a column name to a standard field
    function matchColumn(colName) {
      const aliases = getAliases();
      const colLower = colName.toLowerCase().trim();
      
      for (const [standard, alts] of Object.entries(aliases)) {
        for (const alt of alts) {
          if (alt.toLowerCase() === colLower || colName === alt) {
            return standard;
          }
        }
      }
      return null;
    }
    
    // Analyze columns from file and categorize as matched/unmatched
    function analyzeColumns(sampleProps) {
      const columns = Object.keys(sampleProps);
      const matched = [];
      const unmatched = [];
      
      // System fields we don't need to map
      const systemFields = ['lat', 'lon', 'Lat', 'Lon', 'LAT', 'LON', 'latitude', 'longitude', 
                           'sampleId', 'SampleID', 'ID', 'ORG_ID', 'field', 'Field', 'FIELD_NAME',
                           'year', 'Year', 'CropYear', 'date', 'depth', 'Depth', 'DEPTH',
                           'name', 'Name', 'CLIENT_NAM', 'FARM_NAME', 'Field_Name', 'field_name',
                           'POLYGONTYP', 'CLIENT_ID', 'FARM_ID', 'FIELD_ID', 'geometry', 'type'];
      
      for (const col of columns) {
        if (systemFields.some(sf => sf.toLowerCase() === col.toLowerCase())) continue;
        
        const match = matchColumn(col);
        if (match) {
          matched.push({ fileCol: col, standardCol: match });
        } else {
          unmatched.push({ fileCol: col, standardCol: null });
        }
      }
      
      return { matched, unmatched };
    }
    
    // Pending import data (while modal is open)
    let pendingImportData = null;
    let pendingMappings = {};
    
    function showMappingModal(samples, analysis) {
      pendingImportData = samples;
      pendingMappings = {};
      
      const matchedDiv = document.getElementById('matchedColumns');
      const unmatchedDiv = document.getElementById('unmatchedColumns');
      
      // Show matched
      if (analysis.matched.length > 0) {
        matchedDiv.innerHTML = analysis.matched.map(m => `
          <div class="mapping-row matched">
            <span class="file-col">${m.fileCol}</span>
            <span class="arrow">‚Üí</span>
            <span class="matched-label">${m.standardCol}</span>
          </div>
        `).join('');
        document.getElementById('matchedSection').style.display = 'block';
      } else {
        document.getElementById('matchedSection').style.display = 'none';
      }
      
      // Show unmatched with dropdown
      if (analysis.unmatched.length > 0) {
        const options = ['(skip)', ...STANDARD_FIELDS].map(f => `<option value="${f}">${f}</option>`).join('');
        unmatchedDiv.innerHTML = analysis.unmatched.map(u => {
          // Initialize to skip by default
          pendingMappings[u.fileCol] = '(skip)';
          return `
          <div class="mapping-row unmatched">
            <span class="file-col">${u.fileCol}</span>
            <span class="arrow">‚Üí</span>
            <select onchange="pendingMappings['${u.fileCol}']=this.value">
              ${options}
            </select>
          </div>
        `}).join('');
        document.getElementById('unmatchedSection').style.display = 'block';
      } else {
        document.getElementById('unmatchedSection').style.display = 'none';
      }
      
      document.getElementById('mappingModal').classList.add('active');
    }
    
    function closeMappingModal() {
      document.getElementById('mappingModal').classList.remove('active');
      pendingImportData = null;
      pendingMappings = {};
    }
    
    async function proceedWithImport() {
      if (!pendingImportData) {
        showStatus('No data to import', false);
        return;
      }
      
      const saveAliases = document.getElementById('saveNewAliases').checked;
      
      // Apply mappings and save aliases if requested
      for (const [fileCol, standardCol] of Object.entries(pendingMappings)) {
        if (standardCol && standardCol !== '(skip)') {
          // Apply mapping to all samples
          pendingImportData.forEach(sample => {
            if (sample[fileCol] !== undefined && sample[standardCol] === undefined) {
              const num = parseFloat(sample[fileCol]);
              sample[standardCol] = isNaN(num) ? sample[fileCol] : num;
            }
          });
          
          // Save alias for future
          if (saveAliases) {
            saveAlias(standardCol, fileCol);
          }
        }
      }
      
      // Store samples before closing modal
      const samplesToImport = pendingImportData;
      
      closeMappingModal();
      
      // Continue with import
      try {
        await finishSampleImport(samplesToImport);
      } catch (e) {
        showStatus('Import error: ' + e.message, false);
        console.error(e);
      }
    }
    
    // Normalize column names from different data formats (using aliases)
    function normalizeNutrientData(sample) {
      const aliases = getAliases();
      
      for (const [standard, alternatives] of Object.entries(aliases)) {
        if (sample[standard] === undefined) {
          for (const alt of alternatives) {
            if (sample[alt] !== undefined && sample[alt] !== null && sample[alt] !== '') {
              const num = parseFloat(sample[alt]);
              sample[standard] = isNaN(num) ? sample[alt] : num;
              break;
            }
          }
        }
      }
      return sample;
    }

    function geojsonToSamples(geojson, assignedYear, assignedDepth) {
      const samples = [], features = geojson.features || [geojson];

      // Get shapefile name for fallback field name (from multi-file zips)
      const shapefileName = geojson.fileName || geojson.name || null;

      // Debug
      console.log('Sample GeoJSON:', geojson);
      console.log('Shapefile name:', shapefileName);
      if (features[0]) console.log('First sample properties:', features[0].properties);

      features.forEach((f, idx) => {
        if (!f.geometry || f.geometry.type !== 'Point') return;
        const [lon, lat] = f.geometry.coordinates, props = f.properties || {};

        // Field name will be assigned from boundary matching after import
        // Don't extract from file data - let assignSamplesToFields() handle it
        let fieldName = null;
        
        // Get depth from file or use assigned depth
        const fileDepth = props.Depth || props.depth || props.DEPTH || props.DepthUnits;
        
        const sample = { 
          sampleId: props.ORG_ID || props.SampleID || props.sampleId || props.Sample_ID || props.SAMPLE_ID || props.ID || (idx + 1), 
          field: fieldName, 
          lat, 
          lon, 
          year: assignedYear || parseYear(props.CropYear || props.Year || props.year || props.date),
          depth: assignedDepth || fileDepth || '6'
        };
        Object.entries(props).forEach(([k, v]) => { if (sample[k] === undefined && v !== null) { const n = parseFloat(v); sample[k] = isNaN(n) ? v : n; } });
        
        // Normalize nutrient column names
        normalizeNutrientData(sample);
        
        samples.push(sample);
      });
      return samples;
    }

    function parseCSV(text, assignedYear, assignedDepth) {
      const lines = text.trim().split('\n'); if (lines.length < 2) return [];
      const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, '')), samples = [];
      for (let i = 1; i < lines.length; i++) {
        const values = lines[i].split(',').map(v => v.trim().replace(/"/g, '')), sample = {};
        headers.forEach((h, idx) => { const v = values[idx]; if (v) { const n = parseFloat(v); sample[h] = isNaN(n) ? v : n; } });
        sample.lat = sample.lat || sample.Lat || sample.LAT; sample.lon = sample.lon || sample.Lon || sample.LON || sample.lng;
        sample.field = sample.field || sample.Field || 'Unknown'; sample.year = assignedYear || parseYear(sample.year || sample.Year);
        sample.depth = assignedDepth || sample.depth || sample.Depth || '6';
        sample.sampleId = sample.sampleId || sample.SampleID || sample.ID || i;
        if (sample.lat && sample.lon) samples.push(sample);
      }
      return samples;
    }

    function parseYear(d) { if (!d) return null; if (typeof d === 'number') return d >= 1900 && d <= 2099 ? d : null; const m = String(d).match(/\b(19|20)\d{2}\b/); return m ? parseInt(m[0]) : null; }

    function assignSamplesToFields() {
      sampleData.forEach(sample => {
        let assigned = false;

        // Always try to match sample to a boundary by GPS location
        for (const [name, polys] of Object.entries(fieldBoundaries)) {
          if (assigned) break;
          const arr = Array.isArray(polys[0]?.[0]) ? polys : [polys];
          for (const poly of arr) {
            if (isPointInOrNearPolygon([sample.lat, sample.lon], poly)) {
              sample.field = name;
              assigned = true;
              break;
            }
          }
        }

        // Mark as Unassigned if no boundary match
        if (!assigned) {
          sample.field = 'Unassigned';
        }
      });
    }
    
    function reassignSamplesToBoundaries() {
      if (Object.keys(fieldBoundaries).length === 0) {
        showStatus('No boundaries loaded. Upload boundaries first.', false);
        return;
      }
      
      let reassignedCount = 0;
      sampleData.forEach(sample => {
        const oldField = sample.field;
        let assigned = false;
        
        // Try to find a matching boundary
        for (const [name, polys] of Object.entries(fieldBoundaries)) {
          if (assigned) break;
          const arr = Array.isArray(polys[0]?.[0]) ? polys : [polys];
          for (const poly of arr) { 
            if (isPointInOrNearPolygon([sample.lat, sample.lon], poly)) { 
              if (sample.field !== name) {
                sample.field = name;
                reassignedCount++;
              }
              assigned = true;
              break;
            } 
          }
        }
      });
      
      if (reassignedCount > 0) {
        afterImportSuccess();
        showStatus(`‚úì Reassigned ${reassignedCount} samples to boundaries`, true);
        
        // Sync to Google Sheets if signed in
        if (SheetsAPI.isSignedIn) {
          syncToSheets();
        }
      } else {
        showStatus('All samples already assigned to correct boundaries', true);
      }
    }

    function isPointInOrNearPolygon(point, polygon) {
      const [lat, lon] = point; 
      let inside = false;
      const epsilon = 0.0001; // Larger buffer (~10 meters) for edge cases
      
      // First check: is point very close to any vertex?
      for (let i = 0; i < polygon.length; i++) {
        const [plat, plon] = polygon[i];
        if (Math.abs(lat - plat) < epsilon && Math.abs(lon - plon) < epsilon) {
          return true;
        }
      }
      
      // Second check: is point very close to any edge?
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const [lat1, lon1] = polygon[i], [lat2, lon2] = polygon[j];
        
        // Distance from point to line segment
        const dx = lat2 - lat1;
        const dy = lon2 - lon1;
        const len2 = dx * dx + dy * dy;
        
        if (len2 > 0) {
          let t = Math.max(0, Math.min(1, ((lat - lat1) * dx + (lon - lon1) * dy) / len2));
          const nearestLat = lat1 + t * dx;
          const nearestLon = lon1 + t * dy;
          const dist = Math.sqrt((lat - nearestLat) ** 2 + (lon - nearestLon) ** 2);
          if (dist < epsilon) {
            return true;
          }
        }
      }
      
      // Third check: standard ray casting for inside
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const [lat1, lon1] = polygon[i], [lat2, lon2] = polygon[j];
        if (((lon1 > lon) !== (lon2 > lon)) && (lat < (lat2 - lat1) * (lon - lon1) / (lon2 - lon1) + lat1)) {
          inside = !inside;
        }
      }
      return inside;
    }

    // ========== YIELD DATA FUNCTIONS ==========
    
    async function uploadYield() {
      const fileInput = document.getElementById('yieldFiles');
      const files = fileInput.files;
      const yieldYearInput = document.getElementById('yieldYear');
      let yieldYear = yieldYearInput.value.trim();
      const yieldCrop = document.getElementById('yieldCrop').value;
      const radiusFeet = parseInt(document.getElementById('yieldRadius').value);
      const statusEl = document.getElementById('yieldStatus');

      if (!files.length) { showStatus('Please select yield file(s)', false); return; }

      statusEl.innerHTML = '<span style="color: #3b82f6;">‚è≥ Processing yield data...</span>';

      try {
        let yieldPoints = [];
        let detectedYear = null;

        // Check if ZIP file
        const zipFile = Array.from(files).find(f => f.name.toLowerCase().endsWith('.zip'));

        if (zipFile) {
          const result = await parseYieldFromZip(zipFile);
          yieldPoints = result.points;
          detectedYear = result.detectedYear;
        } else {
          const result = await parseYieldFromShapefiles(files);
          yieldPoints = result.points;
          detectedYear = result.detectedYear;
        }

        // Auto-fill year if detected from file and input is empty
        if (detectedYear && !yieldYear) {
          yieldYear = String(detectedYear);
          yieldYearInput.value = yieldYear;
          statusEl.innerHTML = `<span style="color: #3b82f6;">üìÖ Detected year ${detectedYear} from file</span><br>`;
        }

        // Still require year even after auto-detect attempt
        if (!yieldYear) {
          statusEl.innerHTML = '<span style="color: #ef4444;">‚ùå Please enter the crop year (could not auto-detect from file)</span>';
          return;
        }

        if (yieldPoints.length === 0) {
          statusEl.innerHTML = '<span style="color: #ef4444;">‚ùå No yield points found in file</span>';
          return;
        }

        // Add metadata to each point
        yieldPoints.forEach(p => {
          p.year = parseInt(yieldYear);
          p.crop = yieldCrop;
        });
        
        // Store yield data
        const existingKeys = new Set(yieldData.map(y => `${y.lat}-${y.lon}-${y.year}`));
        const newPoints = yieldPoints.filter(p => !existingKeys.has(`${p.lat}-${p.lon}-${p.year}`));
        yieldData = [...yieldData, ...newPoints];
        
        statusEl.innerHTML = `<span style="color: #22c55e;">‚úì Loaded ${newPoints.length} yield points</span>`;
        
        // Now correlate with soil samples
        statusEl.innerHTML += '<br><span style="color: #3b82f6;">‚è≥ Correlating with soil samples...</span>';
        
        const correlationResults = correlateYieldToSamples(yieldYear, radiusFeet);

        // Clear raw yield data after correlation - only keep correlated summary on samples
        yieldData = [];
        localStorage.removeItem('yieldData');

        afterImportSuccess();

        const yearInfo = detectedYear ? `üìÖ Auto-detected year: ${detectedYear}<br>` : '';
        statusEl.innerHTML = `<span style="color: #22c55e;">${yearInfo}‚úì Processed ${newPoints.length} yield points<br>‚úì Matched ${correlationResults.matched} of ${correlationResults.total} soil samples<br>‚úì Raw yield data cleared (correlated data saved on samples)</span>`;
        
        fileInput.value = '';
        
      } catch (e) {
        console.error('Yield upload error:', e);
        statusEl.innerHTML = `<span style="color: #ef4444;">‚ùå Error: ${e.message}</span>`;
      }
    }
    
    async function parseYieldFromZip(zipFile) {
      const JSZip = window.JSZip || (await loadJSZip());
      const zip = await JSZip.loadAsync(zipFile);
      
      let shpFile, dbfFile;
      for (const [name, file] of Object.entries(zip.files)) {
        const lower = name.toLowerCase();
        if (lower.endsWith('.shp')) shpFile = file;
        if (lower.endsWith('.dbf')) dbfFile = file;
      }
      
      if (!shpFile || !dbfFile) throw new Error('ZIP must contain .shp and .dbf files');
      
      const shpBuffer = await shpFile.async('arraybuffer');
      const dbfBuffer = await dbfFile.async('arraybuffer');
      
      return parseYieldShapefile(shpBuffer, dbfBuffer);
    }
    
    async function parseYieldFromShapefiles(files) {
      const fileMap = {};
      for (const f of files) {
        const ext = f.name.split('.').pop().toLowerCase();
        fileMap[ext] = await f.arrayBuffer();
      }
      
      if (!fileMap.shp || !fileMap.dbf) throw new Error('Need both .shp and .dbf files');
      
      return parseYieldShapefile(fileMap.shp, fileMap.dbf);
    }
    
    function parseYieldShapefile(shpBuffer, dbfBuffer) {
      const points = [];
      
      // Parse DBF for attributes
      const dbfView = new DataView(dbfBuffer);
      const numRecords = dbfView.getUint32(4, true);
      const headerSize = dbfView.getUint16(8, true);
      const recordSize = dbfView.getUint16(10, true);
      
      // Parse field descriptors
      const fields = [];
      let offset = 32;
      while (offset < headerSize - 1) {
        const fieldName = String.fromCharCode(...new Uint8Array(dbfBuffer.slice(offset, offset + 11))).replace(/\0/g, '').trim();
        if (!fieldName) break;
        const fieldType = String.fromCharCode(dbfView.getUint8(offset + 11));
        const fieldLen = dbfView.getUint8(offset + 16);
        fields.push({ name: fieldName, type: fieldType, length: fieldLen });
        offset += 32;
      }
      
      // Find yield field - common names from JD and Climate
      const yieldFieldNames = ['VRYIELDVO', 'Yld_Vol_Dr', 'YLD_VOL_DR', 'YIELD', 'DryYield', 'Dry_Yield', 'YldVolDry', 'YldMassDry', 'VRYIELDMA', 'Yld_Mass_D'];
      let yieldField = fields.find(f => yieldFieldNames.includes(f.name));
      if (!yieldField) {
        // Try partial match
        yieldField = fields.find(f => f.name.toLowerCase().includes('yield') || f.name.toLowerCase().includes('yld'));
      }

      if (!yieldField) {
        console.warn('Available fields:', fields.map(f => f.name));
        throw new Error('Could not find yield field. Available: ' + fields.map(f => f.name).join(', '));
      }

      // Find date/time field to auto-detect year - common names from JD and Climate
      const dateFieldNames = ['TIMESTAMP', 'TimeStamp', 'IsoTime', 'ISOTIME', 'Date', 'DATE', 'HarvestDat', 'Time', 'TIME', 'DATETIME', 'DateTime', 'Harvest_Da', 'VRLOGTIME'];
      let dateField = fields.find(f => dateFieldNames.includes(f.name));
      if (!dateField) {
        // Try partial match for date/time fields
        dateField = fields.find(f => f.name.toLowerCase().includes('time') || f.name.toLowerCase().includes('date'));
      }

      // Also look for explicit year field
      const yearFieldNames = ['Year', 'YEAR', 'CropYear', 'CROPYEAR', 'Crop_Year'];
      let yearField = fields.find(f => yearFieldNames.includes(f.name));
      
      // Parse SHP for coordinates
      const shpView = new DataView(shpBuffer);
      let shpOffset = 100; // Skip header
      
      const records = [];
      while (shpOffset < shpBuffer.byteLength - 8) {
        const recordNum = shpView.getInt32(shpOffset, false);
        const contentLen = shpView.getInt32(shpOffset + 4, false) * 2;
        const shapeType = shpView.getInt32(shpOffset + 8, true);
        
        if (shapeType === 1 || shapeType === 11) { // Point or PointZ
          const x = shpView.getFloat64(shpOffset + 12, true); // Longitude
          const y = shpView.getFloat64(shpOffset + 20, true); // Latitude
          records.push({ lon: x, lat: y });
        }
        
        shpOffset += 8 + contentLen;
      }
      
      // Parse DBF records and match with coordinates
      let dbfOffset = headerSize;
      let detectedYear = null;

      for (let i = 0; i < Math.min(numRecords, records.length); i++) {
        dbfOffset++; // Skip deletion flag

        let fieldOffset = 0;
        let yieldValue = null;

        for (const field of fields) {
          const rawValue = String.fromCharCode(...new Uint8Array(dbfBuffer.slice(dbfOffset + fieldOffset, dbfOffset + fieldOffset + field.length))).trim();

          if (field.name === yieldField.name) {
            yieldValue = parseFloat(rawValue);
          }

          // Try to detect year from first record with valid data
          if (detectedYear === null && rawValue) {
            // Check explicit year field first
            if (yearField && field.name === yearField.name) {
              const yr = parseInt(rawValue);
              if (yr >= 1990 && yr <= 2100) {
                detectedYear = yr;
              }
            }
            // Check date/time field
            else if (dateField && field.name === dateField.name) {
              // Try various date formats
              // ISO format: 2024-09-15T... or 2024/09/15
              const isoMatch = rawValue.match(/^(20\d{2}|19\d{2})[-\/]/);
              if (isoMatch) {
                detectedYear = parseInt(isoMatch[1]);
              }
              // US format: 09/15/2024 or 09-15-2024
              const usMatch = rawValue.match(/[-\/](20\d{2}|19\d{2})($|\s|T)/);
              if (!detectedYear && usMatch) {
                detectedYear = parseInt(usMatch[1]);
              }
              // Just year: 2024
              const yearOnly = rawValue.match(/^(20\d{2}|19\d{2})$/);
              if (!detectedYear && yearOnly) {
                detectedYear = parseInt(yearOnly[1]);
              }
            }
          }

          fieldOffset += field.length;
        }

        dbfOffset += recordSize - 1;

        if (records[i] && yieldValue && !isNaN(yieldValue) && yieldValue > 0) {
          points.push({
            lat: records[i].lat,
            lon: records[i].lon,
            yield: yieldValue
          });
        }
      }

      return { points, detectedYear };
    }
    
    function correlateYieldToSamples(yieldYear, radiusFeet) {
      // Convert feet to approximate degrees (at ~40¬∞ latitude)
      // 1 degree latitude ‚âà 364,000 feet
      // 1 degree longitude ‚âà 288,000 feet (at 40¬∞N)
      const radiusLatDeg = radiusFeet / 364000;
      const radiusLonDeg = radiusFeet / 288000;

      let matched = 0;
      let skippedYear = 0;
      let skippedLocation = 0;
      const yieldYear_int = parseInt(yieldYear);

      // Filter yield data for this year
      const yearYield = yieldData.filter(y => y.year === yieldYear_int);

      if (yearYield.length === 0) {
        return { matched: 0, total: sampleData.length, skippedYear: 0, skippedLocation: 0, noYieldData: true };
      }

      // Get yield data bounding box for debugging
      const yieldLats = yearYield.map(y => y.lat);
      const yieldLons = yearYield.map(y => y.lon);
      const yieldBounds = {
        minLat: Math.min(...yieldLats), maxLat: Math.max(...yieldLats),
        minLon: Math.min(...yieldLons), maxLon: Math.max(...yieldLons)
      };

      // Get sample bounds for comparison
      const sampleLats = sampleData.map(s => s.lat).filter(v => v);
      const sampleLons = sampleData.map(s => s.lon).filter(v => v);
      const sampleBounds = sampleLats.length > 0 ? {
        minLat: Math.min(...sampleLats), maxLat: Math.max(...sampleLats),
        minLon: Math.min(...sampleLons), maxLon: Math.max(...sampleLons)
      } : null;

      console.log('=== YIELD CORRELATION DEBUG ===');
      console.log('Yield points:', yearYield.length);
      console.log('Yield bounds:', yieldBounds);
      console.log('Sample count:', sampleData.length);
      console.log('Sample bounds:', sampleBounds);
      console.log('Radius (ft):', radiusFeet, '‚Üí Lat deg:', radiusLatDeg.toFixed(6), 'Lon deg:', radiusLonDeg.toFixed(6));

      // Find nearest yield point to first few samples
      sampleData.slice(0, 5).forEach((sample, i) => {
        let minDist = Infinity;
        let nearest = null;
        yearYield.forEach(y => {
          const dist = Math.sqrt(Math.pow(y.lat - sample.lat, 2) + Math.pow(y.lon - sample.lon, 2));
          if (dist < minDist) { minDist = dist; nearest = y; }
        });
        const minDistFeet = minDist * 364000; // rough conversion
        console.log(`Sample ${i} (${sample.field}): lat=${sample.lat}, lon=${sample.lon} ‚Üí Nearest yield: ${minDistFeet.toFixed(0)} ft away`);
      });

      sampleData.forEach(sample => {
        // Match yield to ALL soil samples regardless of year (correlate by location)
        // The yield year is stored with the correlation data

        // Find all yield points within radius
        const nearbyYields = yearYield.filter(y => {
          const latDiff = Math.abs(y.lat - sample.lat);
          const lonDiff = Math.abs(y.lon - sample.lon);
          return latDiff <= radiusLatDeg && lonDiff <= radiusLonDeg;
        });

        if (nearbyYields.length > 0) {
          // Calculate average yield
          const avgYield = nearbyYields.reduce((sum, y) => sum + y.yield, 0) / nearbyYields.length;
          const crop = nearbyYields[0].crop;

          // Store on sample
          if (!sample.yieldCorrelations) sample.yieldCorrelations = {};
          sample.yieldCorrelations[yieldYear_int] = {
            avgYield: Math.round(avgYield * 10) / 10,
            pointCount: nearbyYields.length,
            crop: crop,
            radiusFt: radiusFeet
          };

          matched++;
        } else {
          skippedLocation++;
        }
      });

      // Save updated samples
      saveLocalData();

      return { matched, total: sampleData.length, skippedYear, skippedLocation, yieldBounds };
    }
    
    async function loadJSZip() {
      // JSZip should already be loaded from earlier script
      if (window.JSZip) return window.JSZip;
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
        script.onload = () => resolve(window.JSZip);
        script.onerror = reject;
        document.head.appendChild(script);
      });
    }

    async function syncToSheets() {
      if (!SheetsAPI.isSignedIn) { showStatus('Please sign in first', false); return; }
      showStatus('Syncing to Google Sheets...', true);
      try {
        await SheetsAPI.initializeSheets();
        
        // Clear existing data first, then write fresh (prevents duplicates)
        await clearSheetsData('Fields');
        await clearSheetsData('Samples');
        
        // Write fields
        if (Object.keys(fieldBoundaries).length > 0) {
          const fieldRows = Object.entries(fieldBoundaries).map(([name, boundary]) => [
            Date.now().toString(36) + Math.random().toString(36).substr(2, 5),
            name,
            JSON.stringify(boundary),
            0,
            new Date().toISOString()
          ]);
          await gapi.client.sheets.spreadsheets.values.append({
            spreadsheetId: CONFIG.SHEET_ID,
            range: 'Fields!A:E',
            valueInputOption: 'RAW',
            resource: { values: fieldRows }
          });
        }
        
        // Write samples
        if (sampleData.length > 0) {
          const headerRes = await gapi.client.sheets.spreadsheets.values.get({ 
            spreadsheetId: CONFIG.SHEET_ID, 
            range: 'Samples!A1:ZZ1' 
          });
          const headers = headerRes.result.values?.[0] || [];
          const rows = sampleData.map(s => headers.map(h => { 
            const v = s[h]; 
            if (v === undefined || v === null) return ''; 
            if (typeof v === 'object') return JSON.stringify(v); 
            return v; 
          }));
          await gapi.client.sheets.spreadsheets.values.append({
            spreadsheetId: CONFIG.SHEET_ID,
            range: 'Samples!A:ZZ',
            valueInputOption: 'RAW',
            resource: { values: rows }
          });
        }
        
        showStatus(`‚úì Synced ${Object.keys(fieldBoundaries).length} fields, ${sampleData.length} samples`, true);
      } catch (e) { showStatus('Sync error: ' + e.message, false); console.error(e); }
    }

    async function clearSamples() {
      if (!confirm('Clear all samples? Boundaries will be kept.')) return;

      sampleData = [];
      saveLocalData();
      saveBackup();
      updateSummary();
      updateBackupStatus();

      if (SheetsAPI.isSignedIn) {
        showStatus('Clearing from Google Sheets...', true);
        try {
          await clearSheetsData('Samples');
          showStatus('‚úì Samples cleared', true);
        } catch (e) {
          showStatus('Local cleared, but Sheets error: ' + e.message, false);
        }
      } else {
        showStatus('‚úì Samples cleared', true);
      }
    }

    async function clearBoundaries() {
      if (!confirm('Clear all field boundaries? Samples will be kept.')) return;

      fieldBoundaries = {};
      saveLocalData();
      saveBackup();
      updateSummary();
      updateBackupStatus();

      if (SheetsAPI.isSignedIn) {
        showStatus('Clearing from Google Sheets...', true);
        try {
          await clearSheetsData('Fields');
          showStatus('‚úì Boundaries cleared', true);
        } catch (e) {
          showStatus('Local cleared, but Sheets error: ' + e.message, false);
        }
      } else {
        showStatus('‚úì Boundaries cleared', true);
      }
    }

    async function clearYieldData() {
      if (!confirm('Clear all yield correlations from samples?')) return;

      // Remove yield correlations from all samples
      sampleData.forEach(s => {
        if (s.yieldCorrelations) delete s.yieldCorrelations;
      });

      saveLocalData();
      saveBackup();
      updateSummary();
      updateBackupStatus();
      showStatus('‚úì Yield correlations cleared', true);
    }

    async function clearAllData() {
      if (!confirm('Clear ALL data (samples, boundaries, and yield)?')) return;

      sampleData = [];
      fieldBoundaries = {};
      saveLocalData();
      saveBackup();
      updateSummary();
      updateBackupStatus();

      if (SheetsAPI.isSignedIn) {
        showStatus('Clearing from Google Sheets...', true);
        try {
          await clearSheetsData('Samples');
          await clearSheetsData('Fields');
          showStatus('‚úì All data cleared', true);
        } catch (e) {
          showStatus('Local cleared, but Sheets error: ' + e.message, false);
        }
      } else {
        showStatus('‚úì All data cleared', true);
      }
    }
    
    async function clearSheetsData(sheetName) {
      // Get the last row with data
      const response = await gapi.client.sheets.spreadsheets.values.get({
        spreadsheetId: CONFIG.SHEET_ID,
        range: `${sheetName}!A:A`
      });
      const numRows = response.result.values ? response.result.values.length : 1;
      
      if (numRows > 1) {
        // Clear all data rows (keep header row 1)
        await gapi.client.sheets.spreadsheets.values.clear({
          spreadsheetId: CONFIG.SHEET_ID,
          range: `${sheetName}!A2:ZZ${numRows}`
        });
      }
    }

    // ========== EXPORT FUNCTIONS ==========
    function getVisibleNutrients() {
      const saved = JSON.parse(localStorage.getItem('nutrientVisibility') || '{}');
      const defaultVisible = ['sampleId', 'pH', 'P', 'K', 'OM', 'CEC', 'Ca_sat', 'Mg_sat', 'K_Sat', 'H_Sat', 'Zn', 'Cu', 'Mn', 'Fe', 'Boron', 'S', 'Buffer_pH'];
      const allNutrients = ['sampleId', 'pH', 'P', 'K', 'OM', 'CEC', 'Ca_sat', 'Mg_sat', 'K_Sat', 'H_Sat', 'Zn', 'Cu', 'Mn', 'Fe', 'Boron', 'S', 'Buffer_pH', 'P2', 'Na_Sat', 'Na', 'Ca', 'Mg', 'NO3', 'NH4', 'Soluble_Salts', 'EC'];
      return allNutrients.filter(n => saved[n] !== undefined ? saved[n] : defaultVisible.includes(n));
    }

    function exportToCSV() {
      if (sampleData.length === 0) {
        showStatus('No sample data to export', false);
        return;
      }

      const visibleNutrients = getVisibleNutrients();
      const operationName = localStorage.getItem('operationName') || 'SoilData';

      // Build headers: base fields + visible nutrients + yield columns
      const headers = ['Field', 'Year', 'Lat', 'Lon', 'Depth', ...visibleNutrients, 'Yield_Year', 'Yield_Avg', 'Yield_Crop', 'Yield_Points'];

      // Build rows
      const rows = sampleData.map(sample => {
        const row = [
          sample.field || '',
          sample.year || '',
          sample.lat || '',
          sample.lon || '',
          sample.depth || '',
          ...visibleNutrients.map(n => sample[n] !== undefined ? sample[n] : ''),
        ];

        // Add yield data if available
        if (sample.yieldCorrelations && Object.keys(sample.yieldCorrelations).length > 0) {
          const yieldYears = Object.keys(sample.yieldCorrelations);
          const latestYear = yieldYears.sort().pop();
          const yieldInfo = sample.yieldCorrelations[latestYear];
          row.push(latestYear, yieldInfo.avgYield?.toFixed(1) || '', yieldInfo.crop || '', yieldInfo.pointCount || '');
        } else {
          row.push('', '', '', '');
        }

        return row;
      });

      // Create CSV content
      const csvContent = [headers, ...rows]
        .map(row => row.map(cell => {
          const str = String(cell);
          if (str.includes(',') || str.includes('"') || str.includes('\n')) {
            return '"' + str.replace(/"/g, '""') + '"';
          }
          return str;
        }).join(','))
        .join('\n');

      // Download
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = `${operationName}_samples_${new Date().toISOString().split('T')[0]}.csv`;
      link.click();

      showStatus(`‚úì Exported ${sampleData.length} samples to CSV`, true);
    }

    function exportToPDF() {
      if (sampleData.length === 0) {
        showStatus('No sample data to export', false);
        return;
      }

      const visibleNutrients = getVisibleNutrients();
      const operationName = localStorage.getItem('operationName') || 'Soil Analysis';
      const fields = [...new Set(sampleData.map(s => s.field))].filter(f => f);
      const years = [...new Set(sampleData.map(s => s.year))].filter(y => y).sort();

      // Create printable HTML
      const printWindow = window.open('', '_blank');
      printWindow.document.write(`
        <!DOCTYPE html>
        <html>
        <head>
          <title>${operationName} - Sample Data Report</title>
          <style>
            body { font-family: Arial, sans-serif; padding: 20px; font-size: 11px; }
            h1 { color: #1e293b; border-bottom: 2px solid #3b82f6; padding-bottom: 10px; }
            h2 { color: #334155; margin-top: 20px; }
            .summary { display: flex; gap: 20px; margin: 20px 0; }
            .summary-box { background: #f1f5f9; padding: 15px; border-radius: 8px; text-align: center; }
            .summary-box .number { font-size: 24px; font-weight: bold; color: #3b82f6; }
            .summary-box .label { color: #64748b; font-size: 12px; }
            table { width: 100%; border-collapse: collapse; margin: 15px 0; font-size: 10px; }
            th { background: #1e293b; color: white; padding: 8px 4px; text-align: left; }
            td { padding: 6px 4px; border-bottom: 1px solid #e2e8f0; }
            tr:nth-child(even) { background: #f8fafc; }
            .footer { margin-top: 30px; color: #94a3b8; font-size: 10px; text-align: center; }
            @media print { body { padding: 0; } }
          </style>
        </head>
        <body>
          <h1>${operationName} - Sample Data Report</h1>
          <p>Generated: ${new Date().toLocaleString()}</p>

          <div class="summary">
            <div class="summary-box"><div class="number">${sampleData.length}</div><div class="label">Total Samples</div></div>
            <div class="summary-box"><div class="number">${fields.length}</div><div class="label">Fields</div></div>
            <div class="summary-box"><div class="number">${years.join(', ') || 'N/A'}</div><div class="label">Years</div></div>
            <div class="summary-box"><div class="number">${sampleData.filter(s => s.yieldCorrelations && Object.keys(s.yieldCorrelations).length > 0).length}</div><div class="label">With Yield</div></div>
          </div>

          <h2>Sample Data</h2>
          <table>
            <thead>
              <tr>
                <th>Field</th>
                <th>Year</th>
                ${visibleNutrients.slice(0, 12).map(n => `<th>${n}</th>`).join('')}
                <th>Yield</th>
              </tr>
            </thead>
            <tbody>
              ${sampleData.map(s => `
                <tr>
                  <td>${s.field || ''}</td>
                  <td>${s.year || ''}</td>
                  ${visibleNutrients.slice(0, 12).map(n => `<td>${s[n] !== undefined ? (typeof s[n] === 'number' ? s[n].toFixed(1) : s[n]) : ''}</td>`).join('')}
                  <td>${s.yieldCorrelations ? Object.values(s.yieldCorrelations)[0]?.avgYield?.toFixed(0) || '' : ''}</td>
                </tr>
              `).join('')}
            </tbody>
          </table>

          <div class="footer">
            Soil Sample Analysis App ‚Ä¢ ${window.location.hostname}
          </div>
        </body>
        </html>
      `);
      printWindow.document.close();
      printWindow.print();

      showStatus('‚úì PDF report opened for printing', true);
    }

    function showStatus(msg, isSuccess) { const el = document.getElementById('statusMessage'); el.textContent = msg; el.style.display = 'block'; el.style.background = isSuccess ? '#dcfce7' : '#fee2e2'; el.style.color = isSuccess ? '#166534' : '#991b1b'; setTimeout(() => el.style.display = 'none', 4000); }
  </script>
</body>
</html>
