<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/svg+xml" href="favicon.svg">
  <title>Soil Sample Analysis - Import</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f8fafc; color: #1e293b; min-height: 100vh; }
    .top-bar { background: linear-gradient(135deg, #1e293b 0%, #334155 100%); color: white; padding: 1rem 1.5rem; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem; }
    .top-bar h1 { font-size: 1.5rem; font-weight: 700; }
    .top-bar p { font-size: 0.875rem; opacity: 0.8; margin-top: 0.25rem; }
    .nav-links { display: flex; gap: 0.5rem; flex-wrap: wrap; }
    .nav-link { padding: 0.5rem 1rem; background: rgba(255,255,255,0.1); color: white; text-decoration: none; border-radius: 0.375rem; font-size: 0.875rem; font-weight: 500; }
    .nav-link:hover { background: rgba(255,255,255,0.2); }
    .nav-link.active { background: #3b82f6; }
    .auth-section { display: flex; align-items: center; gap: 1rem; }
    .user-info { font-size: 0.875rem; color: rgba(255,255,255,0.9); }
    .sign-in-btn { padding: 0.5rem 1rem; background: #4285f4; color: white; border: none; border-radius: 0.375rem; font-size: 0.875rem; cursor: pointer; }
    .sign-in-btn.signed-in { background: #22c55e; }
    .sign-in-btn.signed-in:hover { background: #16a34a; }
    .import-container { max-width: 1200px; margin: 0 auto; padding: 1.5rem; }

    /* Desktop two-column layout */
    @media (min-width: 769px) {
      .import-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1.5rem;
      }
      .import-grid .yield-section {
        grid-column: 1 / -1;
      }
      .import-grid .field-management-section {
        grid-column: 1 / -1;
      }
    }
    .data-summary { background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1.5rem; }
    .data-summary h4 { margin: 0 0 0.75rem 0; color: #475569; }
    .summary-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; }
    .summary-item { text-align: center; padding: 0.75rem; background: white; border-radius: 0.375rem; }
    .summary-item .number { font-size: 1.5rem; font-weight: 700; color: #1e293b; }
    .summary-item .label { font-size: 0.75rem; color: #64748b; text-transform: uppercase; }
    .import-section { background: white; border-radius: 0.75rem; padding: 1.5rem; margin-bottom: 1.5rem; box-shadow: 0 2px 8px rgba(0,0,0,0.08); border: 2px solid transparent; }
    .import-section h3 { margin: 0 0 1rem 0; display: flex; align-items: center; gap: 0.5rem; font-size: 1.25rem; }
    .import-section.boundaries { background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%); border-color: #3b82f6; }
    .import-section.boundaries h3 { color: #1d4ed8; }
    .import-section.samples { background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%); border-color: #22c55e; }
    .import-section.samples h3 { color: #15803d; }
    .import-section.yield { background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%); border-color: #f59e0b; }
    .import-section.yield h3 { color: #b45309; }
    .import-section.export { background: linear-gradient(135deg, #f5f3ff 0%, #ede9fe 100%); border-color: #8b5cf6; }
    .import-section.export h3 { color: #7c3aed; }
    .import-section.management { background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%); border-color: #64748b; }
    .import-section.management h3 { color: #475569; }
    .form-group { margin-bottom: 1rem; }
    .form-group label { display: block; font-weight: 600; margin-bottom: 0.5rem; color: #374151; font-size: 0.875rem; }
    .form-group input[type="file"], .form-group input[type="text"] { width: 100%; padding: 0.75rem; border: 2px dashed #cbd5e1; border-radius: 0.375rem; background: #f8fafc; }
    .form-group input[type="file"]:hover { border-color: #94a3b8; background: #f1f5f9; }
    .form-group input::placeholder { color: #94a3b8; font-weight: 400; font-style: italic; }
    .form-group small { display: block; margin-top: 0.25rem; color: #64748b; font-size: 0.75rem; }
    .button { padding: 0.75rem 1.5rem; border: none; border-radius: 0.375rem; font-size: 0.875rem; font-weight: 600; cursor: pointer; width: 100%; }
    .button.primary { background: #3b82f6; color: white; }
    .button.success { background: #22c55e; color: white; }
    .button.danger { background: #ef4444; color: white; }
    .button:hover { opacity: 0.9; }
    .btn-row { display: flex; gap: 1rem; flex-wrap: wrap; }
    .btn-row .button { flex: 1; }
    #statusMessage { display: none; position: fixed; top: 1rem; left: 50%; transform: translateX(-50%); z-index: 9999; padding: 0.75rem 1rem; border-radius: 0.375rem; box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
    
    /* Column Mapping Modal */
    .modal-overlay { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10000; justify-content: center; align-items: center; }
    .modal-overlay.active { display: flex; }
    .modal { background: white; border-radius: 0.5rem; max-width: 700px; width: 90%; max-height: 80vh; overflow: hidden; display: flex; flex-direction: column; }
    .modal-header { padding: 1rem 1.5rem; border-bottom: 1px solid #e2e8f0; display: flex; justify-content: space-between; align-items: center; }
    .modal-header h3 { margin: 0; font-size: 1.125rem; }
    .modal-close { background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #64748b; }
    .modal-body { padding: 1.5rem; overflow-y: auto; flex: 1; }
    .modal-footer { padding: 1rem 1.5rem; border-top: 1px solid #e2e8f0; display: flex; justify-content: flex-end; gap: 0.75rem; }
    .mapping-section { margin-bottom: 1.5rem; }
    .mapping-section h4 { margin: 0 0 0.75rem 0; font-size: 0.875rem; color: #475569; display: flex; align-items: center; gap: 0.5rem; }
    .mapping-section h4 .icon { font-size: 1rem; }
    .mapping-row { display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem; background: #f8fafc; border-radius: 0.375rem; margin-bottom: 0.5rem; }
    .mapping-row.matched { background: #dcfce7; }
    .mapping-row.unmatched { background: #fef3c7; }
    .mapping-row .file-col { flex: 1; font-family: monospace; font-size: 0.875rem; color: #1e293b; }
    .mapping-row .arrow { color: #64748b; }
    .mapping-row select { padding: 0.375rem 0.5rem; border: 1px solid #cbd5e1; border-radius: 0.25rem; font-size: 0.875rem; min-width: 120px; }
    .mapping-row .matched-label { color: #166534; font-size: 0.875rem; font-weight: 500; }
    .save-alias-row { display: flex; align-items: center; gap: 0.5rem; margin-top: 0.5rem; }
    .save-alias-row input[type="checkbox"] { width: 1rem; height: 1rem; }
    .save-alias-row label { font-size: 0.875rem; color: #475569; }
    .modal .button { padding: 0.5rem 1rem; width: auto; }
    .backup-footer { position: fixed; bottom: 0; left: 0; right: 0; background: #f8fafc; border-top: 1px solid #e2e8f0; padding: 0.25rem 1rem; font-size: 0.7rem; color: #64748b; text-align: center; z-index: 900; }
    /* CSV Mapping Modal */
    .csv-map-select { width: 100%; padding: 0.375rem 0.5rem; border: 1px solid #cbd5e1; border-radius: 0.25rem; font-size: 0.8rem; background: white; }
    .csv-mapping-field { display: flex; flex-direction: column; gap: 0.25rem; }
    .csv-step-tab.active { border-bottom: 3px solid #8b5cf6; color: #7c3aed; }
    /* Shapefile Mapping Modal */
    .shp-map-select { width: 100%; padding: 0.375rem 0.5rem; border: 1px solid #cbd5e1; border-radius: 0.25rem; font-size: 0.8rem; background: white; }
    .shp-mapping-field { display: flex; flex-direction: column; gap: 0.25rem; }
    .shp-preview-values { font-size: 0.7rem; color: #059669; font-style: italic; max-width: 150px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .shp-step-tab.active { border-bottom: 3px solid #3b82f6; color: #1d4ed8; }
    .shp-unmapped-chip { background: #fef3c7; border: 1px solid #fde047; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-size: 0.75rem; color: #854d0e; }
  </style>
</head>
<body>
  <div class="top-bar">
    <div>
      <h1>üìÅ Import Data</h1>
      <p>Upload boundaries and soil samples</p>
    </div>
    <nav class="nav-links">
      <a href="index.html" class="nav-link">üìç Map</a>
      <a href="analysis.html" class="nav-link">üìä Analysis</a>
      <a href="import.html" class="nav-link active">üìÅ Import</a>
      <a href="settings.html" class="nav-link">‚öôÔ∏è Settings</a>
    </nav>
    <div class="auth-section">
      <span class="user-info" id="userInfo"></span>
      <button class="sign-in-btn" id="authBtn" onclick="handleAuth()">Sign In to Sync</button>
    </div>
  </div>

  <div class="import-container">
    <div class="data-summary">
      <h4>üìä Current Data</h4>
      <div class="summary-grid">
        <div class="summary-item"><div class="number" id="fieldCount">0</div><div class="label">Fields</div></div>
        <div class="summary-item"><div class="number" id="sampleCount">0</div><div class="label">Samples</div></div>
        <div class="summary-item"><div class="number" id="yearCount">0</div><div class="label">Years</div><div class="year-list" id="yearList" style="font-size: 0.7rem; color: #64748b; margin-top: 0.35rem; display: flex; flex-wrap: wrap; gap: 0.25rem 0.5rem; justify-content: center;"></div></div>
        <div class="summary-item"><div class="number" id="yieldCount">0</div><div class="label">Samples w/ Yield</div><div id="yieldFieldSummary" style="font-size: 0.75rem; color: #64748b; margin-top: 0.25rem;"></div></div>
      </div>
      <div id="yieldFieldListContainer" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #fffbeb; border: 1px solid #f59e0b; border-radius: 0.5rem;">
        <div id="yieldFieldList"></div>
      </div>
      <div id="backupStatus" style="margin-top: 1rem; padding: 0.75rem; border-radius: 0.375rem; font-size: 0.8125rem; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 0.5rem;"></div>
    </div>

    <!-- Import Sections Grid -->
    <div class="import-grid">

    <div class="import-section boundaries">
      <h3>üì¶ Import Field Boundaries</h3>

      <!-- Client/Farm Selection -->
      <div style="display: flex; gap: 1rem; flex-wrap: wrap; margin-bottom: 1rem; padding: 0.75rem; background: #f5f3ff; border-radius: 0.5rem; border: 1px solid #ddd6fe;">
        <div class="form-group" style="flex: 1; min-width: 150px;">
          <label style="color: #6b21a8;">Client *</label>
          <div style="display: flex; gap: 0.5rem;">
            <select id="boundaryClientSelect" onchange="updateBoundaryFarmDropdown()" style="flex: 1;"></select>
            <button onclick="quickAddClient()" title="Add new client" style="background: #8b5cf6; color: white; border: none; padding: 0.35rem 0.6rem; border-radius: 0.25rem; cursor: pointer; font-size: 0.875rem;">+</button>
          </div>
        </div>
        <div class="form-group" style="flex: 1; min-width: 150px;">
          <label style="color: #6b21a8;">Farm *</label>
          <div style="display: flex; gap: 0.5rem;">
            <select id="boundaryFarmSelect" style="flex: 1;"></select>
            <button onclick="quickAddFarm()" title="Add new farm" style="background: #8b5cf6; color: white; border: none; padding: 0.35rem 0.6rem; border-radius: 0.25rem; cursor: pointer; font-size: 0.875rem;">+</button>
          </div>
        </div>
      </div>

      <div class="form-group">
        <label>Field Name (optional)</label>
        <input type="text" id="boundaryFieldName" placeholder="Auto-detects from file">
      </div>
      <div class="form-group">
        <label>Boundary File(s)</label>
        <input type="file" id="boundaryFiles" multiple accept=".shp,.dbf,.prj,.shx,.zip,.geojson,.json">
        <small>GeoJSON, Shapefile, or ZIP ‚Ä¢ Select multiple for batch import</small>
      </div>
      <button class="button primary" id="uploadBoundaryBtn">Upload Boundaries</button>
    </div>

    <div class="import-section samples">
      <h3>üî¨ Import Soil Samples</h3>
      <div style="display: flex; gap: 1rem; flex-wrap: wrap; margin-bottom: 1rem;">
        <div class="form-group">
          <label>Sample Year <span style="font-weight: 400; font-size: 0.75rem; color: #dc2626;">(required)</span></label>
          <input type="text" id="sampleYear" placeholder="e.g., 2024" style="width: 120px; border: 2px solid #dc2626; background: #fef2f2;" required>
        </div>
        <div class="form-group">
          <label>Sample Depth <span style="font-weight: 400; font-size: 0.75rem; color: #166534;">(default: 6")</span></label>
          <input type="text" id="sampleDepth" value="6" style="width: 80px; border: 2px solid #22c55e; background: #f0fdf4;">
          <small>inches</small>
        </div>
      </div>

      <!-- Import Type Selection -->
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
        <!-- Option A: Shapefile/ZIP -->
        <div id="shapefileImportBox" style="border: 2px solid #3b82f6; border-radius: 0.5rem; padding: 1rem; background: #eff6ff; cursor: pointer;" onclick="selectImportType('shapefile')">
          <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
            <input type="radio" name="importType" id="importTypeShapefile" value="shapefile" checked style="width: 18px; height: 18px;">
            <label for="importTypeShapefile" style="font-weight: 600; color: #1e40af; cursor: pointer;">üìÅ Shapefile / ZIP / GeoJSON</label>
          </div>
          <p style="font-size: 0.75rem; color: #3b82f6; margin: 0;">For files from precision ag software. Auto-detects columns.</p>
        </div>

        <!-- Option B: CSV with Mapping -->
        <div id="csvImportBox" style="border: 2px solid #e2e8f0; border-radius: 0.5rem; padding: 1rem; background: #f8fafc; cursor: pointer;" onclick="selectImportType('csv')">
          <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
            <input type="radio" name="importType" id="importTypeCSV" value="csv" style="width: 18px; height: 18px;">
            <label for="importTypeCSV" style="font-weight: 600; color: #475569; cursor: pointer;">üìÑ CSV with Column Mapping</label>
          </div>
          <p style="font-size: 0.75rem; color: #64748b; margin: 0;">For lab reports. Map columns to standard fields.</p>
        </div>
      </div>

      <!-- Shapefile Import Panel -->
      <div id="shapefileImportPanel">
        <div class="form-group">
          <label>Sample File(s)</label>
          <input type="file" id="sampleFiles" multiple accept=".shp,.dbf,.prj,.shx,.zip,.geojson,.json">
          <small>Shapefile (.shp + .dbf), ZIP, or GeoJSON ‚Ä¢ Auto-assigns to fields by GPS</small>
        </div>
        <button class="button success" id="uploadSampleBtn">Upload Samples</button>
      </div>

      <!-- CSV Import Panel -->
      <div id="csvImportPanel" style="display: none;">
        <div class="form-group">
          <label>CSV File</label>
          <input type="file" id="csvSampleFile" accept=".csv">
          <small>CSV file from soil testing lab</small>
        </div>
        <div id="csvFileInfo" style="display: none; margin-bottom: 0.5rem; padding: 0.75rem; background: #f0fdf4; border: 1px solid #22c55e; border-radius: 0.375rem;">
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <span id="csvFileName" style="font-weight: 500; color: #166534;"></span>
            <span id="csvRowCount" style="font-size: 0.8rem; color: #64748b;"></span>
          </div>
        </div>
        <div id="csvColumnList" style="display: none; margin-bottom: 1rem; padding: 0.75rem; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 0.375rem; font-size: 0.8rem; color: #475569; line-height: 1.8;"></div>

        <!-- Saved Mappings Dropdown -->
        <div class="form-group" id="savedMappingsGroup" style="display: none;">
          <label>Load Saved Mapping <span style="font-weight: 400; font-size: 0.75rem; color: #64748b;">(optional)</span></label>
          <select id="savedMappingSelect" style="width: 100%;">
            <option value="">-- Select a saved mapping --</option>
          </select>
        </div>

        <button class="button" id="openCsvMappingBtn" style="background: #8b5cf6; color: white;" disabled>üìã Map Columns & Preview</button>
      </div>
    </div>

    <div class="import-section yield yield-section">
      <h3>üåæ Import Yield Data</h3>
      <p style="color: #92400e; font-size: 0.875rem; margin-bottom: 1rem;">Upload yield maps to correlate soil nutrients with crop performance.</p>

      <!-- Import Mode Toggle -->
      <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem; background: #fef3c7; padding: 0.5rem; border-radius: 0.5rem;">
        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; flex: 1; padding: 0.5rem; border-radius: 0.375rem; background: white; border: 2px solid #f59e0b;">
          <input type="radio" name="yieldImportMode" value="quick" checked onchange="toggleYieldImportMode('quick')">
          <div>
            <strong style="color: #92400e;">‚ö° Quick Import</strong>
            <small style="display: block; color: #78716c; font-size: 0.7rem;">Auto-detect columns, minimal setup</small>
          </div>
        </label>
        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; flex: 1; padding: 0.5rem; border-radius: 0.375rem; background: #f5f5f4; border: 2px solid transparent;" id="rawModeLabel">
          <input type="radio" name="yieldImportMode" value="raw" onchange="toggleYieldImportMode('raw')">
          <div>
            <strong style="color: #57534e;">üîß Raw Monitor Data</strong>
            <small style="display: block; color: #78716c; font-size: 0.7rem;">Column mapping & data cleaning</small>
          </div>
        </label>
      </div>

      <!-- Quick Import Mode (default) -->
      <div id="quickYieldMode">
        <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
          <div class="form-group">
            <label>Crop Year <small style="font-weight: normal; color: #64748b;">(auto-detects)</small></label>
            <input type="text" id="yieldYear" placeholder="auto or enter" style="width: 120px;">
          </div>
          <div class="form-group">
            <label>Crop Type</label>
            <select id="yieldCrop" style="width: 140px;" required>
              <option value="">-- Select Crop --</option>
              <option value="corn">üåΩ Corn</option>
              <option value="soybeans">ü´ò Soybeans</option>
              <option value="wheat">üåæ Wheat</option>
              <option value="amylose">üçö Amylose</option>
            </select>
          </div>
          <div class="form-group">
            <label>Sample Radius</label>
            <select id="yieldRadius" style="width: 100px;">
              <option value="50">50 ft</option>
              <option value="100" selected>100 ft</option>
              <option value="150">150 ft</option>
            </select>
          </div>
        </div>
        <div class="form-group">
          <label>Yield File (Shapefile)</label>
          <input type="file" id="yieldFiles" multiple accept=".shp,.dbf,.prj,.shx,.zip">
          <small>Batch upload supported: select up to 250 ZIPs or .shp/.dbf pairs at once (auto-matched by name)</small>
        </div>
        <button class="button" id="uploadYieldBtn" style="background: #f59e0b; color: white;">Upload Yield Data</button>
      </div>

      <!-- Raw Monitor Data Mode -->
      <div id="rawYieldMode" style="display: none;">
        <div style="background: #fffbeb; border: 1px solid #fcd34d; border-radius: 0.5rem; padding: 0.75rem; margin-bottom: 1rem; font-size: 0.8rem;">
          <strong style="color: #92400e;">üìã Raw Yield Monitor Import</strong>
          <p style="color: #78716c; margin: 0.25rem 0 0 0;">Upload raw yield files from John Deere, Ag Leader, Climate FieldView, or other systems. You'll map columns and configure data cleaning filters.</p>
        </div>
        <div style="display: flex; gap: 1rem; flex-wrap: wrap; margin-bottom: 1rem;">
          <div class="form-group">
            <label>Crop Type</label>
            <select id="rawYieldCrop" style="width: 140px;" onchange="updateRawYieldDefaults()">
              <option value="corn">üåΩ Corn</option>
              <option value="soybeans">ü´ò Soybeans</option>
              <option value="wheat">üåæ Wheat</option>
              <option value="amylose">üçö Amylose</option>
            </select>
          </div>
          <div class="form-group">
            <label>Crop Year</label>
            <input type="text" id="rawYieldYear" placeholder="2024" style="width: 100px;">
          </div>
          <div class="form-group">
            <label>Sample Radius</label>
            <select id="rawYieldRadius" style="width: 100px;">
              <option value="50">50 ft</option>
              <option value="100" selected>100 ft</option>
              <option value="150">150 ft</option>
            </select>
          </div>
        </div>
        <div class="form-group">
          <label>Yield Monitor Files</label>
          <input type="file" id="rawYieldFiles" multiple accept=".shp,.dbf,.prj,.shx,.zip,.geojson,.json">
          <small>ZIP, Shapefile (.shp + .dbf + .shx), or GeoJSON ‚Ä¢ Select multiple files</small>
        </div>
        <button class="button" style="background: #f59e0b; color: white;" onclick="startRawYieldImport()">Upload & Map Columns ‚Üí</button>
      </div>

      <div id="yieldStatus" style="margin-top: 0.75rem;"></div>
    </div>

    <div class="import-section export">
      <h3>üì§ Export Data</h3>
      <p style="color: #64748b; font-size: 0.875rem; margin-bottom: 1rem;">Export all sample data with visible attributes and yield correlations.</p>
      <div class="btn-row">
        <button class="button" id="exportCSVBtn" style="background: #8b5cf6; color: white;">üìä Export CSV</button>
        <button class="button" id="exportPDFBtn" style="background: #6366f1; color: white;">üìÑ Export PDF Report</button>
        <button class="button" id="exportJSONBtn" style="background: #059669; color: white;">üíæ Download Full Backup</button>
      </div>
    </div>

    <div class="import-section management">
      <h3>üîÑ Data Management</h3>
      <div class="btn-row">
        <button class="button primary" id="loadFromSheetsBtn" style="background: #059669; color: white;">üì• Load from Google Sheets</button>
        <button class="button" id="reassignBtn" style="background: #3b82f6; color: white;">üîÑ Reassign Samples to Boundaries</button>
      </div>
      <div class="btn-row" style="margin-top: 0.75rem;">
        <button class="button danger" id="clearSamplesBtn">üóëÔ∏è Clear Samples</button>
        <button class="button danger" id="clearBoundariesBtn">üóëÔ∏è Clear Boundaries</button>
        <button class="button danger" id="clearYieldBtn">üóëÔ∏è Clear Yield Data</button>
        <button class="button danger" id="clearAllBtn">üóëÔ∏è Clear All</button>
      </div>
      <small style="display:block; margin-top:0.75rem; color:#64748b;">Imports auto-sync to Google Sheets when signed in. Use "Load from Sheets" to pull data from another device.</small>
    </div>

    <!-- Data Quality / Outlier Removal Section -->
    <div class="import-section" style="background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%); border-color: #ef4444;">
      <h3 style="color: #dc2626;">üßπ Data Quality</h3>
      <p style="color: #991b1b; font-size: 0.875rem; margin-bottom: 1rem;">Scan for and remove outliers or bad data points from your dataset.</p>

      <!-- Outlier Thresholds (collapsible) -->
      <div style="margin-bottom: 1rem;">
        <button onclick="toggleOutlierThresholds()" style="background: none; border: 1px solid #fca5a5; padding: 0.5rem 0.75rem; border-radius: 0.375rem; cursor: pointer; font-size: 0.8rem; color: #991b1b; display: flex; align-items: center; gap: 0.5rem;">
          <span id="thresholdToggleIcon">‚ñ∂</span> Configure Outlier Thresholds
        </button>
        <div id="outlierThresholds" style="display: none; margin-top: 0.75rem; padding: 1rem; background: white; border-radius: 0.5rem; border: 1px solid #fca5a5;">
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">
            <div>
              <label style="font-size: 0.75rem; font-weight: 600; color: #475569;">üåΩ Corn Yield Range (bu/ac)</label>
              <div style="display: flex; gap: 0.5rem; align-items: center;">
                <input type="number" id="outlierCornMin" value="50" style="width: 70px; padding: 0.375rem; border: 1px solid #cbd5e1; border-radius: 0.25rem;">
                <span style="color: #64748b;">to</span>
                <input type="number" id="outlierCornMax" value="350" style="width: 70px; padding: 0.375rem; border: 1px solid #cbd5e1; border-radius: 0.25rem;">
              </div>
            </div>
            <div>
              <label style="font-size: 0.75rem; font-weight: 600; color: #475569;">ü´ò Soybean Yield Range (bu/ac)</label>
              <div style="display: flex; gap: 0.5rem; align-items: center;">
                <input type="number" id="outlierSoyMin" value="20" style="width: 70px; padding: 0.375rem; border: 1px solid #cbd5e1; border-radius: 0.25rem;">
                <span style="color: #64748b;">to</span>
                <input type="number" id="outlierSoyMax" value="100" style="width: 70px; padding: 0.375rem; border: 1px solid #cbd5e1; border-radius: 0.25rem;">
              </div>
            </div>
            <div>
              <label style="font-size: 0.75rem; font-weight: 600; color: #475569;">pH Range</label>
              <div style="display: flex; gap: 0.5rem; align-items: center;">
                <input type="number" id="outlierPHMin" value="4.5" step="0.1" style="width: 70px; padding: 0.375rem; border: 1px solid #cbd5e1; border-radius: 0.25rem;">
                <span style="color: #64748b;">to</span>
                <input type="number" id="outlierPHMax" value="8.5" step="0.1" style="width: 70px; padding: 0.375rem; border: 1px solid #cbd5e1; border-radius: 0.25rem;">
              </div>
            </div>
            <div>
              <label style="font-size: 0.75rem; font-weight: 600; color: #475569;">Phosphorus Max (ppm)</label>
              <input type="number" id="outlierPMax" value="300" style="width: 100px; padding: 0.375rem; border: 1px solid #cbd5e1; border-radius: 0.25rem;">
            </div>
            <div>
              <label style="font-size: 0.75rem; font-weight: 600; color: #475569;">Potassium Max (ppm)</label>
              <input type="number" id="outlierKMax" value="800" style="width: 100px; padding: 0.375rem; border: 1px solid #cbd5e1; border-radius: 0.25rem;">
            </div>
            <div>
              <label style="font-size: 0.75rem; font-weight: 600; color: #475569;">CEC Max</label>
              <input type="number" id="outlierCECMax" value="50" style="width: 100px; padding: 0.375rem; border: 1px solid #cbd5e1; border-radius: 0.25rem;">
            </div>
            <div>
              <label style="font-size: 0.75rem; font-weight: 600; color: #475569;">OM Max (%)</label>
              <input type="number" id="outlierOMMax" value="15" step="0.1" style="width: 100px; padding: 0.375rem; border: 1px solid #cbd5e1; border-radius: 0.25rem;">
            </div>
          </div>
          <button onclick="saveOutlierThresholds()" style="margin-top: 1rem; padding: 0.5rem 1rem; background: #dc2626; color: white; border: none; border-radius: 0.375rem; cursor: pointer; font-size: 0.8rem;">Save Thresholds</button>
        </div>
      </div>

      <!-- Scan Buttons -->
      <div style="display: flex; gap: 0.75rem; flex-wrap: wrap; margin-bottom: 1rem;">
        <button class="button" id="scanOutliersBtn" onclick="scanForOutliers()" style="background: #dc2626; color: white;">üîç Scan for Outliers</button>
        <button class="button" onclick="scanOrphanedSamples()" style="background: #7c3aed; color: white;">üìç Find Samples Outside Boundaries</button>
      </div>

      <!-- Scan Results (hidden by default) -->
      <div id="outlierResults" style="display: none;">
        <div id="outlierSummary" style="padding: 0.75rem; background: white; border-radius: 0.5rem; margin-bottom: 1rem; border: 1px solid #fca5a5;"></div>

        <!-- Outlier Table -->
        <div id="outlierTableContainer" style="max-height: 400px; overflow-y: auto; background: white; border-radius: 0.5rem; border: 1px solid #fca5a5;">
          <table id="outlierTable" style="width: 100%; border-collapse: collapse; font-size: 0.8rem;">
            <thead style="position: sticky; top: 0; background: #fef2f2;">
              <tr>
                <th style="padding: 0.5rem; text-align: left; border-bottom: 2px solid #fca5a5; width: 40px;">
                  <input type="checkbox" id="selectAllOutliers" onchange="toggleAllOutliers(this.checked)">
                </th>
                <th style="padding: 0.5rem; text-align: left; border-bottom: 2px solid #fca5a5;">Field</th>
                <th style="padding: 0.5rem; text-align: left; border-bottom: 2px solid #fca5a5;">Year</th>
                <th style="padding: 0.5rem; text-align: left; border-bottom: 2px solid #fca5a5;">Type</th>
                <th style="padding: 0.5rem; text-align: left; border-bottom: 2px solid #fca5a5;">Issue</th>
                <th style="padding: 0.5rem; text-align: left; border-bottom: 2px solid #fca5a5;">Value</th>
              </tr>
            </thead>
            <tbody id="outlierTableBody"></tbody>
          </table>
        </div>

        <!-- Action Buttons -->
        <div style="margin-top: 1rem; display: flex; gap: 0.75rem; flex-wrap: wrap;">
          <button onclick="selectAllOutliersBtn()" style="padding: 0.5rem 0.75rem; background: #f1f5f9; border: 1px solid #cbd5e1; border-radius: 0.375rem; cursor: pointer; font-size: 0.8rem;">Select All</button>
          <button onclick="selectNoneOutliersBtn()" style="padding: 0.5rem 0.75rem; background: #f1f5f9; border: 1px solid #cbd5e1; border-radius: 0.375rem; cursor: pointer; font-size: 0.8rem;">Select None</button>
          <button onclick="deleteSelectedOutliers()" class="button danger" style="padding: 0.5rem 1rem; font-size: 0.875rem;">üóëÔ∏è Delete Selected</button>
        </div>
      </div>

      <!-- Audit Log -->
      <div id="outlierAuditLog" style="margin-top: 1rem; padding: 0.75rem; background: #fef3c7; border: 1px solid #f59e0b; border-radius: 0.5rem; display: none;">
        <h4 style="margin: 0 0 0.5rem 0; font-size: 0.875rem; color: #92400e;">üìã Deletion History</h4>
        <div id="auditLogContent" style="font-size: 0.75rem; color: #78350f; max-height: 150px; overflow-y: auto;"></div>
      </div>
    </div>

    <!-- Field Management Section (Collapsible) -->
    <div class="import-section field-management-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-color: #0ea5e9;">
      <div style="display: flex; justify-content: space-between; align-items: center; cursor: pointer;" onclick="toggleFieldManagement()">
        <div>
          <h3 style="color: #0369a1; margin: 0;">üó∫Ô∏è Manage Field Boundaries</h3>
          <p style="color: #0c4a6e; font-size: 0.875rem; margin: 0.25rem 0 0 0;">View, rename, or delete field boundaries and their associated soil samples.</p>
        </div>
        <div style="display: flex; align-items: center; gap: 0.75rem;">
          <span id="fieldManagementQuickSummary" style="font-size: 0.8rem; color: #0369a1; background: #e0f2fe; padding: 0.25rem 0.5rem; border-radius: 0.25rem;"></span>
          <span id="fieldManagementToggleIcon" style="font-size: 1.25rem; color: #0369a1; transition: transform 0.2s; transform: rotate(-90deg);">‚ñº</span>
        </div>
      </div>

      <!-- Collapsible Content (collapsed by default) -->
      <div id="fieldManagementContent" style="margin-top: 1rem; display: none;">
        <!-- Field Table -->
        <div id="fieldManagementTable" style="background: white; border-radius: 0.5rem; border: 1px solid #bae6fd; overflow: hidden;">
          <table style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
            <thead style="background: #f0f9ff;">
              <tr>
                <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #bae6fd; color: #0369a1;">Field Name</th>
                <th style="padding: 0.75rem; text-align: right; border-bottom: 2px solid #bae6fd; color: #0369a1;">Acres</th>
                <th style="padding: 0.75rem; text-align: right; border-bottom: 2px solid #bae6fd; color: #0369a1;">Samples</th>
                <th style="padding: 0.75rem; text-align: center; border-bottom: 2px solid #bae6fd; color: #0369a1;">Years</th>
                <th style="padding: 0.75rem; text-align: center; border-bottom: 2px solid #bae6fd; color: #0369a1; width: 150px;">Actions</th>
              </tr>
            </thead>
            <tbody id="fieldTableBody">
              <tr>
                <td colspan="5" style="padding: 2rem; text-align: center; color: #64748b;">
                  <em>No field boundaries loaded</em>
                </td>
              </tr>
            </tbody>
          </table>
        </div>

        <!-- Summary -->
        <div id="fieldManagementSummary" style="margin-top: 1rem; padding: 0.75rem; background: #e0f2fe; border-radius: 0.5rem; font-size: 0.8rem; color: #0369a1; display: none;">
          <span id="fieldSummaryText"></span>
        </div>
      </div>
    </div>

    </div><!-- End import-grid -->
  </div>

  <div id="statusMessage"></div>

  <!-- Field Edit Modal -->
  <div id="fieldEditModal" class="modal-overlay">
    <div class="modal" style="max-width: 450px;">
      <div class="modal-header" style="background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);">
        <h3>‚úèÔ∏è Rename Field</h3>
        <button class="modal-close" onclick="closeFieldEditModal()">&times;</button>
      </div>
      <div class="modal-body" style="padding: 1.5rem;">
        <p style="margin: 0 0 1rem 0; color: #475569;">Rename field boundary and update all associated soil samples.</p>
        <div style="margin-bottom: 1rem;">
          <label style="font-size: 0.85rem; font-weight: 600; color: #334155; display: block; margin-bottom: 0.5rem;">Current Name:</label>
          <div id="fieldEditCurrentName" style="padding: 0.5rem 0.75rem; background: #f1f5f9; border-radius: 0.375rem; font-weight: 500; color: #1e293b;"></div>
        </div>
        <div>
          <label style="font-size: 0.85rem; font-weight: 600; color: #334155; display: block; margin-bottom: 0.5rem;">New Name:</label>
          <input type="text" id="fieldEditNewName" style="width: 100%; padding: 0.5rem 0.75rem; border: 1px solid #cbd5e1; border-radius: 0.375rem; font-size: 0.9rem;" placeholder="Enter new field name">
        </div>
      </div>
      <div class="modal-footer" style="border-top: 1px solid #e2e8f0;">
        <button class="button" style="background: #94a3b8;" onclick="closeFieldEditModal()">Cancel</button>
        <button class="button" style="background: #0ea5e9;" onclick="confirmFieldRename()">Rename Field</button>
      </div>
    </div>
  </div>

  <!-- Field Delete Modal -->
  <div id="fieldDeleteModal" class="modal-overlay">
    <div class="modal" style="max-width: 500px;">
      <div class="modal-header" style="background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%);">
        <h3>üóëÔ∏è Delete Field</h3>
        <button class="modal-close" onclick="closeFieldDeleteModal()">&times;</button>
      </div>
      <div class="modal-body" style="padding: 1.5rem;">
        <p style="margin: 0 0 0.5rem 0; font-size: 1.1rem; font-weight: 600; color: #1e293b;">
          Delete field "<span id="fieldDeleteName"></span>"?
        </p>
        <p id="fieldDeleteSampleInfo" style="margin: 0 0 1.25rem 0; color: #64748b; font-size: 0.9rem;"></p>

        <div style="display: flex; flex-direction: column; gap: 0.75rem;">
          <label class="delete-option" style="display: flex; align-items: flex-start; gap: 0.75rem; padding: 0.75rem; background: #f8fafc; border: 2px solid #e2e8f0; border-radius: 0.5rem; cursor: pointer;">
            <input type="radio" name="deleteOption" value="boundary_only" checked style="margin-top: 0.25rem;">
            <div>
              <div style="font-weight: 600; color: #334155;">Delete boundary only</div>
              <div style="font-size: 0.8rem; color: #64748b;">Keep soil samples - they will become "Unassigned"</div>
            </div>
          </label>

          <label class="delete-option" style="display: flex; align-items: flex-start; gap: 0.75rem; padding: 0.75rem; background: #fef2f2; border: 2px solid #fecaca; border-radius: 0.5rem; cursor: pointer;">
            <input type="radio" name="deleteOption" value="boundary_and_samples" style="margin-top: 0.25rem;">
            <div>
              <div style="font-weight: 600; color: #dc2626;">Delete boundary AND all soil samples</div>
              <div style="font-size: 0.8rem; color: #991b1b;">Permanently remove the boundary and <span id="fieldDeleteSampleCount">0</span> associated samples</div>
            </div>
          </label>

          <label class="delete-option" style="display: flex; align-items: flex-start; gap: 0.75rem; padding: 0.75rem; background: #f0fdf4; border: 2px solid #bbf7d0; border-radius: 0.5rem; cursor: pointer;">
            <input type="radio" name="deleteOption" value="reassign_samples" style="margin-top: 0.25rem;">
            <div>
              <div style="font-weight: 600; color: #166534;">Delete boundary and reassign samples</div>
              <div style="font-size: 0.8rem; color: #15803d;">Samples will be matched to the nearest remaining field by GPS</div>
            </div>
          </label>
        </div>
      </div>
      <div class="modal-footer" style="border-top: 1px solid #e2e8f0;">
        <button class="button" style="background: #94a3b8;" onclick="closeFieldDeleteModal()">Cancel</button>
        <button class="button danger" onclick="confirmFieldDelete()">Delete</button>
      </div>
    </div>
  </div>

  <!-- Column Mapping Modal -->
  <div id="mappingModal" class="modal-overlay">
    <div class="modal">
      <div class="modal-header">
        <h3>üìã Column Mapping</h3>
        <button class="modal-close" onclick="closeMappingModal()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="mapping-section" id="matchedSection">
          <h4><span class="icon">‚úì</span> Matched Columns</h4>
          <div id="matchedColumns"></div>
        </div>
        <div class="mapping-section" id="unmatchedSection">
          <h4><span class="icon">‚ö†Ô∏è</span> Unmatched Columns (select mapping or skip)</h4>
          <div id="unmatchedColumns"></div>
        </div>
        <div class="save-alias-row">
          <input type="checkbox" id="saveNewAliases" checked>
          <label for="saveNewAliases">Save new mappings for future imports</label>
        </div>
      </div>
      <div class="modal-footer">
        <button class="button" style="background: #94a3b8;" onclick="closeMappingModal()">Cancel</button>
        <button class="button primary" onclick="proceedWithImport()">Import with Mappings</button>
      </div>
    </div>
  </div>

  <!-- CSV Column Mapping Modal -->
  <div id="csvMappingModal" class="modal-overlay">
    <div class="modal" style="max-width: 900px; max-height: 90vh; display: flex; flex-direction: column;">
      <div class="modal-header" style="background: linear-gradient(135deg, #f3e8ff 0%, #e9d5ff 100%);">
        <h3>üìÑ CSV Column Mapping</h3>
        <button class="modal-close" onclick="closeCsvMappingModal()">&times;</button>
      </div>
      <div class="modal-body" style="flex: 1; overflow-y: auto; padding: 0;">
        <!-- Step Indicator -->
        <div style="display: flex; border-bottom: 1px solid #e2e8f0; background: #f8fafc;">
          <div id="csvStep1Tab" class="csv-step-tab active" style="flex: 1; padding: 0.75rem; text-align: center; font-weight: 600; border-bottom: 3px solid #8b5cf6; color: #7c3aed;">
            1. Map Columns
          </div>
          <div id="csvStep2Tab" class="csv-step-tab" style="flex: 1; padding: 0.75rem; text-align: center; font-weight: 500; color: #94a3b8;">
            2. Preview & Import
          </div>
        </div>

        <!-- Step 1: Column Mapping -->
        <div id="csvMappingStep1" style="padding: 1rem;">
          <!-- Instructions -->
          <div style="margin-bottom: 1rem; padding: 0.75rem; background: #eff6ff; border: 1px solid #93c5fd; border-radius: 0.5rem;">
            <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
              <span style="font-size: 1.1rem;">üìã</span>
              <strong style="color: #1e40af;">How to map columns:</strong>
            </div>
            <div style="font-size: 0.8rem; color: #1e40af; display: flex; align-items: center; gap: 0.5rem;">
              <span style="background: #dbeafe; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-weight: 600;">Standard Field</span>
              <span>‚Üê</span>
              <span style="background: #e0e7ff; padding: 0.25rem 0.5rem; border-radius: 0.25rem;">Select your CSV column</span>
            </div>
            <p style="margin: 0.5rem 0 0 0; font-size: 0.75rem; color: #64748b;">
              For each field below, choose which column from your CSV contains that data. Leave as "(skip)" if not available.
            </p>
          </div>

          <!-- Required Fields -->
          <div style="background: #fef2f2; border: 1px solid #fecaca; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem;">
            <h4 style="margin: 0 0 0.5rem 0; color: #991b1b; font-size: 0.9rem;">üìç Required Fields</h4>
            <p style="margin: 0 0 0.75rem 0; font-size: 0.7rem; color: #991b1b;">Latitude and Longitude are required. Select the CSV column that contains each value.</p>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 0.75rem;">
              <div class="csv-mapping-field">
                <label style="font-size: 0.8rem; font-weight: 600; color: #dc2626;">Latitude * <span style="font-weight: 400; color: #64748b;">‚Üê CSV column:</span></label>
                <div style="display: flex; gap: 0.5rem; align-items: center;">
                  <select id="csvMapLat" class="csv-map-select" style="flex: 1;" onchange="updateCsvPreview('Lat')"></select>
                  <span id="csvPreviewLat" class="shp-preview-values"></span>
                </div>
              </div>
              <div class="csv-mapping-field">
                <label style="font-size: 0.8rem; font-weight: 600; color: #dc2626;">Longitude * <span style="font-weight: 400; color: #64748b;">‚Üê CSV column:</span></label>
                <div style="display: flex; gap: 0.5rem; align-items: center;">
                  <select id="csvMapLon" class="csv-map-select" style="flex: 1;" onchange="updateCsvPreview('Lon')"></select>
                  <span id="csvPreviewLon" class="shp-preview-values"></span>
                </div>
              </div>
              <div class="csv-mapping-field">
                <label style="font-size: 0.8rem; font-weight: 500;">Sample ID <span style="font-weight: 400; color: #64748b;">‚Üê CSV column:</span></label>
                <div style="display: flex; gap: 0.5rem; align-items: center;">
                  <select id="csvMapSampleId" class="csv-map-select" style="flex: 1;" onchange="updateCsvPreview('SampleId')"></select>
                  <span id="csvPreviewSampleId" class="shp-preview-values"></span>
                </div>
              </div>
              <div class="csv-mapping-field">
                <label style="font-size: 0.8rem; font-weight: 500;">Field Name <span style="font-weight: 400; color: #64748b;">‚Üê CSV column:</span></label>
                <div style="display: flex; gap: 0.5rem; align-items: center;">
                  <select id="csvMapField" class="csv-map-select" style="flex: 1;" onchange="updateCsvPreview('Field')"></select>
                  <span id="csvPreviewField" class="shp-preview-values"></span>
                </div>
              </div>
              <div class="csv-mapping-field">
                <label style="font-size: 0.8rem; font-weight: 500;">Sample Year <span style="font-weight: 400; color: #64748b;">‚Üê CSV column:</span></label>
                <div style="display: flex; gap: 0.5rem; align-items: center;">
                  <select id="csvMapYear" class="csv-map-select" style="flex: 1;" onchange="updateCsvPreview('Year')"></select>
                  <span id="csvPreviewYear" class="shp-preview-values"></span>
                </div>
              </div>
              <div class="csv-mapping-field">
                <label style="font-size: 0.8rem; font-weight: 500;">Sample Depth <span style="font-weight: 400; color: #64748b;">‚Üê CSV column:</span></label>
                <div style="display: flex; gap: 0.5rem; align-items: center;">
                  <select id="csvMapDepth" class="csv-map-select" style="flex: 1;" onchange="updateCsvPreview('Depth')"></select>
                  <span id="csvPreviewDepth" class="shp-preview-values"></span>
                </div>
              </div>
            </div>
          </div>

          <!-- Nutrient Fields -->
          <div style="background: #f0fdf4; border: 1px solid #bbf7d0; border-radius: 0.5rem; padding: 1rem;">
            <h4 style="margin: 0 0 0.5rem 0; color: #166534; font-size: 0.9rem;">üß™ Nutrient Fields</h4>
            <p style="margin: 0 0 0.75rem 0; font-size: 0.7rem; color: #166534;">Match each nutrient to the corresponding column in your CSV. Dropdowns show your CSV column names.</p>
            <div id="csvNutrientMappings" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 0.75rem;"></div>
          </div>

          <!-- Save Mapping Option -->
          <div style="margin-top: 1rem; padding: 0.75rem; background: #f8fafc; border-radius: 0.375rem; display: flex; align-items: center; gap: 0.75rem;">
            <input type="checkbox" id="csvSaveMapping" style="width: 18px; height: 18px;">
            <label for="csvSaveMapping" style="font-size: 0.85rem; color: #475569;">Save this mapping as:</label>
            <input type="text" id="csvMappingName" placeholder="e.g., Ward Labs, AgSource" style="flex: 1; padding: 0.375rem 0.5rem; border: 1px solid #cbd5e1; border-radius: 0.25rem; font-size: 0.85rem;">
          </div>
        </div>

        <!-- Step 2: Preview -->
        <div id="csvMappingStep2" style="display: none; padding: 1rem;">
          <div style="margin-bottom: 1rem; padding: 0.75rem; background: #eff6ff; border: 1px solid #93c5fd; border-radius: 0.375rem;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="font-weight: 600; color: #1e40af;">Preview: First 5 rows of mapped data</span>
              <span id="csvPreviewCount" style="font-size: 0.85rem; color: #3b82f6;"></span>
            </div>
          </div>
          <div style="overflow-x: auto; border: 1px solid #e2e8f0; border-radius: 0.375rem;">
            <table id="csvPreviewTable" style="width: 100%; border-collapse: collapse; font-size: 0.8rem;">
              <thead id="csvPreviewHead" style="background: #f1f5f9;"></thead>
              <tbody id="csvPreviewBody"></tbody>
            </table>
          </div>
          <div id="csvPreviewWarnings" style="margin-top: 1rem;"></div>
        </div>
      </div>
      <div class="modal-footer" style="border-top: 1px solid #e2e8f0;">
        <button class="button" style="background: #94a3b8;" onclick="closeCsvMappingModal()">Cancel</button>
        <button class="button" id="csvBackBtn" style="display: none; background: #64748b;" onclick="csvMappingBack()">‚Üê Back</button>
        <button class="button" id="csvNextBtn" style="background: #8b5cf6;" onclick="csvMappingNext()">Preview ‚Üí</button>
        <button class="button success" id="csvImportBtn" style="display: none;" onclick="csvImportConfirm()">Import Records</button>
      </div>
    </div>
  </div>

  <!-- Shapefile Attribute Mapping Modal -->
  <div id="shpMappingModal" class="modal-overlay">
    <div class="modal" style="max-width: 950px; max-height: 90vh; display: flex; flex-direction: column;">
      <div class="modal-header" style="background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);">
        <h3>üìç Shapefile Attribute Mapping</h3>
        <button class="modal-close" onclick="closeShpMappingModal()">&times;</button>
      </div>
      <div class="modal-body" style="flex: 1; overflow-y: auto; padding: 0;">
        <!-- Summary bar -->
        <div id="shpSummaryBar" style="padding: 0.75rem 1rem; background: #f0f9ff; border-bottom: 1px solid #bae6fd; display: flex; justify-content: space-between; align-items: center;">
          <span id="shpSummaryText" style="font-weight: 600; color: #0369a1;"></span>
          <span id="shpAttrCount" style="font-size: 0.85rem; color: #64748b;"></span>
        </div>

        <!-- Step Indicator -->
        <div style="display: flex; border-bottom: 1px solid #e2e8f0; background: #f8fafc;">
          <div id="shpStep1Tab" class="shp-step-tab active" style="flex: 1; padding: 0.75rem; text-align: center; font-weight: 600; border-bottom: 3px solid #3b82f6; color: #1d4ed8;">
            1. Map Attributes
          </div>
          <div id="shpStep2Tab" class="shp-step-tab" style="flex: 1; padding: 0.75rem; text-align: center; font-weight: 500; color: #94a3b8;">
            2. Preview & Import
          </div>
        </div>

        <!-- Step 1: Attribute Mapping -->
        <div id="shpMappingStep1" style="padding: 1rem;">
          <!-- Instructions -->
          <div style="margin-bottom: 1rem; padding: 0.75rem; background: #eff6ff; border: 1px solid #93c5fd; border-radius: 0.5rem;">
            <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
              <span style="font-size: 1.1rem;">üìã</span>
              <strong style="color: #1e40af;">Map shapefile attributes to soil sample fields:</strong>
            </div>
            <p style="margin: 0 0 0.75rem 0; font-size: 0.8rem; color: #475569;">
              The dropdown options below show ALL attributes found in your shapefile. Select which shapefile attribute corresponds to each soil sample field. Preview values are shown to help verify correct mapping.
            </p>
            <div style="font-size: 0.8rem; color: #1e40af; display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;">
              <span style="background: #dbeafe; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-weight: 600;">Standard Field</span>
              <span>‚Üê</span>
              <span style="background: #e0e7ff; padding: 0.25rem 0.5rem; border-radius: 0.25rem;">Shapefile Attribute</span>
              <span>‚Üí</span>
              <span style="background: #f0fdf4; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-style: italic;">Preview values</span>
            </div>
            <p style="margin: 0.5rem 0 0 0; font-size: 0.75rem; color: #64748b;">
              Lat/Lon are extracted from point geometry.
            </p>
          </div>

          <!-- Required Fields -->
          <div style="background: #f0f9ff; border: 1px solid #bae6fd; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem;">
            <h4 style="margin: 0 0 0.5rem 0; color: #0369a1; font-size: 0.9rem;">üìç Required Fields</h4>
            <p style="margin: 0 0 0.75rem 0; font-size: 0.7rem; color: #0369a1;">Coordinates extracted from geometry. Sample ID helps identify records.</p>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 0.75rem;">
              <div class="shp-mapping-field">
                <label style="font-size: 0.8rem; font-weight: 600; color: #0369a1;">Latitude <span style="font-weight: 400; color: #64748b;">(from geometry)</span></label>
                <div style="padding: 0.375rem 0.5rem; background: #e0f2fe; border-radius: 0.25rem; font-size: 0.8rem; color: #0c4a6e;">Auto-extracted from point coordinates</div>
              </div>
              <div class="shp-mapping-field">
                <label style="font-size: 0.8rem; font-weight: 600; color: #0369a1;">Longitude <span style="font-weight: 400; color: #64748b;">(from geometry)</span></label>
                <div style="padding: 0.375rem 0.5rem; background: #e0f2fe; border-radius: 0.25rem; font-size: 0.8rem; color: #0c4a6e;">Auto-extracted from point coordinates</div>
              </div>
              <div class="shp-mapping-field">
                <label style="font-size: 0.8rem; font-weight: 500;">Sample ID <span style="font-weight: 400; color: #64748b;">‚Üê attribute:</span></label>
                <div style="display: flex; gap: 0.5rem; align-items: center;">
                  <select id="shpMapSampleId" class="shp-map-select" style="flex: 1;" onchange="updateShpPreview('SampleId'); updateUnmappedFromDropdowns();"></select>
                  <span id="shpPreviewSampleId" class="shp-preview-values"></span>
                </div>
              </div>
              <div class="shp-mapping-field">
                <label style="font-size: 0.8rem; font-weight: 500;">Field Name <span style="font-weight: 400; color: #64748b;">‚Üê attribute:</span></label>
                <div style="display: flex; gap: 0.5rem; align-items: center;">
                  <select id="shpMapField" class="shp-map-select" style="flex: 1;" onchange="updateShpPreview('Field'); updateUnmappedFromDropdowns();"></select>
                  <span id="shpPreviewField" class="shp-preview-values"></span>
                </div>
              </div>
              <div class="shp-mapping-field">
                <label style="font-size: 0.8rem; font-weight: 500;">Sample Year <span style="font-weight: 400; color: #64748b;">‚Üê attribute:</span></label>
                <div style="display: flex; gap: 0.5rem; align-items: center;">
                  <select id="shpMapYear" class="shp-map-select" style="flex: 1;" onchange="updateShpPreview('Year'); updateUnmappedFromDropdowns();"></select>
                  <span id="shpPreviewYear" class="shp-preview-values"></span>
                </div>
              </div>
              <div class="shp-mapping-field">
                <label style="font-size: 0.8rem; font-weight: 500;">Sample Depth <span style="font-weight: 400; color: #64748b;">‚Üê attribute:</span></label>
                <div style="display: flex; gap: 0.5rem; align-items: center;">
                  <select id="shpMapDepth" class="shp-map-select" style="flex: 1;" onchange="updateShpPreview('Depth'); updateUnmappedFromDropdowns();"></select>
                  <span id="shpPreviewDepth" class="shp-preview-values"></span>
                </div>
              </div>
            </div>
          </div>

          <!-- Nutrient Fields -->
          <div style="background: #f0fdf4; border: 1px solid #bbf7d0; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem;">
            <h4 style="margin: 0 0 0.5rem 0; color: #166534; font-size: 0.9rem;">üß™ Nutrient Fields</h4>
            <p style="margin: 0 0 0.75rem 0; font-size: 0.7rem; color: #166534;">Match nutrients to shapefile attributes. Preview values shown to verify correct mapping.</p>
            <div id="shpNutrientMappings" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 0.75rem;"></div>
          </div>

          <!-- Unmapped Attributes -->
          <div id="shpUnmappedSection" style="background: #fefce8; border: 1px solid #fde047; border-radius: 0.5rem; padding: 1rem; display: none;">
            <h4 style="margin: 0 0 0.5rem 0; color: #854d0e; font-size: 0.9rem;">üì¶ Unmapped Shapefile Attributes</h4>
            <p style="margin: 0 0 0.5rem 0; font-size: 0.75rem; color: #a16207;">These attributes were found in your shapefile but haven't been mapped above. They will be imported as custom fields. If you need any of these, select them in the dropdowns above.</p>
            <div id="shpUnmappedList" style="display: flex; flex-wrap: wrap; gap: 0.5rem;"></div>
          </div>

          <!-- Save Mapping Option -->
          <div style="margin-top: 1rem; padding: 0.75rem; background: #f8fafc; border-radius: 0.375rem; display: flex; align-items: center; gap: 0.75rem;">
            <input type="checkbox" id="shpSaveMapping" style="width: 18px; height: 18px;">
            <label for="shpSaveMapping" style="font-size: 0.85rem; color: #475569;">Save new mappings as aliases for future imports</label>
          </div>
        </div>

        <!-- Step 2: Preview -->
        <div id="shpMappingStep2" style="display: none; padding: 1rem;">
          <div style="margin-bottom: 1rem; padding: 0.75rem; background: #eff6ff; border: 1px solid #93c5fd; border-radius: 0.375rem;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="font-weight: 600; color: #1e40af;">Preview: First 5 rows of mapped data</span>
              <span id="shpPreviewCount" style="font-size: 0.85rem; color: #3b82f6;"></span>
            </div>
          </div>
          <div style="overflow-x: auto; border: 1px solid #e2e8f0; border-radius: 0.375rem;">
            <table id="shpPreviewTable" style="width: 100%; border-collapse: collapse; font-size: 0.8rem;">
              <thead id="shpPreviewHead" style="background: #f1f5f9;"></thead>
              <tbody id="shpPreviewBody"></tbody>
            </table>
          </div>
          <div id="shpPreviewWarnings" style="margin-top: 1rem;"></div>
        </div>
      </div>
      <div class="modal-footer" style="border-top: 1px solid #e2e8f0;">
        <button class="button" style="background: #94a3b8;" onclick="closeShpMappingModal()">Cancel</button>
        <button class="button" id="shpBackBtn" style="display: none; background: #64748b;" onclick="shpMappingBack()">‚Üê Back</button>
        <button class="button" id="shpNextBtn" style="background: #3b82f6;" onclick="shpMappingNext()">Preview ‚Üí</button>
        <button class="button success" id="shpImportBtn" style="display: none;" onclick="shpImportConfirm()">Import Samples</button>
      </div>
    </div>
  </div>

  <!-- Raw Yield Attribute Mapping Modal -->
  <div id="yieldMappingModal" class="modal-overlay">
    <div class="modal" style="max-width: 900px; max-height: 90vh; display: flex; flex-direction: column;">
      <div class="modal-header" style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);">
        <h3>üìã Yield Data Attribute Mapping</h3>
        <button class="modal-close" onclick="closeYieldMappingModal()">&times;</button>
      </div>
      <div class="modal-body" style="flex: 1; overflow-y: auto; padding: 0;">
        <!-- Summary bar -->
        <div id="yieldMappingSummary" style="padding: 0.75rem 1rem; background: #fffbeb; border-bottom: 1px solid #fcd34d; display: flex; justify-content: space-between; align-items: center;">
          <span id="yieldMappingSummaryText" style="font-weight: 600; color: #92400e;">Found 0 yield points</span>
          <span id="yieldMappingFileCount" style="font-size: 0.85rem; color: #78716c;"></span>
        </div>

        <div style="padding: 1rem;">
          <!-- Instructions -->
          <div style="margin-bottom: 1rem; padding: 0.75rem; background: #fffbeb; border: 1px solid #fcd34d; border-radius: 0.5rem; font-size: 0.85rem; color: #92400e;">
            Detected columns from your yield monitor. Verify the mapping is correct. Preview values help confirm you selected the right columns.
          </div>

          <!-- Required Fields -->
          <div style="background: #fef3c7; border: 1px solid #fcd34d; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem;">
            <h4 style="margin: 0 0 0.75rem 0; color: #92400e; font-size: 0.9rem;">üìç Required Fields</h4>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 0.75rem;">
              <div class="shp-mapping-field">
                <label style="font-size: 0.8rem; font-weight: 600; color: #92400e;">Latitude/Longitude</label>
                <div style="padding: 0.375rem 0.5rem; background: #fef9c3; border-radius: 0.25rem; font-size: 0.8rem; color: #78716c;">Auto-extracted from geometry</div>
              </div>
              <div class="shp-mapping-field">
                <label style="font-size: 0.8rem; font-weight: 500;">Yield (bu/ac) <span style="color: #dc2626;">*</span></label>
                <div style="display: flex; gap: 0.5rem; align-items: center;">
                  <select id="yieldMapYield" class="shp-map-select" style="flex: 1;" onchange="updateYieldMapPreview('yield')"></select>
                  <span id="yieldPreviewYield" class="shp-preview-values" style="color: #059669;"></span>
                </div>
              </div>
              <div class="shp-mapping-field">
                <label style="font-size: 0.8rem; font-weight: 500;">Moisture % <span style="color: #64748b;">(optional)</span></label>
                <div style="display: flex; gap: 0.5rem; align-items: center;">
                  <select id="yieldMapMoisture" class="shp-map-select" style="flex: 1;" onchange="updateYieldMapPreview('moisture')"></select>
                  <span id="yieldPreviewMoisture" class="shp-preview-values" style="color: #059669;"></span>
                </div>
              </div>
            </div>
          </div>

          <!-- Optional Fields for Filtering -->
          <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem;">
            <h4 style="margin: 0 0 0.75rem 0; color: #475569; font-size: 0.9rem;">üîß Optional Fields (for filtering & metadata)</h4>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 0.75rem;">
              <div class="shp-mapping-field">
                <label style="font-size: 0.8rem; font-weight: 500;">Speed (mph)</label>
                <div style="display: flex; gap: 0.5rem; align-items: center;">
                  <select id="yieldMapSpeed" class="shp-map-select" style="flex: 1;" onchange="updateYieldMapPreview('speed')"></select>
                  <span id="yieldPreviewSpeed" class="shp-preview-values" style="color: #059669;"></span>
                </div>
              </div>
              <div class="shp-mapping-field">
                <label style="font-size: 0.8rem; font-weight: 500;">Swath Width (ft)</label>
                <div style="display: flex; gap: 0.5rem; align-items: center;">
                  <select id="yieldMapSwath" class="shp-map-select" style="flex: 1;" onchange="updateYieldMapPreview('swath')"></select>
                  <span id="yieldPreviewSwath" class="shp-preview-values" style="color: #059669;"></span>
                </div>
              </div>
              <div class="shp-mapping-field">
                <label style="font-size: 0.8rem; font-weight: 500;">Timestamp</label>
                <div style="display: flex; gap: 0.5rem; align-items: center;">
                  <select id="yieldMapTimestamp" class="shp-map-select" style="flex: 1;" onchange="updateYieldMapPreview('timestamp')"></select>
                  <span id="yieldPreviewTimestamp" class="shp-preview-values" style="color: #059669;"></span>
                </div>
              </div>
              <div class="shp-mapping-field">
                <label style="font-size: 0.8rem; font-weight: 500;">Field Name</label>
                <div style="display: flex; gap: 0.5rem; align-items: center;">
                  <select id="yieldMapFieldName" class="shp-map-select" style="flex: 1;" onchange="updateYieldMapPreview('fieldName')"></select>
                  <span id="yieldPreviewFieldName" class="shp-preview-values" style="color: #059669;"></span>
                </div>
              </div>
            </div>
          </div>

          <!-- Data Cleaning Filters -->
          <div style="background: #fef2f2; border: 1px solid #fca5a5; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem;">
            <h4 style="margin: 0 0 0.75rem 0; color: #dc2626; font-size: 0.9rem;">‚öôÔ∏è Data Cleaning Filters</h4>
            <p style="margin: 0 0 0.75rem 0; font-size: 0.75rem; color: #7f1d1d;">Filter out bad data points from starts, stops, turns, and sensor errors.</p>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 0.75rem;">
              <div style="display: flex; align-items: center; gap: 0.5rem;">
                <input type="checkbox" id="filterSlowSpeed" checked style="width: 16px; height: 16px;">
                <label for="filterSlowSpeed" style="font-size: 0.8rem;">Remove slow/stopped points &lt;</label>
                <input type="number" id="filterSlowSpeedVal" value="1.5" step="0.5" min="0" style="width: 60px; padding: 0.25rem; border: 1px solid #cbd5e1; border-radius: 0.25rem; font-size: 0.8rem;">
                <span style="font-size: 0.8rem; color: #64748b;">mph</span>
              </div>
              <div style="display: flex; align-items: center; gap: 0.5rem;">
                <input type="checkbox" id="filterHighSpeed" checked style="width: 16px; height: 16px;">
                <label for="filterHighSpeed" style="font-size: 0.8rem;">Remove high-speed points &gt;</label>
                <input type="number" id="filterHighSpeedVal" value="7.0" step="0.5" min="0" style="width: 60px; padding: 0.25rem; border: 1px solid #cbd5e1; border-radius: 0.25rem; font-size: 0.8rem;">
                <span style="font-size: 0.8rem; color: #64748b;">mph</span>
              </div>
              <div style="display: flex; align-items: center; gap: 0.5rem;">
                <input type="checkbox" id="filterYieldLow" checked style="width: 16px; height: 16px;">
                <label for="filterYieldLow" style="font-size: 0.8rem;">Remove yield outliers below</label>
                <input type="number" id="filterYieldLowVal" value="20" step="5" min="0" style="width: 60px; padding: 0.25rem; border: 1px solid #cbd5e1; border-radius: 0.25rem; font-size: 0.8rem;">
                <span style="font-size: 0.8rem; color: #64748b;">bu/ac</span>
              </div>
              <div style="display: flex; align-items: center; gap: 0.5rem;">
                <input type="checkbox" id="filterYieldHigh" checked style="width: 16px; height: 16px;">
                <label for="filterYieldHigh" style="font-size: 0.8rem;">Remove yield outliers above</label>
                <input type="number" id="filterYieldHighVal" value="400" step="10" min="0" style="width: 60px; padding: 0.25rem; border: 1px solid #cbd5e1; border-radius: 0.25rem; font-size: 0.8rem;">
                <span style="font-size: 0.8rem; color: #64748b;">bu/ac</span>
              </div>
              <div style="display: flex; align-items: center; gap: 0.5rem;">
                <input type="checkbox" id="filterMoistureLow" style="width: 16px; height: 16px;">
                <label for="filterMoistureLow" style="font-size: 0.8rem;">Remove moisture below</label>
                <input type="number" id="filterMoistureLowVal" value="8" step="1" min="0" style="width: 60px; padding: 0.25rem; border: 1px solid #cbd5e1; border-radius: 0.25rem; font-size: 0.8rem;">
                <span style="font-size: 0.8rem; color: #64748b;">%</span>
              </div>
              <div style="display: flex; align-items: center; gap: 0.5rem;">
                <input type="checkbox" id="filterMoistureHigh" style="width: 16px; height: 16px;">
                <label for="filterMoistureHigh" style="font-size: 0.8rem;">Remove moisture above</label>
                <input type="number" id="filterMoistureHighVal" value="35" step="1" min="0" style="width: 60px; padding: 0.25rem; border: 1px solid #cbd5e1; border-radius: 0.25rem; font-size: 0.8rem;">
                <span style="font-size: 0.8rem; color: #64748b;">%</span>
              </div>
            </div>
          </div>

          <!-- Unmapped Attributes -->
          <div id="yieldUnmappedSection" style="background: #f1f5f9; border: 1px solid #cbd5e1; border-radius: 0.5rem; padding: 0.75rem; display: none;">
            <h4 style="margin: 0 0 0.5rem 0; color: #475569; font-size: 0.85rem;">üì¶ Unmapped Attributes (will be ignored)</h4>
            <div id="yieldUnmappedList" style="display: flex; flex-wrap: wrap; gap: 0.5rem;"></div>
          </div>

          <!-- Save Mapping Option -->
          <div style="margin-top: 1rem; padding: 0.75rem; background: #f8fafc; border-radius: 0.375rem; display: flex; align-items: center; gap: 0.75rem;">
            <input type="checkbox" id="yieldSaveMapping" checked style="width: 18px; height: 18px;">
            <label for="yieldSaveMapping" style="font-size: 0.85rem; color: #475569;">Save these mappings for future yield imports</label>
          </div>
        </div>
      </div>
      <div class="modal-footer" style="border-top: 1px solid #e2e8f0;">
        <button class="button" style="background: #94a3b8;" onclick="closeYieldMappingModal()">Cancel</button>
        <button class="button" style="background: #f59e0b; color: white;" onclick="previewYieldCleaning()">Preview & Clean Data ‚Üí</button>
      </div>
    </div>
  </div>

  <!-- Raw Yield Preview & Cleaning Modal -->
  <div id="yieldPreviewModal" class="modal-overlay">
    <div class="modal" style="max-width: 950px; max-height: 90vh; display: flex; flex-direction: column;">
      <div class="modal-header" style="background: linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%);">
        <h3>üìä Yield Data Preview</h3>
        <button class="modal-close" onclick="closeYieldPreviewModal()">&times;</button>
      </div>
      <div class="modal-body" style="flex: 1; overflow-y: auto; padding: 0;">
        <!-- Import Summary -->
        <div style="background: #f8fafc; border-bottom: 1px solid #e2e8f0; padding: 1rem;">
          <h4 style="margin: 0 0 0.75rem 0; color: #1e293b; font-size: 0.95rem;">Import Summary</h4>
          <div id="yieldCleaningSummary" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 0.5rem; font-size: 0.85rem;"></div>
        </div>

        <!-- Yield Statistics -->
        <div style="background: #f0fdf4; border-bottom: 1px solid #bbf7d0; padding: 1rem;">
          <h4 style="margin: 0 0 0.75rem 0; color: #166534; font-size: 0.95rem;">Yield Statistics (after cleaning)</h4>
          <div id="yieldStatsGrid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 0.75rem;"></div>
          <div id="yieldFieldBreakdown" style="margin-top: 1rem;"></div>
        </div>

        <!-- Sample Data Preview -->
        <div style="padding: 1rem;">
          <h4 style="margin: 0 0 0.75rem 0; color: #1e293b; font-size: 0.95rem;">Sample Data (first 10 rows)</h4>
          <div style="overflow-x: auto; border: 1px solid #e2e8f0; border-radius: 0.375rem;">
            <table id="yieldPreviewTable" style="width: 100%; border-collapse: collapse; font-size: 0.8rem;">
              <thead style="background: #f1f5f9;">
                <tr id="yieldPreviewHead"></tr>
              </thead>
              <tbody id="yieldPreviewBody"></tbody>
            </table>
          </div>
        </div>
      </div>
      <div class="modal-footer" style="border-top: 1px solid #e2e8f0;">
        <button class="button" style="background: #64748b;" onclick="backToYieldMapping()">‚Üê Back to Mapping</button>
        <button class="button" style="background: #059669; color: white;" id="confirmYieldImportBtn" onclick="confirmRawYieldImport()">Import Points</button>
      </div>
    </div>
  </div>

  <!-- Yield Import Progress Modal -->
  <div id="yieldProgressModal" class="modal-overlay">
    <div class="modal" style="max-width: 500px;">
      <div class="modal-header" style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);">
        <h3>‚è≥ Importing Yield Data...</h3>
      </div>
      <div class="modal-body" style="text-align: center; padding: 2rem;">
        <div style="background: #e2e8f0; border-radius: 9999px; height: 20px; margin-bottom: 1rem; overflow: hidden;">
          <div id="yieldProgressBar" style="background: linear-gradient(90deg, #f59e0b, #fbbf24); height: 100%; width: 0%; transition: width 0.3s ease;"></div>
        </div>
        <p id="yieldProgressText" style="font-size: 0.9rem; color: #475569; margin: 0;">Processing: 0 of 0 points</p>
        <p id="yieldProgressMatched" style="font-size: 0.85rem; color: #059669; margin: 0.5rem 0 0 0;"></p>
        <p style="font-size: 0.8rem; color: #94a3b8; margin-top: 1rem;">Please wait... this may take a minute for large files.</p>
      </div>
    </div>
  </div>

  <!-- Yield Import Summary Modal -->
  <div id="yieldSummaryModal" class="modal-overlay">
    <div class="modal" style="max-width: 900px;">
      <div class="modal-header" style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);">
        <h3>üåæ Yield Import Summary</h3>
        <button class="modal-close" onclick="closeYieldSummary()">&times;</button>
      </div>
      <div class="modal-body" style="padding: 0;">
        <!-- Summary Stats -->
        <div id="yieldSummaryStats" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; padding: 1rem; background: #f8fafc; border-bottom: 1px solid #e2e8f0;"></div>

        <!-- Tabs -->
        <div style="display: flex; border-bottom: 1px solid #e2e8f0;">
          <button class="yield-tab active" onclick="switchYieldTab('fields')" data-tab="fields" style="flex: 1; padding: 0.75rem; border: none; background: white; cursor: pointer; font-weight: 600; border-bottom: 2px solid #f59e0b;">üìä Per-Field Breakdown</button>
          <button class="yield-tab" onclick="switchYieldTab('unmatched')" data-tab="unmatched" style="flex: 1; padding: 0.75rem; border: none; background: #f8fafc; cursor: pointer; font-weight: 500; border-bottom: 2px solid transparent;">‚ö†Ô∏è Unmatched Samples</button>
          <button class="yield-tab" onclick="switchYieldTab('map')" data-tab="map" style="flex: 1; padding: 0.75rem; border: none; background: #f8fafc; cursor: pointer; font-weight: 500; border-bottom: 2px solid transparent;">üó∫Ô∏è Map View</button>
        </div>

        <!-- Tab Content -->
        <div id="yieldTabFields" class="yield-tab-content" style="padding: 1rem; max-height: 400px; overflow-y: auto;"></div>
        <div id="yieldTabUnmatched" class="yield-tab-content" style="display: none; padding: 1rem; max-height: 400px; overflow-y: auto;"></div>
        <div id="yieldTabMap" class="yield-tab-content" style="display: none; padding: 0;">
          <div id="yieldMatchMap" style="height: 400px; width: 100%;"></div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="button" style="background: #059669; color: white;" onclick="closeYieldSummary()">Done</button>
      </div>
    </div>
  </div>

  <script src="https://apis.google.com/js/api.js"></script>
  <script src="https://accounts.google.com/gsi/client"></script>
  <script src="https://unpkg.com/shpjs@latest/dist/shp.js"></script>
  <script src="js/core/data.js"></script>
  <script src="js/core/utils.js"></script>
  <script>
    // ========== APP VERSION ==========
    const APP_VERSION = "v1.0.127";
    const BUILD_DATE = "2026-01-22T11:34:51";

    // Reference shared data config with import-specific additions
    const CONFIG = {
      get CLIENT_ID() { return DataCore.config.CLIENT_ID; },
      get API_KEY() { return DataCore.config.API_KEY; },
      get SHEET_ID() { return DataCore.config.SHEET_ID; },
      DECIMAL_PLACES: {
        pH: 2, Buffer_pH: 2, OM: 2, P: 0, P2: 0, K: 0, CEC: 1,
        Ca_sat: 1, Mg_sat: 1, K_Sat: 1, H_Sat: 1, Na_Sat: 1,
        Zn: 2, Cu: 2, Mn: 1, Fe: 1, Boron: 2, S: 1,
        Ca: 0, Mg: 0, Na: 0, NO3: 1, NH4: 1, Soluble_Salts: 2, EC: 2
      }
    };

    // Use shared getDecimals and formatValue from Utils
    function getDecimals(attr) {
      return window.Utils.getDecimals(attr, CONFIG.DECIMAL_PLACES);
    }
    function formatValue(value, attr) {
      return window.Utils.formatValue(value, attr, CONFIG.DECIMAL_PLACES);
    }

    // Use shared SheetsAPI from DataCore, extended with import-specific methods
    const SheetsAPI = Object.assign({}, DataCore.SheetsAPI, {
      
      async initializeSheets() {
        // Helper to create a tab if it doesn't exist
        async function ensureTabExists(tabName) {
          try {
            await gapi.client.sheets.spreadsheets.values.get({ spreadsheetId: CONFIG.SHEET_ID, range: `${tabName}!A1` });
            return true; // Tab exists
          } catch (e) {
            if (e.result?.error?.code === 400 || e.result?.error?.message?.includes('Unable to parse range')) {
              // Tab doesn't exist - create it
              try {
                await gapi.client.sheets.spreadsheets.batchUpdate({
                  spreadsheetId: CONFIG.SHEET_ID,
                  resource: {
                    requests: [{ addSheet: { properties: { title: tabName } } }]
                  }
                });
                console.log(`Created ${tabName} tab`);
                return true;
              } catch (createError) {
                console.error(`Failed to create ${tabName} tab:`, createError);
                return false;
              }
            }
            return false;
          }
        }

        // Ensure all tabs exist
        await ensureTabExists('Clients');
        await ensureTabExists('Farms');
        await ensureTabExists('Fields');
        await ensureTabExists('Samples');

        // Clients tab headers
        try {
          const clientsCheck = await gapi.client.sheets.spreadsheets.values.get({ spreadsheetId: CONFIG.SHEET_ID, range: 'Clients!A1:D1' });
          if (!clientsCheck.result.values || clientsCheck.result.values.length === 0) {
            await gapi.client.sheets.spreadsheets.values.update({ spreadsheetId: CONFIG.SHEET_ID, range: 'Clients!A1:D1', valueInputOption: 'RAW', resource: { values: [['id', 'name', 'createdAt', 'updatedAt']] } });
          }
        } catch (e) { console.warn('Could not set Clients headers:', e); }

        // Farms tab headers
        try {
          const farmsCheck = await gapi.client.sheets.spreadsheets.values.get({ spreadsheetId: CONFIG.SHEET_ID, range: 'Farms!A1:E1' });
          if (!farmsCheck.result.values || farmsCheck.result.values.length === 0) {
            await gapi.client.sheets.spreadsheets.values.update({ spreadsheetId: CONFIG.SHEET_ID, range: 'Farms!A1:E1', valueInputOption: 'RAW', resource: { values: [['id', 'clientId', 'name', 'createdAt', 'updatedAt']] } });
          }
        } catch (e) { console.warn('Could not set Farms headers:', e); }

        // Fields tab (now includes farmId)
        const fieldsCheck = await gapi.client.sheets.spreadsheets.values.get({ spreadsheetId: CONFIG.SHEET_ID, range: 'Fields!A1:F1' });
        if (!fieldsCheck.result.values || fieldsCheck.result.values.length === 0) {
          await gapi.client.sheets.spreadsheets.values.update({ spreadsheetId: CONFIG.SHEET_ID, range: 'Fields!A1:F1', valueInputOption: 'RAW', resource: { values: [['id', 'name', 'boundary', 'acres', 'farmId', 'created']] } });
        } else if (!fieldsCheck.result.values[0].includes('farmId')) {
          // Add farmId column if missing
          const headers = fieldsCheck.result.values[0];
          headers.splice(4, 0, 'farmId'); // Insert before 'created'
          await gapi.client.sheets.spreadsheets.values.update({ spreadsheetId: CONFIG.SHEET_ID, range: 'Fields!A1:F1', valueInputOption: 'RAW', resource: { values: [headers] } });
        }

        // Samples tab
        const samplesCheck = await gapi.client.sheets.spreadsheets.values.get({ spreadsheetId: CONFIG.SHEET_ID, range: 'Samples!A1:Z1' });
        if (!samplesCheck.result.values || samplesCheck.result.values.length === 0) {
          await gapi.client.sheets.spreadsheets.values.update({ spreadsheetId: CONFIG.SHEET_ID, range: 'Samples!A1:W1', valueInputOption: 'RAW', resource: { values: [['sampleId', 'field', 'lat', 'lon', 'year', 'depth', 'pH', 'P', 'K', 'OM', 'Ca_sat', 'Mg_sat', 'K_Sat', 'H_Sat', 'Zn', 'Cu', 'Mn', 'Fe', 'Boron', 'S', 'CEC', 'Buffer_pH', 'yieldCorrelations']] } });
        }
      },
      
      async addField(field) {
        await gapi.client.sheets.spreadsheets.values.append({ spreadsheetId: CONFIG.SHEET_ID, range: 'Fields!A:E', valueInputOption: 'RAW', resource: { values: [[field.id || Date.now().toString(36), field.name, JSON.stringify(field.boundary), field.acres || 0, new Date().toISOString()]] } });
      },
      
      async addSamples(samples) {
        const headerRes = await gapi.client.sheets.spreadsheets.values.get({ spreadsheetId: CONFIG.SHEET_ID, range: 'Samples!A1:ZZ1' });
        const headers = headerRes.result.values?.[0] || [];
        const rows = samples.map(s => headers.map(h => { const v = s[h]; if (v === undefined || v === null) return ''; if (typeof v === 'object') return JSON.stringify(v); return v; }));
        await gapi.client.sheets.spreadsheets.values.append({ spreadsheetId: CONFIG.SHEET_ID, range: 'Samples!A:ZZ', valueInputOption: 'RAW', resource: { values: rows } });
      }
    });

    let sampleData = [], fieldBoundaries = {}, yieldData = [];
    let backupDownloadedThisSession = false;

    // ========== CLIENT/FARM DATA ==========
    let clientsData = [];
    let farmsData = [];
    let activeClientId = 'all';
    let activeFarmId = 'all';

    function loadClientsData() {
      clientsData = DataCore.loadClientsData();
      return clientsData;
    }

    function saveClientsData() {
      DataCore.saveClientsData(clientsData);
    }

    function loadFarmsData() {
      farmsData = DataCore.loadFarmsData();
      return farmsData;
    }

    function saveFarmsData() {
      DataCore.saveFarmsData(farmsData);
    }

    function loadActiveSelection() {
      const selection = DataCore.loadActiveSelection();
      activeClientId = selection.clientId;
      activeFarmId = selection.farmId;
    }

    function getActiveFields() {
      return DataCore.getActiveFields(fieldBoundaries, farmsData, activeClientId, activeFarmId);
    }

    function getFieldBoundaryCoords(fieldName) {
      const field = fieldBoundaries[fieldName];
      if (!field) return null;
      return field.boundary || field;
    }

    // Populate client/farm dropdowns for boundary import
    function populateBoundaryClientFarmSelectors() {
      loadClientsData();
      loadFarmsData();
      loadActiveSelection();

      const clientSelect = document.getElementById('boundaryClientSelect');
      const farmSelect = document.getElementById('boundaryFarmSelect');
      if (!clientSelect || !farmSelect) return;

      // Populate client dropdown
      let clientHtml = '';
      clientsData.forEach(client => {
        const selected = client.id === activeClientId ? 'selected' : '';
        clientHtml += `<option value="${client.id}" ${selected}>${client.name}</option>`;
      });
      if (clientsData.length === 0) {
        clientHtml = '<option value="">No clients - create one first</option>';
      }
      clientSelect.innerHTML = clientHtml;

      // Populate farm dropdown based on selected client
      updateBoundaryFarmDropdown();
    }

    // Update farm dropdown based on selected client
    function updateBoundaryFarmDropdown() {
      const clientSelect = document.getElementById('boundaryClientSelect');
      const farmSelect = document.getElementById('boundaryFarmSelect');
      if (!clientSelect || !farmSelect) return;

      const selectedClientId = clientSelect.value;
      const farms = farmsData.filter(f => f.clientId === selectedClientId);

      let farmHtml = '';
      farms.forEach(farm => {
        const selected = farm.id === activeFarmId ? 'selected' : '';
        farmHtml += `<option value="${farm.id}" ${selected}>${farm.name}</option>`;
      });
      if (farms.length === 0) {
        farmHtml = '<option value="">No farms for this client</option>';
      }
      farmSelect.innerHTML = farmHtml;
    }

    // Quick add client from import page
    function quickAddClient() {
      const name = prompt('Enter new client name:');
      if (!name || !name.trim()) return;

      const newClientId = DataCore.generateId('cli');
      const newFarmId = DataCore.generateId('frm');

      clientsData.push({
        id: newClientId,
        name: name.trim(),
        createdAt: new Date().toISOString()
      });

      farmsData.push({
        id: newFarmId,
        clientId: newClientId,
        name: name.trim() + ' Farm',
        isDefault: true,
        createdAt: new Date().toISOString()
      });

      saveClientsData();
      saveFarmsData();
      populateBoundaryClientFarmSelectors();

      // Select the new client
      document.getElementById('boundaryClientSelect').value = newClientId;
      updateBoundaryFarmDropdown();
      document.getElementById('boundaryFarmSelect').value = newFarmId;

      showStatus(`Client "${name.trim()}" created`, true);
    }

    // Quick add farm from import page
    function quickAddFarm() {
      const clientSelect = document.getElementById('boundaryClientSelect');
      const clientId = clientSelect.value;
      if (!clientId) {
        showStatus('Select a client first', false);
        return;
      }

      const name = prompt('Enter new farm name:');
      if (!name || !name.trim()) return;

      const newFarmId = DataCore.generateId('frm');
      farmsData.push({
        id: newFarmId,
        clientId: clientId,
        name: name.trim(),
        createdAt: new Date().toISOString()
      });

      saveFarmsData();
      updateBoundaryFarmDropdown();
      document.getElementById('boundaryFarmSelect').value = newFarmId;

      const client = clientsData.find(c => c.id === clientId);
      showStatus(`Farm "${name.trim()}" added to ${client?.name || 'client'}`, true);
    }

    document.addEventListener('DOMContentLoaded', async () => {
      // Run migration first
      DataCore.migrateDataIfNeeded();
      loadClientsData();
      loadFarmsData();
      loadActiveSelection();
      await loadLocalData(); updateSummary(); updateBackupStatus(); updateBackupFooter(); refreshFieldTable();
      populateBoundaryClientFarmSelectors(); // Initialize client/farm dropdowns
      try { await SheetsAPI.init(); SheetsAPI.onSignInChange = handleSignInChange; handleSignInChange(SheetsAPI.isSignedIn); } catch (e) { console.warn(e); }
      document.getElementById('uploadBoundaryBtn').addEventListener('click', uploadBoundaries);
      document.getElementById('uploadSampleBtn').addEventListener('click', uploadSamples);
      document.getElementById('uploadYieldBtn').addEventListener('click', uploadYield);
      document.getElementById('loadFromSheetsBtn').addEventListener('click', loadFromSheets);
      document.getElementById('clearSamplesBtn').addEventListener('click', clearSamples);
      document.getElementById('clearBoundariesBtn').addEventListener('click', clearBoundaries);
      document.getElementById('clearYieldBtn').addEventListener('click', clearYieldData);
      document.getElementById('clearAllBtn').addEventListener('click', clearAllData);
      document.getElementById('reassignBtn').addEventListener('click', reassignSamplesToBoundaries);
      document.getElementById('exportCSVBtn').addEventListener('click', exportToCSV);
      document.getElementById('exportPDFBtn').addEventListener('click', exportToPDF);
      document.getElementById('exportJSONBtn').addEventListener('click', exportToJSON);
    });

    async function handleAuth() { if (SheetsAPI.isSignedIn) await SheetsAPI.signOut(); else await SheetsAPI.signIn(); }
    function handleSignInChange(isSignedIn) {
      const authBtn = document.getElementById('authBtn'), userInfo = document.getElementById('userInfo');
      if (isSignedIn) {
        userInfo.textContent = 'Connected';
        authBtn.textContent = '‚úì Signed In';
        authBtn.classList.add('signed-in');
      } else {
        userInfo.textContent = '';
        authBtn.textContent = 'Sign In to Sync';
        authBtn.classList.remove('signed-in');
      }
    }

    // IndexedDB - use shared openDB from DataCore
    let indexedDBAvailable = false;
    async function openDB() {
      const db = await DataCore.openDB();
      indexedDBAvailable = true;
      return db;
    }

    async function saveToIndexedDB() {
      try {
        const db = await openDB();
        const tx = db.transaction(['samples', 'boundaries', 'yield'], 'readwrite');
        const samplesStore = tx.objectStore('samples');
        const boundariesStore = tx.objectStore('boundaries');
        const yieldStore = tx.objectStore('yield');

        // Clear and save samples
        await new Promise((resolve, reject) => {
          const clearReq = samplesStore.clear();
          clearReq.onsuccess = resolve;
          clearReq.onerror = reject;
        });
        await new Promise((resolve, reject) => {
          const putReq = samplesStore.put({ id: 'all', data: sampleData });
          putReq.onsuccess = resolve;
          putReq.onerror = reject;
        });

        // Clear and save boundaries
        await new Promise((resolve, reject) => {
          const clearReq = boundariesStore.clear();
          clearReq.onsuccess = resolve;
          clearReq.onerror = reject;
        });
        await new Promise((resolve, reject) => {
          const putReq = boundariesStore.put({ id: 'all', data: fieldBoundaries });
          putReq.onsuccess = resolve;
          putReq.onerror = reject;
        });

        // Clear and save yield data
        await new Promise((resolve, reject) => {
          const clearReq = yieldStore.clear();
          clearReq.onsuccess = resolve;
          clearReq.onerror = reject;
        });
        await new Promise((resolve, reject) => {
          const putReq = yieldStore.put({ id: 'all', data: yieldData });
          putReq.onsuccess = resolve;
          putReq.onerror = reject;
        });

        db.close();
        localStorage.setItem('usingIndexedDB', 'true');
        console.log('Data saved to IndexedDB (samples:', sampleData.length, ', yield:', yieldData.length, ')');
        return true;
      } catch (e) {
        console.error('IndexedDB save failed:', e);
        return false;
      }
    }

    async function loadFromIndexedDB() {
      try {
        const db = await openDB();
        // Check if yield store exists (may not on older DBs)
        const storeNames = Array.from(db.objectStoreNames);
        const hasYield = storeNames.includes('yield');
        const stores = hasYield ? ['samples', 'boundaries', 'yield'] : ['samples', 'boundaries'];
        const tx = db.transaction(stores, 'readonly');
        const samplesStore = tx.objectStore('samples');
        const boundariesStore = tx.objectStore('boundaries');

        const samplesData = await new Promise((resolve, reject) => {
          const req = samplesStore.get('all');
          req.onsuccess = () => resolve(req.result?.data || []);
          req.onerror = reject;
        });

        const boundariesData = await new Promise((resolve, reject) => {
          const req = boundariesStore.get('all');
          req.onsuccess = () => resolve(req.result?.data || {});
          req.onerror = reject;
        });

        let yieldDataResult = [];
        if (hasYield) {
          const yieldStore = tx.objectStore('yield');
          yieldDataResult = await new Promise((resolve, reject) => {
            const req = yieldStore.get('all');
            req.onsuccess = () => resolve(req.result?.data || []);
            req.onerror = reject;
          });
        }

        db.close();
        return { samples: samplesData, boundaries: boundariesData, yield: yieldDataResult };
      } catch (e) {
        console.error('IndexedDB load failed:', e);
        return null;
      }
    }

    async function loadLocalData() {
      try {
        // Check if we're using IndexedDB
        if (localStorage.getItem('usingIndexedDB') === 'true') {
          const idbData = await loadFromIndexedDB();
          if (idbData) {
            // Load samples, boundaries, and yield independently
            if (idbData.samples && idbData.samples.length > 0) {
              sampleData = idbData.samples;
            }
            if (idbData.boundaries && Object.keys(idbData.boundaries).length > 0) {
              fieldBoundaries = idbData.boundaries;
            }
            if (idbData.yield && idbData.yield.length > 0) {
              yieldData = idbData.yield;
            }
            console.log('Loaded from IndexedDB:', sampleData.length, 'samples,', Object.keys(fieldBoundaries).length, 'fields,', yieldData.length, 'yield points');
            return;
          }
        }
        // Fallback to localStorage
        const s = localStorage.getItem('soilSamples');
        const b = localStorage.getItem('fieldBoundaries');
        const y = localStorage.getItem('yieldData');
        if (s) sampleData = JSON.parse(s);
        if (b) fieldBoundaries = JSON.parse(b);
        if (y) yieldData = JSON.parse(y);
        console.log('Loaded from localStorage:', sampleData.length, 'samples,', yieldData.length, 'yield points');
      } catch (e) {
        console.error('Load error:', e);
      }
    }

    async function saveLocalData() {
      // Try localStorage first (faster for small datasets)
      try {
        const dataStr = JSON.stringify(sampleData);
        const boundariesStr = JSON.stringify(fieldBoundaries);
        const yieldStr = JSON.stringify(yieldData);

        // Check if data is likely too large for localStorage (~4MB limit with safety margin)
        const totalSize = dataStr.length + boundariesStr.length + yieldStr.length;
        if (totalSize > 4000000) {
          throw new Error('Data too large for localStorage');
        }

        localStorage.setItem('soilSamples', dataStr);
        localStorage.setItem('fieldBoundaries', boundariesStr);
        localStorage.setItem('yieldData', yieldStr);
        localStorage.removeItem('usingIndexedDB');
        console.log('Data saved to localStorage:', sampleData.length, 'samples,', yieldData.length, 'yield points');
      } catch (e) {
        // localStorage quota exceeded or data too large - use IndexedDB
        console.log('localStorage quota exceeded, switching to IndexedDB...');
        const success = await saveToIndexedDB();
        if (success) {
          // Clear localStorage to free up space
          localStorage.removeItem('soilSamples');
          localStorage.removeItem('fieldBoundaries');
          localStorage.removeItem('yieldData');
          showStatus('Data saved (using IndexedDB for large dataset)', true);
        } else {
          showStatus('Warning: Could not save data locally. Data is synced to Google Sheets.', false);
        }
      }
    }

    // ========== BACKUP SYSTEM ==========
    function saveBackup() {
      // Save full backup to localStorage (skip if data too large)
      try {
        const backup = {
          version: 1,
          timestamp: Date.now(),
          operationName: localStorage.getItem('operationName') || '',
          sampleData: sampleData,
          fieldBoundaries: fieldBoundaries,
          settings: JSON.parse(localStorage.getItem('soilSettings') || '{}')
        };
        const backupStr = JSON.stringify(backup);
        // Skip localStorage backup if too large - data is in IndexedDB/Sheets
        if (backupStr.length < 4000000) {
          localStorage.setItem('soilDataBackup', backupStr);
        } else {
          localStorage.removeItem('soilDataBackup'); // Clear old backup to free space
        }
        localStorage.setItem('soilDataBackupTime', Date.now().toString());
        updateBackupStatus();
      } catch (e) {
        console.log('Backup to localStorage skipped (data too large)');
        localStorage.setItem('soilDataBackupTime', Date.now().toString());
        updateBackupStatus();
      }
    }

    function updateBackupStatus() {
      const container = document.getElementById('backupStatus');
      const backupTime = localStorage.getItem('soilDataBackupTime');
      const lastDownload = localStorage.getItem('lastBackupDownload');
      const autoBackup = localStorage.getItem('autoBackupFrequency') || 'weekly';

      // No data yet - show neutral message
      if (sampleData.length === 0) {
        container.style.background = '#f8fafc';
        container.style.border = '1px solid #e2e8f0';
        container.innerHTML = '<span style="color: #64748b;">No data to backup yet</span>';
        return;
      }

      const now = Date.now();
      const daysSinceBackup = backupTime ? Math.floor((now - parseInt(backupTime)) / (1000 * 60 * 60 * 24)) : null;
      const daysSinceDownload = lastDownload ? Math.floor((now - parseInt(lastDownload)) / (1000 * 60 * 60 * 24)) : null;

      let statusColor, statusBg, statusBorder, statusIcon, statusText;

      if (!lastDownload) {
        // Has data but never downloaded a backup - show warning
        statusIcon = '‚ö†Ô∏è';
        statusText = 'No backup file downloaded yet - consider downloading one';
        statusBg = '#fffbeb';
        statusBorder = '#fcd34d';
        statusColor = '#92400e';
      } else if (daysSinceDownload > 30) {
        // Backup is old
        statusIcon = '‚ö†Ô∏è';
        statusText = `Last backup download: ${formatDate(parseInt(lastDownload))} (${daysSinceDownload} days ago)`;
        statusBg = '#fffbeb';
        statusBorder = '#fcd34d';
        statusColor = '#92400e';
      } else {
        // Backup is recent
        statusIcon = '‚úì';
        statusText = `Last backup download: ${formatDate(parseInt(lastDownload))}`;
        statusBg = '#f0fdf4';
        statusBorder = '#86efac';
        statusColor = '#166534';
      }

      container.style.background = statusBg;
      container.style.border = `1px solid ${statusBorder}`;
      container.innerHTML = `
        <span style="color: ${statusColor};">${statusIcon} ${statusText}</span>
        <span style="color: #64748b; font-size: 0.75rem;">Auto-backup: ${autoBackup}</span>
      `;

      // Check if we should prompt for auto-backup
      checkAutoBackupPrompt();
    }

    function checkAutoBackupPrompt() {
      const autoBackup = localStorage.getItem('autoBackupFrequency') || 'weekly';
      const lastDownload = localStorage.getItem('lastBackupDownload');
      const lastPrompt = localStorage.getItem('lastBackupPrompt');
      const now = Date.now();

      // Don't prompt more than once per session
      if (lastPrompt && (now - parseInt(lastPrompt)) < 1000 * 60 * 60) return;

      if (autoBackup === 'weekly' && sampleData.length > 0) {
        const daysSince = lastDownload ? Math.floor((now - parseInt(lastDownload)) / (1000 * 60 * 60 * 24)) : 999;
        if (daysSince >= 7) {
          localStorage.setItem('lastBackupPrompt', now.toString());
          if (confirm(`It's been ${daysSince === 999 ? 'a while' : daysSince + ' days'} since your last backup.\n\nDownload a backup now?`)) {
            exportToJSON();
          }
        }
      }
    }

    function formatDate(timestamp) {
      return new Date(timestamp).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
    }

    function exportToJSON() {
      if (sampleData.length === 0 && Object.keys(fieldBoundaries).length === 0) {
        showStatus('No data to export', false);
        return;
      }

      const backup = {
        version: 1,
        exportDate: new Date().toISOString(),
        operationName: localStorage.getItem('operationName') || 'SoilData',
        sampleData: sampleData,
        fieldBoundaries: fieldBoundaries,
        settings: JSON.parse(localStorage.getItem('soilSettings') || '{}'),
        columnAliases: JSON.parse(localStorage.getItem('columnAliases') || '{}'),
        nutrientVisibility: JSON.parse(localStorage.getItem('nutrientVisibility') || '{}')
      };

      const blob = new Blob([JSON.stringify(backup, null, 2)], { type: 'application/json' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      const opName = (backup.operationName || 'SoilData').replace(/[^a-zA-Z0-9]/g, '_');
      link.download = `${opName}_backup_${new Date().toISOString().split('T')[0]}.json`;
      link.click();

      // Record the download
      localStorage.setItem('lastBackupDownload', Date.now().toString());
      updateBackupStatus();
      showStatus(`‚úì Backup downloaded (${sampleData.length} samples, ${Object.keys(fieldBoundaries).length} fields)`, true);
    }

    // Call saveBackup after successful imports
    async function afterImportSuccess() {
      await saveLocalData();
      saveBackup();
      updateSummary();
      updateBackupStatus();
      updateBackupFooter();
      refreshFieldTable();

      // Auto-download only once per session if setting is 'after-import'
      const autoBackup = localStorage.getItem('autoBackupFrequency');
      if (autoBackup === 'after-import' && !backupDownloadedThisSession) {
        backupDownloadedThisSession = true;
        setTimeout(() => exportToJSON(), 500);
      }
    }

    function updateSummary() {
      document.getElementById('fieldCount').textContent = Object.keys(fieldBoundaries).length;
      document.getElementById('sampleCount').textContent = sampleData.length;
      const uniqueYears = [...new Set(sampleData.map(s => s.year).filter(y => y))].sort((a, b) => a - b);
      document.getElementById('yearCount').textContent = uniqueYears.length;
      // Show sample count per year as styled badges
      const yearCounts = {};
      sampleData.forEach(s => {
        if (s.year) {
          yearCounts[s.year] = (yearCounts[s.year] || 0) + 1;
        }
      });
      const yearListEl = document.getElementById('yearList');
      yearListEl.innerHTML = uniqueYears.map(y =>
        `<span style="background: #f1f5f9; padding: 0.15rem 0.4rem; border-radius: 0.25rem; white-space: nowrap;"><strong>${y}</strong>: ${yearCounts[y].toLocaleString()}</span>`
      ).join('');
      // Count samples with yield correlations and build organized field list
      const samplesWithYield = sampleData.filter(s => s.yieldCorrelations && Object.keys(s.yieldCorrelations).length > 0);
      document.getElementById('yieldCount').textContent = samplesWithYield.length;

      // Build field summary with crop/year info
      const fieldYieldInfo = {};
      samplesWithYield.forEach(s => {
        if (!s.field || s.field === 'Unknown') return;
        if (!fieldYieldInfo[s.field]) {
          fieldYieldInfo[s.field] = { count: 0, crops: new Set(), years: new Set() };
        }
        fieldYieldInfo[s.field].count++;
        Object.values(s.yieldCorrelations).forEach(yieldInfo => {
          if (yieldInfo.crop) fieldYieldInfo[s.field].crops.add(yieldInfo.crop);
          if (yieldInfo.year) fieldYieldInfo[s.field].years.add(yieldInfo.year);
        });
        Object.keys(s.yieldCorrelations).forEach(year => {
          fieldYieldInfo[s.field].years.add(parseInt(year));
        });
      });

      const sortedFields = Object.keys(fieldYieldInfo).sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));
      const container = document.getElementById('yieldFieldListContainer');
      const summaryEl = document.getElementById('yieldFieldSummary');

      if (sortedFields.length > 0) {
        // Show collapsible summary
        summaryEl.innerHTML = `across ${sortedFields.length} fields <a href="#" onclick="toggleYieldFieldList(event)" style="color: #f59e0b; text-decoration: none;" id="yieldFieldToggle">Show ‚ñº</a>`;

        // Generate field tags for expanded view
        let yieldListHtml = '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 0.35rem;">';
        sortedFields.forEach(field => {
          const info = fieldYieldInfo[field];
          const crops = [...info.crops].map(c => c === 'corn' ? 'üåΩ' : c === 'amylose' ? 'üçö' : c === 'soybeans' ? 'ü´ò' : '').join('');
          yieldListHtml += `<span style="background: white; border: 1px solid #fbbf24; border-radius: 0.25rem; padding: 0.2rem 0.4rem; font-size: 0.7rem; color: #92400e; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
            <strong>${field}</strong> ${crops} <span style="color: #b45309;">${info.count}</span>
          </span>`;
        });
        yieldListHtml += '</div>';
        document.getElementById('yieldFieldList').innerHTML = yieldListHtml;
      } else {
        summaryEl.innerHTML = '';
        container.style.display = 'none';
      }
    }

    function toggleYieldFieldList(e) {
      e.preventDefault();
      const container = document.getElementById('yieldFieldListContainer');
      const toggle = document.getElementById('yieldFieldToggle');
      if (container.style.display === 'none') {
        container.style.display = 'block';
        toggle.textContent = 'Hide ‚ñ≤';
      } else {
        container.style.display = 'none';
        toggle.textContent = 'Show ‚ñº';
      }
    }

    async function uploadBoundaries() {
      const files = Array.from(document.getElementById('boundaryFiles').files);
      const fieldName = document.getElementById('boundaryFieldName').value.trim();
      const farmId = document.getElementById('boundaryFarmSelect').value;

      if (files.length === 0) { showStatus('Please select file(s)', false); return; }
      if (!farmId) { showStatus('Please select a farm for these boundaries', false); return; }

      showStatus('Processing...', true);
      try {
        let total = 0;
        const shpFile = files.find(f => f.name.toLowerCase().endsWith('.shp'));
        const dbfFile = files.find(f => f.name.toLowerCase().endsWith('.dbf'));
        const isZip = files.length === 1 && files[0].name.toLowerCase().endsWith('.zip');
        const jsonFiles = files.filter(f => f.name.toLowerCase().match(/\.(geo)?json$/));

        // Helper to wrap parsed boundaries in new format with farmId
        function wrapWithFarmId(parsed) {
          const wrapped = {};
          Object.entries(parsed).forEach(([name, coords]) => {
            wrapped[name] = {
              boundary: coords,
              farmId: farmId,
              createdAt: new Date().toISOString()
            };
          });
          return wrapped;
        }

        if (isZip) {
          const arrayBuffer = await files[0].arrayBuffer();
          const geojson = await shp(arrayBuffer);
          const parsed = geojsonToBoundaries(geojson, fieldName);
          Object.assign(fieldBoundaries, wrapWithFarmId(parsed));
          total = Object.keys(parsed).length;
        } else if (shpFile && dbfFile) {
          const shpBuffer = await shpFile.arrayBuffer();
          const dbfBuffer = await dbfFile.arrayBuffer();
          const geojson = await shp({ shp: shpBuffer, dbf: dbfBuffer });
          const parsed = geojsonToBoundaries(geojson, fieldName);
          Object.assign(fieldBoundaries, wrapWithFarmId(parsed));
          total = Object.keys(parsed).length;
        } else if (jsonFiles.length > 0) {
          for (const file of jsonFiles) {
            const text = await file.text(), geojson = JSON.parse(text);
            const parsed = geojsonToBoundaries(geojson, fieldName || file.name.replace(/\.(geo)?json$/i, ''));
            Object.assign(fieldBoundaries, wrapWithFarmId(parsed));
            total += Object.keys(parsed).length;
          }
        } else {
          throw new Error('Please select a ZIP, Shapefile (.shp + .dbf), or GeoJSON');
        }

        // Get farm name for status message
        const farm = farmsData.find(f => f.id === farmId);
        const client = clientsData.find(c => c.id === farm?.clientId);
        const farmLabel = client && farm ? `${client.name} > ${farm.name}` : 'selected farm';

        await afterImportSuccess(); showStatus(`‚úì Imported ${total} field(s) to ${farmLabel}`, true);
        document.getElementById('boundaryFiles').value = ''; document.getElementById('boundaryFieldName').value = '';
        // Auto-sync to Google Sheets if signed in
        if (SheetsAPI.isSignedIn) {
          showStatus('Syncing to Google Sheets...', true);
          await syncToSheets();
        }
      } catch (e) { showStatus('Error: ' + e.message, false); console.error(e); }
    }

    function geojsonToBoundaries(geojson, defaultName) {
      const boundaries = {}, features = geojson.features || [geojson];
      
      // Debug: log the geojson structure
      console.log('GeoJSON structure:', geojson);
      console.log('Features count:', features.length);
      console.log('defaultName parameter:', defaultName);
      if (features[0]) console.log('First feature properties:', features[0].properties);
      
      features.forEach(f => {
        if (!f.geometry) return;
        const type = f.geometry.type;
        if (type !== 'Polygon' && type !== 'MultiPolygon') return;
        const props = f.properties || {};
        
        // Debug: log properties for each feature
        console.log('Feature properties:', props);
        console.log('props.FIELD_NAME value:', props.FIELD_NAME);
        console.log('props.FIELD_NAME truthy?:', !!props.FIELD_NAME);
        
        // Get field name - prioritize FIELD_NAME from properties FIRST (before defaultName)
        let fieldName = null;
        
        // First priority: FIELD_NAME in properties (exact match)
        if (props.FIELD_NAME) {
          fieldName = props.FIELD_NAME;
          console.log('Using props.FIELD_NAME:', fieldName);
        }
        else if (props.Field_Name) {
          fieldName = props.Field_Name;
          console.log('Using props.Field_Name:', fieldName);
        }
        else if (props.field_name) {
          fieldName = props.field_name;
          console.log('Using props.field_name:', fieldName);
        }
        // Second priority: user-provided default name
        else if (defaultName) {
          fieldName = defaultName;
          console.log('Using defaultName:', fieldName);
        }
        // Third priority: extract from compound names
        else {
          const rawName = props.name || props.Name || props.Field || props.field || geojson.name || 'Unknown';
          console.log('Falling back to rawName:', rawName);
          // Extract last part after underscore (e.g., "Precision Farms_Precision Farms_WCG" -> "WCG")
          if (rawName.includes('_')) {
            fieldName = rawName.split('_').pop();
          } else {
            fieldName = rawName;
          }
        }
        
        console.log('Final resolved field name:', fieldName);
        
        if (!boundaries[fieldName]) boundaries[fieldName] = [];
        if (type === 'Polygon') { boundaries[fieldName].push(f.geometry.coordinates[0].map(c => [c[1], c[0]])); }
        else { f.geometry.coordinates.forEach(poly => { boundaries[fieldName].push(poly[0].map(c => [c[1], c[0]])); }); }
      });
      return boundaries;
    }

    async function uploadSamples() {
      const files = Array.from(document.getElementById('sampleFiles').files);
      const yearInput = document.getElementById('sampleYear').value.trim();
      const depth = document.getElementById('sampleDepth').value.trim() || '6';

      // Validate required year
      if (!yearInput) { showStatus('Sample Year is required', false); return; }
      const year = parseInt(yearInput);
      if (isNaN(year) || year < 1900 || year > 2100) { showStatus('Please enter a valid year (e.g., 2024)', false); return; }

      if (files.length === 0) { showStatus('Please select file(s)', false); return; }
      showStatus('Processing...', true);
      try {
        let samples = [];
        const shpFile = files.find(f => f.name.toLowerCase().endsWith('.shp'));
        const dbfFile = files.find(f => f.name.toLowerCase().endsWith('.dbf'));
        const isZip = files.length === 1 && files[0].name.toLowerCase().endsWith('.zip');
        const csvFile = files.find(f => f.name.toLowerCase().endsWith('.csv'));
        const jsonFile = files.find(f => f.name.toLowerCase().match(/\.(geo)?json$/));

        // For shapefiles, show mapping modal before importing
        if (isZip || (shpFile && dbfFile)) {
          let geojson;
          if (isZip) {
            const arrayBuffer = await files[0].arrayBuffer();
            geojson = await shp(arrayBuffer);
            // If multiple shapefiles in zip, combine them
            if (Array.isArray(geojson)) {
              const allFeatures = [];
              geojson.forEach(gj => {
                if (gj.features) allFeatures.push(...gj.features);
              });
              geojson = { type: 'FeatureCollection', features: allFeatures };
            }
          } else {
            const shpBuffer = await shpFile.arrayBuffer();
            const dbfBuffer = await dbfFile.arrayBuffer();
            geojson = await shp({ shp: shpBuffer, dbf: dbfBuffer });
          }

          // Store parsed data and show mapping modal
          shpYear = year;
          shpDepth = depth;
          showShpMappingModal(geojson);
          return; // Modal will call shpImportConfirm() when user confirms
        } else if (csvFile) {
          const text = await csvFile.text();
          samples = parseCSV(text, year, depth);
        } else if (jsonFile) {
          const text = await jsonFile.text();
          const geojson = JSON.parse(text);
          samples = geojsonToSamples(geojson, year, depth);
        } else {
          throw new Error('Please select a ZIP, Shapefile (.shp + .dbf), CSV, or GeoJSON');
        }
        
        if (samples.length === 0) throw new Error('No samples found in file');
        
        // Analyze columns for mapping
        const firstSampleProps = samples[0] || {};
        const analysis = analyzeColumns(firstSampleProps);
        
        // If there are unmatched columns, show the mapping modal
        if (analysis.unmatched.length > 0) {
          showMappingModal(samples, analysis);
          return; // Modal will call finishSampleImport when user confirms
        }
        
        // No unmatched columns - proceed directly
        await finishSampleImport(samples);
        
      } catch (e) { showStatus('Error: ' + e.message, false); console.error(e); }
    }
    
    async function finishSampleImport(samples) {
        // Prevent duplicates - check by sampleId + year + location (not field since it's assigned later)
        const existingKeys = new Set(sampleData.map(s => `${s.sampleId}-${s.year}-${s.lat?.toFixed(5)}-${s.lon?.toFixed(5)}`));
        const newSamples = samples.filter(s => !existingKeys.has(`${s.sampleId}-${s.year}-${s.lat?.toFixed(5)}-${s.lon?.toFixed(5)}`));

        if (newSamples.length === 0) {
          showStatus('All samples already exist (duplicates skipped)', false);
          return;
        }

        const skipped = samples.length - newSamples.length;
        sampleData = [...sampleData, ...newSamples];

        // Assign field names based on boundary GPS matching
        if (Object.keys(fieldBoundaries).length > 0) {
          assignSamplesToFields();
          const assignedCount = newSamples.filter(s => s.field && s.field !== 'Unassigned').length;
          const unassignedCount = newSamples.length - assignedCount;
          await afterImportSuccess();
          let msg = `‚úì Imported ${newSamples.length} samples, ${assignedCount} assigned to fields`;
          if (unassignedCount > 0) msg += ` (${unassignedCount} unassigned - outside boundaries)`;
          if (skipped > 0) msg += ` (${skipped} duplicates skipped)`;
          showStatus(msg, true);
        } else {
          await afterImportSuccess();
          showStatus(`‚úì Imported ${newSamples.length} samples. Upload boundaries to assign field names.${skipped > 0 ? ` (${skipped} duplicates skipped)` : ''}`, true);
        }
        document.getElementById('sampleFiles').value = ''; document.getElementById('sampleYear').value = '';
        // Auto-sync to Google Sheets if signed in
        if (SheetsAPI.isSignedIn) {
          showStatus('Syncing to Google Sheets...', true);
          await syncToSheets();
        }
    }

    // Standard fields we care about
    const STANDARD_FIELDS = ['pH', 'P', 'P2', 'K', 'OM', 'CEC', 'Ca_sat', 'Mg_sat', 'K_Sat', 'H_Sat', 'Na_Sat', 'Zn', 'Cu', 'Mn', 'Fe', 'Boron', 'S', 'Buffer_pH', 'Na', 'Ca', 'Mg', 'NO3', 'NH4', 'Soluble_Salts', 'EC'];
    
    // Default aliases (built-in)
    const DEFAULT_ALIASES = {
      'P': ['P', 'P (M3)', 'P_M3', 'Phosphorus', 'Bray_P1', 'Bray P1', 'Mehlich2_P', 'Mehlich P', 'M3P', 'Olsen P', 'P1', 'P ppm'],
      'P2': ['P2', 'Bray_P2', 'Bray P2', 'P2 ppm'],
      'pH': ['pH', 'pH (1_1)', 'pH_1_1', 'ph', 'Soil_pH', 'pH 1:1', 'pH_s', 'soil pH'],
      'K': ['K', 'K (M3)', 'K_M3', 'Potassium', 'ExchK', 'Exch K', 'Mehlich K', 'M3K', 'K ppm'],
      'OM': ['OM', 'OM (LOI)', 'OM_LOI', 'Organic_Matter', 'Organic Matter', 'O.M.', 'OM %', 'SOM'],
      'CEC': ['CEC', 'CEC (Calc)', 'CEC_Calc', 'CEC (Cal_1', 'CEC meq'],
      'Ca_sat': ['Ca_sat', 'BS-Ca', 'BS_Ca', 'Ca_Base_Sat', 'Ca_Sat', 'Ca %', 'Ca Sat', '% Ca'],
      'Mg_sat': ['Mg_sat', 'BS-Mg', 'BS_Mg', 'Mg_Base_Sat', 'Mg_Sat', 'Mg %', 'Mg Sat', '% Mg'],
      'K_Sat': ['K_Sat', 'BS-K', 'BS_K', 'K_Base_Sat', 'K %', 'K Sat', '% K'],
      'H_Sat': ['H_Sat', 'BS-H', 'BS_H', 'H_Base_Sat', 'H %', 'H Sat', '% H'],
      'Na_Sat': ['Na_Sat', 'BS-Na', 'BS_Na', 'Na_Base_Sat', 'Na %', 'Na Sat', '% Na'],
      'Zn': ['Zn', 'Zn (M3)', 'Zn_M3', 'Zinc', 'Mehlich Zn'],
      'Cu': ['Cu', 'Cu (M3)', 'Cu_M3', 'Copper', 'Mehlich Cu'],
      'Mn': ['Mn', 'Mn (M3)', 'Mn_M3', 'Manganese', 'Mehlich Mn'],
      'Fe': ['Fe', 'Fe (M3)', 'Fe_M3', 'Iron', 'Mehlich Fe'],
      'Boron': ['Boron', 'B (M3)', 'B_M3', 'B'],
      'S': ['S', 'S (M3)', 'S_M3', 'Sulfur', 'SO4', 'SO4-S'],
      'Buffer_pH': ['Buffer_pH', 'BpH', 'Buffer pH', 'SMP', 'SMP pH', 'Buffer'],
      'Na': ['Na', 'Sodium', 'Na (M3)', 'ExchNa', 'Exch Na'],
      'Ca': ['Ca', 'Calcium', 'Ca (M3)', 'ExchCa', 'Exch Ca'],
      'Mg': ['Mg', 'Magnesium', 'Mg (M3)', 'ExchMg', 'Exch Mg'],
      'NO3': ['NO3', 'NO3-N', 'Nitrate', 'Nitrate-N', 'N03'],
      'NH4': ['NH4', 'NH4-N', 'Ammonium', 'Ammonium-N'],
      'Soluble_Salts': ['Soluble_Salts', 'Soluble_Sal', 'Sol_Salts', 'Salts', 'SS'],
      'EC': ['EC', 'EC (1:1)', 'Electrical Conductivity']
    };
    
    // Get combined aliases (default + user-saved)
    function getAliases() {
      const saved = JSON.parse(localStorage.getItem('columnAliases') || '{}');
      const combined = JSON.parse(JSON.stringify(DEFAULT_ALIASES));
      
      for (const [standard, aliases] of Object.entries(saved)) {
        if (combined[standard]) {
          // Add user aliases to the beginning (higher priority)
          combined[standard] = [...new Set([...aliases, ...combined[standard]])];
        } else {
          combined[standard] = aliases;
        }
      }
      return combined;
    }
    
    // Save a new alias
    function saveAlias(standardField, alias) {
      const saved = JSON.parse(localStorage.getItem('columnAliases') || '{}');
      if (!saved[standardField]) saved[standardField] = [];
      if (!saved[standardField].includes(alias)) {
        saved[standardField].push(alias);
        localStorage.setItem('columnAliases', JSON.stringify(saved));
      }
    }
    
    // Match a column name to a standard field
    function matchColumn(colName) {
      const aliases = getAliases();
      const colLower = colName.toLowerCase().trim();
      
      for (const [standard, alts] of Object.entries(aliases)) {
        for (const alt of alts) {
          if (alt.toLowerCase() === colLower || colName === alt) {
            return standard;
          }
        }
      }
      return null;
    }
    
    // Analyze columns from file and categorize as matched/unmatched
    function analyzeColumns(sampleProps) {
      const columns = Object.keys(sampleProps);
      const matched = [];
      const unmatched = [];
      
      // System fields we don't need to map
      const systemFields = ['lat', 'lon', 'Lat', 'Lon', 'LAT', 'LON', 'latitude', 'longitude', 
                           'sampleId', 'SampleID', 'ID', 'ORG_ID', 'field', 'Field', 'FIELD_NAME',
                           'year', 'Year', 'CropYear', 'date', 'depth', 'Depth', 'DEPTH',
                           'name', 'Name', 'CLIENT_NAM', 'FARM_NAME', 'Field_Name', 'field_name',
                           'POLYGONTYP', 'CLIENT_ID', 'FARM_ID', 'FIELD_ID', 'geometry', 'type'];
      
      for (const col of columns) {
        if (systemFields.some(sf => sf.toLowerCase() === col.toLowerCase())) continue;
        
        const match = matchColumn(col);
        if (match) {
          matched.push({ fileCol: col, standardCol: match });
        } else {
          unmatched.push({ fileCol: col, standardCol: null });
        }
      }
      
      return { matched, unmatched };
    }
    
    // Pending import data (while modal is open)
    let pendingImportData = null;
    let pendingMappings = {};
    
    function showMappingModal(samples, analysis) {
      pendingImportData = samples;
      pendingMappings = {};
      
      const matchedDiv = document.getElementById('matchedColumns');
      const unmatchedDiv = document.getElementById('unmatchedColumns');
      
      // Show matched
      if (analysis.matched.length > 0) {
        matchedDiv.innerHTML = analysis.matched.map(m => `
          <div class="mapping-row matched">
            <span class="file-col">${m.fileCol}</span>
            <span class="arrow">‚Üí</span>
            <span class="matched-label">${m.standardCol}</span>
          </div>
        `).join('');
        document.getElementById('matchedSection').style.display = 'block';
      } else {
        document.getElementById('matchedSection').style.display = 'none';
      }
      
      // Show unmatched with dropdown
      if (analysis.unmatched.length > 0) {
        const options = ['(skip)', ...STANDARD_FIELDS].map(f => `<option value="${f}">${f}</option>`).join('');
        unmatchedDiv.innerHTML = analysis.unmatched.map(u => {
          // Initialize to skip by default
          pendingMappings[u.fileCol] = '(skip)';
          return `
          <div class="mapping-row unmatched">
            <span class="file-col">${u.fileCol}</span>
            <span class="arrow">‚Üí</span>
            <select onchange="pendingMappings['${u.fileCol}']=this.value">
              ${options}
            </select>
          </div>
        `}).join('');
        document.getElementById('unmatchedSection').style.display = 'block';
      } else {
        document.getElementById('unmatchedSection').style.display = 'none';
      }
      
      document.getElementById('mappingModal').classList.add('active');
    }
    
    function closeMappingModal() {
      document.getElementById('mappingModal').classList.remove('active');
      pendingImportData = null;
      pendingMappings = {};
    }
    
    async function proceedWithImport() {
      if (!pendingImportData) {
        showStatus('No data to import', false);
        return;
      }
      
      const saveAliases = document.getElementById('saveNewAliases').checked;
      
      // Apply mappings and save aliases if requested
      for (const [fileCol, standardCol] of Object.entries(pendingMappings)) {
        if (standardCol && standardCol !== '(skip)') {
          // Apply mapping to all samples
          pendingImportData.forEach(sample => {
            if (sample[fileCol] !== undefined && sample[standardCol] === undefined) {
              const num = parseFloat(sample[fileCol]);
              sample[standardCol] = isNaN(num) ? sample[fileCol] : num;
            }
          });
          
          // Save alias for future
          if (saveAliases) {
            saveAlias(standardCol, fileCol);
          }
        }
      }
      
      // Store samples before closing modal
      const samplesToImport = pendingImportData;
      
      closeMappingModal();
      
      // Continue with import
      try {
        await finishSampleImport(samplesToImport);
      } catch (e) {
        showStatus('Import error: ' + e.message, false);
        console.error(e);
      }
    }
    
    // Normalize column names from different data formats (using aliases)
    function normalizeNutrientData(sample) {
      const aliases = getAliases();
      
      for (const [standard, alternatives] of Object.entries(aliases)) {
        if (sample[standard] === undefined) {
          for (const alt of alternatives) {
            if (sample[alt] !== undefined && sample[alt] !== null && sample[alt] !== '') {
              const num = parseFloat(sample[alt]);
              sample[standard] = isNaN(num) ? sample[alt] : num;
              break;
            }
          }
        }
      }

      // Ensure P and Zn are numbers (they might be strings from import)
      if (sample.P !== undefined && sample.P !== '') {
        sample.P = parseFloat(sample.P);
      }
      if (sample.Zn !== undefined && sample.Zn !== '') {
        sample.Zn = parseFloat(sample.Zn);
      }

      // Calculate P:Zn Ratio if both P and Zn are valid numbers
      if (!isNaN(sample.P) && !isNaN(sample.Zn) && sample.Zn > 0) {
        sample.P_Zn_Ratio = sample.P / sample.Zn;
      }

      return sample;
    }

    function geojsonToSamples(geojson, assignedYear, assignedDepth) {
      const samples = [], features = geojson.features || [geojson];

      // Get shapefile name for fallback field name (from multi-file zips)
      const shapefileName = geojson.fileName || geojson.name || null;

      // Debug
      console.log('Sample GeoJSON:', geojson);
      console.log('Shapefile name:', shapefileName);
      if (features[0]) console.log('First sample properties:', features[0].properties);

      features.forEach((f, idx) => {
        if (!f.geometry || f.geometry.type !== 'Point') return;
        const [lon, lat] = f.geometry.coordinates, props = f.properties || {};

        // Field name will be assigned from boundary matching after import
        // Don't extract from file data - let assignSamplesToFields() handle it
        let fieldName = null;
        
        // Get depth from file or use assigned depth
        const fileDepth = props.Depth || props.depth || props.DEPTH || props.DepthUnits;
        
        const sample = { 
          sampleId: props.ORG_ID || props.SampleID || props.sampleId || props.Sample_ID || props.SAMPLE_ID || props.ID || (idx + 1), 
          field: fieldName, 
          lat, 
          lon, 
          year: assignedYear || parseYear(props.CropYear || props.Year || props.year || props.date),
          depth: assignedDepth || fileDepth || '6'
        };
        Object.entries(props).forEach(([k, v]) => { if (sample[k] === undefined && v !== null) { const n = parseFloat(v); sample[k] = isNaN(n) ? v : n; } });
        
        // Normalize nutrient column names
        normalizeNutrientData(sample);
        
        samples.push(sample);
      });
      return samples;
    }

    function parseCSV(text, assignedYear, assignedDepth) {
      const lines = text.trim().split('\n'); if (lines.length < 2) return [];
      const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, '')), samples = [];
      for (let i = 1; i < lines.length; i++) {
        const values = lines[i].split(',').map(v => v.trim().replace(/"/g, '')), sample = {};
        headers.forEach((h, idx) => { const v = values[idx]; if (v) { const n = parseFloat(v); sample[h] = isNaN(n) ? v : n; } });
        sample.lat = sample.lat || sample.Lat || sample.LAT; sample.lon = sample.lon || sample.Lon || sample.LON || sample.lng;
        sample.field = sample.field || sample.Field || 'Unknown'; sample.year = assignedYear || parseYear(sample.year || sample.Year);
        sample.depth = assignedDepth || sample.depth || sample.Depth || '6';
        sample.sampleId = sample.sampleId || sample.SampleID || sample.ID || i;
        if (sample.lat && sample.lon) samples.push(sample);
      }
      return samples;
    }

    function parseYear(d) { if (!d) return null; if (typeof d === 'number') return d >= 1900 && d <= 2099 ? d : null; const m = String(d).match(/\b(19|20)\d{2}\b/); return m ? parseInt(m[0]) : null; }

    function assignSamplesToFields() {
      sampleData.forEach(sample => {
        let assigned = false;

        // Always try to match sample to a boundary by GPS location
        for (const [name, fieldData] of Object.entries(fieldBoundaries)) {
          if (assigned) break;
          // Handle both legacy (array) and new format (object with boundary property)
          const polys = fieldData.boundary || fieldData;
          const arr = Array.isArray(polys[0]?.[0]) ? polys : [polys];
          for (const poly of arr) {
            if (isPointInOrNearPolygon([sample.lat, sample.lon], poly)) {
              sample.field = name;
              assigned = true;
              break;
            }
          }
        }

        // Mark as Unassigned if no boundary match
        if (!assigned) {
          sample.field = 'Unassigned';
        }
      });
    }
    
    async function reassignSamplesToBoundaries() {
      if (Object.keys(fieldBoundaries).length === 0) {
        showStatus('No boundaries loaded. Upload boundaries first.', false);
        return;
      }

      let reassignedCount = 0;
      sampleData.forEach(sample => {
        const oldField = sample.field;
        let assigned = false;

        // Try to find a matching boundary
        for (const [name, fieldData] of Object.entries(fieldBoundaries)) {
          if (assigned) break;
          // Handle both legacy (array) and new format (object with boundary property)
          const polys = fieldData.boundary || fieldData;
          const arr = Array.isArray(polys[0]?.[0]) ? polys : [polys];
          for (const poly of arr) {
            if (isPointInOrNearPolygon([sample.lat, sample.lon], poly)) {
              if (sample.field !== name) {
                sample.field = name;
                reassignedCount++;
              }
              assigned = true;
              break;
            }
          }
        }
      });
      
      if (reassignedCount > 0) {
        await afterImportSuccess();
        showStatus(`‚úì Reassigned ${reassignedCount} samples to boundaries`, true);
        
        // Sync to Google Sheets if signed in
        if (SheetsAPI.isSignedIn) {
          syncToSheets();
        }
      } else {
        showStatus('All samples already assigned to correct boundaries', true);
      }
    }

    function isPointInOrNearPolygon(point, polygon) {
      const [lat, lon] = point; 
      let inside = false;
      const epsilon = 0.0001; // Larger buffer (~10 meters) for edge cases
      
      // First check: is point very close to any vertex?
      for (let i = 0; i < polygon.length; i++) {
        const [plat, plon] = polygon[i];
        if (Math.abs(lat - plat) < epsilon && Math.abs(lon - plon) < epsilon) {
          return true;
        }
      }
      
      // Second check: is point very close to any edge?
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const [lat1, lon1] = polygon[i], [lat2, lon2] = polygon[j];
        
        // Distance from point to line segment
        const dx = lat2 - lat1;
        const dy = lon2 - lon1;
        const len2 = dx * dx + dy * dy;
        
        if (len2 > 0) {
          let t = Math.max(0, Math.min(1, ((lat - lat1) * dx + (lon - lon1) * dy) / len2));
          const nearestLat = lat1 + t * dx;
          const nearestLon = lon1 + t * dy;
          const dist = Math.sqrt((lat - nearestLat) ** 2 + (lon - nearestLon) ** 2);
          if (dist < epsilon) {
            return true;
          }
        }
      }
      
      // Third check: standard ray casting for inside
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const [lat1, lon1] = polygon[i], [lat2, lon2] = polygon[j];
        if (((lon1 > lon) !== (lon2 > lon)) && (lat < (lat2 - lat1) * (lon - lon1) / (lon2 - lon1) + lat1)) {
          inside = !inside;
        }
      }
      return inside;
    }

    // ========== YIELD DATA FUNCTIONS ==========

    // ========== RAW YIELD MONITOR IMPORT ==========

    // Crop-specific defaults for yield/moisture ranges
    const CROP_DEFAULTS = {
      corn: { yieldMin: 20, yieldMax: 400, moistureMin: 8, moistureMax: 35 },
      soybeans: { yieldMin: 10, yieldMax: 120, moistureMin: 8, moistureMax: 20 },
      wheat: { yieldMin: 15, yieldMax: 150, moistureMin: 8, moistureMax: 20 },
      amylose: { yieldMin: 15, yieldMax: 300, moistureMin: 8, moistureMax: 35 }
    };

    // Common yield field aliases from different monitors
    const YIELD_FIELD_ALIASES = {
      yield: ['Yld_Vol_Dr', 'YLD_VOL_DR', 'DryYield', 'Dry_Yield', 'YldVolDry', 'YldMassDry', 'VRYIELDVO', 'VRYIELDMA', 'Yld_Mass_D', 'Dry Yield', 'DryYld', 'Yield (Dry)', 'Yld', 'yield_bu_ac', 'YIELD', 'Yield'],
      moisture: ['Moisture', 'MOISTURE', 'WetMoist', 'Moist', 'moisture_percent', 'Yld_Mass_W', 'WetMass'],
      speed: ['Speed', 'SPEED', 'Spd', 'SPD', 'AvgSpeed'],
      swath: ['SwathWidth', 'Swath', 'SWATH', 'Width', 'CutWidth', 'Head_Wdth'],
      timestamp: ['TIMESTAMP', 'TimeStamp', 'IsoTime', 'ISOTIME', 'Date', 'DATE', 'HarvestDat', 'Time', 'TIME', 'DATETIME', 'DateTime', 'Harvest_Da', 'VRLOGTIME'],
      fieldName: ['FieldName', 'Field', 'FIELD', 'Farm', 'FARM', 'Field_Name', 'Grower', 'Client']
    };

    // State for raw yield import
    let rawYieldData = {
      rawPoints: [],        // All parsed points before cleaning
      cleanedPoints: [],    // Points after applying filters
      fields: [],           // Detected field columns
      sampleValues: {},     // Sample values for preview
      removedCounts: {}     // Count of removed points by filter
    };

    // Toggle between Quick and Raw import modes
    function toggleYieldImportMode(mode) {
      const quickMode = document.getElementById('quickYieldMode');
      const rawMode = document.getElementById('rawYieldMode');
      const quickLabel = document.querySelector('label:has(input[value="quick"])');
      const rawLabel = document.getElementById('rawModeLabel');

      if (mode === 'quick') {
        quickMode.style.display = 'block';
        rawMode.style.display = 'none';
        quickLabel.style.background = 'white';
        quickLabel.style.border = '2px solid #f59e0b';
        rawLabel.style.background = '#f5f5f4';
        rawLabel.style.border = '2px solid transparent';
      } else {
        quickMode.style.display = 'none';
        rawMode.style.display = 'block';
        quickLabel.style.background = '#f5f5f4';
        quickLabel.style.border = '2px solid transparent';
        rawLabel.style.background = 'white';
        rawLabel.style.border = '2px solid #f59e0b';
      }
    }

    // Update filter defaults based on crop type
    function updateRawYieldDefaults() {
      const crop = document.getElementById('rawYieldCrop').value;
      const defaults = CROP_DEFAULTS[crop] || CROP_DEFAULTS.corn;
      document.getElementById('filterYieldLowVal').value = defaults.yieldMin;
      document.getElementById('filterYieldHighVal').value = defaults.yieldMax;
      document.getElementById('filterMoistureLowVal').value = defaults.moistureMin;
      document.getElementById('filterMoistureHighVal').value = defaults.moistureMax;
    }

    // Start raw yield import - parse files and show mapping modal
    async function startRawYieldImport() {
      const fileInput = document.getElementById('rawYieldFiles');
      const files = fileInput.files;
      const statusEl = document.getElementById('yieldStatus');

      if (!files.length) {
        showStatus('Please select yield file(s)', false);
        return;
      }

      statusEl.innerHTML = '<span style="color: #3b82f6;">‚è≥ Parsing yield files...</span>';

      try {
        rawYieldData = { rawPoints: [], cleanedPoints: [], fields: [], sampleValues: {}, removedCounts: {} };
        let allFields = new Set();
        let filesProcessed = 0;

        // Process files
        const zipFiles = Array.from(files).filter(f => f.name.toLowerCase().endsWith('.zip'));
        const shpFiles = Array.from(files).filter(f => f.name.toLowerCase().endsWith('.shp'));
        const dbfFiles = Array.from(files).filter(f => f.name.toLowerCase().endsWith('.dbf'));

        if (zipFiles.length > 0) {
          for (const zipFile of zipFiles) {
            try {
              statusEl.innerHTML = `<span style="color: #3b82f6;">‚è≥ Parsing ${zipFile.name}...</span>`;
              const result = await parseRawYieldFromZip(zipFile);
              rawYieldData.rawPoints.push(...result.points);
              result.fields.forEach(f => allFields.add(f));
              filesProcessed++;
            } catch (err) {
              console.warn(`Error parsing ${zipFile.name}:`, err);
            }
          }
        } else if (shpFiles.length > 0) {
          // Match SHP with DBF
          const dbfByName = {};
          dbfFiles.forEach(f => dbfByName[f.name.toLowerCase().replace('.dbf', '')] = f);

          for (const shpFile of shpFiles) {
            const baseName = shpFile.name.toLowerCase().replace('.shp', '');
            const dbfFile = dbfByName[baseName];
            if (!dbfFile) continue;

            try {
              statusEl.innerHTML = `<span style="color: #3b82f6;">‚è≥ Parsing ${shpFile.name}...</span>`;
              const shpBuffer = await shpFile.arrayBuffer();
              const dbfBuffer = await dbfFile.arrayBuffer();
              const result = parseRawYieldShapefile(shpBuffer, dbfBuffer);
              rawYieldData.rawPoints.push(...result.points);
              result.fields.forEach(f => allFields.add(f));
              filesProcessed++;
            } catch (err) {
              console.warn(`Error parsing ${shpFile.name}:`, err);
            }
          }
        }

        if (rawYieldData.rawPoints.length === 0) {
          statusEl.innerHTML = '<span style="color: #ef4444;">‚ùå No yield points found in files</span>';
          return;
        }

        rawYieldData.fields = Array.from(allFields);

        // Get sample values for preview
        const samplePoint = rawYieldData.rawPoints[0];
        rawYieldData.sampleValues = {};
        for (const field of rawYieldData.fields) {
          const values = rawYieldData.rawPoints.slice(0, 5).map(p => p.attributes[field]).filter(v => v !== null && v !== undefined);
          rawYieldData.sampleValues[field] = values.map(v => typeof v === 'number' ? v.toFixed(1) : String(v)).slice(0, 3).join(', ');
        }

        statusEl.innerHTML = `<span style="color: #059669;">‚úì Found ${rawYieldData.rawPoints.toLocaleString()} points in ${filesProcessed} file(s)</span>`;

        // Open mapping modal
        openYieldMappingModal(filesProcessed);

      } catch (err) {
        console.error('Error in raw yield import:', err);
        statusEl.innerHTML = `<span style="color: #ef4444;">‚ùå Error: ${err.message}</span>`;
      }
    }

    // Parse raw yield from ZIP file (returns points with all attributes)
    async function parseRawYieldFromZip(zipFile) {
      const zip = await JSZip.loadAsync(zipFile);
      const files = {};

      for (const [name, file] of Object.entries(zip.files)) {
        if (file.dir) continue;
        const ext = name.split('.').pop().toLowerCase();
        if (['shp', 'dbf', 'prj'].includes(ext)) {
          files[ext] = await file.async('arraybuffer');
        }
      }

      if (!files.shp || !files.dbf) {
        throw new Error('ZIP must contain .shp and .dbf files');
      }

      return parseRawYieldShapefile(files.shp, files.dbf);
    }

    // Parse raw yield shapefile (returns all attributes for mapping)
    function parseRawYieldShapefile(shpBuffer, dbfBuffer) {
      const points = [];
      const fields = [];

      // Parse DBF
      const dbfView = new DataView(dbfBuffer);
      const numRecords = dbfView.getUint32(4, true);
      const headerSize = dbfView.getUint16(8, true);
      const recordSize = dbfView.getUint16(10, true);

      const bytesToString = (buffer, start, length) => {
        const bytes = new Uint8Array(buffer.slice(start, start + length));
        let str = '';
        for (let i = 0; i < bytes.length; i++) {
          if (bytes[i] === 0) break;
          str += String.fromCharCode(bytes[i]);
        }
        return str.trim();
      };

      // Parse field descriptors
      const fieldDefs = [];
      let offset = 32;
      while (offset < headerSize - 1) {
        const fieldName = bytesToString(dbfBuffer, offset, 11);
        if (!fieldName) break;
        const fieldType = String.fromCharCode(dbfView.getUint8(offset + 11));
        const fieldLen = dbfView.getUint8(offset + 16);
        const fieldDec = dbfView.getUint8(offset + 17);
        fieldDefs.push({ name: fieldName, type: fieldType, length: fieldLen, decimals: fieldDec });
        fields.push(fieldName);
        offset += 32;
      }

      // Parse SHP for coordinates
      const shpView = new DataView(shpBuffer);
      let shpOffset = 100;
      const coords = [];

      while (shpOffset < shpBuffer.byteLength - 8) {
        const contentLen = shpView.getInt32(shpOffset + 4, false) * 2;
        const shapeType = shpView.getInt32(shpOffset + 8, true);

        if (shapeType === 1 || shapeType === 11) {
          const x = shpView.getFloat64(shpOffset + 12, true);
          const y = shpView.getFloat64(shpOffset + 20, true);
          coords.push({ lon: x, lat: y });
        }
        shpOffset += 8 + contentLen;
      }

      // Parse DBF records
      let dbfOffset = headerSize;
      for (let i = 0; i < Math.min(numRecords, coords.length); i++) {
        dbfOffset++; // Skip deletion flag

        const attributes = {};
        let fieldOffset = 0;

        for (const field of fieldDefs) {
          const rawValue = bytesToString(dbfBuffer, dbfOffset + fieldOffset, field.length);

          if (field.type === 'N' || field.type === 'F') {
            attributes[field.name] = rawValue ? parseFloat(rawValue) : null;
          } else {
            attributes[field.name] = rawValue || null;
          }
          fieldOffset += field.length;
        }

        dbfOffset += recordSize - 1;

        points.push({
          lat: coords[i].lat,
          lon: coords[i].lon,
          attributes: attributes
        });
      }

      return { points, fields };
    }

    // Open yield mapping modal
    function openYieldMappingModal(fileCount) {
      const modal = document.getElementById('yieldMappingModal');
      const fields = rawYieldData.fields;

      // Update summary
      document.getElementById('yieldMappingSummaryText').textContent = `Found ${rawYieldData.rawPoints.toLocaleString()} yield points`;
      document.getElementById('yieldMappingFileCount').textContent = `${fileCount} file(s)`;

      // Populate dropdowns with auto-detection
      const dropdowns = [
        { id: 'yieldMapYield', aliases: YIELD_FIELD_ALIASES.yield },
        { id: 'yieldMapMoisture', aliases: YIELD_FIELD_ALIASES.moisture },
        { id: 'yieldMapSpeed', aliases: YIELD_FIELD_ALIASES.speed },
        { id: 'yieldMapSwath', aliases: YIELD_FIELD_ALIASES.swath },
        { id: 'yieldMapTimestamp', aliases: YIELD_FIELD_ALIASES.timestamp },
        { id: 'yieldMapFieldName', aliases: YIELD_FIELD_ALIASES.fieldName }
      ];

      for (const { id, aliases } of dropdowns) {
        const select = document.getElementById(id);
        select.innerHTML = '<option value="">(none)</option>' + fields.map(f => `<option value="${f}">${f}</option>`).join('');

        // Auto-detect based on aliases
        let matched = null;
        for (const alias of aliases) {
          const found = fields.find(f => f.toLowerCase() === alias.toLowerCase());
          if (found) { matched = found; break; }
        }

        // Also try partial matching
        if (!matched) {
          for (const alias of aliases) {
            const found = fields.find(f => f.toLowerCase().includes(alias.toLowerCase()));
            if (found) { matched = found; break; }
          }
        }

        if (matched) {
          select.value = matched;
          updateYieldMapPreview(id.replace('yieldMap', '').toLowerCase());
        }
      }

      // Show unmapped fields
      updateYieldUnmappedList();

      modal.style.display = 'flex';
    }

    // Update preview values for a mapped field
    function updateYieldMapPreview(fieldType) {
      const selectId = 'yieldMap' + fieldType.charAt(0).toUpperCase() + fieldType.slice(1);
      const previewId = 'yieldPreview' + fieldType.charAt(0).toUpperCase() + fieldType.slice(1);
      const select = document.getElementById(selectId);
      const preview = document.getElementById(previewId);

      if (!select || !preview) return;

      const selectedField = select.value;
      if (selectedField && rawYieldData.sampleValues[selectedField]) {
        preview.textContent = rawYieldData.sampleValues[selectedField] + '...';
      } else {
        preview.textContent = '';
      }

      updateYieldUnmappedList();
    }

    // Update unmapped fields list
    function updateYieldUnmappedList() {
      const mappedFields = new Set();
      ['yieldMapYield', 'yieldMapMoisture', 'yieldMapSpeed', 'yieldMapSwath', 'yieldMapTimestamp', 'yieldMapFieldName'].forEach(id => {
        const val = document.getElementById(id)?.value;
        if (val) mappedFields.add(val);
      });

      const unmapped = rawYieldData.fields.filter(f => !mappedFields.has(f));
      const section = document.getElementById('yieldUnmappedSection');
      const list = document.getElementById('yieldUnmappedList');

      if (unmapped.length > 0) {
        section.style.display = 'block';
        list.innerHTML = unmapped.map(f => `<span class="shp-unmapped-chip">${f}</span>`).join('');
      } else {
        section.style.display = 'none';
      }
    }

    // Close yield mapping modal
    function closeYieldMappingModal() {
      document.getElementById('yieldMappingModal').style.display = 'none';
    }

    // Preview yield data with cleaning filters applied
    function previewYieldCleaning() {
      const yieldField = document.getElementById('yieldMapYield').value;
      if (!yieldField) {
        showStatus('Please select a yield column', false);
        return;
      }

      const moistureField = document.getElementById('yieldMapMoisture').value;
      const speedField = document.getElementById('yieldMapSpeed').value;

      // Get filter settings
      const filters = {
        slowSpeed: document.getElementById('filterSlowSpeed').checked ? parseFloat(document.getElementById('filterSlowSpeedVal').value) : null,
        highSpeed: document.getElementById('filterHighSpeed').checked ? parseFloat(document.getElementById('filterHighSpeedVal').value) : null,
        yieldLow: document.getElementById('filterYieldLow').checked ? parseFloat(document.getElementById('filterYieldLowVal').value) : null,
        yieldHigh: document.getElementById('filterYieldHigh').checked ? parseFloat(document.getElementById('filterYieldHighVal').value) : null,
        moistureLow: document.getElementById('filterMoistureLow').checked ? parseFloat(document.getElementById('filterMoistureLowVal').value) : null,
        moistureHigh: document.getElementById('filterMoistureHigh').checked ? parseFloat(document.getElementById('filterMoistureHighVal').value) : null
      };

      // Apply filters
      const removed = { slowSpeed: 0, highSpeed: 0, yieldLow: 0, yieldHigh: 0, moistureLow: 0, moistureHigh: 0 };
      const cleaned = [];

      for (const point of rawYieldData.rawPoints) {
        const yieldVal = point.attributes[yieldField];
        const moistureVal = moistureField ? point.attributes[moistureField] : null;
        const speedVal = speedField ? point.attributes[speedField] : null;

        // Check filters
        let keep = true;

        if (filters.slowSpeed !== null && speedVal !== null && speedVal < filters.slowSpeed) {
          removed.slowSpeed++;
          keep = false;
        } else if (filters.highSpeed !== null && speedVal !== null && speedVal > filters.highSpeed) {
          removed.highSpeed++;
          keep = false;
        } else if (filters.yieldLow !== null && yieldVal !== null && yieldVal < filters.yieldLow) {
          removed.yieldLow++;
          keep = false;
        } else if (filters.yieldHigh !== null && yieldVal !== null && yieldVal > filters.yieldHigh) {
          removed.yieldHigh++;
          keep = false;
        } else if (filters.moistureLow !== null && moistureVal !== null && moistureVal < filters.moistureLow) {
          removed.moistureLow++;
          keep = false;
        } else if (filters.moistureHigh !== null && moistureVal !== null && moistureVal > filters.moistureHigh) {
          removed.moistureHigh++;
          keep = false;
        }

        if (keep && yieldVal !== null && !isNaN(yieldVal)) {
          cleaned.push({
            lat: point.lat,
            lon: point.lon,
            yield: yieldVal,
            moisture: moistureVal,
            speed: speedVal,
            fieldName: document.getElementById('yieldMapFieldName').value ? point.attributes[document.getElementById('yieldMapFieldName').value] : null
          });
        }
      }

      rawYieldData.cleanedPoints = cleaned;
      rawYieldData.removedCounts = removed;

      // Show preview modal
      showYieldPreviewModal(removed, filters);
    }

    // Show yield preview modal with cleaning results
    function showYieldPreviewModal(removed, filters) {
      const modal = document.getElementById('yieldPreviewModal');
      const cleaned = rawYieldData.cleanedPoints;
      const total = rawYieldData.rawPoints.length;
      const totalRemoved = Object.values(removed).reduce((a, b) => a + b, 0);

      // Cleaning summary
      const summaryEl = document.getElementById('yieldCleaningSummary');
      let summaryHtml = `
        <div style="padding: 0.5rem; background: white; border-radius: 0.375rem; border: 1px solid #e2e8f0;">
          <div style="font-size: 0.75rem; color: #64748b;">Total in files</div>
          <div style="font-size: 1.1rem; font-weight: 600; color: #1e293b;">${total.toLocaleString()}</div>
        </div>
      `;

      if (removed.slowSpeed > 0) {
        summaryHtml += `<div style="padding: 0.5rem; background: #fef2f2; border-radius: 0.375rem; border: 1px solid #fca5a5;">
          <div style="font-size: 0.75rem; color: #991b1b;">Slow/stopped</div>
          <div style="font-size: 1rem; font-weight: 600; color: #dc2626;">-${removed.slowSpeed.toLocaleString()}</div>
        </div>`;
      }
      if (removed.highSpeed > 0) {
        summaryHtml += `<div style="padding: 0.5rem; background: #fef2f2; border-radius: 0.375rem; border: 1px solid #fca5a5;">
          <div style="font-size: 0.75rem; color: #991b1b;">High speed</div>
          <div style="font-size: 1rem; font-weight: 600; color: #dc2626;">-${removed.highSpeed.toLocaleString()}</div>
        </div>`;
      }
      if (removed.yieldLow > 0 || removed.yieldHigh > 0) {
        summaryHtml += `<div style="padding: 0.5rem; background: #fef2f2; border-radius: 0.375rem; border: 1px solid #fca5a5;">
          <div style="font-size: 0.75rem; color: #991b1b;">Yield outliers</div>
          <div style="font-size: 1rem; font-weight: 600; color: #dc2626;">-${(removed.yieldLow + removed.yieldHigh).toLocaleString()}</div>
        </div>`;
      }
      if (removed.moistureLow > 0 || removed.moistureHigh > 0) {
        summaryHtml += `<div style="padding: 0.5rem; background: #fef2f2; border-radius: 0.375rem; border: 1px solid #fca5a5;">
          <div style="font-size: 0.75rem; color: #991b1b;">Moisture outliers</div>
          <div style="font-size: 1rem; font-weight: 600; color: #dc2626;">-${(removed.moistureLow + removed.moistureHigh).toLocaleString()}</div>
        </div>`;
      }

      const pctRetained = ((cleaned.length / total) * 100).toFixed(1);
      summaryHtml += `<div style="padding: 0.5rem; background: #f0fdf4; border-radius: 0.375rem; border: 1px solid #86efac;">
        <div style="font-size: 0.75rem; color: #166534;">Points to import</div>
        <div style="font-size: 1.1rem; font-weight: 600; color: #059669;">${cleaned.length.toLocaleString()} <span style="font-size: 0.8rem; font-weight: 400;">(${pctRetained}%)</span></div>
      </div>`;

      summaryEl.innerHTML = summaryHtml;

      // Yield statistics
      const yields = cleaned.map(p => p.yield).filter(y => y !== null);
      const moistures = cleaned.filter(p => p.moisture !== null).map(p => p.moisture);

      const statsEl = document.getElementById('yieldStatsGrid');
      const crop = document.getElementById('rawYieldCrop').value;
      const year = document.getElementById('rawYieldYear').value || 'Unknown';

      statsEl.innerHTML = `
        <div style="text-align: center; padding: 0.5rem; background: white; border-radius: 0.375rem; border: 1px solid #e2e8f0;">
          <div style="font-size: 0.7rem; color: #64748b;">Crop</div>
          <div style="font-weight: 600; color: #1e293b;">${crop.charAt(0).toUpperCase() + crop.slice(1)}</div>
        </div>
        <div style="text-align: center; padding: 0.5rem; background: white; border-radius: 0.375rem; border: 1px solid #e2e8f0;">
          <div style="font-size: 0.7rem; color: #64748b;">Year</div>
          <div style="font-weight: 600; color: #1e293b;">${year}</div>
        </div>
        <div style="text-align: center; padding: 0.5rem; background: white; border-radius: 0.375rem; border: 1px solid #e2e8f0;">
          <div style="font-size: 0.7rem; color: #64748b;">Min Yield</div>
          <div style="font-weight: 600; color: #ef4444;">${Math.min(...yields).toFixed(1)}</div>
        </div>
        <div style="text-align: center; padding: 0.5rem; background: white; border-radius: 0.375rem; border: 1px solid #e2e8f0;">
          <div style="font-size: 0.7rem; color: #64748b;">Max Yield</div>
          <div style="font-weight: 600; color: #22c55e;">${Math.max(...yields).toFixed(1)}</div>
        </div>
        <div style="text-align: center; padding: 0.5rem; background: white; border-radius: 0.375rem; border: 1px solid #e2e8f0;">
          <div style="font-size: 0.7rem; color: #64748b;">Avg Yield</div>
          <div style="font-weight: 600; color: #3b82f6;">${(yields.reduce((a, b) => a + b, 0) / yields.length).toFixed(1)}</div>
        </div>
        ${moistures.length > 0 ? `
        <div style="text-align: center; padding: 0.5rem; background: white; border-radius: 0.375rem; border: 1px solid #e2e8f0;">
          <div style="font-size: 0.7rem; color: #64748b;">Avg Moisture</div>
          <div style="font-weight: 600; color: #8b5cf6;">${(moistures.reduce((a, b) => a + b, 0) / moistures.length).toFixed(1)}%</div>
        </div>
        ` : ''}
      `;

      // Field breakdown
      const fieldBreakdownEl = document.getElementById('yieldFieldBreakdown');
      const fieldNames = [...new Set(cleaned.map(p => p.fieldName).filter(f => f))];
      if (fieldNames.length > 0) {
        let breakdownHtml = '<div style="font-size: 0.85rem; color: #166534; margin-bottom: 0.5rem;"><strong>Fields detected:</strong></div><div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 0.5rem;">';
        for (const field of fieldNames) {
          const fieldPoints = cleaned.filter(p => p.fieldName === field);
          const avgYield = fieldPoints.reduce((a, b) => a + b.yield, 0) / fieldPoints.length;
          breakdownHtml += `<div style="padding: 0.5rem; background: white; border-radius: 0.375rem; border: 1px solid #e2e8f0; font-size: 0.8rem;">
            <strong>${field}</strong>: ${fieldPoints.length.toLocaleString()} pts (avg ${avgYield.toFixed(1)} bu/ac)
          </div>`;
        }
        breakdownHtml += '</div>';
        fieldBreakdownEl.innerHTML = breakdownHtml;
      } else {
        fieldBreakdownEl.innerHTML = '';
      }

      // Preview table
      const headRow = document.getElementById('yieldPreviewHead');
      const tbody = document.getElementById('yieldPreviewBody');
      headRow.innerHTML = '<th style="padding: 0.5rem; text-align: left; border-bottom: 1px solid #e2e8f0;">Lat</th><th style="padding: 0.5rem; text-align: left; border-bottom: 1px solid #e2e8f0;">Lon</th><th style="padding: 0.5rem; text-align: left; border-bottom: 1px solid #e2e8f0;">Yield</th><th style="padding: 0.5rem; text-align: left; border-bottom: 1px solid #e2e8f0;">Moisture</th><th style="padding: 0.5rem; text-align: left; border-bottom: 1px solid #e2e8f0;">Field</th>';

      tbody.innerHTML = cleaned.slice(0, 10).map(p => `
        <tr>
          <td style="padding: 0.5rem; border-bottom: 1px solid #f1f5f9;">${p.lat.toFixed(6)}</td>
          <td style="padding: 0.5rem; border-bottom: 1px solid #f1f5f9;">${p.lon.toFixed(6)}</td>
          <td style="padding: 0.5rem; border-bottom: 1px solid #f1f5f9; font-weight: 600;">${p.yield.toFixed(1)}</td>
          <td style="padding: 0.5rem; border-bottom: 1px solid #f1f5f9;">${p.moisture ? p.moisture.toFixed(1) + '%' : '-'}</td>
          <td style="padding: 0.5rem; border-bottom: 1px solid #f1f5f9;">${p.fieldName || '-'}</td>
        </tr>
      `).join('');

      // Update import button
      document.getElementById('confirmYieldImportBtn').textContent = `Import ${cleaned.length.toLocaleString()} Points`;

      // Close mapping modal, show preview
      document.getElementById('yieldMappingModal').style.display = 'none';
      modal.style.display = 'flex';
    }

    // Go back to mapping modal
    function backToYieldMapping() {
      document.getElementById('yieldPreviewModal').style.display = 'none';
      document.getElementById('yieldMappingModal').style.display = 'flex';
    }

    // Close yield preview modal
    function closeYieldPreviewModal() {
      document.getElementById('yieldPreviewModal').style.display = 'none';
    }

    // Confirm and process raw yield import
    async function confirmRawYieldImport() {
      const yieldYear = document.getElementById('rawYieldYear').value.trim();
      const yieldCrop = document.getElementById('rawYieldCrop').value;
      const radiusFeet = parseInt(document.getElementById('rawYieldRadius').value);

      if (!yieldYear) {
        showStatus('Please enter the crop year', false);
        return;
      }

      const cleaned = rawYieldData.cleanedPoints;
      if (cleaned.length === 0) {
        showStatus('No points to import', false);
        return;
      }

      // Close preview modal, show progress
      document.getElementById('yieldPreviewModal').style.display = 'none';
      document.getElementById('yieldProgressModal').style.display = 'flex';

      // Convert to yield points format
      const yieldPoints = cleaned.map(p => ({
        lat: p.lat,
        lon: p.lon,
        yield: p.yield,
        year: parseInt(yieldYear),
        crop: yieldCrop,
        moisture: p.moisture
      }));

      // Process yield data
      try {
        await processYieldDataWithProgress(yieldPoints, parseInt(yieldYear), yieldCrop, radiusFeet);
      } catch (err) {
        console.error('Error processing yield data:', err);
        document.getElementById('yieldProgressModal').style.display = 'none';
        showStatus('Error processing yield data: ' + err.message, false);
      }
    }

    // Process yield data with progress updates (used by both quick and raw import)
    async function processYieldDataWithProgress(yieldPoints, yieldYear, yieldCrop, radiusFeet) {
      const progressBar = document.getElementById('yieldProgressBar');
      const progressText = document.getElementById('yieldProgressText');
      const progressMatched = document.getElementById('yieldProgressMatched');

      const samples = JSON.parse(localStorage.getItem('soilSamples') || '[]');
      const radiusMeters = radiusFeet * 0.3048;
      let matchedCount = 0;
      let processedCount = 0;
      const totalPoints = yieldPoints.length;
      const batchSize = 1000;

      const breathe = () => new Promise(resolve => setTimeout(resolve, 10));

      // Process in batches
      for (let i = 0; i < totalPoints; i += batchSize) {
        const batch = yieldPoints.slice(i, i + batchSize);

        for (const yieldPoint of batch) {
          for (const sample of samples) {
            const dist = getDistanceMeters(sample.lat, sample.lon, yieldPoint.lat, yieldPoint.lon);
            if (dist <= radiusMeters) {
              if (!sample.yieldCorrelations) sample.yieldCorrelations = {};
              if (!sample.yieldCorrelations[yieldYear]) {
                sample.yieldCorrelations[yieldYear] = {
                  yields: [],
                  crop: yieldCrop,
                  radiusFt: radiusFeet
                };
              }
              sample.yieldCorrelations[yieldYear].yields.push(yieldPoint.yield);
              matchedCount++;
            }
          }
          processedCount++;
        }

        // Update progress
        const pct = Math.round((processedCount / totalPoints) * 100);
        progressBar.style.width = pct + '%';
        progressText.textContent = `Processing: ${processedCount.toLocaleString()} of ${totalPoints.toLocaleString()} points`;
        progressMatched.textContent = `Matched to soil samples: ${matchedCount.toLocaleString()}`;

        await breathe();
      }

      // Calculate averages
      let samplesWithYield = 0;
      for (const sample of samples) {
        if (sample.yieldCorrelations && sample.yieldCorrelations[yieldYear]) {
          const yields = sample.yieldCorrelations[yieldYear].yields;
          sample.yieldCorrelations[yieldYear].avgYield = yields.reduce((a, b) => a + b, 0) / yields.length;
          sample.yieldCorrelations[yieldYear].pointCount = yields.length;
          delete sample.yieldCorrelations[yieldYear].yields;
          samplesWithYield++;
        }
      }

      // Save
      localStorage.setItem('soilSamples', JSON.stringify(samples));

      // Store yield points
      const existingYield = JSON.parse(localStorage.getItem('yieldData') || '[]');
      const newYieldData = yieldPoints.map(p => ({ lat: p.lat, lon: p.lon, yield: p.yield, year: yieldYear, crop: yieldCrop }));
      localStorage.setItem('yieldData', JSON.stringify([...existingYield, ...newYieldData]));

      // Close progress modal
      document.getElementById('yieldProgressModal').style.display = 'none';

      // Show summary
      document.getElementById('yieldStatus').innerHTML = `<span style="color: #059669;">‚úì Imported ${totalPoints.toLocaleString()} yield points. ${samplesWithYield} samples matched.</span>`;
      showStatus(`Imported ${totalPoints.toLocaleString()} yield points. ${samplesWithYield} soil samples now have yield data.`, true);

      // Save mapping if checkbox checked
      if (document.getElementById('yieldSaveMapping')?.checked) {
        // Save the current mappings as aliases for future imports
        const aliases = JSON.parse(localStorage.getItem('yieldColumnAliases') || '{}');
        const yieldField = document.getElementById('yieldMapYield')?.value;
        const moistureField = document.getElementById('yieldMapMoisture')?.value;
        const speedField = document.getElementById('yieldMapSpeed')?.value;

        if (yieldField && !YIELD_FIELD_ALIASES.yield.includes(yieldField)) {
          aliases.yield = aliases.yield || [];
          if (!aliases.yield.includes(yieldField)) aliases.yield.push(yieldField);
        }
        if (moistureField && !YIELD_FIELD_ALIASES.moisture.includes(moistureField)) {
          aliases.moisture = aliases.moisture || [];
          if (!aliases.moisture.includes(moistureField)) aliases.moisture.push(moistureField);
        }
        if (speedField && !YIELD_FIELD_ALIASES.speed.includes(speedField)) {
          aliases.speed = aliases.speed || [];
          if (!aliases.speed.includes(speedField)) aliases.speed.push(speedField);
        }

        localStorage.setItem('yieldColumnAliases', JSON.stringify(aliases));
      }
    }

    // Distance calculation helper (in meters)
    function getDistanceMeters(lat1, lon1, lat2, lon2) {
      const R = 6371000; // Earth radius in meters
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    // ========== QUICK YIELD IMPORT (original) ==========

    async function uploadYield() {
      const fileInput = document.getElementById('yieldFiles');
      const files = fileInput.files;
      const yieldYearInput = document.getElementById('yieldYear');
      let yieldYear = yieldYearInput.value.trim();
      const yieldCrop = document.getElementById('yieldCrop').value;
      const radiusFeet = parseInt(document.getElementById('yieldRadius').value);
      const statusEl = document.getElementById('yieldStatus');

      if (!files.length) { showStatus('Please select yield file(s)', false); return; }
      if (!yieldCrop) { showStatus('Please select a crop type before importing', false); return; }

      statusEl.innerHTML = '<span style="color: #3b82f6;">‚è≥ Processing yield data...</span>';

      try {
        let yieldPoints = [];
        let detectedYear = null;
        let filesProcessed = 0;
        let fileErrors = [];
        let totalPointsLoaded = 0;

        // Helper to add points without stack overflow (use push in batches)
        const addPoints = (newPoints) => {
          // Push in chunks to avoid stack issues with very large arrays
          const chunkSize = 10000;
          for (let i = 0; i < newPoints.length; i += chunkSize) {
            const chunk = newPoints.slice(i, i + chunkSize);
            for (const p of chunk) {
              yieldPoints.push(p);
            }
          }
          totalPointsLoaded += newPoints.length;
        };

        // Small delay to let browser breathe and update UI
        const breathe = () => new Promise(resolve => setTimeout(resolve, 10));

        // Check for ZIP files and loose shapefiles
        const zipFiles = Array.from(files).filter(f => f.name.toLowerCase().endsWith('.zip'));
        const shpFiles = Array.from(files).filter(f => f.name.toLowerCase().endsWith('.shp'));
        const dbfFiles = Array.from(files).filter(f => f.name.toLowerCase().endsWith('.dbf'));

        if (zipFiles.length > 1) {
          // BATCH MODE: Multiple ZIP files (one per field)
          const totalFiles = zipFiles.length;
          statusEl.innerHTML = `<span style="color: #3b82f6;">‚è≥ Processing ${totalFiles} yield files...</span>`;

          for (let i = 0; i < zipFiles.length; i++) {
            const zipFile = zipFiles[i];
            try {
              statusEl.innerHTML = `<span style="color: #3b82f6;">‚è≥ Processing file ${i + 1} of ${totalFiles}: ${zipFile.name}<br><small>${totalPointsLoaded.toLocaleString()} points loaded so far</small></span>`;
              await breathe(); // Let UI update
              const result = await parseYieldFromZip(zipFile);
              addPoints(result.points);
              if (result.detectedYear && !detectedYear) {
                detectedYear = result.detectedYear;
              }
              filesProcessed++;
            } catch (err) {
              console.warn(`Error processing ${zipFile.name}:`, err);
              fileErrors.push({ file: zipFile.name, error: err.message });
            }
            // Breathe every file to prevent blocking
            if (i % 5 === 4) await breathe();
          }

          statusEl.innerHTML = `<span style="color: #3b82f6;">‚è≥ Processed ${filesProcessed}/${totalFiles} files, ${totalPointsLoaded.toLocaleString()} points...</span>`;

        } else if (zipFiles.length === 1) {
          // Single ZIP file
          const result = await parseYieldFromZip(zipFiles[0]);
          addPoints(result.points);
          detectedYear = result.detectedYear;
          filesProcessed = 1;

        } else if (shpFiles.length > 1) {
          // BATCH MODE: Multiple loose .shp/.dbf pairs - group by base filename
          const totalFiles = shpFiles.length;
          statusEl.innerHTML = `<span style="color: #3b82f6;">‚è≥ Processing ${totalFiles} shapefiles...</span>`;

          // Create lookup for dbf files by base name
          const dbfByName = {};
          for (const dbf of dbfFiles) {
            const baseName = dbf.name.toLowerCase().replace('.dbf', '');
            dbfByName[baseName] = dbf;
          }

          for (let i = 0; i < shpFiles.length; i++) {
            const shpFile = shpFiles[i];
            const baseName = shpFile.name.toLowerCase().replace('.shp', '');
            const dbfFile = dbfByName[baseName];

            if (!dbfFile) {
              fileErrors.push({ file: shpFile.name, error: 'No matching .dbf file found' });
              continue;
            }

            try {
              statusEl.innerHTML = `<span style="color: #3b82f6;">‚è≥ Processing file ${i + 1} of ${totalFiles}: ${shpFile.name}<br><small>${totalPointsLoaded.toLocaleString()} points loaded so far</small></span>`;
              await breathe(); // Let UI update
              const shpBuffer = await shpFile.arrayBuffer();
              const dbfBuffer = await dbfFile.arrayBuffer();
              const result = parseYieldShapefile(shpBuffer, dbfBuffer);
              addPoints(result.points);
              if (result.detectedYear && !detectedYear) {
                detectedYear = result.detectedYear;
              }
              filesProcessed++;
            } catch (err) {
              console.warn(`Error processing ${shpFile.name}:`, err);
              fileErrors.push({ file: shpFile.name, error: err.message });
            }
            // Breathe every file to prevent blocking
            if (i % 5 === 4) await breathe();
          }

          statusEl.innerHTML = `<span style="color: #3b82f6;">‚è≥ Processed ${filesProcessed}/${totalFiles} shapefiles, ${totalPointsLoaded.toLocaleString()} points...</span>`;

        } else {
          // Single shapefile (loose files)
          const result = await parseYieldFromShapefiles(files);
          addPoints(result.points);
          detectedYear = result.detectedYear;
          filesProcessed = 1;
        }

        // Auto-fill year if detected from file and input is empty
        if (detectedYear && !yieldYear) {
          yieldYear = String(detectedYear);
          yieldYearInput.value = yieldYear;
          statusEl.innerHTML = `<span style="color: #3b82f6;">üìÖ Detected year ${detectedYear} from file</span><br>`;
        }

        // Still require year even after auto-detect attempt
        if (!yieldYear) {
          statusEl.innerHTML = '<span style="color: #ef4444;">‚ùå Please enter the crop year (could not auto-detect from file)</span>';
          return;
        }

        if (yieldPoints.length === 0) {
          statusEl.innerHTML = '<span style="color: #ef4444;">‚ùå No yield points found in files</span>';
          if (fileErrors.length > 0) {
            statusEl.innerHTML += `<br><span style="color: #f59e0b;">‚ö†Ô∏è ${fileErrors.length} file(s) had errors</span>`;
          }
          return;
        }

        // Add metadata to each point
        statusEl.innerHTML = `<span style="color: #3b82f6;">‚è≥ Adding metadata to ${yieldPoints.length.toLocaleString()} points...</span>`;
        await breathe();
        for (const p of yieldPoints) {
          p.year = parseInt(yieldYear);
          p.crop = yieldCrop;
        }

        // Store yield data - avoid spread operator for large arrays
        statusEl.innerHTML = `<span style="color: #3b82f6;">‚è≥ Filtering duplicates...</span>`;
        await breathe();
        const existingKeys = new Set(yieldData.map(y => `${y.lat}-${y.lon}-${y.year}`));
        const newPoints = [];
        for (const p of yieldPoints) {
          const key = `${p.lat}-${p.lon}-${p.year}`;
          if (!existingKeys.has(key)) {
            newPoints.push(p);
          }
        }
        // Add to yieldData without spread
        for (const p of newPoints) {
          yieldData.push(p);
        }

        statusEl.innerHTML = `<span style="color: #22c55e;">‚úì Loaded ${newPoints.length.toLocaleString()} yield points from ${filesProcessed} file(s)</span>`;

        // Now correlate with soil samples
        statusEl.innerHTML += '<br><span style="color: #3b82f6;">‚è≥ Correlating with soil samples...</span>';

        const correlationResults = await correlateYieldToSamples(yieldYear, radiusFeet);

        // Clear raw yield data after correlation - only keep correlated summary on samples
        yieldData = [];
        localStorage.removeItem('yieldData');

        await afterImportSuccess();

        // Calculate coverage area match rate (samples matched / samples in coverage area)
        const coverageMatchRate = correlationResults.samplesInCoverageArea > 0
          ? Math.round((correlationResults.samplesWithYield / correlationResults.samplesInCoverageArea) * 100)
          : 0;
        const coverageMatchColor = coverageMatchRate >= 95 ? '#22c55e' : (coverageMatchRate >= 80 ? '#f59e0b' : '#ef4444');

        // Get unmatched in coverage (yield was close but not close enough)
        const unmatchedInCoverage = correlationResults.samplesInCoverageButNoMatch || 0;
        const unmatchedPct = correlationResults.samplesInCoverageArea > 0
          ? Math.round((unmatchedInCoverage / correlationResults.samplesInCoverageArea) * 100)
          : 0;

        // Calculate overall data status
        const totalWithYield = sampleData.filter(s => s.yieldCorrelations && Object.keys(s.yieldCorrelations).length > 0).length;
        const totalWithoutYield = sampleData.length - totalWithYield;
        const overallPct = sampleData.length > 0 ? Math.round((totalWithYield / sampleData.length) * 100) : 0;
        const overallColor = overallPct >= 50 ? '#22c55e' : (overallPct >= 25 ? '#f59e0b' : '#64748b');

        // Build status HTML
        let statusHtml = '<div style="font-size: 0.9rem; line-height: 1.6;">';

        // Upload summary
        if (detectedYear) statusHtml += `<span style="color: #22c55e;">‚úì Auto-detected year: ${detectedYear}</span><br>`;
        if (filesProcessed > 1) statusHtml += `<span style="color: #22c55e;">‚úì Processed ${filesProcessed} yield files</span><br>`;
        statusHtml += `<span style="color: #22c55e;">‚úì Uploaded ${newPoints.length.toLocaleString()} yield points</span>`;
        if (fileErrors.length > 0) {
          statusHtml += `<br><span style="color: #f59e0b;">‚ö† ${fileErrors.length} file(s) skipped due to errors</span>`;
        }

        // Yield-to-Sample Matching section
        let matchingRows = `
              <span style="color: #64748b;">Soil samples in yield coverage:</span>
              <span style="font-weight: 600; text-align: right;">${correlationResults.samplesInCoverageArea.toLocaleString()}</span>
              <span style="color: #64748b;">Successfully matched:</span>
              <span style="font-weight: 600; color: ${coverageMatchColor}; text-align: right;">${correlationResults.samplesWithYield.toLocaleString()} (${coverageMatchRate}%)</span>`;

        // Only show "no yield within radius" row if there are gaps
        if (unmatchedInCoverage > 0) {
          matchingRows += `
              <span style="color: #64748b;">No yield within radius:</span>
              <span style="font-weight: 600; color: #f59e0b; text-align: right;">${unmatchedInCoverage.toLocaleString()} (${unmatchedPct}%)</span>`;
        }

        matchingRows += `
              <span style="color: #64748b;">Avg yield points per sample:</span>
              <span style="font-weight: 600; text-align: right;">${correlationResults.avgYieldPointsPerSample}</span>`;

        statusHtml += `
          <div style="margin-top: 0.75rem; padding: 0.5rem 0.75rem; background: #f8fafc; border-radius: 0.375rem; border: 1px solid #e2e8f0;">
            <div style="font-weight: 600; color: #475569; margin-bottom: 0.5rem; font-size: 0.8rem;">Yield-to-Sample Matching</div>
            <div style="display: grid; grid-template-columns: 1fr auto; gap: 0.25rem 1rem; font-size: 0.85rem;">${matchingRows}
            </div>
          </div>`;

        // Overall Data Status section
        statusHtml += `
          <div style="margin-top: 0.5rem; padding: 0.5rem 0.75rem; background: #f0fdf4; border-radius: 0.375rem; border: 1px solid #bbf7d0;">
            <div style="font-weight: 600; color: #166534; margin-bottom: 0.5rem; font-size: 0.8rem;">Overall Data Status</div>
            <div style="display: grid; grid-template-columns: 1fr auto; gap: 0.25rem 1rem; font-size: 0.85rem;">
              <span style="color: #64748b;">Total soil samples:</span>
              <span style="font-weight: 600; text-align: right;">${sampleData.length.toLocaleString()}</span>
              <span style="color: #64748b;">Samples with yield data:</span>
              <span style="font-weight: 600; color: ${overallColor}; text-align: right;">${totalWithYield.toLocaleString()} (${overallPct}%)</span>
              <span style="color: #64748b;">Samples without yield data:</span>
              <span style="font-weight: 600; text-align: right;">${totalWithoutYield.toLocaleString()} (${100 - overallPct}%)</span>
            </div>
          </div>`;

        statusHtml += '</div>';
        statusHtml += `
          <button onclick="showYieldSummary(lastYieldResults)" style="margin-top: 0.75rem; padding: 0.5rem 1rem; background: #f59e0b; color: white; border: none; border-radius: 0.25rem; cursor: pointer; font-weight: 600;">
            üìä View Detailed Summary
          </button>
        `;

        statusEl.innerHTML = statusHtml;

        // Store results for later viewing
        lastYieldResults = correlationResults;

        fileInput.value = '';

      } catch (e) {
        console.error('Yield upload error:', e);
        statusEl.innerHTML = `<span style="color: #ef4444;">‚ùå Error: ${e.message}</span>`;
      }
    }
    
    async function parseYieldFromZip(zipFile) {
      const JSZip = window.JSZip || (await loadJSZip());
      const zip = await JSZip.loadAsync(zipFile);
      
      let shpFile, dbfFile;
      for (const [name, file] of Object.entries(zip.files)) {
        const lower = name.toLowerCase();
        if (lower.endsWith('.shp')) shpFile = file;
        if (lower.endsWith('.dbf')) dbfFile = file;
      }
      
      if (!shpFile || !dbfFile) throw new Error('ZIP must contain .shp and .dbf files');
      
      const shpBuffer = await shpFile.async('arraybuffer');
      const dbfBuffer = await dbfFile.async('arraybuffer');
      
      return parseYieldShapefile(shpBuffer, dbfBuffer);
    }
    
    async function parseYieldFromShapefiles(files) {
      const fileMap = {};
      for (const f of files) {
        const ext = f.name.split('.').pop().toLowerCase();
        fileMap[ext] = await f.arrayBuffer();
      }
      
      if (!fileMap.shp || !fileMap.dbf) throw new Error('Need both .shp and .dbf files');
      
      return parseYieldShapefile(fileMap.shp, fileMap.dbf);
    }
    
    function parseYieldShapefile(shpBuffer, dbfBuffer) {
      const points = [];
      
      // Parse DBF for attributes
      const dbfView = new DataView(dbfBuffer);
      const numRecords = dbfView.getUint32(4, true);
      const headerSize = dbfView.getUint16(8, true);
      const recordSize = dbfView.getUint16(10, true);
      
      // Helper to convert bytes to string without spread operator (avoids stack overflow)
      const bytesToString = (buffer, start, length) => {
        const bytes = new Uint8Array(buffer.slice(start, start + length));
        let str = '';
        for (let i = 0; i < bytes.length; i++) {
          if (bytes[i] === 0) break; // Stop at null terminator
          str += String.fromCharCode(bytes[i]);
        }
        return str.trim();
      };

      // Parse field descriptors
      const fields = [];
      let offset = 32;
      while (offset < headerSize - 1) {
        const fieldName = bytesToString(dbfBuffer, offset, 11);
        if (!fieldName) break;
        const fieldType = String.fromCharCode(dbfView.getUint8(offset + 11));
        const fieldLen = dbfView.getUint8(offset + 16);
        fields.push({ name: fieldName, type: fieldType, length: fieldLen });
        offset += 32;
      }
      
      // Find yield field - common names from JD and Climate
      const yieldFieldNames = ['VRYIELDVO', 'Yld_Vol_Dr', 'YLD_VOL_DR', 'YIELD', 'DryYield', 'Dry_Yield', 'YldVolDry', 'YldMassDry', 'VRYIELDMA', 'Yld_Mass_D'];
      let yieldField = fields.find(f => yieldFieldNames.includes(f.name));
      if (!yieldField) {
        // Try partial match
        yieldField = fields.find(f => f.name.toLowerCase().includes('yield') || f.name.toLowerCase().includes('yld'));
      }

      if (!yieldField) {
        console.warn('Available fields:', fields.map(f => f.name));
        throw new Error('Could not find yield field. Available: ' + fields.map(f => f.name).join(', '));
      }

      // Find date/time field to auto-detect year - common names from JD and Climate
      const dateFieldNames = ['TIMESTAMP', 'TimeStamp', 'IsoTime', 'ISOTIME', 'Date', 'DATE', 'HarvestDat', 'Time', 'TIME', 'DATETIME', 'DateTime', 'Harvest_Da', 'VRLOGTIME'];
      let dateField = fields.find(f => dateFieldNames.includes(f.name));
      if (!dateField) {
        // Try partial match for date/time fields
        dateField = fields.find(f => f.name.toLowerCase().includes('time') || f.name.toLowerCase().includes('date'));
      }

      // Also look for explicit year field
      const yearFieldNames = ['Year', 'YEAR', 'CropYear', 'CROPYEAR', 'Crop_Year'];
      let yearField = fields.find(f => yearFieldNames.includes(f.name));
      
      // Parse SHP for coordinates
      const shpView = new DataView(shpBuffer);
      let shpOffset = 100; // Skip header
      
      const records = [];
      while (shpOffset < shpBuffer.byteLength - 8) {
        const recordNum = shpView.getInt32(shpOffset, false);
        const contentLen = shpView.getInt32(shpOffset + 4, false) * 2;
        const shapeType = shpView.getInt32(shpOffset + 8, true);
        
        if (shapeType === 1 || shapeType === 11) { // Point or PointZ
          const x = shpView.getFloat64(shpOffset + 12, true); // Longitude
          const y = shpView.getFloat64(shpOffset + 20, true); // Latitude
          records.push({ lon: x, lat: y });
        }
        
        shpOffset += 8 + contentLen;
      }
      
      // Parse DBF records and match with coordinates
      let dbfOffset = headerSize;
      let detectedYear = null;

      for (let i = 0; i < Math.min(numRecords, records.length); i++) {
        dbfOffset++; // Skip deletion flag

        let fieldOffset = 0;
        let yieldValue = null;

        for (const field of fields) {
          const rawValue = bytesToString(dbfBuffer, dbfOffset + fieldOffset, field.length);

          if (field.name === yieldField.name) {
            yieldValue = parseFloat(rawValue);
          }

          // Try to detect year from first record with valid data
          if (detectedYear === null && rawValue) {
            // Check explicit year field first
            if (yearField && field.name === yearField.name) {
              const yr = parseInt(rawValue);
              if (yr >= 1990 && yr <= 2100) {
                detectedYear = yr;
              }
            }
            // Check date/time field
            else if (dateField && field.name === dateField.name) {
              // Try various date formats
              // ISO format: 2024-09-15T... or 2024/09/15
              const isoMatch = rawValue.match(/^(20\d{2}|19\d{2})[-\/]/);
              if (isoMatch) {
                detectedYear = parseInt(isoMatch[1]);
              }
              // US format: 09/15/2024 or 09-15-2024
              const usMatch = rawValue.match(/[-\/](20\d{2}|19\d{2})($|\s|T)/);
              if (!detectedYear && usMatch) {
                detectedYear = parseInt(usMatch[1]);
              }
              // Just year: 2024
              const yearOnly = rawValue.match(/^(20\d{2}|19\d{2})$/);
              if (!detectedYear && yearOnly) {
                detectedYear = parseInt(yearOnly[1]);
              }
            }
          }

          fieldOffset += field.length;
        }

        dbfOffset += recordSize - 1;

        if (records[i] && yieldValue && !isNaN(yieldValue) && yieldValue > 0) {
          points.push({
            lat: records[i].lat,
            lon: records[i].lon,
            yield: yieldValue
          });
        }
      }

      return { points, detectedYear };
    }
    
    async function correlateYieldToSamples(yieldYear, radiusFeet) {
      // SOIL-SAMPLE-CENTRIC LOGIC:
      // For each soil sample location, find all yield points within the radius
      // Calculate average yield from those points and assign to the sample
      // This answers: "For this soil sample location, what was the average yield?"

      // Convert feet to approximate degrees (at ~40¬∞ latitude)
      const radiusLatDeg = radiusFeet / 364000;
      const radiusLonDeg = radiusFeet / 288000;

      const yieldYear_int = parseInt(yieldYear);

      // Filter yield data for this year
      const yearYield = yieldData.filter(y => y.year === yieldYear_int);

      if (yearYield.length === 0) {
        return {
          totalSamples: sampleData.length,
          samplesInCoverageArea: 0,
          samplesInCoverageButNoMatch: 0,
          samplesWithYield: 0,
          samplesWithoutYield: sampleData.length,
          totalYieldPoints: 0,
          avgYieldPointsPerSample: 0,
          noYieldData: true,
          fieldStats: {},
          yieldYear: yieldYear_int,
          radiusFeet
        };
      }

      // Helper for async breathing
      const breathe = () => new Promise(resolve => setTimeout(resolve, 0));

      // Use 2x radius for "coverage detection" - samples where yield data is nearby but maybe not quite close enough
      const coverageRadiusLatDeg = radiusLatDeg * 2;
      const coverageRadiusLonDeg = radiusLonDeg * 2;

      // Track results
      let samplesWithYieldCount = 0;
      let samplesWithoutYieldCount = 0;
      let totalYieldPointsMatched = 0;

      // Per-field tracking
      const fieldStats = {};

      // Get unique fields that have samples
      const fieldsWithSamples = [...new Set(sampleData.map(s => s.field).filter(f => f))];

      // Initialize field stats
      fieldsWithSamples.forEach(field => {
        const fieldSamples = sampleData.filter(s => s.field === field);
        const samplesByYear = {};
        fieldSamples.forEach(s => {
          const yr = parseInt(s.year);
          if (!isNaN(yr)) {
            samplesByYear[yr] = (samplesByYear[yr] || 0) + 1;
          }
        });

        fieldStats[field] = {
          totalSamples: fieldSamples.length,
          samplesWithYield: 0,
          samplesWithoutYield: 0,
          totalYieldPointsMatched: 0,
          sampleInventory: samplesByYear
        };
      });

      console.log('=== YIELD MATCHING (SOIL-SAMPLE-CENTRIC) ===');
      console.log(`Total soil samples: ${sampleData.length}`);
      console.log(`Total yield points for ${yieldYear_int}: ${yearYield.length}`);
      console.log(`Search radius: ${radiusFeet}ft`);

      // Track samples in coverage area (yield nearby within 2x radius)
      let samplesInCoverageArea = 0;
      let samplesInCoverageButNoMatch = 0;

      // Process each soil sample - find nearby yield points
      for (let sIdx = 0; sIdx < sampleData.length; sIdx++) {
        const sample = sampleData[sIdx];

        if (!sample.lat || !sample.lon) continue;

        // Find all yield points within matching radius AND check for coverage (2x radius)
        const nearbyYieldPoints = [];
        let hasYieldInCoverage = false;

        for (let yIdx = 0; yIdx < yearYield.length; yIdx++) {
          const yp = yearYield[yIdx];
          const latDiff = Math.abs(sample.lat - yp.lat);
          const lonDiff = Math.abs(sample.lon - yp.lon);

          // Check if within matching radius
          if (latDiff <= radiusLatDeg && lonDiff <= radiusLonDeg) {
            nearbyYieldPoints.push(yp);
          }
          // Check if within coverage radius (2x) - only need to find one
          if (!hasYieldInCoverage && latDiff <= coverageRadiusLatDeg && lonDiff <= coverageRadiusLonDeg) {
            hasYieldInCoverage = true;
          }
        }

        const field = sample.field || 'Unknown';

        // Track coverage area (samples where yield data is nearby)
        if (hasYieldInCoverage) {
          samplesInCoverageArea++;
        }

        if (nearbyYieldPoints.length > 0) {
          // Calculate average yield from nearby points
          let totalYield = 0;
          for (const yp of nearbyYieldPoints) {
            totalYield += yp.yield;
          }
          const avgYield = totalYield / nearbyYieldPoints.length;

          // Store yield correlation on the sample
          if (!sample.yieldCorrelations) sample.yieldCorrelations = {};
          sample.yieldCorrelations[yieldYear_int] = {
            avgYield: Math.round(avgYield * 10) / 10,
            pointCount: nearbyYieldPoints.length,
            crop: nearbyYieldPoints[0].crop,
            radiusFt: radiusFeet
          };

          samplesWithYieldCount++;
          totalYieldPointsMatched += nearbyYieldPoints.length;

          if (fieldStats[field]) {
            fieldStats[field].samplesWithYield++;
            fieldStats[field].totalYieldPointsMatched += nearbyYieldPoints.length;
          }
        } else {
          samplesWithoutYieldCount++;
          if (fieldStats[field]) {
            fieldStats[field].samplesWithoutYield++;
          }
          // Track samples in coverage but no match (yield was close but not close enough)
          if (hasYieldInCoverage) {
            samplesInCoverageButNoMatch++;
          }
        }

        // Breathe every 100 samples to keep UI responsive
        if (sIdx % 100 === 99) await breathe();
      }

      // Calculate per-field match rates
      for (const field of Object.keys(fieldStats)) {
        const stats = fieldStats[field];
        stats.matchRate = stats.totalSamples > 0
          ? Math.round((stats.samplesWithYield / stats.totalSamples) * 100)
          : 0;
        stats.avgYieldPointsPerSample = stats.samplesWithYield > 0
          ? Math.round(stats.totalYieldPointsMatched / stats.samplesWithYield)
          : 0;
      }

      // Save updated samples
      await saveLocalData();

      const avgYieldPointsPerSample = samplesWithYieldCount > 0
        ? Math.round(totalYieldPointsMatched / samplesWithYieldCount)
        : 0;

      console.log('=== YIELD MATCHING RESULTS ===');
      console.log(`Samples in yield coverage: ${samplesInCoverageArea}`);
      console.log(`Successfully matched: ${samplesWithYieldCount}`);
      console.log(`In coverage but no match: ${samplesInCoverageButNoMatch}`);
      console.log(`Avg yield points per matched sample: ${avgYieldPointsPerSample}`);

      return {
        totalSamples: sampleData.length,
        samplesInCoverageArea,
        samplesInCoverageButNoMatch,
        samplesWithYield: samplesWithYieldCount,
        samplesWithoutYield: samplesWithoutYieldCount,
        totalYieldPoints: yearYield.length,
        totalYieldPointsMatched,
        avgYieldPointsPerSample,
        yieldYear: yieldYear_int,
        radiusFeet,
        fieldStats
      };
    }

    // Helper: check if point is inside polygon
    function pointInPolygon(point, polygon) {
      if (!polygon || polygon.length < 3) return false;
      const [lat, lon] = point;
      let inside = false;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const [yi, xi] = polygon[i];
        const [yj, xj] = polygon[j];
        if (((yi > lat) !== (yj > lat)) && (lon < (xj - xi) * (lat - yi) / (yj - yi) + xi)) {
          inside = !inside;
        }
      }
      return inside;
    }

    // ========== YIELD SUMMARY MODAL ==========
    let yieldSummaryMap = null;
    let lastYieldResults = null;

    function showYieldSummary(results) {
      lastYieldResults = results;
      const modal = document.getElementById('yieldSummaryModal');

      // Calculate coverage area match rate
      const coverageMatchRate = results.samplesInCoverageArea > 0
        ? Math.round((results.samplesWithYield / results.samplesInCoverageArea) * 100)
        : 0;
      const coverageMatchColor = coverageMatchRate >= 95 ? '#16a34a' : (coverageMatchRate >= 80 ? '#d97706' : '#dc2626');

      // Calculate overall data status
      const totalWithYield = sampleData.filter(s => s.yieldCorrelations && Object.keys(s.yieldCorrelations).length > 0).length;
      const overallPct = sampleData.length > 0 ? Math.round((totalWithYield / sampleData.length) * 100) : 0;

      // Clear any existing debug section from previous opens
      const existingDebug = document.getElementById('gpsDebugSection');
      if (existingDebug) existingDebug.remove();

      // Get unmatched in coverage (from results, not calculated)
      const unmatchedInCoverage = results.samplesInCoverageButNoMatch || 0;
      const unmatchedPct = results.samplesInCoverageArea > 0
        ? Math.round((unmatchedInCoverage / results.samplesInCoverageArea) * 100)
        : 0;

      // Build summary stats - show 3 boxes if no gaps, 4 if there are gaps
      let statsBoxes = `
            <div style="text-align: center; padding: 0.5rem; background: white; border-radius: 0.375rem; border: 1px solid #e2e8f0;">
              <div style="font-size: 1.25rem; font-weight: 700; color: #1e293b;">${(results.samplesInCoverageArea || 0).toLocaleString()}</div>
              <div style="font-size: 0.7rem; color: #64748b;">In Yield Coverage</div>
            </div>
            <div style="text-align: center; padding: 0.5rem; background: white; border-radius: 0.375rem; border: 1px solid #22c55e;">
              <div style="font-size: 1.25rem; font-weight: 700; color: #16a34a;">${results.samplesWithYield.toLocaleString()}</div>
              <div style="font-size: 0.7rem; color: #64748b;">Matched (${coverageMatchRate}%)</div>
            </div>`;

      // Only show "No Match" box if there are gaps
      if (unmatchedInCoverage > 0) {
        statsBoxes += `
            <div style="text-align: center; padding: 0.5rem; background: white; border-radius: 0.375rem; border: 1px solid #f59e0b;">
              <div style="font-size: 1.25rem; font-weight: 700; color: #d97706;">${unmatchedInCoverage.toLocaleString()}</div>
              <div style="font-size: 0.7rem; color: #64748b;">No Match (${unmatchedPct}%)</div>
            </div>`;
      }

      statsBoxes += `
            <div style="text-align: center; padding: 0.5rem; background: white; border-radius: 0.375rem; border: 1px solid #e2e8f0;">
              <div style="font-size: 1.25rem; font-weight: 700; color: #1e293b;">${results.avgYieldPointsPerSample}</div>
              <div style="font-size: 0.7rem; color: #64748b;">Avg Pts/Sample</div>
            </div>`;

      const gridCols = unmatchedInCoverage > 0 ? 'repeat(4, 1fr)' : 'repeat(3, 1fr)';

      // Summary stats with coverage area focus
      document.getElementById('yieldSummaryStats').innerHTML = `
        <div style="grid-column: span 4; margin-bottom: 0.5rem;">
          <div style="font-weight: 600; color: #475569; font-size: 0.8rem; margin-bottom: 0.5rem;">This Import (Year ${results.yieldYear})</div>
          <div style="display: grid; grid-template-columns: ${gridCols}; gap: 0.5rem;">${statsBoxes}
          </div>
        </div>
        <div style="grid-column: span 4; margin-top: 0.5rem; padding: 0.5rem 0.75rem; background: #f0fdf4; border-radius: 0.375rem; border: 1px solid #bbf7d0;">
          <div style="font-weight: 600; color: #166534; font-size: 0.8rem; margin-bottom: 0.25rem;">Overall Data Status</div>
          <div style="display: flex; justify-content: space-between; font-size: 0.85rem;">
            <span style="color: #64748b;">Total samples: <strong style="color: #1e293b;">${sampleData.length.toLocaleString()}</strong></span>
            <span style="color: #64748b;">With yield data: <strong style="color: #16a34a;">${totalWithYield.toLocaleString()} (${overallPct}%)</strong></span>
            <span style="color: #64748b;">Without yield: <strong>${(sampleData.length - totalWithYield).toLocaleString()} (${100 - overallPct}%)</strong></span>
          </div>
        </div>
      `;

      // Per-field breakdown
      const fieldRows = Object.entries(results.fieldStats)
        .filter(([field, stats]) => stats.totalSamples > 0)
        .sort((a, b) => a[0].localeCompare(b[0], undefined, { numeric: true }))
        .map(([field, stats]) => {
          const fieldMatchRate = stats.matchRate || 0;
          const isLowMatch = fieldMatchRate < 80;
          const rateColor = fieldMatchRate === 100 ? '#16a34a' : (isLowMatch ? '#dc2626' : '#d97706');
          const rateBg = fieldMatchRate === 100 ? '#f0fdf4' : (isLowMatch ? '#fef2f2' : '#fffbeb');

          // Sample inventory display
          const inventory = stats.sampleInventory || {};
          const invYears = Object.keys(inventory).map(Number).sort((a,b) => b - a);
          const invDisplay = invYears.length > 0
            ? invYears.map(y => `${y}: ${inventory[y]}`).join(', ')
            : '<span style="color:#dc2626;">None</span>';

          return `
            <tr style="border-bottom: 1px solid #e2e8f0; vertical-align: top;">
              <td style="padding: 0.75rem 0.5rem;">
                <div style="font-weight: 600;">${field}</div>
                <div style="font-size: 0.7rem; color: #64748b; margin-top: 0.25rem;">
                  Samples by year: ${invDisplay}
                </div>
              </td>
              <td style="padding: 0.75rem 0.5rem; text-align: center;">
                <div style="color: #1e293b; font-weight: 500;">${stats.totalSamples}</div>
                <div style="font-size: 0.7rem; color: #64748b;">samples</div>
              </td>
              <td style="padding: 0.75rem 0.5rem; text-align: center;">
                <div style="color: #16a34a; font-weight: 500;">${stats.samplesWithYield}</div>
                <div style="font-size: 0.7rem; color: #64748b;">with yield</div>
              </td>
              <td style="padding: 0.75rem 0.5rem; text-align: center;">
                <span style="background: ${rateBg}; color: ${rateColor}; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-weight: 600;">
                  ${fieldMatchRate}%
                </span>
              </td>
              <td style="padding: 0.75rem 0.5rem; text-align: center;">
                <div style="color: #64748b;">${stats.avgYieldPointsPerSample || 0}</div>
                <div style="font-size: 0.7rem; color: #64748b;">pts/sample</div>
              </td>
            </tr>
          `;
        }).join('');

      document.getElementById('yieldTabFields').innerHTML = `
        <div style="margin-bottom: 1rem; padding: 0.75rem; background: #eff6ff; border-radius: 0.375rem; border: 1px solid #bfdbfe;">
          <div style="font-weight: 600; color: #1e40af; margin-bottom: 0.5rem;">How Yield Matching Works</div>
          <div style="font-size: 0.8rem; color: #1e40af;">
            For each <strong>soil sample location</strong>, we find all yield points within <strong>${results.radiusFeet}ft</strong> and calculate the average yield.<br>
            Samples with no yield points nearby will show "No Yield Nearby" - this means no harvester passed within ${results.radiusFeet}ft of that sample location.
          </div>
        </div>
        <table style="width: 100%; border-collapse: collapse; font-size: 0.875rem;">
          <thead>
            <tr style="background: #f8fafc; border-bottom: 2px solid #e2e8f0;">
              <th style="padding: 0.5rem; text-align: left;">Field</th>
              <th style="padding: 0.5rem; text-align: center;">Samples</th>
              <th style="padding: 0.5rem; text-align: center;">With Yield</th>
              <th style="padding: 0.5rem; text-align: center;">Match %</th>
              <th style="padding: 0.5rem; text-align: center;">Avg Pts</th>
            </tr>
          </thead>
          <tbody>${fieldRows}</tbody>
        </table>
        <div style="margin-top: 1rem; padding: 0.75rem; background: #f8fafc; border-radius: 0.375rem; font-size: 0.8125rem; color: #64748b;">
          <strong>Import Settings:</strong> Yield Year ${results.yieldYear}, Search Radius ${results.radiusFeet}ft, ${results.totalYieldPoints.toLocaleString()} yield points available
        </div>
      `;

      // Samples without yield - show which fields have gaps
      const fieldsWithGaps = Object.entries(results.fieldStats)
        .filter(([_, stats]) => stats.samplesWithoutYield > 0)
        .sort((a, b) => b[1].samplesWithoutYield - a[1].samplesWithoutYield);

      if (fieldsWithGaps.length > 0) {
        let gapsHtml = `
          <div style="margin-bottom: 1rem; padding: 0.75rem; background: #fef3c7; border-radius: 0.375rem; border: 1px solid #fcd34d;">
            <strong style="color: #92400e;">${results.samplesWithoutYield} soil samples</strong>
            <span style="color: #92400e;"> have no yield data within ${results.radiusFeet}ft</span>
          </div>
          <div style="font-size: 0.875rem; color: #64748b; margin-bottom: 0.75rem;">
            This typically means the harvester didn't pass close enough to these sample locations, or yield data wasn't uploaded for that field.
          </div>
          <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
        `;
        fieldsWithGaps.forEach(([field, stats]) => {
          gapsHtml += `
            <span style="background: #fef3c7; border: 1px solid #fcd34d; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-size: 0.8rem;">
              ${field}: ${stats.samplesWithoutYield} samples
            </span>
          `;
        });
        gapsHtml += '</div>';
        document.getElementById('yieldTabUnmatched').innerHTML = gapsHtml;
      } else {
        document.getElementById('yieldTabUnmatched').innerHTML = `
          <div style="text-align: center; padding: 2rem; color: #16a34a;">
            <div style="font-size: 2rem;">‚úì</div>
            <div style="font-weight: 600;">All soil samples have yield data nearby!</div>
          </div>
        `;
      }

      modal.classList.add('active');

      // Reset to first tab
      switchYieldTab('fields');
    }

    function switchYieldTab(tab) {
      // Update tab buttons
      document.querySelectorAll('.yield-tab').forEach(btn => {
        const isActive = btn.dataset.tab === tab;
        btn.style.background = isActive ? 'white' : '#f8fafc';
        btn.style.fontWeight = isActive ? '600' : '500';
        btn.style.borderBottom = isActive ? '2px solid #f59e0b' : '2px solid transparent';
      });

      // Show/hide content
      document.getElementById('yieldTabFields').style.display = tab === 'fields' ? 'block' : 'none';
      document.getElementById('yieldTabUnmatched').style.display = tab === 'unmatched' ? 'block' : 'none';
      document.getElementById('yieldTabMap').style.display = tab === 'map' ? 'block' : 'none';

      // Initialize map if switching to map tab
      if (tab === 'map' && lastYieldResults) {
        setTimeout(() => initYieldSummaryMap(), 100);
      }
    }

    function initYieldSummaryMap() {
      const mapContainer = document.getElementById('yieldMatchMap');

      // Destroy existing map if any
      if (yieldSummaryMap) {
        yieldSummaryMap.remove();
        yieldSummaryMap = null;
      }

      // Create map
      yieldSummaryMap = L.map(mapContainer).setView([40, -95], 4);
      L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        attribution: '¬© Esri'
      }).addTo(yieldSummaryMap);

      const allMarkers = [];
      const ageCounts = { sameYear: 0, oneYear: 0, twoThree: 0, stale: 0, noYield: 0 };

      // Add samples colored by sample age at harvest time
      sampleData.forEach((sample, idx) => {
        if (!sample.lat || !sample.lon) return;

        const yieldCorr = sample.yieldCorrelations && sample.yieldCorrelations[lastYieldResults.yieldYear];
        let color, fillColor, ageLabel;

        if (yieldCorr) {
          const age = yieldCorr.sampleAge || 0;
          if (age === 0) {
            color = '#166534'; fillColor = '#86efac'; ageLabel = 'Same year';
            ageCounts.sameYear++;
          } else if (age === 1) {
            color = '#1e40af'; fillColor = '#93c5fd'; ageLabel = '1 year prior';
            ageCounts.oneYear++;
          } else if (age <= 3) {
            color = '#92400e'; fillColor = '#fcd34d'; ageLabel = `${age} years prior`;
            ageCounts.twoThree++;
          } else {
            color = '#dc2626'; fillColor = '#fca5a5'; ageLabel = `${age} years (stale)`;
            ageCounts.stale++;
          }
        } else {
          color = '#64748b'; fillColor = '#cbd5e1'; ageLabel = 'No yield data';
          ageCounts.noYield++;
        }

        const marker = L.circleMarker([sample.lat, sample.lon], {
          radius: 6,
          fillColor: fillColor,
          color: color,
          weight: 2,
          opacity: 1,
          fillOpacity: 0.8
        });

        const yieldInfo = yieldCorr ? `<br>Yield: ${yieldCorr.avgYield}<br>Sample Age: ${ageLabel}` : '';
        marker.bindPopup(`<b>${sample.field}</b><br>Sample ${sample.sampleId || idx} (${sample.year})${yieldInfo}`);
        marker.addTo(yieldSummaryMap);
        allMarkers.push(marker);
      });

      // Add field boundaries
      for (const [name, fieldData] of Object.entries(fieldBoundaries)) {
        const coords = fieldData.boundary || fieldData;
        if (coords && coords.length > 2) {
          L.polygon(coords, {
            color: '#3b82f6',
            weight: 2,
            fillOpacity: 0.1
          }).addTo(yieldSummaryMap);
        }
      }

      // Fit to bounds
      if (allMarkers.length > 0) {
        const group = L.featureGroup(allMarkers);
        yieldSummaryMap.fitBounds(group.getBounds().pad(0.1));
      }

      // Add legend showing sample age colors
      const legend = L.control({ position: 'bottomright' });
      legend.onAdd = function() {
        const div = L.DomUtil.create('div', 'info legend');
        div.style.background = 'white';
        div.style.padding = '8px 12px';
        div.style.borderRadius = '4px';
        div.style.boxShadow = '0 1px 4px rgba(0,0,0,0.2)';
        div.style.fontSize = '11px';
        div.innerHTML = `
          <div style="font-weight:600;margin-bottom:4px;">Sample Age at Harvest</div>
          <div style="margin-bottom:2px;"><span style="display:inline-block;width:10px;height:10px;background:#86efac;border:2px solid #166534;border-radius:50%;margin-right:4px;"></span>Same year (${ageCounts.sameYear})</div>
          <div style="margin-bottom:2px;"><span style="display:inline-block;width:10px;height:10px;background:#93c5fd;border:2px solid #1e40af;border-radius:50%;margin-right:4px;"></span>1 year (${ageCounts.oneYear})</div>
          <div style="margin-bottom:2px;"><span style="display:inline-block;width:10px;height:10px;background:#fcd34d;border:2px solid #92400e;border-radius:50%;margin-right:4px;"></span>2-3 years (${ageCounts.twoThree})</div>
          <div style="margin-bottom:2px;"><span style="display:inline-block;width:10px;height:10px;background:#fca5a5;border:2px solid #dc2626;border-radius:50%;margin-right:4px;"></span>4+ stale (${ageCounts.stale})</div>
          <div><span style="display:inline-block;width:10px;height:10px;background:#cbd5e1;border:2px solid #64748b;border-radius:50%;margin-right:4px;"></span>No yield (${ageCounts.noYield})</div>
        `;
        return div;
      };
      legend.addTo(yieldSummaryMap);
    }

    function closeYieldSummary() {
      document.getElementById('yieldSummaryModal').classList.remove('active');
      if (yieldSummaryMap) {
        yieldSummaryMap.remove();
        yieldSummaryMap = null;
      }
    }

    async function loadJSZip() {
      // JSZip should already be loaded from earlier script
      if (window.JSZip) return window.JSZip;
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
        script.onload = () => resolve(window.JSZip);
        script.onerror = reject;
        document.head.appendChild(script);
      });
    }

    async function syncToSheets() {
      if (!SheetsAPI.isSignedIn) { showStatus('Please sign in first', false); return; }

      // Safety check: don't sync if no local data (prevents wiping Sheets)
      if (sampleData.length === 0 && Object.keys(fieldBoundaries).length === 0) {
        showStatus('No local data to sync. Load data first.', false);
        return;
      }

      showStatus('Syncing to Google Sheets...', true);
      try {
        await SheetsAPI.initializeSheets();

        // NEVER clear data from Sheets - only append
        // This prevents data loss if local data fails to load properly
        // Users can manually clean up duplicates in Sheets if needed

        // Write clients
        if (clientsData.length > 0) {
          const clientRows = clientsData.map(c => [
            c.id,
            c.name,
            c.createdAt || new Date().toISOString(),
            new Date().toISOString()
          ]);
          try {
            await gapi.client.sheets.spreadsheets.values.append({
              spreadsheetId: CONFIG.SHEET_ID,
              range: 'Clients!A:D',
              valueInputOption: 'RAW',
              resource: { values: clientRows }
            });
          } catch (e) { console.warn('Could not sync Clients - tab may not exist'); }
        }

        // Write farms
        if (farmsData.length > 0) {
          const farmRows = farmsData.map(f => [
            f.id,
            f.clientId,
            f.name,
            f.createdAt || new Date().toISOString(),
            new Date().toISOString()
          ]);
          try {
            await gapi.client.sheets.spreadsheets.values.append({
              spreadsheetId: CONFIG.SHEET_ID,
              range: 'Farms!A:E',
              valueInputOption: 'RAW',
              resource: { values: farmRows }
            });
          } catch (e) { console.warn('Could not sync Farms - tab may not exist'); }
        }

        // Write fields (now includes farmId)
        if (Object.keys(fieldBoundaries).length > 0) {
          const fieldRows = Object.entries(fieldBoundaries).map(([name, fieldData]) => {
            // Handle both legacy format (array) and new format (object with boundary)
            const boundary = fieldData.boundary || fieldData;
            const farmId = fieldData.farmId || '';
            const acres = fieldData.acres || 0;
            return [
              Date.now().toString(36) + Math.random().toString(36).substr(2, 5),
              name,
              JSON.stringify(boundary),
              acres,
              farmId,
              new Date().toISOString()
            ];
          });
          await gapi.client.sheets.spreadsheets.values.append({
            spreadsheetId: CONFIG.SHEET_ID,
            range: 'Fields!A:F',
            valueInputOption: 'RAW',
            resource: { values: fieldRows }
          });
        }

        // Write samples
        if (sampleData.length > 0) {
          const headerRes = await gapi.client.sheets.spreadsheets.values.get({
            spreadsheetId: CONFIG.SHEET_ID,
            range: 'Samples!A1:ZZ1'
          });
          let headers = headerRes.result.values?.[0] || [];

          // Ensure required columns exist in headers
          let headersUpdated = false;
          if (!headers.includes('yieldCorrelations')) {
            headers.push('yieldCorrelations');
            headersUpdated = true;
            console.log('Added yieldCorrelations column to Sheet headers');
          }
          if (headersUpdated) {
            // Update header row to include new columns
            // Convert column index to letter (supports AA, AB, etc. for columns > 26)
            function colToLetter(col) {
              let letter = '';
              while (col >= 0) {
                letter = String.fromCharCode(65 + (col % 26)) + letter;
                col = Math.floor(col / 26) - 1;
              }
              return letter;
            }
            const lastCol = colToLetter(headers.length - 1);
            await gapi.client.sheets.spreadsheets.values.update({
              spreadsheetId: CONFIG.SHEET_ID,
              range: `Samples!A1:${lastCol}1`,
              valueInputOption: 'RAW',
              resource: { values: [headers] }
            });
          }

          // Debug: check how many samples have yield data
          const samplesWithYield = sampleData.filter(s => s.yieldCorrelations && Object.keys(s.yieldCorrelations).length > 0);
          console.log(`Syncing ${sampleData.length} samples, ${samplesWithYield.length} with yield data`);
          if (samplesWithYield.length > 0) {
            console.log('Sample yield data example:', JSON.stringify(samplesWithYield[0].yieldCorrelations));
          }

          const rows = sampleData.map(s => headers.map(h => {
            const v = s[h];
            if (v === undefined || v === null) return '';
            if (typeof v === 'object') return JSON.stringify(v);
            return v;
          }));

          await gapi.client.sheets.spreadsheets.values.append({
            spreadsheetId: CONFIG.SHEET_ID,
            range: 'Samples!A:ZZ',
            valueInputOption: 'RAW',
            resource: { values: rows }
          });
        }

        const samplesWithYield = sampleData.filter(s => s.yieldCorrelations && Object.keys(s.yieldCorrelations).length > 0).length;
        showStatus(`‚úì Synced ${clientsData.length} clients, ${farmsData.length} farms, ${Object.keys(fieldBoundaries).length} fields, ${sampleData.length} samples`, true);
      } catch (e) { showStatus('Sync error: ' + e.message, false); console.error(e); }
    }

    async function loadFromSheets() {
      if (!SheetsAPI.isSignedIn) { showStatus('Please sign in first', false); return; }
      if (!CONFIG.SHEET_ID) { showStatus('No Google Sheet ID configured', false); return; }

      showStatus('Loading from Google Sheets...', true);
      try {
        let loadedClients = 0, loadedFarms = 0, loadedFields = 0, loadedSamples = 0;

        // Load Clients
        try {
          const clientsRes = await gapi.client.sheets.spreadsheets.values.get({
            spreadsheetId: CONFIG.SHEET_ID, range: 'Clients!A2:D1000'
          });
          if (clientsRes.result.values && clientsRes.result.values.length > 0) {
            clientsData = clientsRes.result.values.map(row => ({
              id: row[0] || '',
              name: row[1] || '',
              createdAt: row[2] || '',
              updatedAt: row[3] || ''
            })).filter(c => c.id && c.name);
            loadedClients = clientsData.length;
            localStorage.setItem('clientsData', JSON.stringify(clientsData));
          }
        } catch (e) { console.warn('Could not load Clients:', e); }

        // Load Farms
        try {
          const farmsRes = await gapi.client.sheets.spreadsheets.values.get({
            spreadsheetId: CONFIG.SHEET_ID, range: 'Farms!A2:E1000'
          });
          if (farmsRes.result.values && farmsRes.result.values.length > 0) {
            farmsData = farmsRes.result.values.map(row => ({
              id: row[0] || '',
              clientId: row[1] || '',
              name: row[2] || '',
              createdAt: row[3] || '',
              updatedAt: row[4] || ''
            })).filter(f => f.id && f.name);
            loadedFarms = farmsData.length;
            localStorage.setItem('farmsData', JSON.stringify(farmsData));
          }
        } catch (e) { console.warn('Could not load Farms:', e); }

        // Load Fields
        try {
          const fieldsRes = await gapi.client.sheets.spreadsheets.values.get({
            spreadsheetId: CONFIG.SHEET_ID, range: 'Fields!A2:F10000'
          });
          if (fieldsRes.result.values && fieldsRes.result.values.length > 0) {
            fieldBoundaries = {};
            fieldsRes.result.values.forEach(row => {
              const name = row[1];
              if (name) {
                try {
                  const boundary = JSON.parse(row[2] || '[]');
                  fieldBoundaries[name] = {
                    boundary: boundary.boundary || boundary, // Handle both formats
                    acres: parseFloat(row[3]) || 0,
                    farmId: row[4] || '',
                    createdAt: row[5] || ''
                  };
                  loadedFields++;
                } catch (e) { console.warn('Could not parse field:', name); }
              }
            });
          }
        } catch (e) { console.warn('Could not load Fields:', e); }

        // Load Samples
        try {
          const samplesRes = await gapi.client.sheets.spreadsheets.values.get({
            spreadsheetId: CONFIG.SHEET_ID, range: 'Samples!A1:ZZ50000'
          });
          if (samplesRes.result.values && samplesRes.result.values.length > 1) {
            const headers = samplesRes.result.values[0];
            sampleData = samplesRes.result.values.slice(1).map(row => {
              const sample = {};
              headers.forEach((h, i) => {
                if (row[i] !== undefined && row[i] !== '') {
                  // Try to parse as number for numeric fields
                  if (['lat', 'lon', 'year', 'pH', 'P', 'P2', 'K', 'OM', 'CEC', 'Ca_sat', 'Mg_sat', 'K_Sat', 'H_Sat', 'Na_Sat', 'Zn', 'Cu', 'Mn', 'Fe', 'Boron', 'S', 'Buffer_pH', 'Na', 'Ca', 'Mg', 'NO3', 'NH4', 'Soluble_Salts', 'EC', 'P_Zn_Ratio'].includes(h)) {
                    const num = parseFloat(row[i]);
                    sample[h] = isNaN(num) ? row[i] : num;
                  } else if (h === 'yieldCorrelations' && row[i]) {
                    try { sample[h] = JSON.parse(row[i]); } catch (e) { sample[h] = {}; }
                  } else {
                    sample[h] = row[i];
                  }
                }
              });
              return sample;
            }).filter(s => s.lat && s.lon);
            loadedSamples = sampleData.length;

            // Auto-calculate P_Zn_Ratio for samples that have P and Zn but no ratio
            let calculatedRatios = 0;
            sampleData.forEach(s => {
              if ((s.P_Zn_Ratio === undefined || s.P_Zn_Ratio === null) && s.P !== undefined && s.Zn !== undefined && s.Zn > 0) {
                s.P_Zn_Ratio = s.P / s.Zn;
                calculatedRatios++;
              }
            });
            if (calculatedRatios > 0) {
              console.log(`Auto-calculated P_Zn_Ratio for ${calculatedRatios} samples`);
            }
          }
        } catch (e) { console.warn('Could not load Samples:', e); }

        // Save to local storage/IndexedDB
        await saveLocalData();
        await saveToIndexedDB();

        // Refresh UI
        updateSummary();
        refreshFieldTable();
        populateBoundaryClientFarmSelectors();

        showStatus(`‚úì Loaded from Sheets: ${loadedClients} clients, ${loadedFarms} farms, ${loadedFields} fields, ${loadedSamples} samples`, true);
      } catch (e) {
        showStatus('Load error: ' + e.message, false);
        console.error(e);
      }
    }

    async function clearSamples() {
      if (!confirm('Clear all samples? Boundaries will be kept.')) return;

      sampleData = [];
      await saveLocalData();
      saveBackup();
      updateSummary();
      updateBackupStatus();

      if (SheetsAPI.isSignedIn) {
        showStatus('Clearing from Google Sheets...', true);
        try {
          await clearSheetsData('Samples');
          showStatus('‚úì Samples cleared', true);
        } catch (e) {
          showStatus('Local cleared, but Sheets error: ' + e.message, false);
        }
      } else {
        showStatus('‚úì Samples cleared', true);
      }
    }

    async function clearBoundaries() {
      if (!confirm('Clear all field boundaries? Samples will be kept.')) return;

      fieldBoundaries = {};
      await saveLocalData();
      saveBackup();
      updateSummary();
      updateBackupStatus();

      if (SheetsAPI.isSignedIn) {
        showStatus('Clearing from Google Sheets...', true);
        try {
          await clearSheetsData('Fields');
          showStatus('‚úì Boundaries cleared', true);
        } catch (e) {
          showStatus('Local cleared, but Sheets error: ' + e.message, false);
        }
      } else {
        showStatus('‚úì Boundaries cleared', true);
      }
    }

    async function clearYieldData() {
      if (!confirm('Clear all yield correlations from samples?')) return;

      // Remove yield correlations from all samples
      sampleData.forEach(s => {
        if (s.yieldCorrelations) delete s.yieldCorrelations;
      });

      await saveLocalData();
      saveBackup();
      updateSummary();
      updateBackupStatus();
      showStatus('‚úì Yield correlations cleared', true);
    }

    async function clearAllData() {
      if (!confirm('Clear ALL data (samples, boundaries, and yield)?')) return;

      sampleData = [];
      fieldBoundaries = {};
      await saveLocalData();
      saveBackup();
      updateSummary();
      updateBackupStatus();

      if (SheetsAPI.isSignedIn) {
        showStatus('Clearing from Google Sheets...', true);
        try {
          await clearSheetsData('Samples');
          await clearSheetsData('Fields');
          showStatus('‚úì All data cleared', true);
        } catch (e) {
          showStatus('Local cleared, but Sheets error: ' + e.message, false);
        }
      } else {
        showStatus('‚úì All data cleared', true);
      }
    }
    
    async function clearSheetsData(sheetName) {
      // Get the last row with data
      const response = await gapi.client.sheets.spreadsheets.values.get({
        spreadsheetId: CONFIG.SHEET_ID,
        range: `${sheetName}!A:A`
      });
      const numRows = response.result.values ? response.result.values.length : 1;
      
      if (numRows > 1) {
        // Clear all data rows (keep header row 1)
        await gapi.client.sheets.spreadsheets.values.clear({
          spreadsheetId: CONFIG.SHEET_ID,
          range: `${sheetName}!A2:ZZ${numRows}`
        });
      }
    }

    // ========== EXPORT FUNCTIONS ==========
    function getVisibleNutrients() {
      const saved = JSON.parse(localStorage.getItem('nutrientVisibility') || '{}');
      const defaultVisible = ['sampleId', 'pH', 'P_Zn_Ratio', 'P', 'K', 'OM', 'CEC', 'Ca_sat', 'Mg_sat', 'K_Sat', 'H_Sat', 'Zn', 'Cu', 'Mn', 'Fe', 'Boron', 'S', 'Buffer_pH'];
      const allNutrients = ['sampleId', 'pH', 'P_Zn_Ratio', 'P', 'K', 'OM', 'CEC', 'Ca_sat', 'Mg_sat', 'K_Sat', 'H_Sat', 'Zn', 'Cu', 'Mn', 'Fe', 'Boron', 'S', 'Buffer_pH', 'P2', 'Na_Sat', 'Na', 'Ca', 'Mg', 'NO3', 'NH4', 'Soluble_Salts', 'EC'];
      return allNutrients.filter(n => saved[n] !== undefined ? saved[n] : defaultVisible.includes(n));
    }

    function exportToCSV() {
      if (sampleData.length === 0) {
        showStatus('No sample data to export', false);
        return;
      }

      const visibleNutrients = getVisibleNutrients();
      const operationName = localStorage.getItem('operationName') || 'SoilData';

      // Build headers: base fields + visible nutrients + yield columns
      const headers = ['Field', 'Year', 'Lat', 'Lon', 'Depth', ...visibleNutrients, 'Yield_Year', 'Yield_Avg', 'Yield_Crop', 'Yield_Points'];

      // Build rows
      const rows = sampleData.map(sample => {
        const row = [
          sample.field || '',
          sample.year || '',
          sample.lat || '',
          sample.lon || '',
          sample.depth || '',
          ...visibleNutrients.map(n => sample[n] !== undefined ? sample[n] : ''),
        ];

        // Add yield data if available
        if (sample.yieldCorrelations && Object.keys(sample.yieldCorrelations).length > 0) {
          const yieldYears = Object.keys(sample.yieldCorrelations);
          const latestYear = yieldYears.sort().pop();
          const yieldInfo = sample.yieldCorrelations[latestYear];
          row.push(latestYear, yieldInfo.avgYield?.toFixed(1) || '', yieldInfo.crop || '', yieldInfo.pointCount || '');
        } else {
          row.push('', '', '', '');
        }

        return row;
      });

      // Create CSV content
      const csvContent = [headers, ...rows]
        .map(row => row.map(cell => {
          const str = String(cell);
          if (str.includes(',') || str.includes('"') || str.includes('\n')) {
            return '"' + str.replace(/"/g, '""') + '"';
          }
          return str;
        }).join(','))
        .join('\n');

      // Download
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = `${operationName}_samples_${new Date().toISOString().split('T')[0]}.csv`;
      link.click();

      showStatus(`‚úì Exported ${sampleData.length} samples to CSV`, true);
    }

    function exportToPDF() {
      if (sampleData.length === 0) {
        showStatus('No sample data to export', false);
        return;
      }

      const visibleNutrients = getVisibleNutrients();
      const operationName = localStorage.getItem('operationName') || 'Soil Analysis';
      const fields = [...new Set(sampleData.map(s => s.field))].filter(f => f);
      const years = [...new Set(sampleData.map(s => s.year))].filter(y => y).sort();

      // Create printable HTML
      const printWindow = window.open('', '_blank');
      printWindow.document.write(`
        <!DOCTYPE html>
        <html>
        <head>
          <title>${operationName} - Sample Data Report</title>
          <style>
            body { font-family: Arial, sans-serif; padding: 20px; font-size: 11px; }
            h1 { color: #1e293b; border-bottom: 2px solid #3b82f6; padding-bottom: 10px; }
            h2 { color: #334155; margin-top: 20px; }
            .summary { display: flex; gap: 20px; margin: 20px 0; }
            .summary-box { background: #f1f5f9; padding: 15px; border-radius: 8px; text-align: center; }
            .summary-box .number { font-size: 24px; font-weight: bold; color: #3b82f6; }
            .summary-box .label { color: #64748b; font-size: 12px; }
            table { width: 100%; border-collapse: collapse; margin: 15px 0; font-size: 10px; }
            th { background: #1e293b; color: white; padding: 8px 4px; text-align: left; }
            td { padding: 6px 4px; border-bottom: 1px solid #e2e8f0; }
            tr:nth-child(even) { background: #f8fafc; }
            .footer { margin-top: 30px; color: #94a3b8; font-size: 10px; text-align: center; }
            @media print { body { padding: 0; } }
          </style>
        </head>
        <body>
          <h1>${operationName} - Sample Data Report</h1>
          <p>Generated: ${new Date().toLocaleString()}</p>

          <div class="summary">
            <div class="summary-box"><div class="number">${sampleData.length}</div><div class="label">Total Samples</div></div>
            <div class="summary-box"><div class="number">${fields.length}</div><div class="label">Fields</div></div>
            <div class="summary-box"><div class="number">${years.join(', ') || 'N/A'}</div><div class="label">Years</div></div>
            <div class="summary-box"><div class="number">${sampleData.filter(s => s.yieldCorrelations && Object.keys(s.yieldCorrelations).length > 0).length}</div><div class="label">With Yield</div></div>
          </div>

          <h2>Sample Data</h2>
          <table>
            <thead>
              <tr>
                <th>Field</th>
                <th>Year</th>
                ${visibleNutrients.slice(0, 12).map(n => `<th>${n}</th>`).join('')}
                <th>Yield</th>
              </tr>
            </thead>
            <tbody>
              ${sampleData.map(s => `
                <tr>
                  <td>${s.field || ''}</td>
                  <td>${s.year || ''}</td>
                  ${visibleNutrients.slice(0, 12).map(n => `<td>${s[n] !== undefined ? (typeof s[n] === 'number' ? formatValue(s[n], n) : s[n]) : ''}</td>`).join('')}
                  <td>${s.yieldCorrelations ? Object.values(s.yieldCorrelations)[0]?.avgYield?.toFixed(0) || '' : ''}</td>
                </tr>
              `).join('')}
            </tbody>
          </table>

          <div class="footer">
            Soil Sample Analysis App ‚Ä¢ ${window.location.hostname}
          </div>
        </body>
        </html>
      `);
      printWindow.document.close();
      printWindow.print();

      showStatus('‚úì PDF report opened for printing', true);
    }

    // Use shared showStatus from Utils
    const showStatus = window.Utils.showStatus;

    function updateBackupFooter() {
      const backupTime = localStorage.getItem('soilDataBackupTime');
      const footer = document.getElementById('backupFooter');
      const buildDate = new Date(BUILD_DATE);
      const buildStr = buildDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) + ', ' +
                       buildDate.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
      const versionInfo = `App ${APP_VERSION} ‚Ä¢ Built: ${buildStr}`;
      const legalLinks = `<span style="margin: 0 0.5rem; color: #cbd5e1;">|</span> <a href="privacy-policy.html" style="color: #94a3b8; text-decoration: none;">Privacy</a> <span style="color: #cbd5e1;">¬∑</span> <a href="terms-of-service.html" style="color: #94a3b8; text-decoration: none;">Terms</a>`;

      const sampleData = JSON.parse(localStorage.getItem('soilSamples') || '[]');

      if (backupTime) {
        const date = new Date(parseInt(backupTime));
        const backupStr = date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
        footer.innerHTML = `${versionInfo} <span style="margin: 0 0.5rem; color: #cbd5e1;">|</span> <span style="color: #22c55e;">Data backup: ${backupStr}</span>${legalLinks}`;
      } else if (sampleData.length === 0) {
        // No data yet - don't show backup warning
        footer.innerHTML = versionInfo + legalLinks;
      } else {
        // Has data but no backup - show warning
        footer.innerHTML = `${versionInfo} <span style="margin: 0 0.5rem; color: #cbd5e1;">|</span> <span style="color: #f59e0b;">No backup yet</span>${legalLinks}`;
      }
    }

    // ========== DATA QUALITY / OUTLIER DETECTION ==========
    let detectedOutliers = [];

    function toggleOutlierThresholds() {
      const panel = document.getElementById('outlierThresholds');
      const icon = document.getElementById('thresholdToggleIcon');
      if (panel.style.display === 'none') {
        panel.style.display = 'block';
        icon.textContent = '‚ñº';
        loadOutlierThresholds();
      } else {
        panel.style.display = 'none';
        icon.textContent = '‚ñ∂';
      }
    }

    function loadOutlierThresholds() {
      const saved = localStorage.getItem('outlierThresholds');
      if (saved) {
        const thresholds = JSON.parse(saved);
        // Corn thresholds
        if (thresholds.cornMin) document.getElementById('outlierCornMin').value = thresholds.cornMin;
        if (thresholds.cornMax) document.getElementById('outlierCornMax').value = thresholds.cornMax;
        // Soybean thresholds
        if (thresholds.soyMin) document.getElementById('outlierSoyMin').value = thresholds.soyMin;
        if (thresholds.soyMax) document.getElementById('outlierSoyMax').value = thresholds.soyMax;
        if (thresholds.pHMin) document.getElementById('outlierPHMin').value = thresholds.pHMin;
        if (thresholds.pHMax) document.getElementById('outlierPHMax').value = thresholds.pHMax;
        if (thresholds.pMax) document.getElementById('outlierPMax').value = thresholds.pMax;
        if (thresholds.kMax) document.getElementById('outlierKMax').value = thresholds.kMax;
        if (thresholds.cecMax) document.getElementById('outlierCECMax').value = thresholds.cecMax;
        if (thresholds.omMax) document.getElementById('outlierOMMax').value = thresholds.omMax;
      }
    }

    function saveOutlierThresholds() {
      const thresholds = {
        cornMin: parseFloat(document.getElementById('outlierCornMin').value),
        cornMax: parseFloat(document.getElementById('outlierCornMax').value),
        soyMin: parseFloat(document.getElementById('outlierSoyMin').value),
        soyMax: parseFloat(document.getElementById('outlierSoyMax').value),
        pHMin: parseFloat(document.getElementById('outlierPHMin').value),
        pHMax: parseFloat(document.getElementById('outlierPHMax').value),
        pMax: parseFloat(document.getElementById('outlierPMax').value),
        kMax: parseFloat(document.getElementById('outlierKMax').value),
        cecMax: parseFloat(document.getElementById('outlierCECMax').value),
        omMax: parseFloat(document.getElementById('outlierOMMax').value)
      };
      localStorage.setItem('outlierThresholds', JSON.stringify(thresholds));
      showStatus('‚úì Outlier thresholds saved', true);
    }

    function getOutlierThresholds() {
      const saved = localStorage.getItem('outlierThresholds');
      if (saved) return JSON.parse(saved);
      return {
        cornMin: 50, cornMax: 350,
        soyMin: 20, soyMax: 100,
        pHMin: 4.5, pHMax: 8.5,
        pMax: 300, kMax: 800, cecMax: 50, omMax: 15
      };
    }

    // Get yield thresholds for a specific crop
    function getYieldThresholdsForCrop(crop, thresholds) {
      const cropLower = (crop || '').toLowerCase();
      if (cropLower.includes('soy') || cropLower.includes('bean')) {
        return { min: thresholds.soyMin || 20, max: thresholds.soyMax || 100 };
      } else if (cropLower.includes('corn') || cropLower.includes('maize')) {
        return { min: thresholds.cornMin || 50, max: thresholds.cornMax || 350 };
      }
      // Default to corn thresholds for unknown crops
      return { min: thresholds.cornMin || 50, max: thresholds.cornMax || 350 };
    }

    async function scanForOutliers() {
      showStatus('Scanning for outliers...', true);
      detectedOutliers = [];
      const thresholds = getOutlierThresholds();

      // Make sure we have data loaded
      await loadLocalData();

      // Scan soil samples for nutrient outliers
      sampleData.forEach((sample, index) => {
        const field = sample.field || 'Unknown';
        const year = sample.year || 'N/A';
        const sampleId = sample.sampleId || sample.SAMPLE_ID || sample.sample_id || `#${index + 1}`;

        // pH check
        const pH = parseFloat(sample.pH);
        if (!isNaN(pH) && pH > 0) {
          if (pH < thresholds.pHMin) {
            detectedOutliers.push({
              type: 'sample',
              index,
              field,
              year,
              sampleId,
              dataType: 'Nutrient',
              issue: 'pH too low',
              value: pH.toFixed(2),
              attribute: 'pH'
            });
          } else if (pH > thresholds.pHMax) {
            detectedOutliers.push({
              type: 'sample',
              index,
              field,
              year,
              sampleId,
              dataType: 'Nutrient',
              issue: 'pH too high',
              value: pH.toFixed(2),
              attribute: 'pH'
            });
          }
        }

        // Phosphorus check
        const P = parseFloat(sample.P);
        if (!isNaN(P) && P > thresholds.pMax) {
          detectedOutliers.push({
            type: 'sample',
            index,
            field,
            year,
            sampleId,
            dataType: 'Nutrient',
            issue: 'P too high',
            value: P.toFixed(0) + ' ppm',
            attribute: 'P'
          });
        }

        // Potassium check
        const K = parseFloat(sample.K);
        if (!isNaN(K) && K > thresholds.kMax) {
          detectedOutliers.push({
            type: 'sample',
            index,
            field,
            year,
            sampleId,
            dataType: 'Nutrient',
            issue: 'K too high',
            value: K.toFixed(0) + ' ppm',
            attribute: 'K'
          });
        }

        // CEC check
        const CEC = parseFloat(sample.CEC);
        if (!isNaN(CEC) && CEC > thresholds.cecMax) {
          detectedOutliers.push({
            type: 'sample',
            index,
            field,
            year,
            sampleId,
            dataType: 'Nutrient',
            issue: 'CEC too high',
            value: CEC.toFixed(1),
            attribute: 'CEC'
          });
        }

        // OM check
        const OM = parseFloat(sample.OM);
        if (!isNaN(OM) && OM > thresholds.omMax) {
          detectedOutliers.push({
            type: 'sample',
            index,
            field,
            year,
            sampleId,
            dataType: 'Nutrient',
            issue: 'OM too high',
            value: OM.toFixed(2) + '%',
            attribute: 'OM'
          });
        }

        // Yield outlier checks (embedded in sample) - CROP-SPECIFIC
        if (sample.yieldInfo && Array.isArray(sample.yieldInfo)) {
          sample.yieldInfo.forEach((yi, yiIndex) => {
            const avgYield = yi.avgYield;
            if (!avgYield || avgYield <= 0) return;

            // Get crop-specific thresholds
            const cropThresholds = getYieldThresholdsForCrop(yi.crop, thresholds);

            // Raw yield range check with crop-specific limits
            if (avgYield < cropThresholds.min) {
              detectedOutliers.push({
                type: 'yield',
                sampleIndex: index,
                yieldIndex: yiIndex,
                field,
                year: yi.year || 'N/A',
                sampleId,
                dataType: `Yield (${yi.crop || 'unknown'})`,
                issue: `Yield too low (<${cropThresholds.min})`,
                value: avgYield.toFixed(1) + ' bu/ac',
                crop: yi.crop
              });
            } else if (avgYield > cropThresholds.max) {
              detectedOutliers.push({
                type: 'yield',
                sampleIndex: index,
                yieldIndex: yiIndex,
                field,
                year: yi.year || 'N/A',
                sampleId,
                dataType: `Yield (${yi.crop || 'unknown'})`,
                issue: `Yield too high (>${cropThresholds.max})`,
                value: avgYield.toFixed(1) + ' bu/ac',
                crop: yi.crop
              });
            }
          });
        }
      });

      // Display results
      displayOutlierResults();
      loadAuditLog();
    }

    // Scan for samples outside all field boundaries
    async function scanOrphanedSamples() {
      if (Object.keys(fieldBoundaries).length === 0) {
        showStatus('No field boundaries loaded. Import boundaries first.', false);
        return;
      }

      showStatus('Scanning for samples outside boundaries...', true);
      detectedOutliers = [];

      await loadLocalData();

      let orphanedCount = 0;

      sampleData.forEach((sample, index) => {
        if (!sample.lat || !sample.lon) return;

        let isInsideAnyBoundary = false;

        // Check if sample is inside any field boundary
        for (const [fieldName, fieldData] of Object.entries(fieldBoundaries)) {
          const polys = fieldData.boundary || fieldData;
          const polyArray = Array.isArray(polys[0]?.[0]) ? polys : [polys];
          for (const poly of polyArray) {
            if (isPointInOrNearPolygon([sample.lat, sample.lon], poly, 0)) {
              isInsideAnyBoundary = true;
              break;
            }
          }
          if (isInsideAnyBoundary) break;
        }

        if (!isInsideAnyBoundary) {
          orphanedCount++;
          detectedOutliers.push({
            type: 'sample',
            index,
            field: sample.field || 'Unassigned',
            year: sample.year || 'N/A',
            sampleId: sample.sampleId || sample.SAMPLE_ID || `#${index + 1}`,
            dataType: 'Outside Boundary',
            issue: 'Not inside any field',
            value: `${sample.lat.toFixed(5)}, ${sample.lon.toFixed(5)}`,
            attribute: 'location'
          });
        }
      });

      if (orphanedCount === 0) {
        showStatus('‚úì All samples are inside field boundaries!', true);
      } else {
        showStatus(`Found ${orphanedCount} samples outside boundaries`, true);
      }

      displayOrphanedResults();
      loadAuditLog();
    }

    function displayOrphanedResults() {
      const resultsDiv = document.getElementById('outlierResults');
      const summaryDiv = document.getElementById('outlierSummary');
      const tableBody = document.getElementById('outlierTableBody');

      if (detectedOutliers.length === 0) {
        resultsDiv.style.display = 'block';
        summaryDiv.innerHTML = '<div style="color: #166534; font-weight: 600;">‚úì All samples are inside field boundaries!</div>';
        tableBody.innerHTML = '';
        return;
      }

      summaryDiv.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 0.5rem;">
          <div>
            <span style="font-weight: 700; color: #7c3aed; font-size: 1.25rem;">üìç Found ${detectedOutliers.length} samples outside boundaries</span>
            <div style="font-size: 0.8rem; color: #64748b; margin-top: 0.25rem;">
              These samples are not inside any field boundary - possibly from fields no longer farmed or boundary changes.
            </div>
          </div>
          <div style="font-size: 0.75rem; color: #64748b;">
            Review and select items to delete
          </div>
        </div>
      `;

      // Build table rows
      tableBody.innerHTML = detectedOutliers.map((outlier, idx) => `
        <tr style="border-bottom: 1px solid #e9d5ff;">
          <td style="padding: 0.5rem;">
            <input type="checkbox" class="outlier-checkbox" data-index="${idx}" checked>
          </td>
          <td style="padding: 0.5rem;">${outlier.field}</td>
          <td style="padding: 0.5rem;">${outlier.year}</td>
          <td style="padding: 0.5rem;">
            <span style="padding: 0.125rem 0.375rem; border-radius: 0.25rem; font-size: 0.7rem; background: #f3e8ff; color: #7c3aed;">
              ${outlier.dataType}
            </span>
          </td>
          <td style="padding: 0.5rem; color: #7c3aed;">${outlier.issue}</td>
          <td style="padding: 0.5rem; font-family: monospace; font-size: 0.7rem;">${outlier.value}</td>
        </tr>
      `).join('');

      resultsDiv.style.display = 'block';
    }

    function displayOutlierResults() {
      const resultsDiv = document.getElementById('outlierResults');
      const summaryDiv = document.getElementById('outlierSummary');
      const tableBody = document.getElementById('outlierTableBody');

      if (detectedOutliers.length === 0) {
        resultsDiv.style.display = 'block';
        summaryDiv.innerHTML = '<div style="color: #166534; font-weight: 600;">‚úì No outliers detected! Your data looks clean.</div>';
        tableBody.innerHTML = '';
        return;
      }

      // Count by type
      const nutrientCount = detectedOutliers.filter(o => o.dataType === 'Nutrient').length;
      const yieldCount = detectedOutliers.filter(o => o.dataType.startsWith('Yield')).length;

      summaryDiv.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 0.5rem;">
          <div>
            <span style="font-weight: 700; color: #dc2626; font-size: 1.25rem;">‚ö†Ô∏è Found ${detectedOutliers.length} potential outliers</span>
            <div style="font-size: 0.8rem; color: #64748b; margin-top: 0.25rem;">
              ${nutrientCount} nutrient issues ‚Ä¢ ${yieldCount} yield issues
            </div>
          </div>
          <div style="font-size: 0.75rem; color: #64748b;">
            Review and select items to delete
          </div>
        </div>
      `;

      // Build table rows
      tableBody.innerHTML = detectedOutliers.map((outlier, idx) => `
        <tr style="border-bottom: 1px solid #fecaca;">
          <td style="padding: 0.5rem;">
            <input type="checkbox" class="outlier-checkbox" data-index="${idx}" checked>
          </td>
          <td style="padding: 0.5rem;">${outlier.field}</td>
          <td style="padding: 0.5rem;">${outlier.year}</td>
          <td style="padding: 0.5rem;">
            <span style="padding: 0.125rem 0.375rem; border-radius: 0.25rem; font-size: 0.7rem; background: ${outlier.dataType === 'Nutrient' ? '#dbeafe' : '#fef3c7'}; color: ${outlier.dataType === 'Nutrient' ? '#1e40af' : '#92400e'};">
              ${outlier.dataType}
            </span>
          </td>
          <td style="padding: 0.5rem; color: #dc2626; font-weight: 500;">${outlier.issue}</td>
          <td style="padding: 0.5rem; font-family: monospace;">${outlier.value}</td>
        </tr>
      `).join('');

      resultsDiv.style.display = 'block';
      document.getElementById('selectAllOutliers').checked = true;

      showStatus(`Found ${detectedOutliers.length} potential outliers`, true);
    }

    function toggleAllOutliers(checked) {
      document.querySelectorAll('.outlier-checkbox').forEach(cb => cb.checked = checked);
    }

    function selectAllOutliersBtn() {
      toggleAllOutliers(true);
      document.getElementById('selectAllOutliers').checked = true;
    }

    function selectNoneOutliersBtn() {
      toggleAllOutliers(false);
      document.getElementById('selectAllOutliers').checked = false;
    }

    async function deleteSelectedOutliers() {
      const checkboxes = document.querySelectorAll('.outlier-checkbox:checked');
      const selectedIndices = Array.from(checkboxes).map(cb => parseInt(cb.dataset.index));

      if (selectedIndices.length === 0) {
        showStatus('No outliers selected for deletion', false);
        return;
      }

      // Confirmation dialog
      const confirmMsg = `Permanently delete ${selectedIndices.length} data point(s)?\n\nThis cannot be undone!`;
      if (!confirm(confirmMsg)) {
        return;
      }

      // Group by type and gather info for audit log
      const toDelete = selectedIndices.map(i => detectedOutliers[i]);
      const nutrientDeletes = toDelete.filter(o => o.type === 'sample');
      const yieldDeletes = toDelete.filter(o => o.type === 'yield');

      // Track what we're deleting for the audit log
      const deletionSummary = {
        date: new Date().toISOString(),
        total: toDelete.length,
        nutrients: nutrientDeletes.length,
        yields: yieldDeletes.length,
        details: toDelete.map(o => ({
          field: o.field,
          year: o.year,
          issue: o.issue,
          value: o.value
        }))
      };

      // Delete yield data from samples (remove specific yieldInfo entries)
      // We need to process in reverse order to maintain correct indices
      const yieldDeletesByExample = {};
      yieldDeletes.forEach(yd => {
        const key = yd.sampleIndex;
        if (!yieldDeletesByExample[key]) yieldDeletesByExample[key] = [];
        yieldDeletesByExample[key].push(yd.yieldIndex);
      });

      Object.keys(yieldDeletesByExample).forEach(sampleIndex => {
        const indices = yieldDeletesByExample[sampleIndex].sort((a, b) => b - a); // reverse order
        const sample = sampleData[parseInt(sampleIndex)];
        if (sample && sample.yieldInfo) {
          indices.forEach(yi => {
            sample.yieldInfo.splice(yi, 1);
          });
          // If no yield data left, remove the yieldInfo array
          if (sample.yieldInfo.length === 0) {
            delete sample.yieldInfo;
          }
        }
      });

      // Delete entire sample records for nutrient outliers
      // Get unique sample indices to delete (sorted in reverse to maintain indices)
      const sampleIndicesToDelete = [...new Set(nutrientDeletes.map(o => o.index))].sort((a, b) => b - a);
      sampleIndicesToDelete.forEach(idx => {
        sampleData.splice(idx, 1);
      });

      // Save updated data
      await saveLocalData();
      await saveToIndexedDB();

      // Add to audit log
      addAuditLogEntry(deletionSummary);

      // Update UI
      updateSummary();
      detectedOutliers = [];
      document.getElementById('outlierResults').style.display = 'none';

      showStatus(`‚úì Deleted ${selectedIndices.length} outlier(s)`, true);

      // Reload audit log display
      loadAuditLog();
    }

    function addAuditLogEntry(entry) {
      const log = JSON.parse(localStorage.getItem('outlierAuditLog') || '[]');
      log.unshift(entry); // Add to beginning
      // Keep only last 50 entries
      if (log.length > 50) log.length = 50;
      localStorage.setItem('outlierAuditLog', JSON.stringify(log));
    }

    function loadAuditLog() {
      const logDiv = document.getElementById('outlierAuditLog');
      const contentDiv = document.getElementById('auditLogContent');
      const log = JSON.parse(localStorage.getItem('outlierAuditLog') || '[]');

      if (log.length === 0) {
        logDiv.style.display = 'none';
        return;
      }

      logDiv.style.display = 'block';
      contentDiv.innerHTML = log.map(entry => {
        const date = new Date(entry.date);
        const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
        const timeStr = date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
        return `<div style="padding: 0.375rem 0; border-bottom: 1px dashed #fcd34d;">
          <strong>${dateStr} ${timeStr}:</strong> Removed ${entry.total} outliers (${entry.nutrients} nutrient, ${entry.yields} yield)
        </div>`;
      }).join('');
    }

    // Load audit log on page load
    setTimeout(loadAuditLog, 500);

    // ============================================
    // CSV Import with Column Mapping
    // ============================================

    let csvParsedData = null; // Store parsed CSV rows
    let csvHeaders = [];      // Store CSV column headers
    let csvMappings = {};     // Current column mappings

    // Shapefile mapping state
    let shpParsedFeatures = [];  // Raw GeoJSON features from shapefile
    let shpAttributes = [];      // List of attribute names in shapefile
    let shpMappings = {};        // Current attribute mappings
    let shpYear = null;          // Year from form
    let shpDepth = null;         // Depth from form

    // Toggle between shapefile and CSV import options
    function selectImportType(type) {
      const shapefileBox = document.getElementById('shapefileImportBox');
      const csvBox = document.getElementById('csvImportBox');
      const shapefilePanel = document.getElementById('shapefileImportPanel');
      const csvPanel = document.getElementById('csvImportPanel');

      if (type === 'shapefile') {
        shapefileBox.style.border = '2px solid #3b82f6';
        shapefileBox.style.background = '#eff6ff';
        csvBox.style.border = '2px solid #e2e8f0';
        csvBox.style.background = '#f8fafc';
        shapefilePanel.style.display = 'block';
        csvPanel.style.display = 'none';
        document.getElementById('importTypeShapefile').checked = true;
      } else {
        csvBox.style.border = '2px solid #8b5cf6';
        csvBox.style.background = '#faf5ff';
        shapefileBox.style.border = '2px solid #e2e8f0';
        shapefileBox.style.background = '#f8fafc';
        csvPanel.style.display = 'block';
        shapefilePanel.style.display = 'none';
        document.getElementById('importTypeCSV').checked = true;
        loadSavedMappings();
      }
    }

    // Handle CSV file selection
    document.getElementById('csvSampleFile').addEventListener('change', async function(e) {
      const file = e.target.files[0];
      if (!file) return;

      try {
        const text = await file.text();
        const result = parseCSVRaw(text);
        csvHeaders = result.headers;
        csvParsedData = result.rows;

        // Show file info
        document.getElementById('csvFileInfo').style.display = 'block';
        document.getElementById('csvFileName').textContent = file.name;
        document.getElementById('csvRowCount').textContent = `${csvParsedData.length} rows, ${csvHeaders.length} columns`;

        // Show detected columns
        const colList = document.getElementById('csvColumnList');
        if (colList) {
          colList.innerHTML = `<strong>Detected columns:</strong> ${csvHeaders.map(h => `<code style="background:#e2e8f0;padding:0.125rem 0.375rem;border-radius:0.25rem;margin:0.125rem;display:inline-block;">${h}</code>`).join(' ')}`;
          colList.style.display = 'block';
        }

        // Enable mapping button
        document.getElementById('openCsvMappingBtn').disabled = false;

        console.log('CSV loaded:', file.name, '- Columns:', csvHeaders);

      } catch (err) {
        showStatus('Error reading CSV: ' + err.message, false);
        console.error('CSV parse error:', err);
      }
    });

    // Parse CSV without applying mappings - just raw data
    function parseCSVRaw(text) {
      // Remove BOM (Byte Order Mark) if present - common in Excel CSVs
      if (text.charCodeAt(0) === 0xFEFF) {
        text = text.slice(1);
        console.log('CSV: Removed BOM from file');
      }

      // Normalize line endings and split
      const lines = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n').trim().split('\n');
      if (lines.length < 2) return { headers: [], rows: [] };

      // DEBUG: Show raw header line
      console.log('=== CSV DEBUG ===');
      console.log('Raw header line:', lines[0]);
      console.log('Header line length:', lines[0].length);
      console.log('First 10 char codes:', [...lines[0].substring(0, 10)].map(c => c.charCodeAt(0)));

      // Detect delimiter (comma, semicolon, or tab)
      const commaCount = (lines[0].match(/,/g) || []).length;
      const semicolonCount = (lines[0].match(/;/g) || []).length;
      const tabCount = (lines[0].match(/\t/g) || []).length;
      console.log('Delimiter counts - comma:', commaCount, 'semicolon:', semicolonCount, 'tab:', tabCount);

      // Use most common delimiter
      let delimiter = ',';
      if (semicolonCount > commaCount && semicolonCount > tabCount) delimiter = ';';
      if (tabCount > commaCount && tabCount > semicolonCount) delimiter = '\t';
      console.log('Using delimiter:', delimiter === '\t' ? 'TAB' : delimiter);

      // Handle quoted values properly - use detected delimiter
      function parseLine(line) {
        const result = [];
        let current = '';
        let inQuotes = false;

        for (let i = 0; i < line.length; i++) {
          const char = line[i];
          if (char === '"') {
            inQuotes = !inQuotes;
          } else if (char === delimiter && !inQuotes) {
            result.push(current);
            current = '';
          } else {
            current += char;
          }
        }
        result.push(current);
        return result;
      }

      // Parse headers - trim whitespace and quotes, filter empty
      const rawHeaders = parseLine(lines[0]);
      console.log('Raw headers after split:', rawHeaders);
      console.log('Raw headers count:', rawHeaders.length);
      const headers = rawHeaders
        .map(h => h.trim().replace(/^"|"$/g, '').trim())  // Remove quotes and trim
        .filter(h => h.length > 0);  // Remove empty headers

      console.log('CSV Headers detected:', headers);
      console.log('CSV Headers count:', headers.length);

      const rows = [];

      for (let i = 1; i < lines.length; i++) {
        const values = parseLine(lines[i]);
        if (values.length > 0 && values.some(v => v && v.trim())) { // Skip empty rows
          const row = {};
          headers.forEach((h, idx) => {
            const val = values[idx] || '';
            row[h] = val.trim().replace(/^"|"$/g, '');  // Trim and remove quotes
          });
          rows.push(row);
        }
      }

      return { headers, rows };
    }

    // Open CSV mapping modal
    document.getElementById('openCsvMappingBtn').addEventListener('click', function() {
      if (!csvHeaders.length) {
        showStatus('Please select a CSV file first', false);
        return;
      }

      populateCsvMappingDropdowns();

      // Check if a saved mapping is selected
      const savedMappingName = document.getElementById('savedMappingSelect').value;
      if (savedMappingName) {
        applySavedMapping(savedMappingName);
      } else {
        autoMapColumns();
      }

      // Reset to step 1
      document.getElementById('csvMappingStep1').style.display = 'block';
      document.getElementById('csvMappingStep2').style.display = 'none';
      document.getElementById('csvStep1Tab').style.borderBottom = '3px solid #8b5cf6';
      document.getElementById('csvStep1Tab').style.color = '#7c3aed';
      document.getElementById('csvStep2Tab').style.borderBottom = 'none';
      document.getElementById('csvStep2Tab').style.color = '#94a3b8';
      document.getElementById('csvBackBtn').style.display = 'none';
      document.getElementById('csvNextBtn').style.display = 'inline-block';
      document.getElementById('csvImportBtn').style.display = 'none';

      document.getElementById('csvMappingModal').style.display = 'flex';
    });

    // Populate dropdowns with CSV headers
    function populateCsvMappingDropdowns() {
      // HTML escape function for safe display
      function escapeHtml(str) {
        return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
      }

      console.log('CSV Column Mapping - Headers detected:', csvHeaders);
      console.log('Total columns:', csvHeaders.length);

      const options = '<option value="">(skip)</option>' +
        csvHeaders.map(h => `<option value="${escapeHtml(h)}">${escapeHtml(h)}</option>`).join('');

      // Required fields - now including Year and Depth
      document.getElementById('csvMapLat').innerHTML = options;
      document.getElementById('csvMapLon').innerHTML = options;
      document.getElementById('csvMapSampleId').innerHTML = options;
      document.getElementById('csvMapField').innerHTML = options;
      document.getElementById('csvMapYear').innerHTML = options;
      document.getElementById('csvMapDepth').innerHTML = options;

      console.log('Dropdown populated with', csvHeaders.length + 1, 'options (including skip)');

      // Nutrient fields - get all standard fields
      const nutrientContainer = document.getElementById('csvNutrientMappings');
      nutrientContainer.innerHTML = '';

      const nutrients = ['pH', 'Buffer_pH', 'P', 'K', 'OM', 'CEC', 'Ca', 'Mg', 'Na', 'S', 'Zn', 'Cu', 'Mn', 'Fe', 'Boron', 'Ca_sat', 'Mg_sat', 'K_Sat', 'H_Sat', 'Na_Sat', 'NO3', 'NH4', 'Soluble_Salts', 'EC', 'P2'];

      nutrients.forEach(nutrient => {
        const div = document.createElement('div');
        div.className = 'csv-mapping-field';
        div.innerHTML = `
          <label style="font-size: 0.8rem; font-weight: 600; color: #166534;">${nutrient}</label>
          <div style="display: flex; gap: 0.5rem; align-items: center;">
            <select id="csvMap${nutrient}" class="csv-map-select" style="flex: 1;" onchange="updateCsvPreview('${nutrient}')">${options}</select>
            <span id="csvPreview${nutrient}" class="shp-preview-values"></span>
          </div>
        `;
        nutrientContainer.appendChild(div);
      });
    }

    // Update preview values when dropdown selection changes
    function updateCsvPreview(fieldName) {
      const selectId = `csvMap${fieldName}`;
      const previewId = `csvPreview${fieldName}`;

      const select = document.getElementById(selectId);
      const preview = document.getElementById(previewId);
      if (!select || !preview) return;

      const colName = select.value;
      if (!colName) {
        preview.textContent = '';
        preview.title = '';
        return;
      }

      // Get sample values from first few rows
      const values = csvParsedData.slice(0, 3)
        .map(row => row[colName])
        .filter(v => v !== null && v !== undefined && v !== '')
        .map(v => {
          const num = parseFloat(v);
          return !isNaN(num) ? num.toFixed(1) : String(v).substring(0, 15);
        });

      if (values.length > 0) {
        preview.textContent = values.join(', ') + '...';
        preview.title = `Sample values: ${values.join(', ')}`;
      } else {
        preview.textContent = '(empty)';
        preview.title = 'No values found';
      }
    }

    // Update all previews after auto-mapping
    function updateAllCsvPreviews() {
      const fields = ['Lat', 'Lon', 'SampleId', 'Field', 'Year', 'Depth', 'pH', 'Buffer_pH', 'P', 'K', 'OM', 'CEC', 'Ca', 'Mg', 'Na', 'S', 'Zn', 'Cu', 'Mn', 'Fe', 'Boron', 'Ca_sat', 'Mg_sat', 'K_Sat', 'H_Sat', 'Na_Sat', 'NO3', 'NH4', 'Soluble_Salts', 'EC', 'P2'];
      fields.forEach(f => updateCsvPreview(f));
    }

    // Auto-map columns using aliases
    function autoMapColumns() {
      const aliases = getAliases();

      // Location aliases
      const latAliases = ['lat', 'latitude', 'y', 'point_y', 'lat_wgs84', 'pt_lat', 'latitud'];
      const lonAliases = ['lon', 'lng', 'longitude', 'x', 'point_x', 'long', 'lon_wgs84', 'pt_lon', 'longitud'];
      const idAliases = ['sampleid', 'sample_id', 'id', 'pointid', 'point_id', 'fid', 'sample id', 'lab #', 'labid', 'lab_id', 'sample #', 'sample number'];
      const fieldAliases = ['field', 'fieldname', 'field_name', 'farm', 'farmname', 'name', 'field name', 'grower'];
      const yearAliases = ['year', 'sample_year', 'sampleyear', 'crop_year', 'cropyear', 'sample year', 'yr'];
      const depthAliases = ['depth', 'sample_depth', 'sampledepth', 'sample depth', 'depth_in', 'depthrange'];

      // Find exact match first, then partial match
      function findMatch(aliasList, requireExact = false) {
        // Exact match
        for (const header of csvHeaders) {
          const h = header.toLowerCase().trim();
          if (aliasList.includes(h)) return header;
        }
        // Partial match (header contains alias)
        if (!requireExact) {
          for (const header of csvHeaders) {
            const h = header.toLowerCase().trim();
            for (const alias of aliasList) {
              if (h.includes(alias) || alias.includes(h)) return header;
            }
          }
        }
        return '';
      }

      // Map required fields
      document.getElementById('csvMapLat').value = findMatch(latAliases);
      document.getElementById('csvMapLon').value = findMatch(lonAliases);
      document.getElementById('csvMapSampleId').value = findMatch(idAliases);
      document.getElementById('csvMapField').value = findMatch(fieldAliases);
      document.getElementById('csvMapYear').value = findMatch(yearAliases);
      document.getElementById('csvMapDepth').value = findMatch(depthAliases);

      // Extended aliases for common lab formats (Midwest Labs, Ward Labs, AgSource, etc.)
      const labAliases = {
        'pH': ['ph', 'wph', 'water ph', 'soil ph', '1:1 ph', 'ph 1:1', 'ph_1_1', 'soil_ph', 'ph water'],
        'Buffer_pH': ['bph', 'buffer ph', 'buffer_ph', 'sikora', 'smp', 'buffer', 'bph_sikora'],
        'P': ['p', 'bray p1', 'bray p-1', 'mehlich p', 'olsen p', 'p1', 'p (m3)', 'phosphorus', 'p_m3', 'bray-1 p', 'bray1', 'p ppm'],
        'P2': ['p2', 'bray p2', 'bray-2 p', 'p-2', 'bray2'],
        'K': ['k', 'aa k', 'potassium', 'k (m3)', 'mehlich k', 'exch k', 'k_m3', 'k ppm'],
        'OM': ['om', 'om (loi)', 'organic matter', 'om%', 'o.m.', 'loi', 'soil om', 'organic', 'soil om(%)'],
        'CEC': ['cec', 'c.e.c.', 'cation exchange', 'cec meq'],
        'Ca': ['ca', 'aa ca', 'calcium', 'ca ppm'],
        'Mg': ['mg', 'aa mg', 'magnesium', 'mg ppm'],
        'Na': ['na', 'aa na', 'sodium', 'na ppm'],
        'S': ['s', 'sulfur', 'so4-s', 'sulfate', 's ppm', 'so4'],
        'Zn': ['zn', 'dtpa-zn', 'zinc', 'zn ppm'],
        'Mn': ['mn', 'dtpa-mn', 'manganese', 'mn ppm'],
        'Fe': ['fe', 'dtpa-fe', 'iron', 'fe ppm'],
        'Cu': ['cu', 'dtpa-cu', 'copper', 'cu ppm'],
        'Boron': ['b', 'dtpa-b', 'boron', 'hot water b', 'b ppm'],
        'Ca_sat': ['ca sat %', 'ca sat', 'ca%', 'ca base sat', '%ca', 'ca_sat', 'ca%bs', '%ca sat', 'ca bs', 'casat'],
        'Mg_sat': ['mg sat %', 'mg sat', 'mg%', 'mg base sat', '%mg', 'mg_sat', 'mg%bs', '%mg sat', 'mg bs', 'mgsat'],
        'K_Sat': ['k sat %', 'k sat', 'k%', 'k base sat', '%k', 'k_sat', 'k%bs', '%k sat', 'k bs', 'ksat'],
        'H_Sat': ['h sat %', 'h sat', 'h%', '%h', 'h_sat', 'h%bs', 'h bs', 'hsat', 'hydrogen'],
        'Na_Sat': ['na sat %', 'na sat', 'na%', '%na', 'na_sat', 'na%bs', 'na bs', 'nasat'],
        'NO3': ['no3-n (ppm)', 'no3-n', 'no3', 'nitrate', 'nitrate-n', 'no3n'],
        'NH4': ['nh4-n', 'nh4', 'ammonium', 'ammonium-n', 'nh4n'],
        'Soluble_Salts': ['soluble salts', 'salts', 'ss', 'soluble_salts', 'sol salts'],
        'EC': ['ec', 'electrical conductivity', 'e.c.', 'conductivity']
      };

      // Map nutrient fields using stored aliases + lab aliases
      const nutrients = ['pH', 'P', 'P2', 'K', 'OM', 'CEC', 'Ca_sat', 'Mg_sat', 'K_Sat', 'Zn', 'Cu', 'Mn', 'Fe', 'Boron', 'S', 'Buffer_pH', 'Na', 'Ca', 'Mg', 'NO3', 'NH4', 'Soluble_Salts', 'H_Sat', 'Na_Sat', 'EC'];

      nutrients.forEach(nutrient => {
        const select = document.getElementById(`csvMap${nutrient}`);
        if (!select) return;

        // Combine stored aliases with lab aliases
        const storedAliases = aliases[nutrient] || [];
        const defaultLabAliases = labAliases[nutrient] || [nutrient.toLowerCase()];
        const nutrientAliases = [...new Set([...storedAliases.map(a => a.toLowerCase()), ...defaultLabAliases])];
        let matched = '';

        // Exact match first
        for (const header of csvHeaders) {
          const h = header.toLowerCase().trim();
          for (const alias of nutrientAliases) {
            if (alias === h) {
              matched = header;
              break;
            }
          }
          if (matched) break;
        }

        // Partial match if no exact match
        if (!matched) {
          for (const header of csvHeaders) {
            const h = header.toLowerCase().trim();
            for (const alias of nutrientAliases) {
              // Check if header contains alias or alias contains header (for short field names)
              if (h.includes(alias) && alias.length >= 2) {
                matched = header;
                break;
              }
            }
            if (matched) break;
          }
        }

        if (matched) select.value = matched;
      });

      // Update all previews after auto-mapping
      updateAllCsvPreviews();

      console.log('Auto-mapping complete. Mapped columns:', {
        lat: document.getElementById('csvMapLat').value,
        lon: document.getElementById('csvMapLon').value,
        field: document.getElementById('csvMapField').value,
        year: document.getElementById('csvMapYear').value
      });
    }

    // Close CSV mapping modal
    function closeCsvMappingModal() {
      document.getElementById('csvMappingModal').style.display = 'none';
    }

    // Go to step 2 (preview)
    function csvMappingNext() {
      // Validate required fields
      const lat = document.getElementById('csvMapLat').value;
      const lon = document.getElementById('csvMapLon').value;

      if (!lat || !lon) {
        showStatus('Latitude and Longitude are required', false);
        return;
      }

      // Generate preview
      generateCsvPreview();

      // Switch to step 2
      document.getElementById('csvMappingStep1').style.display = 'none';
      document.getElementById('csvMappingStep2').style.display = 'block';
      document.getElementById('csvStep1Tab').style.borderBottom = 'none';
      document.getElementById('csvStep1Tab').style.color = '#94a3b8';
      document.getElementById('csvStep2Tab').style.borderBottom = '3px solid #8b5cf6';
      document.getElementById('csvStep2Tab').style.color = '#7c3aed';
      document.getElementById('csvBackBtn').style.display = 'inline-block';
      document.getElementById('csvNextBtn').style.display = 'none';
      document.getElementById('csvImportBtn').style.display = 'inline-block';
    }

    // Go back to step 1
    function csvMappingBack() {
      document.getElementById('csvMappingStep1').style.display = 'block';
      document.getElementById('csvMappingStep2').style.display = 'none';
      document.getElementById('csvStep1Tab').style.borderBottom = '3px solid #8b5cf6';
      document.getElementById('csvStep1Tab').style.color = '#7c3aed';
      document.getElementById('csvStep2Tab').style.borderBottom = 'none';
      document.getElementById('csvStep2Tab').style.color = '#94a3b8';
      document.getElementById('csvBackBtn').style.display = 'none';
      document.getElementById('csvNextBtn').style.display = 'inline-block';
      document.getElementById('csvImportBtn').style.display = 'none';
    }

    // Generate preview of mapped data
    function generateCsvPreview() {
      // Collect current mappings
      csvMappings = {
        lat: document.getElementById('csvMapLat').value,
        lon: document.getElementById('csvMapLon').value,
        sampleId: document.getElementById('csvMapSampleId').value,
        field: document.getElementById('csvMapField').value
      };

      const nutrients = ['pH', 'Buffer_pH', 'P', 'K', 'OM', 'CEC', 'Ca', 'Mg', 'Na', 'S', 'Zn', 'Cu', 'Mn', 'Fe', 'Boron', 'Ca_sat', 'Mg_sat', 'K_Sat', 'H_Sat', 'Na_Sat', 'NO3', 'NH4', 'Soluble_Salts'];
      nutrients.forEach(n => {
        const select = document.getElementById(`csvMap${n}`);
        if (select && select.value) {
          csvMappings[n] = select.value;
        }
      });

      // Find mapped columns (non-empty values)
      const mappedFields = Object.entries(csvMappings)
        .filter(([key, val]) => val)
        .map(([key, val]) => ({ standard: key, source: val }));

      // Build preview table header
      const thead = document.getElementById('csvPreviewHead');
      thead.innerHTML = `<tr>${mappedFields.map(f =>
        `<th style="padding: 0.5rem; text-align: left; border-bottom: 1px solid #e2e8f0;">
          <div style="font-weight: 600; color: #1e293b;">${f.standard}</div>
          <div style="font-size: 0.7rem; color: #64748b; font-weight: normal;">‚Üê ${f.source}</div>
        </th>`
      ).join('')}</tr>`;

      // Build preview table body (first 5 rows)
      const tbody = document.getElementById('csvPreviewBody');
      const previewRows = csvParsedData.slice(0, 5);

      tbody.innerHTML = previewRows.map(row => {
        return `<tr>${mappedFields.map(f => {
          let val = row[f.source] || '';
          // Highlight empty required fields
          const isEmpty = !val && (f.standard === 'lat' || f.standard === 'lon');
          const style = isEmpty ? 'background: #fef2f2; color: #dc2626;' : '';
          return `<td style="padding: 0.5rem; border-bottom: 1px solid #f1f5f9; ${style}">${val || '-'}</td>`;
        }).join('')}</tr>`;
      }).join('');

      // Update count and show warnings
      document.getElementById('csvPreviewCount').textContent = `Total: ${csvParsedData.length} records`;

      // Check for issues
      const warnings = [];
      let missingLatLon = 0;
      csvParsedData.forEach(row => {
        const lat = parseFloat(row[csvMappings.lat]);
        const lon = parseFloat(row[csvMappings.lon]);
        if (isNaN(lat) || isNaN(lon)) missingLatLon++;
      });

      if (missingLatLon > 0) {
        warnings.push(`‚ö†Ô∏è ${missingLatLon} rows have missing or invalid coordinates and will be skipped`);
      }

      const warningsDiv = document.getElementById('csvPreviewWarnings');
      if (warnings.length > 0) {
        warningsDiv.innerHTML = warnings.map(w =>
          `<div style="padding: 0.5rem; background: #fef3c7; border: 1px solid #fcd34d; border-radius: 0.25rem; margin-bottom: 0.5rem; font-size: 0.85rem; color: #92400e;">${w}</div>`
        ).join('');
      } else {
        warningsDiv.innerHTML = `<div style="padding: 0.5rem; background: #dcfce7; border: 1px solid #22c55e; border-radius: 0.25rem; font-size: 0.85rem; color: #166534;">‚úì All rows have valid coordinates</div>`;
      }
    }

    // Perform the CSV import
    async function csvImportConfirm() {
      // Validate required year
      const yearInput = document.getElementById('sampleYear').value.trim();
      if (!yearInput) {
        showStatus('Sample Year is required', false);
        document.getElementById('sampleYear').focus();
        return;
      }
      const year = parseInt(yearInput);
      if (isNaN(year) || year < 1900 || year > 2100) {
        showStatus('Please enter a valid year (e.g., 2024)', false);
        document.getElementById('sampleYear').focus();
        return;
      }

      // Save mapping if requested
      if (document.getElementById('csvSaveMapping').checked) {
        const name = document.getElementById('csvMappingName').value.trim();
        if (name) {
          saveCsvMapping(name);
        }
      }

      // Get depth from the form
      const depth = document.getElementById('sampleDepth').value || '6';

      // Map the data
      const samples = [];
      let skipped = 0;

      csvParsedData.forEach((row, idx) => {
        const lat = parseFloat(row[csvMappings.lat]);
        const lon = parseFloat(row[csvMappings.lon]);

        if (isNaN(lat) || isNaN(lon)) {
          skipped++;
          return;
        }

        const sample = {
          lat: lat,
          lon: lon,
          year: year,
          depth: depth,
          sampleId: csvMappings.sampleId ? (row[csvMappings.sampleId] || `S${idx + 1}`) : `S${idx + 1}`,
          field: csvMappings.field ? (row[csvMappings.field] || 'Unknown') : 'Unknown'
        };

        // Add nutrient values
        const nutrients = ['pH', 'Buffer_pH', 'P', 'K', 'OM', 'CEC', 'Ca', 'Mg', 'Na', 'S', 'Zn', 'Cu', 'Mn', 'Fe', 'Boron', 'Ca_sat', 'Mg_sat', 'K_Sat', 'H_Sat', 'Na_Sat', 'NO3', 'NH4', 'Soluble_Salts'];
        nutrients.forEach(n => {
          if (csvMappings[n] && row[csvMappings[n]]) {
            const val = parseFloat(row[csvMappings[n]]);
            if (!isNaN(val) && val !== 0) {
              sample[n] = val;
            }
          }
        });

        samples.push(sample);
      });

      if (samples.length === 0) {
        showStatus('No valid samples to import', false);
        return;
      }

      // Normalize data using aliases
      samples.forEach(s => normalizeNutrientData(s));

      // Add to sampleData
      sampleData.push(...samples);

      // Assign to fields if boundaries exist
      let assignmentMsg = '';
      if (Object.keys(fieldBoundaries).length > 0) {
        assignSamplesToFields();
        const assignedCount = samples.filter(s => s.field && s.field !== 'Unassigned' && s.field !== 'Unknown').length;
        const unassignedCount = samples.length - assignedCount;
        if (assignedCount > 0) {
          assignmentMsg = `, ${assignedCount} assigned to fields`;
        }
        if (unassignedCount > 0) {
          assignmentMsg += ` (${unassignedCount} outside boundaries)`;
        }
      } else {
        assignmentMsg = '. Upload field boundaries to auto-assign field names.';
      }

      // Save data
      await saveLocalData();
      await saveToIndexedDB();

      // Close modal
      closeCsvMappingModal();

      // Update UI
      await afterImportSuccess();

      let msg = `‚úì Imported ${samples.length} samples${assignmentMsg}`;
      if (skipped > 0) msg += ` (${skipped} rows skipped)`;
      showStatus(msg, true);

      // Sync to Sheets if signed in
      if (SheetsAPI.isSignedIn) {
        syncToSheets();
      }
    }

    // Save CSV mapping profile
    function saveCsvMapping(name) {
      const saved = JSON.parse(localStorage.getItem('csvMappingProfiles') || '{}');
      saved[name] = { ...csvMappings };
      localStorage.setItem('csvMappingProfiles', JSON.stringify(saved));
    }

    // Load saved mappings dropdown
    function loadSavedMappings() {
      const saved = JSON.parse(localStorage.getItem('csvMappingProfiles') || '{}');
      const names = Object.keys(saved);
      const group = document.getElementById('savedMappingsGroup');
      const select = document.getElementById('savedMappingSelect');

      if (names.length === 0) {
        group.style.display = 'none';
        return;
      }

      group.style.display = 'block';
      select.innerHTML = '<option value="">-- Select a saved mapping --</option>' +
        names.map(n => `<option value="${n}">${n}</option>`).join('');
    }

    // Apply saved mapping
    document.getElementById('savedMappingSelect').addEventListener('change', function() {
      const name = this.value;
      if (!name) return;
      showStatus(`Mapping "${name}" will be applied when you open the column mapper`, true);
    });

    // Apply a saved mapping to the dropdowns
    function applySavedMapping(name) {
      const saved = JSON.parse(localStorage.getItem('csvMappingProfiles') || '{}');
      const mapping = saved[name];
      if (!mapping) {
        autoMapColumns();
        return;
      }

      // First auto-map to get defaults, then override with saved
      autoMapColumns();

      // Apply saved mappings - find matching headers
      function findHeader(sourceCol) {
        if (!sourceCol) return '';
        // Check exact match first
        if (csvHeaders.includes(sourceCol)) return sourceCol;
        // Check case-insensitive
        const lower = sourceCol.toLowerCase();
        return csvHeaders.find(h => h.toLowerCase() === lower) || '';
      }

      // Required fields
      if (mapping.lat) document.getElementById('csvMapLat').value = findHeader(mapping.lat);
      if (mapping.lon) document.getElementById('csvMapLon').value = findHeader(mapping.lon);
      if (mapping.sampleId) document.getElementById('csvMapSampleId').value = findHeader(mapping.sampleId);
      if (mapping.field) document.getElementById('csvMapField').value = findHeader(mapping.field);

      // Nutrient fields
      const nutrients = ['pH', 'Buffer_pH', 'P', 'K', 'OM', 'CEC', 'Ca', 'Mg', 'Na', 'S', 'Zn', 'Cu', 'Mn', 'Fe', 'Boron', 'Ca_sat', 'Mg_sat', 'K_Sat', 'H_Sat', 'Na_Sat', 'NO3', 'NH4', 'Soluble_Salts'];
      nutrients.forEach(n => {
        if (mapping[n]) {
          const select = document.getElementById(`csvMap${n}`);
          if (select) select.value = findHeader(mapping[n]);
        }
      });
    }

    // ============================================
    // Shapefile Import with Attribute Mapping
    // ============================================

    function showShpMappingModal(geojson) {
      // Extract features
      const features = geojson.features || [geojson];
      shpParsedFeatures = features.filter(f => f.geometry && f.geometry.type === 'Point');

      if (shpParsedFeatures.length === 0) {
        showStatus('No point features found in shapefile', false);
        return;
      }

      // Extract ALL attribute names from ALL features (not just first)
      // Some shapefiles have sparse data where first record doesn't have all columns
      const allAttributeSet = new Set();
      shpParsedFeatures.forEach((feature, i) => {
        const props = feature.properties || {};
        Object.keys(props).forEach(key => allAttributeSet.add(key));
      });
      shpAttributes = Array.from(allAttributeSet);

      console.log('=== SHAPEFILE ATTRIBUTE EXTRACTION ===');
      console.log('Total features scanned:', shpParsedFeatures.length);
      console.log('Total unique attributes found:', shpAttributes.length);
      console.log('All attributes:', shpAttributes);

      // Update summary bar
      document.getElementById('shpSummaryText').textContent = `Found ${shpParsedFeatures.length} sample points`;
      document.getElementById('shpAttrCount').textContent = `${shpAttributes.length} attributes`;

      // Populate dropdowns and auto-map
      populateShpMappingDropdowns();
      autoMapShpColumns();

      // Reset to step 1
      document.getElementById('shpMappingStep1').style.display = 'block';
      document.getElementById('shpMappingStep2').style.display = 'none';
      document.getElementById('shpStep1Tab').style.borderBottom = '3px solid #3b82f6';
      document.getElementById('shpStep1Tab').style.color = '#1d4ed8';
      document.getElementById('shpStep2Tab').style.borderBottom = 'none';
      document.getElementById('shpStep2Tab').style.color = '#94a3b8';
      document.getElementById('shpBackBtn').style.display = 'none';
      document.getElementById('shpNextBtn').style.display = 'inline-block';
      document.getElementById('shpImportBtn').style.display = 'none';

      document.getElementById('shpMappingModal').style.display = 'flex';
      showStatus('', true); // Clear status
    }

    function populateShpMappingDropdowns() {
      function escapeHtml(str) {
        // Escape HTML special characters AND single quotes for safe attribute values
        return String(str)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
      }

      // Debug: log all attributes being added to dropdowns
      console.log('=== SHP DROPDOWN DEBUG ===');
      console.log('Total attributes to add:', shpAttributes.length);
      console.log('All attributes:', shpAttributes);

      // Sort attributes alphabetically (case-insensitive)
      const sortedAttributes = [...shpAttributes].sort((a, b) => {
        // Extract leading letters for primary sort (handles "B (M3)" sorting under B)
        const aLower = a.toLowerCase();
        const bLower = b.toLowerCase();
        return aLower.localeCompare(bLower);
      });

      // Build options - include ALL attributes sorted A-Z, with (skip) first
      const options = '<option value="">(skip)</option>' +
        sortedAttributes.map((a, i) => {
          const escaped = escapeHtml(a);
          return `<option value="${escaped}">${escaped}</option>`;
        }).join('');

      console.log('Options HTML length:', options.length);
      console.log('Option count (should be', shpAttributes.length + 1, '):', (options.match(/<option/g) || []).length);

      // Required fields
      document.getElementById('shpMapSampleId').innerHTML = options;
      document.getElementById('shpMapField').innerHTML = options;
      document.getElementById('shpMapYear').innerHTML = options;
      document.getElementById('shpMapDepth').innerHTML = options;

      // Debug: verify options were added
      const sampleIdSelect = document.getElementById('shpMapSampleId');
      console.log('SampleId dropdown option count:', sampleIdSelect.options.length);

      // Nutrient fields
      const nutrientContainer = document.getElementById('shpNutrientMappings');
      nutrientContainer.innerHTML = '';

      const nutrients = ['pH', 'Buffer_pH', 'P', 'P2', 'K', 'OM', 'CEC', 'Ca', 'Mg', 'Na', 'S', 'Zn', 'Cu', 'Mn', 'Fe', 'Boron', 'Ca_sat', 'Mg_sat', 'K_Sat', 'H_Sat', 'Na_Sat', 'NO3', 'NH4', 'Soluble_Salts'];

      nutrients.forEach(nutrient => {
        const div = document.createElement('div');
        div.className = 'shp-mapping-field';
        div.innerHTML = `
          <label style="font-size: 0.8rem; font-weight: 600; color: #166534;">${nutrient}</label>
          <div style="display: flex; gap: 0.5rem; align-items: center;">
            <select id="shpMap${nutrient}" class="shp-map-select" style="flex: 1;" onchange="updateShpPreview('${nutrient}'); updateUnmappedFromDropdowns();">${options}</select>
            <span id="shpPreview${nutrient}" class="shp-preview-values"></span>
          </div>
        `;
        nutrientContainer.appendChild(div);
      });

      // Final debug check - use SampleId dropdown (consistent ID)
      const sampleIdDropdown = document.getElementById('shpMapSampleId');
      console.log('=== DROPDOWN VERIFICATION ===');
      console.log('SampleId dropdown option count:', sampleIdDropdown.options.length);
      console.log('Expected count:', shpAttributes.length + 1, '(attributes + skip option)');
      if (sampleIdDropdown.options.length !== shpAttributes.length + 1) {
        console.error('MISMATCH! Some attributes were not added to dropdown');
        console.log('All shpAttributes:', shpAttributes);
        console.log('All dropdown options:', Array.from(sampleIdDropdown.options).map(o => o.value));
      }
    }

    function autoMapShpColumns() {
      const aliases = getAliases();

      // ID aliases
      const idAliases = ['sampleid', 'sample_id', 'id', 'pointid', 'point_id', 'fid', 'org_id', 'objectid', 'sample id'];
      const fieldAliases = ['field', 'fieldname', 'field_name', 'farm', 'farmname', 'name', 'farm_field'];
      const yearAliases = ['year', 'sampleyr', 'sample_year', 'cropyear', 'crop_year', 'cropyr', 'sampleyear', 'sampledate', 'sample_date', 'date'];
      const depthAliases = ['depth', 'sampledepth', 'sample_depth', 'depth_in', 'depthin', 'depthunits'];

      function findMatch(aliasList) {
        for (const attr of shpAttributes) {
          const a = attr.toLowerCase().trim();
          if (aliasList.includes(a)) return attr;
        }
        return '';
      }

      // Map required fields
      document.getElementById('shpMapSampleId').value = findMatch(idAliases);
      document.getElementById('shpMapField').value = findMatch(fieldAliases);
      document.getElementById('shpMapYear').value = findMatch(yearAliases);
      document.getElementById('shpMapDepth').value = findMatch(depthAliases);

      // Extended aliases for lab formats
      const labAliases = {
        'pH': ['ph', 'wph', 'water ph', 'soil ph', '1:1 ph', 'ph 1:1', 'ph_1_1', 'ph_(1_1)'],
        'Buffer_pH': ['bph', 'buffer ph', 'buffer_ph', 'sikora', 'smp', 'smp ph'],
        'P': ['p', 'bray p1', 'bray_p1', 'bray p-1', 'mehlich p', 'olsen p', 'p1', 'p (m3)', 'p_m3', 'phosphorus'],
        'P2': ['p2', 'bray_p2', 'bray p2'],
        'K': ['k', 'aa k', 'potassium', 'k (m3)', 'k_m3', 'mehlich k', 'exchk', 'exch k'],
        'OM': ['om', 'om (loi)', 'om_loi', 'organic matter', 'om%', 'o.m.', 'loi', 'organic_matter'],
        'CEC': ['cec', 'c.e.c.', 'cation exchange', 'cec (calc)', 'cec_calc', 'cec meq'],
        'Ca': ['ca', 'aa ca', 'calcium', 'exchca', 'exch ca', 'ca (m3)'],
        'Mg': ['mg', 'aa mg', 'magnesium', 'exchmg', 'exch mg', 'mg (m3)'],
        'Na': ['na', 'aa na', 'sodium', 'exchna', 'exch na', 'na (m3)'],
        'S': ['s', 'sulfur', 'so4-s', 'sulfate', 's (m3)'],
        'Zn': ['zn', 'dtpa-zn', 'zinc', 'zn (m3)', 'mehlich zn'],
        'Mn': ['mn', 'dtpa-mn', 'manganese', 'mn (m3)', 'mehlich mn'],
        'Fe': ['fe', 'dtpa-fe', 'iron', 'fe (m3)', 'mehlich fe'],
        'Cu': ['cu', 'dtpa-cu', 'copper', 'cu (m3)', 'mehlich cu'],
        'Boron': ['b', 'dtpa-b', 'boron', 'hot water b', 'b (m3)'],
        'Ca_sat': ['ca_sat', 'bs-ca', 'bs_ca', 'ca_base_sat', 'ca sat', 'ca sat %', 'ca%', '%ca'],
        'Mg_sat': ['mg_sat', 'bs-mg', 'bs_mg', 'mg_base_sat', 'mg sat', 'mg sat %', 'mg%', '%mg'],
        'K_Sat': ['k_sat', 'bs-k', 'bs_k', 'k_base_sat', 'k sat', 'k sat %', 'k%', '%k'],
        'H_Sat': ['h_sat', 'bs-h', 'bs_h', 'h_base_sat', 'h sat', 'h sat %', 'h%', '%h'],
        'Na_Sat': ['na_sat', 'bs-na', 'bs_na', 'na_base_sat', 'na sat', 'na sat %', 'na%', '%na'],
        'NO3': ['no3', 'no3-n', 'no3-n (ppm)', 'nitrate', 'nitrate-n'],
        'NH4': ['nh4', 'nh4-n', 'ammonium', 'ammonium-n'],
        'Soluble_Salts': ['soluble_salts', 'soluble_sal', 'sol_salts', 'salts', 'ss']
      };

      // Map nutrient fields
      const nutrients = ['pH', 'Buffer_pH', 'P', 'P2', 'K', 'OM', 'CEC', 'Ca', 'Mg', 'Na', 'S', 'Zn', 'Cu', 'Mn', 'Fe', 'Boron', 'Ca_sat', 'Mg_sat', 'K_Sat', 'H_Sat', 'Na_Sat', 'NO3', 'NH4', 'Soluble_Salts'];
      const mappedAttrs = new Set();

      nutrients.forEach(nutrient => {
        const select = document.getElementById(`shpMap${nutrient}`);
        if (!select) return;

        // Combine stored aliases with lab aliases
        const storedAliases = aliases[nutrient] || [];
        const defaultLabAliases = labAliases[nutrient] || [nutrient.toLowerCase()];
        const nutrientAliases = [...new Set([...storedAliases.map(a => a.toLowerCase()), ...defaultLabAliases])];
        let matched = '';

        for (const attr of shpAttributes) {
          const a = attr.toLowerCase().trim();
          for (const alias of nutrientAliases) {
            if (alias === a) {
              matched = attr;
              break;
            }
          }
          if (matched) break;
        }

        if (matched) {
          select.value = matched;
          mappedAttrs.add(matched);
          updateShpPreview(nutrient);
        }
      });

      // Also mark required fields as mapped
      const sampleIdVal = document.getElementById('shpMapSampleId').value;
      const fieldVal = document.getElementById('shpMapField').value;
      const yearVal = document.getElementById('shpMapYear').value;
      const depthVal = document.getElementById('shpMapDepth').value;
      if (sampleIdVal) mappedAttrs.add(sampleIdVal);
      if (fieldVal) mappedAttrs.add(fieldVal);
      if (yearVal) mappedAttrs.add(yearVal);
      if (depthVal) mappedAttrs.add(depthVal);

      // Update preview for required fields
      updateShpPreview('SampleId');
      updateShpPreview('Field');
      updateShpPreview('Year');
      updateShpPreview('Depth');

      // Show unmapped attributes
      showUnmappedAttributes(mappedAttrs);
    }

    function updateShpPreview(fieldName) {
      // Get values from first few features for preview
      const previewCount = 3;
      let selectId = `shpMap${fieldName}`;
      let previewId = `shpPreview${fieldName}`;

      const select = document.getElementById(selectId);
      const preview = document.getElementById(previewId);
      if (!select || !preview) return;

      const attr = select.value;
      if (!attr) {
        preview.textContent = '';
        preview.title = '';
        return;
      }

      const values = shpParsedFeatures.slice(0, previewCount)
        .map(f => f.properties?.[attr])
        .filter(v => v !== null && v !== undefined && v !== '')
        .map(v => typeof v === 'number' ? v.toFixed(1) : v);

      if (values.length > 0) {
        preview.textContent = values.join(', ') + '...';
        preview.title = `Values: ${values.join(', ')}`;
      } else {
        preview.textContent = '(no data)';
        preview.title = 'No values found';
      }
    }

    function showUnmappedAttributes(mappedAttrs) {
      // System attributes to exclude from unmapped list
      const systemAttrs = ['lat', 'lon', 'latitude', 'longitude', 'point_x', 'point_y', 'x', 'y', 'geometry', 'type'];

      const unmapped = shpAttributes.filter(attr => {
        const a = attr.toLowerCase();
        return !mappedAttrs.has(attr) && !systemAttrs.includes(a);
      });

      const section = document.getElementById('shpUnmappedSection');
      const list = document.getElementById('shpUnmappedList');

      if (unmapped.length === 0) {
        section.style.display = 'none';
        return;
      }

      section.style.display = 'block';
      list.innerHTML = unmapped.map(attr => `<span class="shp-unmapped-chip">${attr}</span>`).join('');
    }

    function updateUnmappedFromDropdowns() {
      // Collect all currently mapped attributes from dropdowns
      const mappedAttrs = new Set();
      const nutrients = ['pH', 'Buffer_pH', 'P', 'P2', 'K', 'OM', 'CEC', 'Ca', 'Mg', 'Na', 'S', 'Zn', 'Cu', 'Mn', 'Fe', 'Boron', 'Ca_sat', 'Mg_sat', 'K_Sat', 'H_Sat', 'Na_Sat', 'NO3', 'NH4', 'Soluble_Salts'];

      // Required fields
      const sampleIdVal = document.getElementById('shpMapSampleId').value;
      const fieldVal = document.getElementById('shpMapField').value;
      const yearVal = document.getElementById('shpMapYear').value;
      const depthVal = document.getElementById('shpMapDepth').value;
      if (sampleIdVal) mappedAttrs.add(sampleIdVal);
      if (fieldVal) mappedAttrs.add(fieldVal);
      if (yearVal) mappedAttrs.add(yearVal);
      if (depthVal) mappedAttrs.add(depthVal);

      // Nutrient fields
      nutrients.forEach(n => {
        const select = document.getElementById(`shpMap${n}`);
        if (select && select.value) mappedAttrs.add(select.value);
      });

      showUnmappedAttributes(mappedAttrs);
    }

    function closeShpMappingModal() {
      document.getElementById('shpMappingModal').style.display = 'none';
      shpParsedFeatures = [];
      shpAttributes = [];
      shpMappings = {};
    }

    function shpMappingNext() {
      // Generate preview
      generateShpPreview();

      // Switch to step 2
      document.getElementById('shpMappingStep1').style.display = 'none';
      document.getElementById('shpMappingStep2').style.display = 'block';
      document.getElementById('shpStep1Tab').style.borderBottom = 'none';
      document.getElementById('shpStep1Tab').style.color = '#94a3b8';
      document.getElementById('shpStep2Tab').style.borderBottom = '3px solid #3b82f6';
      document.getElementById('shpStep2Tab').style.color = '#1d4ed8';
      document.getElementById('shpBackBtn').style.display = 'inline-block';
      document.getElementById('shpNextBtn').style.display = 'none';
      document.getElementById('shpImportBtn').style.display = 'inline-block';
    }

    function shpMappingBack() {
      document.getElementById('shpMappingStep1').style.display = 'block';
      document.getElementById('shpMappingStep2').style.display = 'none';
      document.getElementById('shpStep1Tab').style.borderBottom = '3px solid #3b82f6';
      document.getElementById('shpStep1Tab').style.color = '#1d4ed8';
      document.getElementById('shpStep2Tab').style.borderBottom = 'none';
      document.getElementById('shpStep2Tab').style.color = '#94a3b8';
      document.getElementById('shpBackBtn').style.display = 'none';
      document.getElementById('shpNextBtn').style.display = 'inline-block';
      document.getElementById('shpImportBtn').style.display = 'none';
    }

    function generateShpPreview() {
      // Collect current mappings
      shpMappings = {
        sampleId: document.getElementById('shpMapSampleId').value,
        field: document.getElementById('shpMapField').value
      };

      const nutrients = ['pH', 'Buffer_pH', 'P', 'P2', 'K', 'OM', 'CEC', 'Ca', 'Mg', 'Na', 'S', 'Zn', 'Cu', 'Mn', 'Fe', 'Boron', 'Ca_sat', 'Mg_sat', 'K_Sat', 'H_Sat', 'Na_Sat', 'NO3', 'NH4', 'Soluble_Salts'];
      nutrients.forEach(n => {
        const select = document.getElementById(`shpMap${n}`);
        if (select && select.value) {
          shpMappings[n] = select.value;
        }
      });

      // Build columns to show (lat, lon always shown, plus mapped fields)
      const mappedFields = [
        { standard: 'Lat', source: '(geometry)' },
        { standard: 'Lon', source: '(geometry)' },
        ...Object.entries(shpMappings)
          .filter(([key, val]) => val)
          .map(([key, val]) => ({ standard: key, source: val }))
      ];

      // Build preview table header
      const thead = document.getElementById('shpPreviewHead');
      thead.innerHTML = `<tr>${mappedFields.map(f =>
        `<th style="padding: 0.5rem; text-align: left; border-bottom: 1px solid #e2e8f0;">
          <div style="font-weight: 600; color: #1e293b;">${f.standard}</div>
          <div style="font-size: 0.7rem; color: #64748b; font-weight: normal;">‚Üê ${f.source}</div>
        </th>`
      ).join('')}</tr>`;

      // Build preview table body (first 5 rows)
      const tbody = document.getElementById('shpPreviewBody');
      const previewRows = shpParsedFeatures.slice(0, 5);

      tbody.innerHTML = previewRows.map(feature => {
        const coords = feature.geometry.coordinates;
        const props = feature.properties || {};
        return `<tr>${mappedFields.map(f => {
          let val;
          if (f.standard === 'Lat') val = coords[1]?.toFixed(5);
          else if (f.standard === 'Lon') val = coords[0]?.toFixed(5);
          else val = props[f.source];

          if (typeof val === 'number') val = val.toFixed(2);
          return `<td style="padding: 0.5rem; border-bottom: 1px solid #f1f5f9;">${val ?? '-'}</td>`;
        }).join('')}</tr>`;
      }).join('');

      // Update count
      document.getElementById('shpPreviewCount').textContent = `Total: ${shpParsedFeatures.length} samples`;

      // Show warnings
      const warningsDiv = document.getElementById('shpPreviewWarnings');
      const warnings = [];

      // Check for missing nutrient data
      let noNutrientCount = 0;
      shpParsedFeatures.forEach(f => {
        const props = f.properties || {};
        const hasNutrient = nutrients.some(n => shpMappings[n] && props[shpMappings[n]] !== null && props[shpMappings[n]] !== undefined);
        if (!hasNutrient) noNutrientCount++;
      });

      if (noNutrientCount > 0 && noNutrientCount < shpParsedFeatures.length) {
        warnings.push(`‚ö†Ô∏è ${noNutrientCount} samples have no nutrient data in the mapped columns`);
      }

      // Check if any nutrients were mapped
      const mappedNutrients = nutrients.filter(n => shpMappings[n]);
      if (mappedNutrients.length === 0) {
        warnings.push(`‚ö†Ô∏è No nutrient fields mapped. Consider mapping pH, P, K, etc. for analysis.`);
      }

      if (warnings.length > 0) {
        warningsDiv.innerHTML = warnings.map(w =>
          `<div style="padding: 0.5rem; background: #fef3c7; border: 1px solid #fcd34d; border-radius: 0.25rem; margin-bottom: 0.5rem; font-size: 0.85rem; color: #92400e;">${w}</div>`
        ).join('');
      } else {
        warningsDiv.innerHTML = `<div style="padding: 0.5rem; background: #dcfce7; border: 1px solid #22c55e; border-radius: 0.25rem; font-size: 0.85rem; color: #166534;">‚úì ${mappedNutrients.length} nutrient fields mapped. Ready to import!</div>`;
      }
    }

    async function shpImportConfirm() {
      // Save new mappings as aliases if requested
      if (document.getElementById('shpSaveMapping').checked) {
        const nutrients = ['pH', 'Buffer_pH', 'P', 'P2', 'K', 'OM', 'CEC', 'Ca', 'Mg', 'Na', 'S', 'Zn', 'Cu', 'Mn', 'Fe', 'Boron', 'Ca_sat', 'Mg_sat', 'K_Sat', 'H_Sat', 'Na_Sat', 'NO3', 'NH4', 'Soluble_Salts'];
        nutrients.forEach(n => {
          if (shpMappings[n] && shpMappings[n].toLowerCase() !== n.toLowerCase()) {
            saveAlias(n, shpMappings[n]);
          }
        });
      }

      // Get Year and Depth mappings from form
      const yearMapping = document.getElementById('shpMapYear').value;
      const depthMapping = document.getElementById('shpMapDepth').value;

      // Convert features to samples using mappings
      const samples = [];
      shpParsedFeatures.forEach((feature, idx) => {
        const coords = feature.geometry.coordinates;
        const props = feature.properties || {};

        // Get year from mapping or fall back to global shpYear
        let sampleYear = shpYear;
        if (yearMapping && props[yearMapping]) {
          const mappedYear = props[yearMapping];
          // Handle various year formats
          if (typeof mappedYear === 'number') {
            sampleYear = mappedYear;
          } else if (typeof mappedYear === 'string') {
            // Try to extract year from date string or just parse
            const parsed = parseInt(mappedYear);
            if (!isNaN(parsed) && parsed > 1900 && parsed < 2100) {
              sampleYear = parsed;
            } else if (mappedYear.match(/\d{4}/)) {
              sampleYear = parseInt(mappedYear.match(/\d{4}/)[0]);
            }
          }
        }

        // Get depth from mapping or fall back to global shpDepth
        let sampleDepth = shpDepth || '6';
        if (depthMapping && props[depthMapping]) {
          const mappedDepth = props[depthMapping];
          if (typeof mappedDepth === 'number') {
            sampleDepth = String(mappedDepth);
          } else {
            sampleDepth = String(mappedDepth);
          }
        }

        const sample = {
          lat: coords[1],
          lon: coords[0],
          year: sampleYear,
          depth: sampleDepth,
          sampleId: shpMappings.sampleId ? (props[shpMappings.sampleId] || `S${idx + 1}`) : `S${idx + 1}`,
          field: null // Will be assigned by GPS matching
        };

        // Apply nutrient mappings
        const nutrients = ['pH', 'Buffer_pH', 'P', 'P2', 'K', 'OM', 'CEC', 'Ca', 'Mg', 'Na', 'S', 'Zn', 'Cu', 'Mn', 'Fe', 'Boron', 'Ca_sat', 'Mg_sat', 'K_Sat', 'H_Sat', 'Na_Sat', 'NO3', 'NH4', 'Soluble_Salts'];
        nutrients.forEach(n => {
          if (shpMappings[n]) {
            const val = props[shpMappings[n]];
            if (val !== null && val !== undefined && val !== '' && val !== 0) {
              const num = parseFloat(val);
              sample[n] = isNaN(num) ? val : num;
            }
          }
        });

        // Also copy any unmapped attributes (as raw data)
        Object.entries(props).forEach(([k, v]) => {
          if (sample[k] === undefined && v !== null && v !== undefined) {
            const num = parseFloat(v);
            sample[k] = isNaN(num) ? v : num;
          }
        });

        samples.push(sample);
      });

      // Close modal first
      closeShpMappingModal();

      // Finish import using existing function
      await finishSampleImport(samples);

      // Clear file input
      document.getElementById('sampleFiles').value = '';
      document.getElementById('sampleYear').value = '';
    }

    // ============================================
    // Field Management
    // ============================================

    let fieldToEdit = null;
    let fieldToDelete = null;

    // Refresh field management table
    function refreshFieldTable() {
      const tbody = document.getElementById('fieldTableBody');
      const summaryDiv = document.getElementById('fieldManagementSummary');
      const summaryText = document.getElementById('fieldSummaryText');

      const fieldNames = Object.keys(fieldBoundaries).sort();

      if (fieldNames.length === 0) {
        tbody.innerHTML = `
          <tr>
            <td colspan="5" style="padding: 2rem; text-align: center; color: #64748b;">
              <em>No field boundaries loaded</em>
            </td>
          </tr>
        `;
        summaryDiv.style.display = 'none';
        document.getElementById('fieldManagementQuickSummary').textContent = '0 fields';
        return;
      }

      let totalAcres = 0;
      let totalSamples = 0;

      const rows = fieldNames.map(fieldName => {
        const fieldData = fieldBoundaries[fieldName];

        // Get boundary coordinates (handle both legacy and new format)
        const boundaryCoords = fieldData.boundary || fieldData;

        // Calculate acres
        const acres = calculateFieldAcres(boundaryCoords);
        totalAcres += acres;

        // Count samples and get years
        const fieldSamples = sampleData.filter(s => s.field === fieldName);
        const sampleCount = fieldSamples.length;
        totalSamples += sampleCount;

        const years = [...new Set(fieldSamples.map(s => s.year).filter(y => y))].sort();
        const yearRange = years.length > 0
          ? (years.length === 1 ? years[0] : `${years[0]}-${years[years.length - 1]}`)
          : '--';

        // Get farm/client info
        let farmLabel = '';
        if (fieldData.farmId) {
          const farm = farmsData.find(f => f.id === fieldData.farmId);
          if (farm) {
            const client = clientsData.find(c => c.id === farm.clientId);
            farmLabel = client ? `${client.name} > ${farm.name}` : farm.name;
          }
        }

        // Determine row styling based on data
        const hasNoSamples = sampleCount === 0;
        const rowStyle = hasNoSamples ? 'background: #fef3c7;' : '';

        return `
          <tr style="${rowStyle}">
            <td style="padding: 0.75rem; border-bottom: 1px solid #e0f2fe;">
              <span style="font-weight: 500;">${escapeHtml(fieldName)}</span>
              ${hasNoSamples ? '<span style="margin-left: 0.5rem; font-size: 0.7rem; background: #fde047; padding: 0.125rem 0.375rem; border-radius: 0.25rem; color: #854d0e;">No samples</span>' : ''}
              ${farmLabel ? `<div style="font-size: 0.7rem; color: #8b5cf6; margin-top: 0.25rem;">üìÅ ${escapeHtml(farmLabel)}</div>` : ''}
            </td>
            <td style="padding: 0.75rem; text-align: right; border-bottom: 1px solid #e0f2fe;">${acres.toFixed(1)}</td>
            <td style="padding: 0.75rem; text-align: right; border-bottom: 1px solid #e0f2fe;">${sampleCount}</td>
            <td style="padding: 0.75rem; text-align: center; border-bottom: 1px solid #e0f2fe; font-size: 0.8rem; color: #64748b;">${yearRange}</td>
            <td style="padding: 0.75rem; text-align: center; border-bottom: 1px solid #e0f2fe;">
              <button onclick="openFieldEditModal('${escapeHtml(fieldName)}')" style="padding: 0.25rem 0.5rem; margin-right: 0.25rem; background: #e0f2fe; border: 1px solid #7dd3fc; border-radius: 0.25rem; cursor: pointer; font-size: 0.75rem; color: #0369a1;">‚úèÔ∏è Edit</button>
              <button onclick="openFieldDeleteModal('${escapeHtml(fieldName)}')" style="padding: 0.25rem 0.5rem; background: #fee2e2; border: 1px solid #fca5a5; border-radius: 0.25rem; cursor: pointer; font-size: 0.75rem; color: #dc2626;">üóëÔ∏è Delete</button>
            </td>
          </tr>
        `;
      }).join('');

      tbody.innerHTML = rows;

      // Show summary
      summaryDiv.style.display = 'block';
      const summaryStr = `${fieldNames.length} fields ‚Ä¢ ${totalAcres.toFixed(1)} acres ‚Ä¢ ${totalSamples.toLocaleString()} samples`;
      summaryText.textContent = summaryStr;

      // Update quick summary (shown when collapsed)
      document.getElementById('fieldManagementQuickSummary').textContent = `${fieldNames.length} fields`;
    }

    // Toggle field management section
    function toggleFieldManagement() {
      const content = document.getElementById('fieldManagementContent');
      const icon = document.getElementById('fieldManagementToggleIcon');
      const isHidden = content.style.display === 'none';

      if (isHidden) {
        content.style.display = 'block';
        icon.style.transform = 'rotate(0deg)';
      } else {
        content.style.display = 'none';
        icon.style.transform = 'rotate(-90deg)';
      }
    }

    // Calculate field acres from polygon coordinates
    function calculateFieldAcres(polys) {
      // Ensure polys is an array of polygons
      const polygons = Array.isArray(polys[0]?.[0]) ? polys : [polys];
      let totalArea = 0;

      polygons.forEach(polygon => {
        // Polygon is array of [lat, lng] points
        if (!polygon || polygon.length < 3) return;

        // Use shoelace formula with lat/lng to approximate area
        // Convert to approximate square meters then to acres
        let area = 0;
        const n = polygon.length;

        for (let i = 0; i < n; i++) {
          const j = (i + 1) % n;
          const lat1 = polygon[i][0];
          const lng1 = polygon[i][1];
          const lat2 = polygon[j][0];
          const lng2 = polygon[j][1];

          // Approximate meters per degree at this latitude
          const latRad = (lat1 * Math.PI) / 180;
          const metersPerDegreeLat = 111132.92 - 559.82 * Math.cos(2 * latRad);
          const metersPerDegreeLng = 111412.84 * Math.cos(latRad);

          // Convert to meters
          const x1 = lng1 * metersPerDegreeLng;
          const y1 = lat1 * metersPerDegreeLat;
          const x2 = lng2 * metersPerDegreeLng;
          const y2 = lat2 * metersPerDegreeLat;

          area += (x1 * y2) - (x2 * y1);
        }

        totalArea += Math.abs(area) / 2;
      });

      // Convert square meters to acres (1 acre = 4046.86 sq meters)
      return totalArea / 4046.86;
    }

    // HTML escape helper
    function escapeHtml(str) {
      if (!str) return '';
      return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
    }

    // Edit field modal
    function openFieldEditModal(fieldName) {
      fieldToEdit = fieldName;
      document.getElementById('fieldEditCurrentName').textContent = fieldName;
      document.getElementById('fieldEditNewName').value = fieldName;
      document.getElementById('fieldEditModal').style.display = 'flex';
      document.getElementById('fieldEditNewName').focus();
      document.getElementById('fieldEditNewName').select();
    }

    function closeFieldEditModal() {
      document.getElementById('fieldEditModal').style.display = 'none';
      fieldToEdit = null;
    }

    async function confirmFieldRename() {
      const newName = document.getElementById('fieldEditNewName').value.trim();

      if (!newName) {
        showStatus('Please enter a new field name', false);
        return;
      }

      if (newName === fieldToEdit) {
        closeFieldEditModal();
        return;
      }

      // Check if new name already exists
      if (fieldBoundaries[newName] && newName !== fieldToEdit) {
        showStatus(`Field "${newName}" already exists`, false);
        return;
      }

      // Rename boundary
      fieldBoundaries[newName] = fieldBoundaries[fieldToEdit];
      delete fieldBoundaries[fieldToEdit];

      // Update all samples with this field name
      let updatedCount = 0;
      sampleData.forEach(sample => {
        if (sample.field === fieldToEdit) {
          sample.field = newName;
          updatedCount++;
        }
      });

      // Save changes
      await saveLocalData();
      await saveToIndexedDB();

      closeFieldEditModal();
      refreshFieldTable();
      showStatus(`‚úì Renamed "${fieldToEdit}" to "${newName}" (${updatedCount} samples updated)`, true);

      // Sync to Sheets if signed in
      if (SheetsAPI.isSignedIn) {
        syncToSheets();
      }
    }

    // Delete field modal
    function openFieldDeleteModal(fieldName) {
      fieldToDelete = fieldName;

      // Count samples
      const sampleCount = sampleData.filter(s => s.field === fieldName).length;

      document.getElementById('fieldDeleteName').textContent = fieldName;
      document.getElementById('fieldDeleteSampleCount').textContent = sampleCount;

      if (sampleCount === 0) {
        document.getElementById('fieldDeleteSampleInfo').textContent = 'This field has no associated soil samples.';
      } else {
        document.getElementById('fieldDeleteSampleInfo').textContent = `This field has ${sampleCount} soil sample${sampleCount === 1 ? '' : 's'}.`;
      }

      // Reset to first option
      document.querySelector('input[name="deleteOption"][value="boundary_only"]').checked = true;

      document.getElementById('fieldDeleteModal').style.display = 'flex';
    }

    function closeFieldDeleteModal() {
      document.getElementById('fieldDeleteModal').style.display = 'none';
      fieldToDelete = null;
    }

    async function confirmFieldDelete() {
      if (!fieldToDelete) return;

      const option = document.querySelector('input[name="deleteOption"]:checked').value;
      const fieldName = fieldToDelete;
      const affectedSamples = sampleData.filter(s => s.field === fieldName);

      let message = '';

      if (option === 'boundary_only') {
        // Delete boundary, mark samples as unassigned
        delete fieldBoundaries[fieldName];
        affectedSamples.forEach(s => s.field = 'Unassigned');
        message = `‚úì Deleted "${fieldName}" boundary. ${affectedSamples.length} samples marked as Unassigned.`;

      } else if (option === 'boundary_and_samples') {
        // Delete boundary and all associated samples
        delete fieldBoundaries[fieldName];
        sampleData = sampleData.filter(s => s.field !== fieldName);
        message = `‚úì Deleted "${fieldName}" boundary and ${affectedSamples.length} samples.`;

      } else if (option === 'reassign_samples') {
        // Delete boundary and reassign samples to nearest field
        delete fieldBoundaries[fieldName];

        // Reassign each sample to the nearest remaining field
        const remainingFields = Object.keys(fieldBoundaries);
        let reassignedCount = 0;

        if (remainingFields.length === 0) {
          // No fields left, mark as unassigned
          affectedSamples.forEach(s => s.field = 'Unassigned');
          message = `‚úì Deleted "${fieldName}". No other fields exist - ${affectedSamples.length} samples marked as Unassigned.`;
        } else {
          affectedSamples.forEach(sample => {
            // Find nearest field by checking if sample falls within any boundary
            let assigned = false;
            for (const [name, fieldData] of Object.entries(fieldBoundaries)) {
              const polys = fieldData.boundary || fieldData;
              const arr = Array.isArray(polys[0]?.[0]) ? polys : [polys];
              for (const poly of arr) {
                if (isPointInOrNearPolygon([sample.lat, sample.lon], poly)) {
                  sample.field = name;
                  assigned = true;
                  reassignedCount++;
                  break;
                }
              }
              if (assigned) break;
            }
            if (!assigned) {
              // Find nearest field by centroid distance
              let nearestField = null;
              let nearestDist = Infinity;

              for (const [name, fieldData] of Object.entries(fieldBoundaries)) {
                const polys = fieldData.boundary || fieldData;
                const centroid = getFieldCentroid(polys);
                const dist = Math.sqrt(
                  Math.pow(sample.lat - centroid[0], 2) +
                  Math.pow(sample.lon - centroid[1], 2)
                );
                if (dist < nearestDist) {
                  nearestDist = dist;
                  nearestField = name;
                }
              }

              if (nearestField) {
                sample.field = nearestField;
                reassignedCount++;
              } else {
                sample.field = 'Unassigned';
              }
            }
          });
          message = `‚úì Deleted "${fieldName}". ${reassignedCount} samples reassigned to nearby fields.`;
        }
      }

      // Save changes
      await saveLocalData();
      await saveToIndexedDB();

      closeFieldDeleteModal();
      refreshFieldTable();
      updateDataSummary();
      showStatus(message, true);

      // Sync to Sheets if signed in
      if (SheetsAPI.isSignedIn) {
        syncToSheets();
      }
    }

    // Get centroid of a field's polygons
    function getFieldCentroid(polys) {
      const polygons = Array.isArray(polys[0]?.[0]) ? polys : [polys];
      let totalLat = 0, totalLon = 0, totalPoints = 0;

      polygons.forEach(polygon => {
        polygon.forEach(point => {
          totalLat += point[0];
          totalLon += point[1];
          totalPoints++;
        });
      });

      return totalPoints > 0 ? [totalLat / totalPoints, totalLon / totalPoints] : [0, 0];
    }

    // Refresh field table on page load
    document.addEventListener('DOMContentLoaded', () => {
      // Existing DOMContentLoaded handlers will call afterImportSuccess which calls refreshFieldTable
    });

  </script>
  <div class="backup-footer" id="backupFooter"></div>
</body>
</html>
